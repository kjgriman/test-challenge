import {
  require_react
} from "./chunk-UNLDIJRL.js";
import {
  __commonJS,
  __export,
  __reExport,
  __toESM
} from "./chunk-DI52DQAC.js";

// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports2, module2) {
    !function(e, t2) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTC = t2();
    }(exports2, function() {
      "use strict";
      function e(e2, t3) {
        return t3.forEach(function(t4) {
          t4 && "string" != typeof t4 && !Array.isArray(t4) && Object.keys(t4).forEach(function(i2) {
            if ("default" !== i2 && !(i2 in e2)) {
              var n3 = Object.getOwnPropertyDescriptor(t4, i2);
              Object.defineProperty(e2, i2, n3.get ? n3 : { enumerable: true, get: function() {
                return t4[i2];
              } });
            }
          });
        }), Object.freeze(e2);
      }
      var t2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function i(e2) {
        return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
      }
      var n2 = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, r = !n2(function() {
        var e2 = (function() {
        }).bind();
        return "function" != typeof e2 || e2.hasOwnProperty("prototype");
      }), o = r, s = Function.prototype, a2 = s.call, c2 = o && s.bind.bind(a2, a2), d = o ? c2 : function(e2) {
        return function() {
          return a2.apply(e2, arguments);
        };
      }, l = d({}.isPrototypeOf), u2 = function(e2) {
        return e2 && e2.Math === Math && e2;
      }, h = u2("object" == typeof globalThis && globalThis) || u2("object" == typeof window && window) || u2("object" == typeof self && self) || u2("object" == typeof t2 && t2) || u2("object" == typeof t2 && t2) || /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")(), p = r, _ = Function.prototype, E2 = _.apply, m2 = _.call, f = "object" == typeof Reflect && Reflect.apply || (p ? m2.bind(E2) : function() {
        return m2.apply(E2, arguments);
      }), S2 = d, g = S2({}.toString), T2 = S2("".slice), R2 = function(e2) {
        return T2(g(e2), 8, -1);
      }, v2 = R2, C = d, y2 = function(e2) {
        if ("Function" === v2(e2)) return C(e2);
      }, I2 = "object" == typeof document && document.all, b = void 0 === I2 && void 0 !== I2 ? function(e2) {
        return "function" == typeof e2 || e2 === I2;
      } : function(e2) {
        return "function" == typeof e2;
      }, A = {}, w2 = !n2(function() {
        return 7 !== Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), O2 = r, N2 = Function.prototype.call, D2 = O2 ? N2.bind(N2) : function() {
        return N2.apply(N2, arguments);
      }, P = {}, L2 = {}.propertyIsEnumerable, k = Object.getOwnPropertyDescriptor, M2 = k && !L2.call({ 1: 2 }, 1);
      P.f = M2 ? function(e2) {
        var t3 = k(this, e2);
        return !!t3 && t3.enumerable;
      } : L2;
      var U2, V2, x = function(e2, t3) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t3 };
      }, F2 = n2, B = R2, j = Object, G2 = d("".split), W2 = F2(function() {
        return !j("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return "String" === B(e2) ? G2(e2, "") : j(e2);
      } : j, H = function(e2) {
        return null == e2;
      }, K2 = H, Y2 = TypeError, z = function(e2) {
        if (K2(e2)) throw new Y2("Can't call method on " + e2);
        return e2;
      }, q2 = W2, X2 = z, J2 = function(e2) {
        return q2(X2(e2));
      }, Z2 = b, Q2 = function(e2) {
        return "object" == typeof e2 ? null !== e2 : Z2(e2);
      }, $ = {}, ee2 = $, te2 = h, ie2 = b, ne2 = function(e2) {
        return ie2(e2) ? e2 : void 0;
      }, re2 = function(e2, t3) {
        return arguments.length < 2 ? ne2(ee2[e2]) || ne2(te2[e2]) : ee2[e2] && ee2[e2][t3] || te2[e2] && te2[e2][t3];
      }, oe2 = h.navigator, se2 = oe2 && oe2.userAgent, ae2 = se2 ? String(se2) : "", ce2 = h, de2 = ae2, le2 = ce2.process, ue = ce2.Deno, he2 = le2 && le2.versions || ue && ue.version, pe2 = he2 && he2.v8;
      pe2 && (V2 = (U2 = pe2.split("."))[0] > 0 && U2[0] < 4 ? 1 : +(U2[0] + U2[1])), !V2 && de2 && (!(U2 = de2.match(/Edge\/(\d+)/)) || U2[1] >= 74) && (U2 = de2.match(/Chrome\/(\d+)/)) && (V2 = +U2[1]);
      var _e = V2, Ee2 = _e, me2 = n2, fe2 = h.String, Se2 = !!Object.getOwnPropertySymbols && !me2(function() {
        var e2 = Symbol("symbol detection");
        return !fe2(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Ee2 && Ee2 < 41;
      }), ge2 = Se2 && !Symbol.sham && "symbol" == typeof Symbol.iterator, Te2 = re2, Re2 = b, ve2 = l, Ce2 = Object, ye2 = ge2 ? function(e2) {
        return "symbol" == typeof e2;
      } : function(e2) {
        var t3 = Te2("Symbol");
        return Re2(t3) && ve2(t3.prototype, Ce2(e2));
      }, Ie2 = String, be2 = function(e2) {
        try {
          return Ie2(e2);
        } catch (e3) {
          return "Object";
        }
      }, Ae2 = b, we2 = be2, Oe2 = TypeError, Ne2 = function(e2) {
        if (Ae2(e2)) return e2;
        throw new Oe2(we2(e2) + " is not a function");
      }, De2 = Ne2, Pe2 = H, Le2 = function(e2, t3) {
        var i2 = e2[t3];
        return Pe2(i2) ? void 0 : De2(i2);
      }, ke2 = D2, Me2 = b, Ue2 = Q2, Ve2 = TypeError, xe2 = { exports: {} }, Fe2 = h, Be2 = Object.defineProperty, je2 = h, Ge2 = function(e2, t3) {
        try {
          Be2(Fe2, e2, { value: t3, configurable: true, writable: true });
        } catch (i2) {
          Fe2[e2] = t3;
        }
        return t3;
      }, We2 = "__core-js_shared__", He2 = xe2.exports = je2[We2] || Ge2(We2, {});
      (He2.versions || (He2.versions = [])).push({ version: "3.42.0", mode: "pure", copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.42.0/LICENSE", source: "https://github.com/zloirock/core-js" });
      var Ke2 = xe2.exports, Ye2 = Ke2, ze2 = function(e2, t3) {
        return Ye2[e2] || (Ye2[e2] = t3 || {});
      }, qe2 = z, Xe2 = Object, Je2 = function(e2) {
        return Xe2(qe2(e2));
      }, Ze2 = Je2, Qe2 = d({}.hasOwnProperty), $e2 = Object.hasOwn || function(e2, t3) {
        return Qe2(Ze2(e2), t3);
      }, et2 = d, tt2 = 0, it2 = Math.random(), nt2 = et2(1 .toString), rt2 = function(e2) {
        return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + nt2(++tt2 + it2, 36);
      }, ot2 = ze2, st2 = $e2, at2 = rt2, ct2 = Se2, dt2 = ge2, lt2 = h.Symbol, ut2 = ot2("wks"), ht2 = dt2 ? lt2.for || lt2 : lt2 && lt2.withoutSetter || at2, pt2 = function(e2) {
        return st2(ut2, e2) || (ut2[e2] = ct2 && st2(lt2, e2) ? lt2[e2] : ht2("Symbol." + e2)), ut2[e2];
      }, _t = D2, Et2 = Q2, mt2 = ye2, ft2 = Le2, St2 = function(e2, t3) {
        var i2, n3;
        if ("string" === t3 && Me2(i2 = e2.toString) && !Ue2(n3 = ke2(i2, e2))) return n3;
        if (Me2(i2 = e2.valueOf) && !Ue2(n3 = ke2(i2, e2))) return n3;
        if ("string" !== t3 && Me2(i2 = e2.toString) && !Ue2(n3 = ke2(i2, e2))) return n3;
        throw new Ve2("Can't convert object to primitive value");
      }, gt2 = TypeError, Tt2 = pt2("toPrimitive"), Rt2 = function(e2, t3) {
        if (!Et2(e2) || mt2(e2)) return e2;
        var i2, n3 = ft2(e2, Tt2);
        if (n3) {
          if (void 0 === t3 && (t3 = "default"), i2 = _t(n3, e2, t3), !Et2(i2) || mt2(i2)) return i2;
          throw new gt2("Can't convert object to primitive value");
        }
        return void 0 === t3 && (t3 = "number"), St2(e2, t3);
      }, vt2 = ye2, Ct2 = function(e2) {
        var t3 = Rt2(e2, "string");
        return vt2(t3) ? t3 : t3 + "";
      }, yt2 = Q2, It2 = h.document, bt2 = yt2(It2) && yt2(It2.createElement), At2 = function(e2) {
        return bt2 ? It2.createElement(e2) : {};
      }, wt2 = At2, Ot2 = !w2 && !n2(function() {
        return 7 !== Object.defineProperty(wt2("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), Nt2 = w2, Dt2 = D2, Pt2 = P, Lt2 = x, kt2 = J2, Mt2 = Ct2, Ut2 = $e2, Vt = Ot2, xt2 = Object.getOwnPropertyDescriptor;
      A.f = Nt2 ? xt2 : function(e2, t3) {
        if (e2 = kt2(e2), t3 = Mt2(t3), Vt) try {
          return xt2(e2, t3);
        } catch (e3) {
        }
        if (Ut2(e2, t3)) return Lt2(!Dt2(Pt2.f, e2, t3), e2[t3]);
      };
      var Ft2 = n2, Bt2 = b, jt2 = /#|\.prototype\./, Gt2 = function(e2, t3) {
        var i2 = Ht2[Wt(e2)];
        return i2 === Yt2 || i2 !== Kt2 && (Bt2(t3) ? Ft2(t3) : !!t3);
      }, Wt = Gt2.normalize = function(e2) {
        return String(e2).replace(jt2, ".").toLowerCase();
      }, Ht2 = Gt2.data = {}, Kt2 = Gt2.NATIVE = "N", Yt2 = Gt2.POLYFILL = "P", zt2 = Gt2, qt2 = Ne2, Xt2 = r, Jt2 = y2(y2.bind), Zt2 = function(e2, t3) {
        return qt2(e2), void 0 === t3 ? e2 : Xt2 ? Jt2(e2, t3) : function() {
          return e2.apply(t3, arguments);
        };
      }, Qt2 = {}, $t2 = w2 && n2(function() {
        return 42 !== Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), ei2 = Q2, ti2 = String, ii2 = TypeError, ni2 = function(e2) {
        if (ei2(e2)) return e2;
        throw new ii2(ti2(e2) + " is not an object");
      }, ri2 = w2, oi2 = Ot2, si2 = $t2, ai2 = ni2, ci2 = Ct2, di2 = TypeError, li2 = Object.defineProperty, ui2 = Object.getOwnPropertyDescriptor, hi2 = "enumerable", pi2 = "configurable", _i = "writable";
      Qt2.f = ri2 ? si2 ? function(e2, t3, i2) {
        if (ai2(e2), t3 = ci2(t3), ai2(i2), "function" == typeof e2 && "prototype" === t3 && "value" in i2 && _i in i2 && !i2[_i]) {
          var n3 = ui2(e2, t3);
          n3 && n3[_i] && (e2[t3] = i2.value, i2 = { configurable: pi2 in i2 ? i2[pi2] : n3[pi2], enumerable: hi2 in i2 ? i2[hi2] : n3[hi2], writable: false });
        }
        return li2(e2, t3, i2);
      } : li2 : function(e2, t3, i2) {
        if (ai2(e2), t3 = ci2(t3), ai2(i2), oi2) try {
          return li2(e2, t3, i2);
        } catch (e3) {
        }
        if ("get" in i2 || "set" in i2) throw new di2("Accessors not supported");
        return "value" in i2 && (e2[t3] = i2.value), e2;
      };
      var Ei = Qt2, mi2 = x, fi2 = w2 ? function(e2, t3, i2) {
        return Ei.f(e2, t3, mi2(1, i2));
      } : function(e2, t3, i2) {
        return e2[t3] = i2, e2;
      }, Si2 = h, gi2 = f, Ti2 = y2, Ri2 = b, vi2 = A.f, Ci2 = zt2, yi2 = $, Ii2 = Zt2, bi2 = fi2, Ai2 = $e2, wi2 = function(e2) {
        var t3 = function(i2, n3, r2) {
          if (this instanceof t3) {
            switch (arguments.length) {
              case 0:
                return new e2();
              case 1:
                return new e2(i2);
              case 2:
                return new e2(i2, n3);
            }
            return new e2(i2, n3, r2);
          }
          return gi2(e2, this, arguments);
        };
        return t3.prototype = e2.prototype, t3;
      }, Oi2 = function(e2, t3) {
        var i2, n3, r2, o2, s2, a3, c3, d2, l2, u3 = e2.target, h2 = e2.global, p2 = e2.stat, _2 = e2.proto, E3 = h2 ? Si2 : p2 ? Si2[u3] : Si2[u3] && Si2[u3].prototype, m3 = h2 ? yi2 : yi2[u3] || bi2(yi2, u3, {})[u3], f2 = m3.prototype;
        for (o2 in t3) n3 = !(i2 = Ci2(h2 ? o2 : u3 + (p2 ? "." : "#") + o2, e2.forced)) && E3 && Ai2(E3, o2), a3 = m3[o2], n3 && (c3 = e2.dontCallGetSet ? (l2 = vi2(E3, o2)) && l2.value : E3[o2]), s2 = n3 && c3 ? c3 : t3[o2], (i2 || _2 || typeof a3 != typeof s2) && (d2 = e2.bind && n3 ? Ii2(s2, Si2) : e2.wrap && n3 ? wi2(s2) : _2 && Ri2(s2) ? Ti2(s2) : s2, (e2.sham || s2 && s2.sham || a3 && a3.sham) && bi2(d2, "sham", true), bi2(m3, o2, d2), _2 && (Ai2(yi2, r2 = u3 + "Prototype") || bi2(yi2, r2, {}), bi2(yi2[r2], o2, s2), e2.real && f2 && (i2 || !f2[o2]) && bi2(f2, o2, s2)));
      }, Ni2 = Math.ceil, Di = Math.floor, Pi2 = Math.trunc || function(e2) {
        var t3 = +e2;
        return (t3 > 0 ? Di : Ni2)(t3);
      }, Li2 = Pi2, ki2 = function(e2) {
        var t3 = +e2;
        return t3 != t3 || 0 === t3 ? 0 : Li2(t3);
      }, Mi2 = ki2, Ui2 = Math.max, Vi2 = Math.min, xi2 = function(e2, t3) {
        var i2 = Mi2(e2);
        return i2 < 0 ? Ui2(i2 + t3, 0) : Vi2(i2, t3);
      }, Fi = ki2, Bi2 = Math.min, ji2 = function(e2) {
        var t3 = Fi(e2);
        return t3 > 0 ? Bi2(t3, 9007199254740991) : 0;
      }, Gi = ji2, Wi2 = function(e2) {
        return Gi(e2.length);
      }, Hi2 = J2, Ki2 = xi2, Yi2 = Wi2, zi2 = function(e2) {
        return function(t3, i2, n3) {
          var r2 = Hi2(t3), o2 = Yi2(r2);
          if (0 === o2) return !e2 && -1;
          var s2, a3 = Ki2(n3, o2);
          if (e2 && i2 != i2) {
            for (; o2 > a3; ) if ((s2 = r2[a3++]) != s2) return true;
          } else for (; o2 > a3; a3++) if ((e2 || a3 in r2) && r2[a3] === i2) return e2 || a3 || 0;
          return !e2 && -1;
        };
      }, qi2 = { includes: zi2(true), indexOf: zi2(false) }, Xi2 = qi2.includes;
      Oi2({ target: "Array", proto: true, forced: n2(function() {
        return !Array(1).includes();
      }) }, { includes: function(e2) {
        return Xi2(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var Ji2 = h, Zi2 = $, Qi2 = function(e2, t3) {
        var i2 = Zi2[e2 + "Prototype"], n3 = i2 && i2[t3];
        if (n3) return n3;
        var r2 = Ji2[e2], o2 = r2 && r2.prototype;
        return o2 && o2[t3];
      }, $i2 = Qi2("Array", "includes"), en2 = Q2, tn2 = R2, nn2 = pt2("match"), rn2 = function(e2) {
        var t3;
        return en2(e2) && (void 0 !== (t3 = e2[nn2]) ? !!t3 : "RegExp" === tn2(e2));
      }, on2 = rn2, sn2 = TypeError, an2 = {};
      an2[pt2("toStringTag")] = "z";
      var cn2 = "[object z]" === String(an2), dn2 = cn2, ln2 = b, un2 = R2, hn2 = pt2("toStringTag"), pn2 = Object, _n = "Arguments" === un2(/* @__PURE__ */ function() {
        return arguments;
      }()), En2 = dn2 ? un2 : function(e2) {
        var t3, i2, n3;
        return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t4) {
          try {
            return e3[t4];
          } catch (e4) {
          }
        }(t3 = pn2(e2), hn2)) ? i2 : _n ? un2(t3) : "Object" === (n3 = un2(t3)) && ln2(t3.callee) ? "Arguments" : n3;
      }, mn2 = En2, fn2 = String, Sn2 = function(e2) {
        if ("Symbol" === mn2(e2)) throw new TypeError("Cannot convert a Symbol value to a string");
        return fn2(e2);
      }, gn2 = pt2("match"), Tn2 = Oi2, Rn2 = function(e2) {
        if (on2(e2)) throw new sn2("The method doesn't accept regular expressions");
        return e2;
      }, vn2 = z, Cn2 = Sn2, yn2 = function(e2) {
        var t3 = /./;
        try {
          "/./"[e2](t3);
        } catch (i2) {
          try {
            return t3[gn2] = false, "/./"[e2](t3);
          } catch (e3) {
          }
        }
        return false;
      }, In2 = d("".indexOf);
      Tn2({ target: "String", proto: true, forced: !yn2("includes") }, { includes: function(e2) {
        return !!~In2(Cn2(vn2(this)), Cn2(Rn2(e2)), arguments.length > 1 ? arguments[1] : void 0);
      } });
      var bn2 = Qi2("String", "includes"), An2 = l, wn2 = $i2, On2 = bn2, Nn2 = Array.prototype, Dn2 = String.prototype, Pn2 = function(e2) {
        var t3 = e2.includes;
        return e2 === Nn2 || An2(Nn2, e2) && t3 === Nn2.includes ? wn2 : "string" == typeof e2 || e2 === Dn2 || An2(Dn2, e2) && t3 === Dn2.includes ? On2 : t3;
      }, Ln2 = i(Pn2), kn2 = Ne2, Mn2 = Je2, Un2 = W2, Vn2 = Wi2, xn2 = TypeError, Fn2 = "Reduce of empty array with no initial value", Bn2 = function(e2) {
        return function(t3, i2, n3, r2) {
          var o2 = Mn2(t3), s2 = Un2(o2), a3 = Vn2(o2);
          if (kn2(i2), 0 === a3 && n3 < 2) throw new xn2(Fn2);
          var c3 = e2 ? a3 - 1 : 0, d2 = e2 ? -1 : 1;
          if (n3 < 2) for (; ; ) {
            if (c3 in s2) {
              r2 = s2[c3], c3 += d2;
              break;
            }
            if (c3 += d2, e2 ? c3 < 0 : a3 <= c3) throw new xn2(Fn2);
          }
          for (; e2 ? c3 >= 0 : a3 > c3; c3 += d2) c3 in s2 && (r2 = i2(r2, s2[c3], c3, o2));
          return r2;
        };
      }, jn2 = { left: Bn2(false), right: Bn2(true) }, Gn2 = n2, Wn2 = function(e2, t3) {
        var i2 = [][e2];
        return !!i2 && Gn2(function() {
          i2.call(null, t3 || function() {
            return 1;
          }, 1);
        });
      }, Hn2 = h, Kn2 = ae2, Yn2 = R2, zn2 = function(e2) {
        return Kn2.slice(0, e2.length) === e2;
      }, qn2 = zn2("Bun/") ? "BUN" : zn2("Cloudflare-Workers") ? "CLOUDFLARE" : zn2("Deno/") ? "DENO" : zn2("Node.js/") ? "NODE" : Hn2.Bun && "string" == typeof Bun.version ? "BUN" : Hn2.Deno && "object" == typeof Deno.version ? "DENO" : "process" === Yn2(Hn2.process) ? "NODE" : Hn2.window && Hn2.document ? "BROWSER" : "REST", Xn2 = "NODE" === qn2, Jn2 = jn2.left;
      Oi2({ target: "Array", proto: true, forced: !Xn2 && _e > 79 && _e < 83 || !Wn2("reduce") }, { reduce: function(e2) {
        var t3 = arguments.length;
        return Jn2(this, e2, t3, t3 > 1 ? arguments[1] : void 0);
      } });
      var Zn2 = Qi2("Array", "reduce"), Qn2 = l, $n2 = Zn2, er2 = Array.prototype, tr2 = function(e2) {
        var t3 = e2.reduce;
        return e2 === er2 || Qn2(er2, e2) && t3 === er2.reduce ? $n2 : t3;
      }, ir2 = tr2, nr2 = i(ir2), rr2 = R2, or2 = Array.isArray || function(e2) {
        return "Array" === rr2(e2);
      }, sr2 = Oi2, ar2 = or2, cr2 = d([].reverse), dr2 = [1, 2];
      sr2({ target: "Array", proto: true, forced: String(dr2) === String(dr2.reverse()) }, { reverse: function() {
        return ar2(this) && (this.length = this.length), cr2(this);
      } });
      var lr2 = Qi2("Array", "reverse"), ur2 = l, hr2 = lr2, pr2 = Array.prototype, _r = function(e2) {
        var t3 = e2.reverse;
        return e2 === pr2 || ur2(pr2, e2) && t3 === pr2.reverse ? hr2 : t3;
      }, Er2 = _r, mr2 = i(Er2), fr2 = rt2, Sr2 = ze2("keys"), gr2 = function(e2) {
        return Sr2[e2] || (Sr2[e2] = fr2(e2));
      }, Tr2 = !n2(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), Rr2 = $e2, vr2 = b, Cr2 = Je2, yr2 = Tr2, Ir2 = gr2("IE_PROTO"), br2 = Object, Ar2 = br2.prototype, wr2 = yr2 ? br2.getPrototypeOf : function(e2) {
        var t3 = Cr2(e2);
        if (Rr2(t3, Ir2)) return t3[Ir2];
        var i2 = t3.constructor;
        return vr2(i2) && t3 instanceof i2 ? i2.prototype : t3 instanceof br2 ? Ar2 : null;
      }, Or2 = d, Nr2 = Ne2, Dr2 = Q2, Pr2 = function(e2) {
        return Dr2(e2) || null === e2;
      }, Lr2 = String, kr2 = TypeError, Mr2 = function(e2, t3, i2) {
        try {
          return Or2(Nr2(Object.getOwnPropertyDescriptor(e2, t3)[i2]));
        } catch (e3) {
        }
      }, Ur2 = Q2, Vr2 = z, xr2 = function(e2) {
        if (Pr2(e2)) return e2;
        throw new kr2("Can't set " + Lr2(e2) + " as a prototype");
      }, Fr2 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t3 = false, i2 = {};
        try {
          (e2 = Mr2(Object.prototype, "__proto__", "set"))(i2, []), t3 = i2 instanceof Array;
        } catch (e3) {
        }
        return function(i3, n3) {
          return Vr2(i3), xr2(n3), Ur2(i3) ? (t3 ? e2(i3, n3) : i3.__proto__ = n3, i3) : i3;
        };
      }() : void 0), Br2 = {}, jr2 = {}, Gr2 = $e2, Wr2 = J2, Hr2 = qi2.indexOf, Kr2 = jr2, Yr2 = d([].push), zr2 = function(e2, t3) {
        var i2, n3 = Wr2(e2), r2 = 0, o2 = [];
        for (i2 in n3) !Gr2(Kr2, i2) && Gr2(n3, i2) && Yr2(o2, i2);
        for (; t3.length > r2; ) Gr2(n3, i2 = t3[r2++]) && (~Hr2(o2, i2) || Yr2(o2, i2));
        return o2;
      }, qr2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Xr2 = zr2, Jr2 = qr2.concat("length", "prototype");
      Br2.f = Object.getOwnPropertyNames || function(e2) {
        return Xr2(e2, Jr2);
      };
      var Zr2 = {};
      Zr2.f = Object.getOwnPropertySymbols;
      var Qr2 = re2, $r2 = Br2, eo2 = Zr2, to2 = ni2, io2 = d([].concat), no2 = Qr2("Reflect", "ownKeys") || function(e2) {
        var t3 = $r2.f(to2(e2)), i2 = eo2.f;
        return i2 ? io2(t3, i2(e2)) : t3;
      }, ro2 = $e2, oo2 = no2, so2 = A, ao2 = Qt2, co2 = {}, lo2 = zr2, uo2 = qr2, ho2 = Object.keys || function(e2) {
        return lo2(e2, uo2);
      }, po2 = w2, _o = $t2, Eo2 = Qt2, mo2 = ni2, fo2 = J2, So2 = ho2;
      co2.f = po2 && !_o ? Object.defineProperties : function(e2, t3) {
        mo2(e2);
        for (var i2, n3 = fo2(t3), r2 = So2(t3), o2 = r2.length, s2 = 0; o2 > s2; ) Eo2.f(e2, i2 = r2[s2++], n3[i2]);
        return e2;
      };
      var go2, To2 = re2("document", "documentElement"), Ro2 = ni2, vo2 = co2, Co2 = qr2, yo2 = jr2, Io2 = To2, bo2 = At2, Ao2 = "prototype", wo2 = "script", Oo2 = gr2("IE_PROTO"), No2 = function() {
      }, Do2 = function(e2) {
        return "<" + wo2 + ">" + e2 + "</" + wo2 + ">";
      }, Po2 = function(e2) {
        e2.write(Do2("")), e2.close();
        var t3 = e2.parentWindow.Object;
        return e2 = null, t3;
      }, Lo2 = function() {
        try {
          go2 = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t3, i2;
        Lo2 = "undefined" != typeof document ? document.domain && go2 ? Po2(go2) : (t3 = bo2("iframe"), i2 = "java" + wo2 + ":", t3.style.display = "none", Io2.appendChild(t3), t3.src = String(i2), (e2 = t3.contentWindow.document).open(), e2.write(Do2("document.F=Object")), e2.close(), e2.F) : Po2(go2);
        for (var n3 = Co2.length; n3--; ) delete Lo2[Ao2][Co2[n3]];
        return Lo2();
      };
      yo2[Oo2] = true;
      var ko2 = Object.create || function(e2, t3) {
        var i2;
        return null !== e2 ? (No2[Ao2] = Ro2(e2), i2 = new No2(), No2[Ao2] = null, i2[Oo2] = e2) : i2 = Lo2(), void 0 === t3 ? i2 : vo2.f(i2, t3);
      }, Mo2 = Q2, Uo2 = fi2, Vo2 = Error, xo2 = d("".replace), Fo2 = String(new Vo2("zxcasd").stack), Bo2 = /\n\s*at [^:]*:[^\n]*/, jo2 = Bo2.test(Fo2), Go2 = x, Wo2 = !n2(function() {
        var e2 = new Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", Go2(1, 7)), 7 !== e2.stack);
      }), Ho2 = fi2, Ko2 = function(e2, t3) {
        if (jo2 && "string" == typeof e2 && !Vo2.prepareStackTrace) for (; t3--; ) e2 = xo2(e2, Bo2, "");
        return e2;
      }, Yo2 = Wo2, zo2 = Error.captureStackTrace, qo2 = {}, Xo2 = qo2, Jo2 = pt2("iterator"), Zo2 = Array.prototype, Qo2 = function(e2) {
        return void 0 !== e2 && (Xo2.Array === e2 || Zo2[Jo2] === e2);
      }, $o2 = En2, es2 = Le2, ts2 = H, is2 = qo2, ns2 = pt2("iterator"), rs2 = function(e2) {
        if (!ts2(e2)) return es2(e2, ns2) || es2(e2, "@@iterator") || is2[$o2(e2)];
      }, os2 = D2, ss2 = Ne2, as2 = ni2, cs2 = be2, ds2 = rs2, ls2 = TypeError, us2 = function(e2, t3) {
        var i2 = arguments.length < 2 ? ds2(e2) : t3;
        if (ss2(i2)) return as2(os2(i2, e2));
        throw new ls2(cs2(e2) + " is not iterable");
      }, hs2 = D2, ps2 = ni2, _s = Le2, Es2 = function(e2, t3, i2) {
        var n3, r2;
        ps2(e2);
        try {
          if (!(n3 = _s(e2, "return"))) {
            if ("throw" === t3) throw i2;
            return i2;
          }
          n3 = hs2(n3, e2);
        } catch (e3) {
          r2 = true, n3 = e3;
        }
        if ("throw" === t3) throw i2;
        if (r2) throw n3;
        return ps2(n3), i2;
      }, ms2 = Zt2, fs2 = D2, Ss2 = ni2, gs2 = be2, Ts2 = Qo2, Rs2 = Wi2, vs2 = l, Cs2 = us2, ys2 = rs2, Is2 = Es2, bs2 = TypeError, As2 = function(e2, t3) {
        this.stopped = e2, this.result = t3;
      }, ws2 = As2.prototype, Os2 = function(e2, t3, i2) {
        var n3, r2, o2, s2, a3, c3, d2, l2 = i2 && i2.that, u3 = !(!i2 || !i2.AS_ENTRIES), h2 = !(!i2 || !i2.IS_RECORD), p2 = !(!i2 || !i2.IS_ITERATOR), _2 = !(!i2 || !i2.INTERRUPTED), E3 = ms2(t3, l2), m3 = function(e3) {
          return n3 && Is2(n3, "normal", e3), new As2(true, e3);
        }, f2 = function(e3) {
          return u3 ? (Ss2(e3), _2 ? E3(e3[0], e3[1], m3) : E3(e3[0], e3[1])) : _2 ? E3(e3, m3) : E3(e3);
        };
        if (h2) n3 = e2.iterator;
        else if (p2) n3 = e2;
        else {
          if (!(r2 = ys2(e2))) throw new bs2(gs2(e2) + " is not iterable");
          if (Ts2(r2)) {
            for (o2 = 0, s2 = Rs2(e2); s2 > o2; o2++) if ((a3 = f2(e2[o2])) && vs2(ws2, a3)) return a3;
            return new As2(false);
          }
          n3 = Cs2(e2, r2);
        }
        for (c3 = h2 ? e2.next : n3.next; !(d2 = fs2(c3, n3)).done; ) {
          try {
            a3 = f2(d2.value);
          } catch (e3) {
            Is2(n3, "throw", e3);
          }
          if ("object" == typeof a3 && a3 && vs2(ws2, a3)) return a3;
        }
        return new As2(false);
      }, Ns2 = Sn2, Ds2 = Oi2, Ps2 = l, Ls2 = wr2, ks2 = Fr2, Ms2 = function(e2, t3, i2) {
        for (var n3 = oo2(t3), r2 = ao2.f, o2 = so2.f, s2 = 0; s2 < n3.length; s2++) {
          var a3 = n3[s2];
          ro2(e2, a3) || i2 && ro2(i2, a3) || r2(e2, a3, o2(t3, a3));
        }
      }, Us2 = ko2, Vs2 = fi2, xs2 = x, Fs2 = function(e2, t3) {
        Mo2(t3) && "cause" in t3 && Uo2(e2, "cause", t3.cause);
      }, Bs2 = function(e2, t3, i2, n3) {
        Yo2 && (zo2 ? zo2(e2, t3) : Ho2(e2, "stack", Ko2(i2, n3)));
      }, js2 = Os2, Gs2 = function(e2, t3) {
        return void 0 === e2 ? arguments.length < 2 ? "" : t3 : Ns2(e2);
      }, Ws2 = pt2("toStringTag"), Hs2 = Error, Ks2 = [].push, Ys2 = function(e2, t3) {
        var i2, n3 = Ps2(zs2, this);
        ks2 ? i2 = ks2(new Hs2(), n3 ? Ls2(this) : zs2) : (i2 = n3 ? this : Us2(zs2), Vs2(i2, Ws2, "Error")), void 0 !== t3 && Vs2(i2, "message", Gs2(t3)), Bs2(i2, Ys2, i2.stack, 1), arguments.length > 2 && Fs2(i2, arguments[2]);
        var r2 = [];
        return js2(e2, Ks2, { that: r2 }), Vs2(i2, "errors", r2), i2;
      };
      ks2 ? ks2(Ys2, Hs2) : Ms2(Ys2, Hs2, { name: true });
      var zs2 = Ys2.prototype = Us2(Hs2.prototype, { constructor: xs2(1, Ys2), message: xs2(1, ""), name: xs2(1, "AggregateError") });
      Ds2({ global: true, constructor: true, arity: 2 }, { AggregateError: Ys2 });
      var qs2, Xs2, Js2, Zs2 = b, Qs2 = h.WeakMap, $s2 = Zs2(Qs2) && /native code/.test(String(Qs2)), ea2 = h, ta2 = Q2, ia2 = fi2, na2 = $e2, ra2 = Ke2, oa2 = gr2, sa2 = jr2, aa2 = "Object already initialized", ca2 = ea2.TypeError, da2 = ea2.WeakMap;
      if ($s2 || ra2.state) {
        var la2 = ra2.state || (ra2.state = new da2());
        la2.get = la2.get, la2.has = la2.has, la2.set = la2.set, qs2 = function(e2, t3) {
          if (la2.has(e2)) throw new ca2(aa2);
          return t3.facade = e2, la2.set(e2, t3), t3;
        }, Xs2 = function(e2) {
          return la2.get(e2) || {};
        }, Js2 = function(e2) {
          return la2.has(e2);
        };
      } else {
        var ua2 = oa2("state");
        sa2[ua2] = true, qs2 = function(e2, t3) {
          if (na2(e2, ua2)) throw new ca2(aa2);
          return t3.facade = e2, ia2(e2, ua2, t3), t3;
        }, Xs2 = function(e2) {
          return na2(e2, ua2) ? e2[ua2] : {};
        }, Js2 = function(e2) {
          return na2(e2, ua2);
        };
      }
      var ha2, pa2, _a, Ea2 = { set: qs2, get: Xs2, has: Js2, enforce: function(e2) {
        return Js2(e2) ? Xs2(e2) : qs2(e2, {});
      }, getterFor: function(e2) {
        return function(t3) {
          var i2;
          if (!ta2(t3) || (i2 = Xs2(t3)).type !== e2) throw new ca2("Incompatible receiver, " + e2 + " required");
          return i2;
        };
      } }, ma2 = w2, fa2 = $e2, Sa2 = Function.prototype, ga = ma2 && Object.getOwnPropertyDescriptor, Ta2 = fa2(Sa2, "name"), Ra2 = { EXISTS: Ta2, PROPER: Ta2 && "something" === (function() {
      }).name, CONFIGURABLE: Ta2 && (!ma2 || ma2 && ga(Sa2, "name").configurable) }, va2 = fi2, Ca2 = function(e2, t3, i2, n3) {
        return n3 && n3.enumerable ? e2[t3] = i2 : va2(e2, t3, i2), e2;
      }, ya2 = n2, Ia2 = b, ba2 = Q2, Aa2 = ko2, wa2 = wr2, Oa2 = Ca2, Na2 = pt2("iterator"), Da2 = false;
      [].keys && ("next" in (_a = [].keys()) ? (pa2 = wa2(wa2(_a))) !== Object.prototype && (ha2 = pa2) : Da2 = true);
      var Pa2 = !ba2(ha2) || ya2(function() {
        var e2 = {};
        return ha2[Na2].call(e2) !== e2;
      });
      Ia2((ha2 = Pa2 ? {} : Aa2(ha2))[Na2]) || Oa2(ha2, Na2, function() {
        return this;
      });
      var La2 = { IteratorPrototype: ha2, BUGGY_SAFARI_ITERATORS: Da2 }, ka2 = En2, Ma2 = cn2 ? {}.toString : function() {
        return "[object " + ka2(this) + "]";
      }, Ua2 = cn2, Va2 = Qt2.f, xa2 = fi2, Fa2 = $e2, Ba2 = Ma2, ja2 = pt2("toStringTag"), Ga2 = function(e2, t3, i2, n3) {
        var r2 = i2 ? e2 : e2 && e2.prototype;
        r2 && (Fa2(r2, ja2) || Va2(r2, ja2, { configurable: true, value: t3 }), n3 && !Ua2 && xa2(r2, "toString", Ba2));
      }, Wa2 = La2.IteratorPrototype, Ha2 = ko2, Ka2 = x, Ya2 = Ga2, za2 = qo2, qa2 = function() {
        return this;
      }, Xa2 = function(e2, t3, i2, n3) {
        var r2 = t3 + " Iterator";
        return e2.prototype = Ha2(Wa2, { next: Ka2(+!n3, i2) }), Ya2(e2, r2, false, true), za2[r2] = qa2, e2;
      }, Ja2 = Oi2, Za2 = D2, Qa2 = Ra2, $a2 = Xa2, ec2 = wr2, tc2 = Ga2, ic2 = Ca2, nc2 = qo2, rc2 = La2, oc2 = Qa2.PROPER, sc2 = rc2.BUGGY_SAFARI_ITERATORS, ac2 = pt2("iterator"), cc2 = "keys", dc2 = "values", lc2 = "entries", uc2 = function() {
        return this;
      }, hc2 = function(e2, t3, i2, n3, r2, o2, s2) {
        $a2(i2, t3, n3);
        var a3, c3, d2, l2 = function(e3) {
          if (e3 === r2 && E3) return E3;
          if (!sc2 && e3 && e3 in p2) return p2[e3];
          switch (e3) {
            case cc2:
            case dc2:
            case lc2:
              return function() {
                return new i2(this, e3);
              };
          }
          return function() {
            return new i2(this);
          };
        }, u3 = t3 + " Iterator", h2 = false, p2 = e2.prototype, _2 = p2[ac2] || p2["@@iterator"] || r2 && p2[r2], E3 = !sc2 && _2 || l2(r2), m3 = "Array" === t3 && p2.entries || _2;
        if (m3 && (a3 = ec2(m3.call(new e2()))) !== Object.prototype && a3.next && (tc2(a3, u3, true, true), nc2[u3] = uc2), oc2 && r2 === dc2 && _2 && _2.name !== dc2 && (h2 = true, E3 = function() {
          return Za2(_2, this);
        }), r2) if (c3 = { values: l2(dc2), keys: o2 ? E3 : l2(cc2), entries: l2(lc2) }, s2) for (d2 in c3) (sc2 || h2 || !(d2 in p2)) && ic2(p2, d2, c3[d2]);
        else Ja2({ target: t3, proto: true, forced: sc2 || h2 }, c3);
        return s2 && p2[ac2] !== E3 && ic2(p2, ac2, E3, { name: r2 }), nc2[t3] = E3, c3;
      }, pc2 = function(e2, t3) {
        return { value: e2, done: t3 };
      }, _c = J2, Ec2 = qo2, mc2 = Ea2;
      Qt2.f;
      var fc2 = hc2, Sc2 = pc2, gc2 = "Array Iterator", Tc2 = mc2.set, Rc2 = mc2.getterFor(gc2);
      fc2(Array, "Array", function(e2, t3) {
        Tc2(this, { type: gc2, target: _c(e2), index: 0, kind: t3 });
      }, function() {
        var e2 = Rc2(this), t3 = e2.target, i2 = e2.index++;
        if (!t3 || i2 >= t3.length) return e2.target = null, Sc2(void 0, true);
        switch (e2.kind) {
          case "keys":
            return Sc2(i2, false);
          case "values":
            return Sc2(t3[i2], false);
        }
        return Sc2([i2, t3[i2]], false);
      }, "values"), Ec2.Arguments = Ec2.Array;
      var vc2 = Qt2, Cc2 = function(e2, t3, i2) {
        return vc2.f(e2, t3, i2);
      }, yc2 = re2, Ic2 = Cc2, bc2 = w2, Ac2 = pt2("species"), wc2 = l, Oc2 = TypeError, Nc2 = function(e2, t3) {
        if (wc2(t3, e2)) return e2;
        throw new Oc2("Incorrect invocation");
      }, Dc2 = b, Pc2 = Ke2, Lc2 = d(Function.toString);
      Dc2(Pc2.inspectSource) || (Pc2.inspectSource = function(e2) {
        return Lc2(e2);
      });
      var kc = Pc2.inspectSource, Mc2 = d, Uc2 = n2, Vc2 = b, xc2 = En2, Fc2 = kc, Bc2 = function() {
      }, jc2 = re2("Reflect", "construct"), Gc2 = /^\s*(?:class|function)\b/, Wc2 = Mc2(Gc2.exec), Hc2 = !Gc2.test(Bc2), Kc2 = function(e2) {
        if (!Vc2(e2)) return false;
        try {
          return jc2(Bc2, [], e2), true;
        } catch (e3) {
          return false;
        }
      }, Yc2 = function(e2) {
        if (!Vc2(e2)) return false;
        switch (xc2(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return Hc2 || !!Wc2(Gc2, Fc2(e2));
        } catch (e3) {
          return true;
        }
      };
      Yc2.sham = true;
      var zc2, qc2, Xc2, Jc2, Zc2 = !jc2 || Uc2(function() {
        var e2;
        return Kc2(Kc2.call) || !Kc2(Object) || !Kc2(function() {
          e2 = true;
        }) || e2;
      }) ? Yc2 : Kc2, Qc2 = Zc2, $c2 = be2, ed2 = TypeError, td2 = ni2, id2 = function(e2) {
        if (Qc2(e2)) return e2;
        throw new ed2($c2(e2) + " is not a constructor");
      }, nd2 = H, rd2 = pt2("species"), od2 = function(e2, t3) {
        var i2, n3 = td2(e2).constructor;
        return void 0 === n3 || nd2(i2 = td2(n3)[rd2]) ? t3 : id2(i2);
      }, sd2 = d([].slice), ad2 = TypeError, cd2 = function(e2, t3) {
        if (e2 < t3) throw new ad2("Not enough arguments");
        return e2;
      }, dd2 = /(?:ipad|iphone|ipod).*applewebkit/i.test(ae2), ld2 = h, ud2 = f, hd2 = Zt2, pd2 = b, _d = $e2, Ed2 = n2, md2 = To2, fd2 = sd2, Sd2 = At2, gd2 = cd2, Td2 = dd2, Rd2 = Xn2, vd2 = ld2.setImmediate, Cd2 = ld2.clearImmediate, yd2 = ld2.process, Id2 = ld2.Dispatch, bd2 = ld2.Function, Ad2 = ld2.MessageChannel, wd2 = ld2.String, Od2 = 0, Nd2 = {}, Dd2 = "onreadystatechange";
      Ed2(function() {
        zc2 = ld2.location;
      });
      var Pd2 = function(e2) {
        if (_d(Nd2, e2)) {
          var t3 = Nd2[e2];
          delete Nd2[e2], t3();
        }
      }, Ld2 = function(e2) {
        return function() {
          Pd2(e2);
        };
      }, kd2 = function(e2) {
        Pd2(e2.data);
      }, Md2 = function(e2) {
        ld2.postMessage(wd2(e2), zc2.protocol + "//" + zc2.host);
      };
      vd2 && Cd2 || (vd2 = function(e2) {
        gd2(arguments.length, 1);
        var t3 = pd2(e2) ? e2 : bd2(e2), i2 = fd2(arguments, 1);
        return Nd2[++Od2] = function() {
          ud2(t3, void 0, i2);
        }, qc2(Od2), Od2;
      }, Cd2 = function(e2) {
        delete Nd2[e2];
      }, Rd2 ? qc2 = function(e2) {
        yd2.nextTick(Ld2(e2));
      } : Id2 && Id2.now ? qc2 = function(e2) {
        Id2.now(Ld2(e2));
      } : Ad2 && !Td2 ? (Jc2 = (Xc2 = new Ad2()).port2, Xc2.port1.onmessage = kd2, qc2 = hd2(Jc2.postMessage, Jc2)) : ld2.addEventListener && pd2(ld2.postMessage) && !ld2.importScripts && zc2 && "file:" !== zc2.protocol && !Ed2(Md2) ? (qc2 = Md2, ld2.addEventListener("message", kd2, false)) : qc2 = Dd2 in Sd2("script") ? function(e2) {
        md2.appendChild(Sd2("script"))[Dd2] = function() {
          md2.removeChild(this), Pd2(e2);
        };
      } : function(e2) {
        setTimeout(Ld2(e2), 0);
      });
      var Ud2 = { set: vd2, clear: Cd2 }, Vd2 = h, xd2 = w2, Fd2 = Object.getOwnPropertyDescriptor, Bd2 = function(e2) {
        if (!xd2) return Vd2[e2];
        var t3 = Fd2(Vd2, e2);
        return t3 && t3.value;
      }, jd2 = function() {
        this.head = null, this.tail = null;
      };
      jd2.prototype = { add: function(e2) {
        var t3 = { item: e2, next: null }, i2 = this.tail;
        i2 ? i2.next = t3 : this.head = t3, this.tail = t3;
      }, get: function() {
        var e2 = this.head;
        if (e2) return null === (this.head = e2.next) && (this.tail = null), e2.item;
      } };
      var Gd2, Wd2, Hd2, Kd2, Yd2, zd2 = jd2, qd2 = /ipad|iphone|ipod/i.test(ae2) && "undefined" != typeof Pebble, Xd2 = /web0s(?!.*chrome)/i.test(ae2), Jd2 = h, Zd2 = Bd2, Qd2 = Zt2, $d2 = Ud2.set, el2 = zd2, tl2 = dd2, il2 = qd2, nl2 = Xd2, rl2 = Xn2, ol2 = Jd2.MutationObserver || Jd2.WebKitMutationObserver, sl2 = Jd2.document, al2 = Jd2.process, cl2 = Jd2.Promise, dl2 = Zd2("queueMicrotask");
      if (!dl2) {
        var ll2 = new el2(), ul2 = function() {
          var e2, t3;
          for (rl2 && (e2 = al2.domain) && e2.exit(); t3 = ll2.get(); ) try {
            t3();
          } catch (e3) {
            throw ll2.head && Gd2(), e3;
          }
          e2 && e2.enter();
        };
        tl2 || rl2 || nl2 || !ol2 || !sl2 ? !il2 && cl2 && cl2.resolve ? ((Kd2 = cl2.resolve(void 0)).constructor = cl2, Yd2 = Qd2(Kd2.then, Kd2), Gd2 = function() {
          Yd2(ul2);
        }) : rl2 ? Gd2 = function() {
          al2.nextTick(ul2);
        } : ($d2 = Qd2($d2, Jd2), Gd2 = function() {
          $d2(ul2);
        }) : (Wd2 = true, Hd2 = sl2.createTextNode(""), new ol2(ul2).observe(Hd2, { characterData: true }), Gd2 = function() {
          Hd2.data = Wd2 = !Wd2;
        }), dl2 = function(e2) {
          ll2.head || Gd2(), ll2.add(e2);
        };
      }
      var hl2 = dl2, pl2 = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, _l = h.Promise, El2 = h, ml2 = _l, fl2 = b, Sl2 = zt2, gl2 = kc, Tl2 = pt2, Rl2 = qn2, vl2 = _e, Cl2 = ml2 && ml2.prototype, yl2 = Tl2("species"), Il2 = false, bl2 = fl2(El2.PromiseRejectionEvent), Al2 = Sl2("Promise", function() {
        var e2 = gl2(ml2), t3 = e2 !== String(ml2);
        if (!t3 && 66 === vl2) return true;
        if (!Cl2.catch || !Cl2.finally) return true;
        if (!vl2 || vl2 < 51 || !/native code/.test(e2)) {
          var i2 = new ml2(function(e3) {
            e3(1);
          }), n3 = function(e3) {
            e3(function() {
            }, function() {
            });
          };
          if ((i2.constructor = {})[yl2] = n3, !(Il2 = i2.then(function() {
          }) instanceof n3)) return true;
        }
        return !(t3 || "BROWSER" !== Rl2 && "DENO" !== Rl2 || bl2);
      }), wl2 = { CONSTRUCTOR: Al2, REJECTION_EVENT: bl2, SUBCLASSING: Il2 }, Ol2 = {}, Nl2 = Ne2, Dl2 = TypeError, Pl2 = function(e2) {
        var t3, i2;
        this.promise = new e2(function(e3, n3) {
          if (void 0 !== t3 || void 0 !== i2) throw new Dl2("Bad Promise constructor");
          t3 = e3, i2 = n3;
        }), this.resolve = Nl2(t3), this.reject = Nl2(i2);
      };
      Ol2.f = function(e2) {
        return new Pl2(e2);
      };
      var Ll2, kl2, Ml2 = Oi2, Ul2 = Xn2, Vl2 = h, xl2 = D2, Fl2 = Ca2, Bl2 = Ga2, jl2 = function(e2) {
        var t3 = yc2(e2);
        bc2 && t3 && !t3[Ac2] && Ic2(t3, Ac2, { configurable: true, get: function() {
          return this;
        } });
      }, Gl2 = Ne2, Wl2 = b, Hl2 = Q2, Kl2 = Nc2, Yl2 = od2, zl2 = Ud2.set, ql2 = hl2, Xl2 = function(e2, t3) {
        try {
          1 === arguments.length ? console.error(e2) : console.error(e2, t3);
        } catch (e3) {
        }
      }, Jl2 = pl2, Zl2 = zd2, Ql2 = Ea2, $l2 = _l, eu2 = wl2, tu2 = Ol2, iu2 = "Promise", nu2 = eu2.CONSTRUCTOR, ru2 = eu2.REJECTION_EVENT, ou2 = Ql2.getterFor(iu2), su2 = Ql2.set, au2 = $l2 && $l2.prototype, cu2 = $l2, du2 = au2, lu2 = Vl2.TypeError, uu2 = Vl2.document, hu2 = Vl2.process, pu2 = tu2.f, _u = pu2, Eu2 = !!(uu2 && uu2.createEvent && Vl2.dispatchEvent), mu2 = "unhandledrejection", fu2 = function(e2) {
        var t3;
        return !(!Hl2(e2) || !Wl2(t3 = e2.then)) && t3;
      }, Su2 = function(e2, t3) {
        var i2, n3, r2, o2 = t3.value, s2 = 1 === t3.state, a3 = s2 ? e2.ok : e2.fail, c3 = e2.resolve, d2 = e2.reject, l2 = e2.domain;
        try {
          a3 ? (s2 || (2 === t3.rejection && Cu2(t3), t3.rejection = 1), true === a3 ? i2 = o2 : (l2 && l2.enter(), i2 = a3(o2), l2 && (l2.exit(), r2 = true)), i2 === e2.promise ? d2(new lu2("Promise-chain cycle")) : (n3 = fu2(i2)) ? xl2(n3, i2, c3, d2) : c3(i2)) : d2(o2);
        } catch (e3) {
          l2 && !r2 && l2.exit(), d2(e3);
        }
      }, gu2 = function(e2, t3) {
        e2.notified || (e2.notified = true, ql2(function() {
          for (var i2, n3 = e2.reactions; i2 = n3.get(); ) Su2(i2, e2);
          e2.notified = false, t3 && !e2.rejection && Ru2(e2);
        }));
      }, Tu2 = function(e2, t3, i2) {
        var n3, r2;
        Eu2 ? ((n3 = uu2.createEvent("Event")).promise = t3, n3.reason = i2, n3.initEvent(e2, false, true), Vl2.dispatchEvent(n3)) : n3 = { promise: t3, reason: i2 }, !ru2 && (r2 = Vl2["on" + e2]) ? r2(n3) : e2 === mu2 && Xl2("Unhandled promise rejection", i2);
      }, Ru2 = function(e2) {
        xl2(zl2, Vl2, function() {
          var t3, i2 = e2.facade, n3 = e2.value;
          if (vu2(e2) && (t3 = Jl2(function() {
            Ul2 ? hu2.emit("unhandledRejection", n3, i2) : Tu2(mu2, i2, n3);
          }), e2.rejection = Ul2 || vu2(e2) ? 2 : 1, t3.error)) throw t3.value;
        });
      }, vu2 = function(e2) {
        return 1 !== e2.rejection && !e2.parent;
      }, Cu2 = function(e2) {
        xl2(zl2, Vl2, function() {
          var t3 = e2.facade;
          Ul2 ? hu2.emit("rejectionHandled", t3) : Tu2("rejectionhandled", t3, e2.value);
        });
      }, yu2 = function(e2, t3, i2) {
        return function(n3) {
          e2(t3, n3, i2);
        };
      }, Iu2 = function(e2, t3, i2) {
        e2.done || (e2.done = true, i2 && (e2 = i2), e2.value = t3, e2.state = 2, gu2(e2, true));
      }, bu2 = function(e2, t3, i2) {
        if (!e2.done) {
          e2.done = true, i2 && (e2 = i2);
          try {
            if (e2.facade === t3) throw new lu2("Promise can't be resolved itself");
            var n3 = fu2(t3);
            n3 ? ql2(function() {
              var i3 = { done: false };
              try {
                xl2(n3, t3, yu2(bu2, i3, e2), yu2(Iu2, i3, e2));
              } catch (t4) {
                Iu2(i3, t4, e2);
              }
            }) : (e2.value = t3, e2.state = 1, gu2(e2, false));
          } catch (t4) {
            Iu2({ done: false }, t4, e2);
          }
        }
      };
      nu2 && (du2 = (cu2 = function(e2) {
        Kl2(this, du2), Gl2(e2), xl2(Ll2, this);
        var t3 = ou2(this);
        try {
          e2(yu2(bu2, t3), yu2(Iu2, t3));
        } catch (e3) {
          Iu2(t3, e3);
        }
      }).prototype, (Ll2 = function(e2) {
        su2(this, { type: iu2, done: false, notified: false, parent: false, reactions: new Zl2(), rejection: false, state: 0, value: null });
      }).prototype = Fl2(du2, "then", function(e2, t3) {
        var i2 = ou2(this), n3 = pu2(Yl2(this, cu2));
        return i2.parent = true, n3.ok = !Wl2(e2) || e2, n3.fail = Wl2(t3) && t3, n3.domain = Ul2 ? hu2.domain : void 0, 0 === i2.state ? i2.reactions.add(n3) : ql2(function() {
          Su2(n3, i2);
        }), n3.promise;
      }), kl2 = function() {
        var e2 = new Ll2(), t3 = ou2(e2);
        this.promise = e2, this.resolve = yu2(bu2, t3), this.reject = yu2(Iu2, t3);
      }, tu2.f = pu2 = function(e2) {
        return e2 === cu2 || void 0 === e2 ? new kl2(e2) : _u(e2);
      }), Ml2({ global: true, constructor: true, wrap: true, forced: nu2 }, { Promise: cu2 }), Bl2(cu2, iu2, false, true), jl2(iu2);
      var Au2 = pt2("iterator"), wu2 = false;
      try {
        var Ou2 = 0, Nu2 = { next: function() {
          return { done: !!Ou2++ };
        }, return: function() {
          wu2 = true;
        } };
        Nu2[Au2] = function() {
          return this;
        }, Array.from(Nu2, function() {
          throw 2;
        });
      } catch (e2) {
      }
      var Du2 = _l, Pu2 = function(e2, t3) {
        try {
          if (!t3 && !wu2) return false;
        } catch (e3) {
          return false;
        }
        var i2 = false;
        try {
          var n3 = {};
          n3[Au2] = function() {
            return { next: function() {
              return { done: i2 = true };
            } };
          }, e2(n3);
        } catch (e3) {
        }
        return i2;
      }, Lu2 = wl2.CONSTRUCTOR || !Pu2(function(e2) {
        Du2.all(e2).then(void 0, function() {
        });
      }), ku2 = D2, Mu2 = Ne2, Uu2 = Ol2, Vu2 = pl2, xu2 = Os2;
      Oi2({ target: "Promise", stat: true, forced: Lu2 }, { all: function(e2) {
        var t3 = this, i2 = Uu2.f(t3), n3 = i2.resolve, r2 = i2.reject, o2 = Vu2(function() {
          var i3 = Mu2(t3.resolve), o3 = [], s2 = 0, a3 = 1;
          xu2(e2, function(e3) {
            var c3 = s2++, d2 = false;
            a3++, ku2(i3, t3, e3).then(function(e4) {
              d2 || (d2 = true, o3[c3] = e4, --a3 || n3(o3));
            }, r2);
          }), --a3 || n3(o3);
        });
        return o2.error && r2(o2.value), i2.promise;
      } });
      var Fu2 = Oi2, Bu2 = wl2.CONSTRUCTOR;
      _l && _l.prototype, Fu2({ target: "Promise", proto: true, forced: Bu2, real: true }, { catch: function(e2) {
        return this.then(void 0, e2);
      } });
      var ju2 = D2, Gu2 = Ne2, Wu2 = Ol2, Hu2 = pl2, Ku2 = Os2;
      Oi2({ target: "Promise", stat: true, forced: Lu2 }, { race: function(e2) {
        var t3 = this, i2 = Wu2.f(t3), n3 = i2.reject, r2 = Hu2(function() {
          var r3 = Gu2(t3.resolve);
          Ku2(e2, function(e3) {
            ju2(r3, t3, e3).then(i2.resolve, n3);
          });
        });
        return r2.error && n3(r2.value), i2.promise;
      } });
      var Yu2 = Ol2;
      Oi2({ target: "Promise", stat: true, forced: wl2.CONSTRUCTOR }, { reject: function(e2) {
        var t3 = Yu2.f(this);
        return (0, t3.reject)(e2), t3.promise;
      } });
      var zu2 = ni2, qu2 = Q2, Xu2 = Ol2, Ju2 = function(e2, t3) {
        if (zu2(e2), qu2(t3) && t3.constructor === e2) return t3;
        var i2 = Xu2.f(e2);
        return (0, i2.resolve)(t3), i2.promise;
      }, Zu2 = Oi2, Qu2 = _l, $u2 = wl2.CONSTRUCTOR, eh2 = Ju2, th2 = re2("Promise"), ih2 = !$u2;
      Zu2({ target: "Promise", stat: true, forced: true }, { resolve: function(e2) {
        return eh2(ih2 && this === th2 ? Qu2 : this, e2);
      } });
      var nh2 = D2, rh2 = Ne2, oh2 = Ol2, sh2 = pl2, ah2 = Os2;
      Oi2({ target: "Promise", stat: true, forced: Lu2 }, { allSettled: function(e2) {
        var t3 = this, i2 = oh2.f(t3), n3 = i2.resolve, r2 = i2.reject, o2 = sh2(function() {
          var i3 = rh2(t3.resolve), r3 = [], o3 = 0, s2 = 1;
          ah2(e2, function(e3) {
            var a3 = o3++, c3 = false;
            s2++, nh2(i3, t3, e3).then(function(e4) {
              c3 || (c3 = true, r3[a3] = { status: "fulfilled", value: e4 }, --s2 || n3(r3));
            }, function(e4) {
              c3 || (c3 = true, r3[a3] = { status: "rejected", reason: e4 }, --s2 || n3(r3));
            });
          }), --s2 || n3(r3);
        });
        return o2.error && r2(o2.value), i2.promise;
      } });
      var ch2 = D2, dh2 = Ne2, lh2 = re2, uh2 = Ol2, hh2 = pl2, ph2 = Os2, _h = "No one promise resolved";
      Oi2({ target: "Promise", stat: true, forced: Lu2 }, { any: function(e2) {
        var t3 = this, i2 = lh2("AggregateError"), n3 = uh2.f(t3), r2 = n3.resolve, o2 = n3.reject, s2 = hh2(function() {
          var n4 = dh2(t3.resolve), s3 = [], a3 = 0, c3 = 1, d2 = false;
          ph2(e2, function(e3) {
            var l2 = a3++, u3 = false;
            c3++, ch2(n4, t3, e3).then(function(e4) {
              u3 || d2 || (d2 = true, r2(e4));
            }, function(e4) {
              u3 || d2 || (u3 = true, s3[l2] = e4, --c3 || o2(new i2(s3, _h)));
            });
          }), --c3 || o2(new i2(s3, _h));
        });
        return s2.error && o2(s2.value), n3.promise;
      } });
      var Eh2 = Oi2, mh2 = f, fh2 = sd2, Sh2 = Ol2, gh2 = Ne2, Th2 = pl2, Rh2 = h.Promise, vh2 = false;
      Eh2({ target: "Promise", stat: true, forced: !Rh2 || !Rh2.try || Th2(function() {
        Rh2.try(function(e2) {
          vh2 = 8 === e2;
        }, 8);
      }).error || !vh2 }, { try: function(e2) {
        var t3 = arguments.length > 1 ? fh2(arguments, 1) : [], i2 = Sh2.f(this), n3 = Th2(function() {
          return mh2(gh2(e2), void 0, t3);
        });
        return (n3.error ? i2.reject : i2.resolve)(n3.value), i2.promise;
      } });
      var Ch2 = Ol2;
      Oi2({ target: "Promise", stat: true }, { withResolvers: function() {
        var e2 = Ch2.f(this);
        return { promise: e2.promise, resolve: e2.resolve, reject: e2.reject };
      } });
      var yh2 = Oi2, Ih2 = _l, bh2 = n2, Ah2 = re2, wh2 = b, Oh2 = od2, Nh2 = Ju2, Dh2 = Ih2 && Ih2.prototype;
      yh2({ target: "Promise", proto: true, real: true, forced: !!Ih2 && bh2(function() {
        Dh2.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t3 = Oh2(this, Ah2("Promise")), i2 = wh2(e2);
        return this.then(i2 ? function(i3) {
          return Nh2(t3, e2()).then(function() {
            return i3;
          });
        } : e2, i2 ? function(i3) {
          return Nh2(t3, e2()).then(function() {
            throw i3;
          });
        } : e2);
      } });
      var Ph2 = d, Lh2 = ki2, kh2 = Sn2, Mh2 = z, Uh2 = Ph2("".charAt), Vh2 = Ph2("".charCodeAt), xh2 = Ph2("".slice), Fh2 = function(e2) {
        return function(t3, i2) {
          var n3, r2, o2 = kh2(Mh2(t3)), s2 = Lh2(i2), a3 = o2.length;
          return s2 < 0 || s2 >= a3 ? e2 ? "" : void 0 : (n3 = Vh2(o2, s2)) < 55296 || n3 > 56319 || s2 + 1 === a3 || (r2 = Vh2(o2, s2 + 1)) < 56320 || r2 > 57343 ? e2 ? Uh2(o2, s2) : n3 : e2 ? xh2(o2, s2, s2 + 2) : r2 - 56320 + (n3 - 55296 << 10) + 65536;
        };
      }, Bh2 = { codeAt: Fh2(false), charAt: Fh2(true) }, jh2 = Bh2.charAt, Gh2 = Sn2, Wh2 = Ea2, Hh2 = hc2, Kh2 = pc2, Yh2 = "String Iterator", zh2 = Wh2.set, qh2 = Wh2.getterFor(Yh2);
      Hh2(String, "String", function(e2) {
        zh2(this, { type: Yh2, string: Gh2(e2), index: 0 });
      }, function() {
        var e2, t3 = qh2(this), i2 = t3.string, n3 = t3.index;
        return n3 >= i2.length ? Kh2(void 0, true) : (e2 = jh2(i2, n3), t3.index += e2.length, Kh2(e2, false));
      });
      var Xh2 = $.Promise, Jh2 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Zh2 = h, Qh2 = Ga2, $h2 = qo2;
      for (var ep2 in Jh2) Qh2(Zh2[ep2], ep2), $h2[ep2] = $h2.Array;
      var tp2 = Xh2, ip2 = i(tp2), np2 = Qi2("Array", "values"), rp2 = En2, op2 = $e2, sp2 = l, ap2 = np2, cp2 = Array.prototype, dp2 = { DOMTokenList: true, NodeList: true }, lp2 = function(e2) {
        var t3 = e2.values;
        return e2 === cp2 || sp2(cp2, e2) && t3 === cp2.values || op2(dp2, rp2(e2)) ? ap2 : t3;
      }, up2 = i(lp2), hp2 = be2, pp2 = TypeError, _p = sd2, Ep2 = Math.floor, mp2 = function(e2, t3) {
        var i2 = e2.length;
        if (i2 < 8) for (var n3, r2, o2 = 1; o2 < i2; ) {
          for (r2 = o2, n3 = e2[o2]; r2 && t3(e2[r2 - 1], n3) > 0; ) e2[r2] = e2[--r2];
          r2 !== o2++ && (e2[r2] = n3);
        }
        else for (var s2 = Ep2(i2 / 2), a3 = mp2(_p(e2, 0, s2), t3), c3 = mp2(_p(e2, s2), t3), d2 = a3.length, l2 = c3.length, u3 = 0, h2 = 0; u3 < d2 || h2 < l2; ) e2[u3 + h2] = u3 < d2 && h2 < l2 ? t3(a3[u3], c3[h2]) <= 0 ? a3[u3++] : c3[h2++] : u3 < d2 ? a3[u3++] : c3[h2++];
        return e2;
      }, fp2 = mp2, Sp2 = ae2.match(/firefox\/(\d+)/i), gp2 = !!Sp2 && +Sp2[1], Tp2 = /MSIE|Trident/.test(ae2), Rp2 = ae2.match(/AppleWebKit\/(\d+)\./), vp2 = !!Rp2 && +Rp2[1], Cp2 = Oi2, yp2 = d, Ip2 = Ne2, bp2 = Je2, Ap2 = Wi2, wp2 = function(e2, t3) {
        if (!delete e2[t3]) throw new pp2("Cannot delete property " + hp2(t3) + " of " + hp2(e2));
      }, Op2 = Sn2, Np2 = n2, Dp2 = fp2, Pp2 = Wn2, Lp2 = gp2, kp2 = Tp2, Mp2 = _e, Up2 = vp2, Vp2 = [], xp2 = yp2(Vp2.sort), Fp2 = yp2(Vp2.push), Bp2 = Np2(function() {
        Vp2.sort(void 0);
      }), jp2 = Np2(function() {
        Vp2.sort(null);
      }), Gp2 = Pp2("sort"), Wp2 = !Np2(function() {
        if (Mp2) return Mp2 < 70;
        if (!(Lp2 && Lp2 > 3)) {
          if (kp2) return true;
          if (Up2) return Up2 < 603;
          var e2, t3, i2, n3, r2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t3 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                i2 = 3;
                break;
              case 68:
              case 71:
                i2 = 4;
                break;
              default:
                i2 = 2;
            }
            for (n3 = 0; n3 < 47; n3++) Vp2.push({ k: t3 + n3, v: i2 });
          }
          for (Vp2.sort(function(e3, t4) {
            return t4.v - e3.v;
          }), n3 = 0; n3 < Vp2.length; n3++) t3 = Vp2[n3].k.charAt(0), r2.charAt(r2.length - 1) !== t3 && (r2 += t3);
          return "DGBEFHACIJK" !== r2;
        }
      });
      Cp2({ target: "Array", proto: true, forced: Bp2 || !jp2 || !Gp2 || !Wp2 }, { sort: function(e2) {
        void 0 !== e2 && Ip2(e2);
        var t3 = bp2(this);
        if (Wp2) return void 0 === e2 ? xp2(t3) : xp2(t3, e2);
        var i2, n3, r2 = [], o2 = Ap2(t3);
        for (n3 = 0; n3 < o2; n3++) n3 in t3 && Fp2(r2, t3[n3]);
        for (Dp2(r2, /* @__PURE__ */ function(e3) {
          return function(t4, i3) {
            return void 0 === i3 ? -1 : void 0 === t4 ? 1 : void 0 !== e3 ? +e3(t4, i3) || 0 : Op2(t4) > Op2(i3) ? 1 : -1;
          };
        }(e2)), i2 = Ap2(r2), n3 = 0; n3 < i2; ) t3[n3] = r2[n3++];
        for (; n3 < o2; ) wp2(t3, n3++);
        return t3;
      } });
      var Hp2 = Qi2("Array", "sort"), Kp2 = l, Yp2 = Hp2, zp2 = Array.prototype, qp2 = function(e2) {
        var t3 = e2.sort;
        return e2 === zp2 || Kp2(zp2, e2) && t3 === zp2.sort ? Yp2 : t3;
      }, Xp2 = i(qp2), Jp2 = Oi2, Zp2 = d, Qp2 = xi2, $p2 = RangeError, e_ = String.fromCharCode, t_ = String.fromCodePoint, i_ = Zp2([].join);
      Jp2({ target: "String", stat: true, arity: 1, forced: !!t_ && 1 !== t_.length }, { fromCodePoint: function(e2) {
        for (var t3, i2 = [], n3 = arguments.length, r2 = 0; n3 > r2; ) {
          if (t3 = +arguments[r2++], Qp2(t3, 1114111) !== t3) throw new $p2(t3 + " is not a valid code point");
          i2[r2] = t3 < 65536 ? e_(t3) : e_(55296 + ((t3 -= 65536) >> 10), t3 % 1024 + 56320);
        }
        return i_(i2, "");
      } });
      var n_ = n2, r_ = pt2("iterator"), o_ = !n_(function() {
        var e2 = new URL("b?a=1&b=2&c=3", "https://a"), t3 = e2.searchParams, i2 = new URLSearchParams("a=1&a=2&b=3"), n3 = "";
        return e2.pathname = "c%20d", t3.forEach(function(e3, i3) {
          t3.delete("b"), n3 += i3 + e3;
        }), i2.delete("a", 2), i2.delete("b", void 0), !e2.toJSON || !i2.has("a", 1) || i2.has("a", 2) || !i2.has("a", void 0) || i2.has("b") || !t3.size && true || !t3.sort || "https://a/c%20d?a=1&c=3" !== e2.href || "3" !== t3.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t3[r_] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("https://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("https://a#Ð±").hash || "a1c3" !== n3 || "x" !== new URL("https://x", void 0).host;
      }), s_ = Ca2, a_ = Oi2, c_ = h, d_ = Bd2, l_ = re2, u_ = D2, h_ = d, p_ = w2, __ = o_, E_ = Ca2, m_ = Cc2, f_ = function(e2, t3, i2) {
        for (var n3 in t3) i2 && i2.unsafe && e2[n3] ? e2[n3] = t3[n3] : s_(e2, n3, t3[n3], i2);
        return e2;
      }, S_ = Ga2, g_ = Xa2, T_ = Ea2, R_ = Nc2, v_ = b, C_ = $e2, y_ = Zt2, I_ = En2, b_ = ni2, A_ = Q2, w_ = Sn2, O_ = ko2, N_ = x, D_ = us2, P_ = rs2, L_ = pc2, k_ = cd2, M_ = fp2, U_ = pt2("iterator"), V_ = "URLSearchParams", x_ = V_ + "Iterator", F_ = T_.set, B_ = T_.getterFor(V_), j_ = T_.getterFor(x_), G_ = d_("fetch"), W_ = d_("Request"), H_ = d_("Headers"), K_ = W_ && W_.prototype, Y_ = H_ && H_.prototype, z_ = c_.TypeError, q_ = c_.encodeURIComponent, X_ = String.fromCharCode, J_ = l_("String", "fromCodePoint"), Z_ = parseInt, Q_ = h_("".charAt), $_ = h_([].join), eE = h_([].push), tE = h_("".replace), iE = h_([].shift), nE = h_([].splice), rE = h_("".split), oE = h_("".slice), sE = h_(/./.exec), aE = /\+/g, cE = /^[0-9a-f]+$/i, dE = function(e2, t3) {
        var i2 = oE(e2, t3, t3 + 2);
        return sE(cE, i2) ? Z_(i2, 16) : NaN;
      }, lE = function(e2) {
        for (var t3 = 0, i2 = 128; i2 > 0 && 0 != (e2 & i2); i2 >>= 1) t3++;
        return t3;
      }, uE = function(e2) {
        var t3 = null;
        switch (e2.length) {
          case 1:
            t3 = e2[0];
            break;
          case 2:
            t3 = (31 & e2[0]) << 6 | 63 & e2[1];
            break;
          case 3:
            t3 = (15 & e2[0]) << 12 | (63 & e2[1]) << 6 | 63 & e2[2];
            break;
          case 4:
            t3 = (7 & e2[0]) << 18 | (63 & e2[1]) << 12 | (63 & e2[2]) << 6 | 63 & e2[3];
        }
        return t3 > 1114111 ? null : t3;
      }, hE = function(e2) {
        for (var t3 = (e2 = tE(e2, aE, " ")).length, i2 = "", n3 = 0; n3 < t3; ) {
          var r2 = Q_(e2, n3);
          if ("%" === r2) {
            if ("%" === Q_(e2, n3 + 1) || n3 + 3 > t3) {
              i2 += "%", n3++;
              continue;
            }
            var o2 = dE(e2, n3 + 1);
            if (o2 != o2) {
              i2 += r2, n3++;
              continue;
            }
            n3 += 2;
            var s2 = lE(o2);
            if (0 === s2) r2 = X_(o2);
            else {
              if (1 === s2 || s2 > 4) {
                i2 += "ï¿½", n3++;
                continue;
              }
              for (var a3 = [o2], c3 = 1; c3 < s2 && !(++n3 + 3 > t3 || "%" !== Q_(e2, n3)); ) {
                var d2 = dE(e2, n3 + 1);
                if (d2 != d2) {
                  n3 += 3;
                  break;
                }
                if (d2 > 191 || d2 < 128) break;
                eE(a3, d2), n3 += 2, c3++;
              }
              if (a3.length !== s2) {
                i2 += "ï¿½";
                continue;
              }
              var l2 = uE(a3);
              null === l2 ? i2 += "ï¿½" : r2 = J_(l2);
            }
          }
          i2 += r2, n3++;
        }
        return i2;
      }, pE = /[!'()~]|%20/g, _E = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, EE = function(e2) {
        return _E[e2];
      }, mE = function(e2) {
        return tE(q_(e2), pE, EE);
      }, fE = g_(function(e2, t3) {
        F_(this, { type: x_, target: B_(e2).entries, index: 0, kind: t3 });
      }, V_, function() {
        var e2 = j_(this), t3 = e2.target, i2 = e2.index++;
        if (!t3 || i2 >= t3.length) return e2.target = null, L_(void 0, true);
        var n3 = t3[i2];
        switch (e2.kind) {
          case "keys":
            return L_(n3.key, false);
          case "values":
            return L_(n3.value, false);
        }
        return L_([n3.key, n3.value], false);
      }, true), SE = function(e2) {
        this.entries = [], this.url = null, void 0 !== e2 && (A_(e2) ? this.parseObject(e2) : this.parseQuery("string" == typeof e2 ? "?" === Q_(e2, 0) ? oE(e2, 1) : e2 : w_(e2)));
      };
      SE.prototype = { type: V_, bindURL: function(e2) {
        this.url = e2, this.update();
      }, parseObject: function(e2) {
        var t3, i2, n3, r2, o2, s2, a3, c3 = this.entries, d2 = P_(e2);
        if (d2) for (i2 = (t3 = D_(e2, d2)).next; !(n3 = u_(i2, t3)).done; ) {
          if (o2 = (r2 = D_(b_(n3.value))).next, (s2 = u_(o2, r2)).done || (a3 = u_(o2, r2)).done || !u_(o2, r2).done) throw new z_("Expected sequence with length 2");
          eE(c3, { key: w_(s2.value), value: w_(a3.value) });
        }
        else for (var l2 in e2) C_(e2, l2) && eE(c3, { key: l2, value: w_(e2[l2]) });
      }, parseQuery: function(e2) {
        if (e2) for (var t3, i2, n3 = this.entries, r2 = rE(e2, "&"), o2 = 0; o2 < r2.length; ) (t3 = r2[o2++]).length && (i2 = rE(t3, "="), eE(n3, { key: hE(iE(i2)), value: hE($_(i2, "=")) }));
      }, serialize: function() {
        for (var e2, t3 = this.entries, i2 = [], n3 = 0; n3 < t3.length; ) e2 = t3[n3++], eE(i2, mE(e2.key) + "=" + mE(e2.value));
        return $_(i2, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var gE = function() {
        R_(this, TE);
        var e2 = F_(this, new SE(arguments.length > 0 ? arguments[0] : void 0));
        p_ || (this.size = e2.entries.length);
      }, TE = gE.prototype;
      if (f_(TE, { append: function(e2, t3) {
        var i2 = B_(this);
        k_(arguments.length, 2), eE(i2.entries, { key: w_(e2), value: w_(t3) }), p_ || this.length++, i2.updateURL();
      }, delete: function(e2) {
        for (var t3 = B_(this), i2 = k_(arguments.length, 1), n3 = t3.entries, r2 = w_(e2), o2 = i2 < 2 ? void 0 : arguments[1], s2 = void 0 === o2 ? o2 : w_(o2), a3 = 0; a3 < n3.length; ) {
          var c3 = n3[a3];
          if (c3.key !== r2 || void 0 !== s2 && c3.value !== s2) a3++;
          else if (nE(n3, a3, 1), void 0 !== s2) break;
        }
        p_ || (this.size = n3.length), t3.updateURL();
      }, get: function(e2) {
        var t3 = B_(this).entries;
        k_(arguments.length, 1);
        for (var i2 = w_(e2), n3 = 0; n3 < t3.length; n3++) if (t3[n3].key === i2) return t3[n3].value;
        return null;
      }, getAll: function(e2) {
        var t3 = B_(this).entries;
        k_(arguments.length, 1);
        for (var i2 = w_(e2), n3 = [], r2 = 0; r2 < t3.length; r2++) t3[r2].key === i2 && eE(n3, t3[r2].value);
        return n3;
      }, has: function(e2) {
        for (var t3 = B_(this).entries, i2 = k_(arguments.length, 1), n3 = w_(e2), r2 = i2 < 2 ? void 0 : arguments[1], o2 = void 0 === r2 ? r2 : w_(r2), s2 = 0; s2 < t3.length; ) {
          var a3 = t3[s2++];
          if (a3.key === n3 && (void 0 === o2 || a3.value === o2)) return true;
        }
        return false;
      }, set: function(e2, t3) {
        var i2 = B_(this);
        k_(arguments.length, 1);
        for (var n3, r2 = i2.entries, o2 = false, s2 = w_(e2), a3 = w_(t3), c3 = 0; c3 < r2.length; c3++) (n3 = r2[c3]).key === s2 && (o2 ? nE(r2, c3--, 1) : (o2 = true, n3.value = a3));
        o2 || eE(r2, { key: s2, value: a3 }), p_ || (this.size = r2.length), i2.updateURL();
      }, sort: function() {
        var e2 = B_(this);
        M_(e2.entries, function(e3, t3) {
          return e3.key > t3.key ? 1 : -1;
        }), e2.updateURL();
      }, forEach: function(e2) {
        for (var t3, i2 = B_(this).entries, n3 = y_(e2, arguments.length > 1 ? arguments[1] : void 0), r2 = 0; r2 < i2.length; ) n3((t3 = i2[r2++]).value, t3.key, this);
      }, keys: function() {
        return new fE(this, "keys");
      }, values: function() {
        return new fE(this, "values");
      }, entries: function() {
        return new fE(this, "entries");
      } }, { enumerable: true }), E_(TE, U_, TE.entries, { name: "entries" }), E_(TE, "toString", function() {
        return B_(this).serialize();
      }, { enumerable: true }), p_ && m_(TE, "size", { get: function() {
        return B_(this).entries.length;
      }, configurable: true, enumerable: true }), S_(gE, V_), a_({ global: true, constructor: true, forced: !__ }, { URLSearchParams: gE }), !__ && v_(H_)) {
        var RE = h_(Y_.has), vE = h_(Y_.set), CE = function(e2) {
          if (A_(e2)) {
            var t3, i2 = e2.body;
            if (I_(i2) === V_) return t3 = e2.headers ? new H_(e2.headers) : new H_(), RE(t3, "content-type") || vE(t3, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), O_(e2, { body: N_(0, w_(i2)), headers: N_(0, t3) });
          }
          return e2;
        };
        if (v_(G_) && a_({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e2) {
          return G_(e2, arguments.length > 1 ? CE(arguments[1]) : {});
        } }), v_(W_)) {
          var yE = function(e2) {
            return R_(this, K_), new W_(e2, arguments.length > 1 ? CE(arguments[1]) : {});
          };
          K_.constructor = yE, yE.prototype = K_, a_({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: yE });
        }
      }
      var IE, bE = { URLSearchParams: gE, getState: B_ }, AE = $.URLSearchParams, wE = w2, OE = d, NE = D2, DE = n2, PE = ho2, LE = Zr2, kE = P, ME = Je2, UE = W2, VE = Object.assign, xE = Object.defineProperty, FE = OE([].concat), BE = !VE || DE(function() {
        if (wE && 1 !== VE({ b: 1 }, VE(xE({}, "a", { enumerable: true, get: function() {
          xE(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b) return true;
        var e2 = {}, t3 = {}, i2 = Symbol("assign detection"), n3 = "abcdefghijklmnopqrst";
        return e2[i2] = 7, n3.split("").forEach(function(e3) {
          t3[e3] = e3;
        }), 7 !== VE({}, e2)[i2] || PE(VE({}, t3)).join("") !== n3;
      }) ? function(e2, t3) {
        for (var i2 = ME(e2), n3 = arguments.length, r2 = 1, o2 = LE.f, s2 = kE.f; n3 > r2; ) for (var a3, c3 = UE(arguments[r2++]), d2 = o2 ? FE(PE(c3), o2(c3)) : PE(c3), l2 = d2.length, u3 = 0; l2 > u3; ) a3 = d2[u3++], wE && !NE(s2, c3, a3) || (i2[a3] = c3[a3]);
        return i2;
      } : VE, jE = ni2, GE = Es2, WE = w2, HE = Qt2, KE = x, YE = function(e2, t3, i2) {
        WE ? HE.f(e2, t3, KE(0, i2)) : e2[t3] = i2;
      }, zE = Zt2, qE = D2, XE = Je2, JE = function(e2, t3, i2, n3) {
        try {
          return n3 ? t3(jE(i2)[0], i2[1]) : t3(i2);
        } catch (t4) {
          GE(e2, "throw", t4);
        }
      }, ZE = Qo2, QE = Zc2, $E = Wi2, em2 = YE, tm2 = us2, im2 = rs2, nm2 = Array, rm2 = d, om2 = 2147483647, sm2 = /[^\0-\u007E]/, am2 = /[.\u3002\uFF0E\uFF61]/g, cm2 = "Overflow: input needs wider integers to process", dm2 = RangeError, lm2 = rm2(am2.exec), um2 = Math.floor, hm2 = String.fromCharCode, pm2 = rm2("".charCodeAt), _m = rm2([].join), Em2 = rm2([].push), mm2 = rm2("".replace), fm2 = rm2("".split), Sm2 = rm2("".toLowerCase), gm2 = function(e2) {
        return e2 + 22 + 75 * (e2 < 26);
      }, Tm2 = function(e2, t3, i2) {
        var n3 = 0;
        for (e2 = i2 ? um2(e2 / 700) : e2 >> 1, e2 += um2(e2 / t3); e2 > 455; ) e2 = um2(e2 / 35), n3 += 36;
        return um2(n3 + 36 * e2 / (e2 + 38));
      }, Rm2 = function(e2) {
        var t3 = [];
        e2 = function(e3) {
          for (var t4 = [], i3 = 0, n4 = e3.length; i3 < n4; ) {
            var r3 = pm2(e3, i3++);
            if (r3 >= 55296 && r3 <= 56319 && i3 < n4) {
              var o3 = pm2(e3, i3++);
              56320 == (64512 & o3) ? Em2(t4, ((1023 & r3) << 10) + (1023 & o3) + 65536) : (Em2(t4, r3), i3--);
            } else Em2(t4, r3);
          }
          return t4;
        }(e2);
        var i2, n3, r2 = e2.length, o2 = 128, s2 = 0, a3 = 72;
        for (i2 = 0; i2 < e2.length; i2++) (n3 = e2[i2]) < 128 && Em2(t3, hm2(n3));
        var c3 = t3.length, d2 = c3;
        for (c3 && Em2(t3, "-"); d2 < r2; ) {
          var l2 = om2;
          for (i2 = 0; i2 < e2.length; i2++) (n3 = e2[i2]) >= o2 && n3 < l2 && (l2 = n3);
          var u3 = d2 + 1;
          if (l2 - o2 > um2((om2 - s2) / u3)) throw new dm2(cm2);
          for (s2 += (l2 - o2) * u3, o2 = l2, i2 = 0; i2 < e2.length; i2++) {
            if ((n3 = e2[i2]) < o2 && ++s2 > om2) throw new dm2(cm2);
            if (n3 === o2) {
              for (var h2 = s2, p2 = 36; ; ) {
                var _2 = p2 <= a3 ? 1 : p2 >= a3 + 26 ? 26 : p2 - a3;
                if (h2 < _2) break;
                var E3 = h2 - _2, m3 = 36 - _2;
                Em2(t3, hm2(gm2(_2 + E3 % m3))), h2 = um2(E3 / m3), p2 += 36;
              }
              Em2(t3, hm2(gm2(h2))), a3 = Tm2(s2, u3, d2 === c3), s2 = 0, d2++;
            }
          }
          s2++, o2++;
        }
        return _m(t3, "");
      }, vm2 = Oi2, Cm2 = w2, ym2 = o_, Im2 = h, bm2 = Zt2, Am2 = d, wm2 = Ca2, Om2 = Cc2, Nm2 = Nc2, Dm2 = $e2, Pm2 = BE, Lm2 = function(e2) {
        var t3 = XE(e2), i2 = QE(this), n3 = arguments.length, r2 = n3 > 1 ? arguments[1] : void 0, o2 = void 0 !== r2;
        o2 && (r2 = zE(r2, n3 > 2 ? arguments[2] : void 0));
        var s2, a3, c3, d2, l2, u3, h2 = im2(t3), p2 = 0;
        if (!h2 || this === nm2 && ZE(h2)) for (s2 = $E(t3), a3 = i2 ? new this(s2) : nm2(s2); s2 > p2; p2++) u3 = o2 ? r2(t3[p2], p2) : t3[p2], em2(a3, p2, u3);
        else for (a3 = i2 ? new this() : [], l2 = (d2 = tm2(t3, h2)).next; !(c3 = qE(l2, d2)).done; p2++) u3 = o2 ? JE(d2, r2, [c3.value, p2], true) : c3.value, em2(a3, p2, u3);
        return a3.length = p2, a3;
      }, km2 = sd2, Mm2 = Bh2.codeAt, Um2 = function(e2) {
        var t3, i2, n3 = [], r2 = fm2(mm2(Sm2(e2), am2, "."), ".");
        for (t3 = 0; t3 < r2.length; t3++) i2 = r2[t3], Em2(n3, lm2(sm2, i2) ? "xn--" + Rm2(i2) : i2);
        return _m(n3, ".");
      }, Vm2 = Sn2, xm2 = Ga2, Fm2 = cd2, Bm2 = bE, jm2 = Ea2, Gm2 = jm2.set, Wm2 = jm2.getterFor("URL"), Hm2 = Bm2.URLSearchParams, Km2 = Bm2.getState, Ym2 = Im2.URL, zm2 = Im2.TypeError, qm2 = Im2.parseInt, Xm2 = Math.floor, Jm2 = Math.pow, Zm2 = Am2("".charAt), Qm = Am2(/./.exec), $m2 = Am2([].join), ef2 = Am2(1 .toString), tf2 = Am2([].pop), nf2 = Am2([].push), rf2 = Am2("".replace), of2 = Am2([].shift), sf2 = Am2("".split), af2 = Am2("".slice), cf2 = Am2("".toLowerCase), df2 = Am2([].unshift), lf2 = "Invalid scheme", uf2 = "Invalid host", hf2 = "Invalid port", pf2 = /[a-z]/i, _f = /[\d+-.a-z]/i, Ef2 = /\d/, mf2 = /^0x/i, ff2 = /^[0-7]+$/, Sf2 = /^\d+$/, gf2 = /^[\da-f]+$/i, Tf2 = /[\0\t\n\r #%/:<>?@[\\\]^|]/, Rf2 = /[\0\t\n\r #/:<>?@[\\\]^|]/, vf = /^[\u0000-\u0020]+/, Cf2 = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, yf2 = /[\t\n\r]/g, If2 = function(e2) {
        var t3, i2, n3, r2;
        if ("number" == typeof e2) {
          for (t3 = [], i2 = 0; i2 < 4; i2++) df2(t3, e2 % 256), e2 = Xm2(e2 / 256);
          return $m2(t3, ".");
        }
        if ("object" == typeof e2) {
          for (t3 = "", n3 = function(e3) {
            for (var t4 = null, i3 = 1, n4 = null, r3 = 0, o2 = 0; o2 < 8; o2++) 0 !== e3[o2] ? (r3 > i3 && (t4 = n4, i3 = r3), n4 = null, r3 = 0) : (null === n4 && (n4 = o2), ++r3);
            return r3 > i3 ? n4 : t4;
          }(e2), i2 = 0; i2 < 8; i2++) r2 && 0 === e2[i2] || (r2 && (r2 = false), n3 === i2 ? (t3 += i2 ? ":" : "::", r2 = true) : (t3 += ef2(e2[i2], 16), i2 < 7 && (t3 += ":")));
          return "[" + t3 + "]";
        }
        return e2;
      }, bf2 = {}, Af2 = Pm2({}, bf2, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), wf2 = Pm2({}, Af2, { "#": 1, "?": 1, "{": 1, "}": 1 }), Of2 = Pm2({}, wf2, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), Nf2 = function(e2, t3) {
        var i2 = Mm2(e2, 0);
        return i2 > 32 && i2 < 127 && !Dm2(t3, e2) ? e2 : encodeURIComponent(e2);
      }, Df2 = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, Pf2 = function(e2, t3) {
        var i2;
        return 2 === e2.length && Qm(pf2, Zm2(e2, 0)) && (":" === (i2 = Zm2(e2, 1)) || !t3 && "|" === i2);
      }, Lf2 = function(e2) {
        var t3;
        return e2.length > 1 && Pf2(af2(e2, 0, 2)) && (2 === e2.length || "/" === (t3 = Zm2(e2, 2)) || "\\" === t3 || "?" === t3 || "#" === t3);
      }, kf2 = function(e2) {
        return "." === e2 || "%2e" === cf2(e2);
      }, Mf2 = {}, Uf2 = {}, Vf2 = {}, xf2 = {}, Ff2 = {}, Bf2 = {}, jf2 = {}, Gf2 = {}, Wf2 = {}, Hf2 = {}, Kf2 = {}, Yf2 = {}, zf2 = {}, qf2 = {}, Xf2 = {}, Jf2 = {}, Zf2 = {}, Qf2 = {}, $f2 = {}, eS = {}, tS = {}, iS = function(e2, t3, i2) {
        var n3, r2, o2, s2 = Vm2(e2);
        if (t3) {
          if (r2 = this.parse(s2)) throw new zm2(r2);
          this.searchParams = null;
        } else {
          if (void 0 !== i2 && (n3 = new iS(i2, true)), r2 = this.parse(s2, null, n3)) throw new zm2(r2);
          (o2 = Km2(new Hm2())).bindURL(this), this.searchParams = o2;
        }
      };
      iS.prototype = { type: "URL", parse: function(e2, t3, i2) {
        var n3, r2, o2, s2, a3, c3 = this, d2 = t3 || Mf2, l2 = 0, u3 = "", h2 = false, p2 = false, _2 = false;
        for (e2 = Vm2(e2), t3 || (c3.scheme = "", c3.username = "", c3.password = "", c3.host = null, c3.port = null, c3.path = [], c3.query = null, c3.fragment = null, c3.cannotBeABaseURL = false, e2 = rf2(e2, vf, ""), e2 = rf2(e2, Cf2, "$1")), e2 = rf2(e2, yf2, ""), n3 = Lm2(e2); l2 <= n3.length; ) {
          switch (r2 = n3[l2], d2) {
            case Mf2:
              if (!r2 || !Qm(pf2, r2)) {
                if (t3) return lf2;
                d2 = Vf2;
                continue;
              }
              u3 += cf2(r2), d2 = Uf2;
              break;
            case Uf2:
              if (r2 && (Qm(_f, r2) || "+" === r2 || "-" === r2 || "." === r2)) u3 += cf2(r2);
              else {
                if (":" !== r2) {
                  if (t3) return lf2;
                  u3 = "", d2 = Vf2, l2 = 0;
                  continue;
                }
                if (t3 && (c3.isSpecial() !== Dm2(Df2, u3) || "file" === u3 && (c3.includesCredentials() || null !== c3.port) || "file" === c3.scheme && !c3.host)) return;
                if (c3.scheme = u3, t3) return void (c3.isSpecial() && Df2[c3.scheme] === c3.port && (c3.port = null));
                u3 = "", "file" === c3.scheme ? d2 = qf2 : c3.isSpecial() && i2 && i2.scheme === c3.scheme ? d2 = xf2 : c3.isSpecial() ? d2 = Gf2 : "/" === n3[l2 + 1] ? (d2 = Ff2, l2++) : (c3.cannotBeABaseURL = true, nf2(c3.path, ""), d2 = $f2);
              }
              break;
            case Vf2:
              if (!i2 || i2.cannotBeABaseURL && "#" !== r2) return lf2;
              if (i2.cannotBeABaseURL && "#" === r2) {
                c3.scheme = i2.scheme, c3.path = km2(i2.path), c3.query = i2.query, c3.fragment = "", c3.cannotBeABaseURL = true, d2 = tS;
                break;
              }
              d2 = "file" === i2.scheme ? qf2 : Bf2;
              continue;
            case xf2:
              if ("/" !== r2 || "/" !== n3[l2 + 1]) {
                d2 = Bf2;
                continue;
              }
              d2 = Wf2, l2++;
              break;
            case Ff2:
              if ("/" === r2) {
                d2 = Hf2;
                break;
              }
              d2 = Qf2;
              continue;
            case Bf2:
              if (c3.scheme = i2.scheme, r2 === IE) c3.username = i2.username, c3.password = i2.password, c3.host = i2.host, c3.port = i2.port, c3.path = km2(i2.path), c3.query = i2.query;
              else if ("/" === r2 || "\\" === r2 && c3.isSpecial()) d2 = jf2;
              else if ("?" === r2) c3.username = i2.username, c3.password = i2.password, c3.host = i2.host, c3.port = i2.port, c3.path = km2(i2.path), c3.query = "", d2 = eS;
              else {
                if ("#" !== r2) {
                  c3.username = i2.username, c3.password = i2.password, c3.host = i2.host, c3.port = i2.port, c3.path = km2(i2.path), c3.path.length--, d2 = Qf2;
                  continue;
                }
                c3.username = i2.username, c3.password = i2.password, c3.host = i2.host, c3.port = i2.port, c3.path = km2(i2.path), c3.query = i2.query, c3.fragment = "", d2 = tS;
              }
              break;
            case jf2:
              if (!c3.isSpecial() || "/" !== r2 && "\\" !== r2) {
                if ("/" !== r2) {
                  c3.username = i2.username, c3.password = i2.password, c3.host = i2.host, c3.port = i2.port, d2 = Qf2;
                  continue;
                }
                d2 = Hf2;
              } else d2 = Wf2;
              break;
            case Gf2:
              if (d2 = Wf2, "/" !== r2 || "/" !== Zm2(u3, l2 + 1)) continue;
              l2++;
              break;
            case Wf2:
              if ("/" !== r2 && "\\" !== r2) {
                d2 = Hf2;
                continue;
              }
              break;
            case Hf2:
              if ("@" === r2) {
                h2 && (u3 = "%40" + u3), h2 = true, o2 = Lm2(u3);
                for (var E3 = 0; E3 < o2.length; E3++) {
                  var m3 = o2[E3];
                  if (":" !== m3 || _2) {
                    var f2 = Nf2(m3, Of2);
                    _2 ? c3.password += f2 : c3.username += f2;
                  } else _2 = true;
                }
                u3 = "";
              } else if (r2 === IE || "/" === r2 || "?" === r2 || "#" === r2 || "\\" === r2 && c3.isSpecial()) {
                if (h2 && "" === u3) return "Invalid authority";
                l2 -= Lm2(u3).length + 1, u3 = "", d2 = Kf2;
              } else u3 += r2;
              break;
            case Kf2:
            case Yf2:
              if (t3 && "file" === c3.scheme) {
                d2 = Jf2;
                continue;
              }
              if (":" !== r2 || p2) {
                if (r2 === IE || "/" === r2 || "?" === r2 || "#" === r2 || "\\" === r2 && c3.isSpecial()) {
                  if (c3.isSpecial() && "" === u3) return uf2;
                  if (t3 && "" === u3 && (c3.includesCredentials() || null !== c3.port)) return;
                  if (s2 = c3.parseHost(u3)) return s2;
                  if (u3 = "", d2 = Zf2, t3) return;
                  continue;
                }
                "[" === r2 ? p2 = true : "]" === r2 && (p2 = false), u3 += r2;
              } else {
                if ("" === u3) return uf2;
                if (s2 = c3.parseHost(u3)) return s2;
                if (u3 = "", d2 = zf2, t3 === Yf2) return;
              }
              break;
            case zf2:
              if (!Qm(Ef2, r2)) {
                if (r2 === IE || "/" === r2 || "?" === r2 || "#" === r2 || "\\" === r2 && c3.isSpecial() || t3) {
                  if ("" !== u3) {
                    var S3 = qm2(u3, 10);
                    if (S3 > 65535) return hf2;
                    c3.port = c3.isSpecial() && S3 === Df2[c3.scheme] ? null : S3, u3 = "";
                  }
                  if (t3) return;
                  d2 = Zf2;
                  continue;
                }
                return hf2;
              }
              u3 += r2;
              break;
            case qf2:
              if (c3.scheme = "file", "/" === r2 || "\\" === r2) d2 = Xf2;
              else {
                if (!i2 || "file" !== i2.scheme) {
                  d2 = Qf2;
                  continue;
                }
                switch (r2) {
                  case IE:
                    c3.host = i2.host, c3.path = km2(i2.path), c3.query = i2.query;
                    break;
                  case "?":
                    c3.host = i2.host, c3.path = km2(i2.path), c3.query = "", d2 = eS;
                    break;
                  case "#":
                    c3.host = i2.host, c3.path = km2(i2.path), c3.query = i2.query, c3.fragment = "", d2 = tS;
                    break;
                  default:
                    Lf2($m2(km2(n3, l2), "")) || (c3.host = i2.host, c3.path = km2(i2.path), c3.shortenPath()), d2 = Qf2;
                    continue;
                }
              }
              break;
            case Xf2:
              if ("/" === r2 || "\\" === r2) {
                d2 = Jf2;
                break;
              }
              i2 && "file" === i2.scheme && !Lf2($m2(km2(n3, l2), "")) && (Pf2(i2.path[0], true) ? nf2(c3.path, i2.path[0]) : c3.host = i2.host), d2 = Qf2;
              continue;
            case Jf2:
              if (r2 === IE || "/" === r2 || "\\" === r2 || "?" === r2 || "#" === r2) {
                if (!t3 && Pf2(u3)) d2 = Qf2;
                else if ("" === u3) {
                  if (c3.host = "", t3) return;
                  d2 = Zf2;
                } else {
                  if (s2 = c3.parseHost(u3)) return s2;
                  if ("localhost" === c3.host && (c3.host = ""), t3) return;
                  u3 = "", d2 = Zf2;
                }
                continue;
              }
              u3 += r2;
              break;
            case Zf2:
              if (c3.isSpecial()) {
                if (d2 = Qf2, "/" !== r2 && "\\" !== r2) continue;
              } else if (t3 || "?" !== r2) if (t3 || "#" !== r2) {
                if (r2 !== IE && (d2 = Qf2, "/" !== r2)) continue;
              } else c3.fragment = "", d2 = tS;
              else c3.query = "", d2 = eS;
              break;
            case Qf2:
              if (r2 === IE || "/" === r2 || "\\" === r2 && c3.isSpecial() || !t3 && ("?" === r2 || "#" === r2)) {
                if (".." === (a3 = cf2(a3 = u3)) || "%2e." === a3 || ".%2e" === a3 || "%2e%2e" === a3 ? (c3.shortenPath(), "/" === r2 || "\\" === r2 && c3.isSpecial() || nf2(c3.path, "")) : kf2(u3) ? "/" === r2 || "\\" === r2 && c3.isSpecial() || nf2(c3.path, "") : ("file" === c3.scheme && !c3.path.length && Pf2(u3) && (c3.host && (c3.host = ""), u3 = Zm2(u3, 0) + ":"), nf2(c3.path, u3)), u3 = "", "file" === c3.scheme && (r2 === IE || "?" === r2 || "#" === r2)) for (; c3.path.length > 1 && "" === c3.path[0]; ) of2(c3.path);
                "?" === r2 ? (c3.query = "", d2 = eS) : "#" === r2 && (c3.fragment = "", d2 = tS);
              } else u3 += Nf2(r2, wf2);
              break;
            case $f2:
              "?" === r2 ? (c3.query = "", d2 = eS) : "#" === r2 ? (c3.fragment = "", d2 = tS) : r2 !== IE && (c3.path[0] += Nf2(r2, bf2));
              break;
            case eS:
              t3 || "#" !== r2 ? r2 !== IE && ("'" === r2 && c3.isSpecial() ? c3.query += "%27" : c3.query += "#" === r2 ? "%23" : Nf2(r2, bf2)) : (c3.fragment = "", d2 = tS);
              break;
            case tS:
              r2 !== IE && (c3.fragment += Nf2(r2, Af2));
          }
          l2++;
        }
      }, parseHost: function(e2) {
        var t3, i2, n3;
        if ("[" === Zm2(e2, 0)) {
          if ("]" !== Zm2(e2, e2.length - 1)) return uf2;
          if (t3 = function(e3) {
            var t4, i3, n4, r2, o2, s2, a3, c3 = [0, 0, 0, 0, 0, 0, 0, 0], d2 = 0, l2 = null, u3 = 0, h2 = function() {
              return Zm2(e3, u3);
            };
            if (":" === h2()) {
              if (":" !== Zm2(e3, 1)) return;
              u3 += 2, l2 = ++d2;
            }
            for (; h2(); ) {
              if (8 === d2) return;
              if (":" !== h2()) {
                for (t4 = i3 = 0; i3 < 4 && Qm(gf2, h2()); ) t4 = 16 * t4 + qm2(h2(), 16), u3++, i3++;
                if ("." === h2()) {
                  if (0 === i3) return;
                  if (u3 -= i3, d2 > 6) return;
                  for (n4 = 0; h2(); ) {
                    if (r2 = null, n4 > 0) {
                      if (!("." === h2() && n4 < 4)) return;
                      u3++;
                    }
                    if (!Qm(Ef2, h2())) return;
                    for (; Qm(Ef2, h2()); ) {
                      if (o2 = qm2(h2(), 10), null === r2) r2 = o2;
                      else {
                        if (0 === r2) return;
                        r2 = 10 * r2 + o2;
                      }
                      if (r2 > 255) return;
                      u3++;
                    }
                    c3[d2] = 256 * c3[d2] + r2, 2 != ++n4 && 4 !== n4 || d2++;
                  }
                  if (4 !== n4) return;
                  break;
                }
                if (":" === h2()) {
                  if (u3++, !h2()) return;
                } else if (h2()) return;
                c3[d2++] = t4;
              } else {
                if (null !== l2) return;
                u3++, l2 = ++d2;
              }
            }
            if (null !== l2) for (s2 = d2 - l2, d2 = 7; 0 !== d2 && s2 > 0; ) a3 = c3[d2], c3[d2--] = c3[l2 + s2 - 1], c3[l2 + --s2] = a3;
            else if (8 !== d2) return;
            return c3;
          }(af2(e2, 1, -1)), !t3) return uf2;
          this.host = t3;
        } else if (this.isSpecial()) {
          if (e2 = Um2(e2), Qm(Tf2, e2)) return uf2;
          if (t3 = function(e3) {
            var t4, i3, n4, r2, o2, s2, a3, c3 = sf2(e3, ".");
            if (c3.length && "" === c3[c3.length - 1] && c3.length--, (t4 = c3.length) > 4) return e3;
            for (i3 = [], n4 = 0; n4 < t4; n4++) {
              if ("" === (r2 = c3[n4])) return e3;
              if (o2 = 10, r2.length > 1 && "0" === Zm2(r2, 0) && (o2 = Qm(mf2, r2) ? 16 : 8, r2 = af2(r2, 8 === o2 ? 1 : 2)), "" === r2) s2 = 0;
              else {
                if (!Qm(10 === o2 ? Sf2 : 8 === o2 ? ff2 : gf2, r2)) return e3;
                s2 = qm2(r2, o2);
              }
              nf2(i3, s2);
            }
            for (n4 = 0; n4 < t4; n4++) if (s2 = i3[n4], n4 === t4 - 1) {
              if (s2 >= Jm2(256, 5 - t4)) return null;
            } else if (s2 > 255) return null;
            for (a3 = tf2(i3), n4 = 0; n4 < i3.length; n4++) a3 += i3[n4] * Jm2(256, 3 - n4);
            return a3;
          }(e2), null === t3) return uf2;
          this.host = t3;
        } else {
          if (Qm(Rf2, e2)) return uf2;
          for (t3 = "", i2 = Lm2(e2), n3 = 0; n3 < i2.length; n3++) t3 += Nf2(i2[n3], bf2);
          this.host = t3;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" === this.scheme;
      }, includesCredentials: function() {
        return "" !== this.username || "" !== this.password;
      }, isSpecial: function() {
        return Dm2(Df2, this.scheme);
      }, shortenPath: function() {
        var e2 = this.path, t3 = e2.length;
        !t3 || "file" === this.scheme && 1 === t3 && Pf2(e2[0], true) || e2.length--;
      }, serialize: function() {
        var e2 = this, t3 = e2.scheme, i2 = e2.username, n3 = e2.password, r2 = e2.host, o2 = e2.port, s2 = e2.path, a3 = e2.query, c3 = e2.fragment, d2 = t3 + ":";
        return null !== r2 ? (d2 += "//", e2.includesCredentials() && (d2 += i2 + (n3 ? ":" + n3 : "") + "@"), d2 += If2(r2), null !== o2 && (d2 += ":" + o2)) : "file" === t3 && (d2 += "//"), d2 += e2.cannotBeABaseURL ? s2[0] : s2.length ? "/" + $m2(s2, "/") : "", null !== a3 && (d2 += "?" + a3), null !== c3 && (d2 += "#" + c3), d2;
      }, setHref: function(e2) {
        var t3 = this.parse(e2);
        if (t3) throw new zm2(t3);
        this.searchParams.update();
      }, getOrigin: function() {
        var e2 = this.scheme, t3 = this.port;
        if ("blob" === e2) try {
          return new nS(e2.path[0]).origin;
        } catch (e3) {
          return "null";
        }
        return "file" !== e2 && this.isSpecial() ? e2 + "://" + If2(this.host) + (null !== t3 ? ":" + t3 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e2) {
        this.parse(Vm2(e2) + ":", Mf2);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e2) {
        var t3 = Lm2(Vm2(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var i2 = 0; i2 < t3.length; i2++) this.username += Nf2(t3[i2], Of2);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e2) {
        var t3 = Lm2(Vm2(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var i2 = 0; i2 < t3.length; i2++) this.password += Nf2(t3[i2], Of2);
        }
      }, getHost: function() {
        var e2 = this.host, t3 = this.port;
        return null === e2 ? "" : null === t3 ? If2(e2) : If2(e2) + ":" + t3;
      }, setHost: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, Kf2);
      }, getHostname: function() {
        var e2 = this.host;
        return null === e2 ? "" : If2(e2);
      }, setHostname: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, Yf2);
      }, getPort: function() {
        var e2 = this.port;
        return null === e2 ? "" : Vm2(e2);
      }, setPort: function(e2) {
        this.cannotHaveUsernamePasswordPort() || ("" === (e2 = Vm2(e2)) ? this.port = null : this.parse(e2, zf2));
      }, getPathname: function() {
        var e2 = this.path;
        return this.cannotBeABaseURL ? e2[0] : e2.length ? "/" + $m2(e2, "/") : "";
      }, setPathname: function(e2) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e2, Zf2));
      }, getSearch: function() {
        var e2 = this.query;
        return e2 ? "?" + e2 : "";
      }, setSearch: function(e2) {
        "" === (e2 = Vm2(e2)) ? this.query = null : ("?" === Zm2(e2, 0) && (e2 = af2(e2, 1)), this.query = "", this.parse(e2, eS)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e2 = this.fragment;
        return e2 ? "#" + e2 : "";
      }, setHash: function(e2) {
        "" !== (e2 = Vm2(e2)) ? ("#" === Zm2(e2, 0) && (e2 = af2(e2, 1)), this.fragment = "", this.parse(e2, tS)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var nS = function(e2) {
        var t3 = Nm2(this, rS), i2 = Fm2(arguments.length, 1) > 1 ? arguments[1] : void 0, n3 = Gm2(t3, new iS(e2, false, i2));
        Cm2 || (t3.href = n3.serialize(), t3.origin = n3.getOrigin(), t3.protocol = n3.getProtocol(), t3.username = n3.getUsername(), t3.password = n3.getPassword(), t3.host = n3.getHost(), t3.hostname = n3.getHostname(), t3.port = n3.getPort(), t3.pathname = n3.getPathname(), t3.search = n3.getSearch(), t3.searchParams = n3.getSearchParams(), t3.hash = n3.getHash());
      }, rS = nS.prototype, oS = function(e2, t3) {
        return { get: function() {
          return Wm2(this)[e2]();
        }, set: t3 && function(e3) {
          return Wm2(this)[t3](e3);
        }, configurable: true, enumerable: true };
      };
      if (Cm2 && (Om2(rS, "href", oS("serialize", "setHref")), Om2(rS, "origin", oS("getOrigin")), Om2(rS, "protocol", oS("getProtocol", "setProtocol")), Om2(rS, "username", oS("getUsername", "setUsername")), Om2(rS, "password", oS("getPassword", "setPassword")), Om2(rS, "host", oS("getHost", "setHost")), Om2(rS, "hostname", oS("getHostname", "setHostname")), Om2(rS, "port", oS("getPort", "setPort")), Om2(rS, "pathname", oS("getPathname", "setPathname")), Om2(rS, "search", oS("getSearch", "setSearch")), Om2(rS, "searchParams", oS("getSearchParams")), Om2(rS, "hash", oS("getHash", "setHash"))), wm2(rS, "toJSON", function() {
        return Wm2(this).serialize();
      }, { enumerable: true }), wm2(rS, "toString", function() {
        return Wm2(this).serialize();
      }, { enumerable: true }), Ym2) {
        var sS = Ym2.createObjectURL, aS = Ym2.revokeObjectURL;
        sS && wm2(nS, "createObjectURL", bm2(sS, Ym2)), aS && wm2(nS, "revokeObjectURL", bm2(aS, Ym2));
      }
      xm2(nS, "URL"), vm2({ global: true, constructor: true, forced: !ym2, sham: !Cm2 }, { URL: nS });
      var cS = Oi2, dS = n2, lS = cd2, uS = Sn2, hS = o_, pS = re2("URL"), _S = hS && dS(function() {
        pS.canParse();
      }), ES = dS(function() {
        return 1 !== pS.canParse.length;
      });
      cS({ target: "URL", stat: true, forced: !_S || ES }, { canParse: function(e2) {
        var t3 = lS(arguments.length, 1), i2 = uS(e2), n3 = t3 < 2 || void 0 === arguments[1] ? void 0 : uS(arguments[1]);
        try {
          return !!new pS(i2, n3);
        } catch (e3) {
          return false;
        }
      } });
      var mS = Oi2, fS = cd2, SS = Sn2, gS = o_, TS = re2("URL");
      mS({ target: "URL", stat: true, forced: !gS }, { parse: function(e2) {
        var t3 = fS(arguments.length, 1), i2 = SS(e2), n3 = t3 < 2 || void 0 === arguments[1] ? void 0 : SS(arguments[1]);
        try {
          return new TS(i2, n3);
        } catch (e3) {
          return null;
        }
      } });
      var RS = i($.URL);
      let vS = true, CS = true;
      function yS(e2, t3, i2) {
        const n3 = e2.match(t3);
        return n3 && n3.length >= i2 && parseInt(n3[i2], 10);
      }
      function IS(e2, t3, i2) {
        if (!e2.RTCPeerConnection) return;
        const n3 = e2.RTCPeerConnection.prototype, r2 = n3.addEventListener;
        n3.addEventListener = function(e3, n4) {
          if (e3 !== t3) return r2.apply(this, arguments);
          const o3 = (e4) => {
            const t4 = i2(e4);
            t4 && (n4.handleEvent ? n4.handleEvent(t4) : n4(t4));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t3] || (this._eventMap[t3] = /* @__PURE__ */ new Map()), this._eventMap[t3].set(n4, o3), r2.apply(this, [e3, o3]);
        };
        const o2 = n3.removeEventListener;
        n3.removeEventListener = function(e3, i3) {
          if (e3 !== t3 || !this._eventMap || !this._eventMap[t3]) return o2.apply(this, arguments);
          if (!this._eventMap[t3].has(i3)) return o2.apply(this, arguments);
          const n4 = this._eventMap[t3].get(i3);
          return this._eventMap[t3].delete(i3), 0 === this._eventMap[t3].size && delete this._eventMap[t3], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e3, n4]);
        }, Object.defineProperty(n3, "on" + t3, { get() {
          return this["_on" + t3];
        }, set(e3) {
          this["_on" + t3] && (this.removeEventListener(t3, this["_on" + t3]), delete this["_on" + t3]), e3 && this.addEventListener(t3, this["_on" + t3] = e3);
        }, enumerable: true, configurable: true });
      }
      function bS(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (vS = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function AS(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (CS = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function wS() {
        if ("object" == typeof window) {
          if (vS) return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function OS(e2, t3) {
        CS && console.warn(e2 + " is deprecated, please use " + t3 + " instead.");
      }
      function NS(e2) {
        return "[object Object]" === Object.prototype.toString.call(e2);
      }
      function DS(e2) {
        var t3;
        return NS(e2) ? nr2(t3 = Object.keys(e2)).call(t3, function(t4, i2) {
          const n3 = NS(e2[i2]), r2 = n3 ? DS(e2[i2]) : e2[i2], o2 = n3 && !Object.keys(r2).length;
          return void 0 === r2 || o2 ? t4 : Object.assign(t4, { [i2]: r2 });
        }, {}) : e2;
      }
      function PS(e2, t3, i2) {
        t3 && !i2.has(t3.id) && (i2.set(t3.id, t3), Object.keys(t3).forEach((n3) => {
          n3.endsWith("Id") ? PS(e2, e2.get(t3[n3]), i2) : n3.endsWith("Ids") && t3[n3].forEach((t4) => {
            PS(e2, e2.get(t4), i2);
          });
        }));
      }
      function LS(e2, t3, i2) {
        const n3 = i2 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
        if (null === t3) return r2;
        const o2 = [];
        return e2.forEach((e3) => {
          "track" === e3.type && e3.trackIdentifier === t3.id && o2.push(e3);
        }), o2.forEach((t4) => {
          e2.forEach((i3) => {
            i3.type === n3 && i3.trackId === t4.id && PS(e2, i3, r2);
          });
        }), r2;
      }
      const kS = wS;
      function MS(e2, t3) {
        const i2 = e2 && e2.navigator;
        if (!i2.mediaDevices) return;
        const n3 = function(e3) {
          if ("object" != typeof e3 || e3.mandatory || e3.optional) return e3;
          const t4 = {};
          return Object.keys(e3).forEach((i3) => {
            if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3) return;
            const n4 = "object" == typeof e3[i3] ? e3[i3] : { ideal: e3[i3] };
            void 0 !== n4.exact && "number" == typeof n4.exact && (n4.min = n4.max = n4.exact);
            const r3 = function(e4, t5) {
              return e4 ? e4 + t5.charAt(0).toUpperCase() + t5.slice(1) : "deviceId" === t5 ? "sourceId" : t5;
            };
            if (void 0 !== n4.ideal) {
              t4.optional = t4.optional || [];
              let e4 = {};
              "number" == typeof n4.ideal ? (e4[r3("min", i3)] = n4.ideal, t4.optional.push(e4), e4 = {}, e4[r3("max", i3)] = n4.ideal, t4.optional.push(e4)) : (e4[r3("", i3)] = n4.ideal, t4.optional.push(e4));
            }
            void 0 !== n4.exact && "number" != typeof n4.exact ? (t4.mandatory = t4.mandatory || {}, t4.mandatory[r3("", i3)] = n4.exact) : ["min", "max"].forEach((e4) => {
              void 0 !== n4[e4] && (t4.mandatory = t4.mandatory || {}, t4.mandatory[r3(e4, i3)] = n4[e4]);
            });
          }), e3.advanced && (t4.optional = (t4.optional || []).concat(e3.advanced)), t4;
        }, r2 = function(e3, r3) {
          if (t3.version >= 61) return r3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
            const t4 = function(e4, t5, i3) {
              t5 in e4 && !(i3 in e4) && (e4[i3] = e4[t5], delete e4[t5]);
            };
            t4((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t4(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n3(e3.audio);
          }
          if (e3 && "object" == typeof e3.video) {
            let o3 = e3.video.facingMode;
            o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
            const s2 = t3.version < 66;
            if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || s2)) {
              let t4;
              if (delete e3.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t4 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t4 = ["front"]), t4) return i2.mediaDevices.enumerateDevices().then((i3) => {
                i3 = i3.filter((e4) => "videoinput" === e4.kind);
                let s3 = i3.find((e4) => t4.some((t5) => {
                  var i4;
                  return Ln2(i4 = e4.label.toLowerCase()).call(i4, t5);
                }));
                return !s3 && i3.length && Ln2(t4).call(t4, "back") && (s3 = i3[i3.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = n3(e3.video), kS("chrome: " + JSON.stringify(e3)), r3(e3);
              });
            }
            e3.video = n3(e3.video);
          }
          return kS("chrome: " + JSON.stringify(e3)), r3(e3);
        }, o2 = function(e3) {
          return t3.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i2.getUserMedia = (function(e3, t4, n4) {
          r2(e3, (e4) => {
            i2.webkitGetUserMedia(e4, t4, (e5) => {
              n4 && n4(o2(e5));
            });
          });
        }).bind(i2), i2.mediaDevices.getUserMedia) {
          const e3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          i2.mediaDevices.getUserMedia = function(t4) {
            return r2(t4, (t5) => e3(t5).then((e4) => {
              if (t5.audio && !e4.getAudioTracks().length || t5.video && !e4.getVideoTracks().length) throw e4.getTracks().forEach((e5) => {
                e5.stop();
              }), new DOMException("", "NotFoundError");
              return e4;
            }, (e4) => ip2.reject(o2(e4))));
          };
        }
      }
      function US(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function VS(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t3 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t4) => {
              t4.stream.addEventListener("addtrack", (i2) => {
                let n3;
                n3 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.track.id) : { track: i2.track };
                const r2 = new Event("track");
                r2.track = i2.track, r2.receiver = n3, r2.transceiver = { receiver: n3 }, r2.streams = [t4.stream], this.dispatchEvent(r2);
              }), t4.stream.getTracks().forEach((i2) => {
                let n3;
                n3 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.id) : { track: i2 };
                const r2 = new Event("track");
                r2.track = i2, r2.receiver = n3, r2.transceiver = { receiver: n3 }, r2.streams = [t4.stream], this.dispatchEvent(r2);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t3.apply(this, arguments);
          };
        } else IS(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
      }
      function xS(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t3 = function(e3, t4) {
            return { track: t4, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t4.kind ? this._dtmf = e3.createDTMFSender(t4) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, n5) {
              let r2 = i3.apply(this, arguments);
              return r2 || (r2 = t3(this, e3), this._senders.push(r2)), r2;
            };
            const n4 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              n4.apply(this, arguments);
              const t4 = this._senders.indexOf(e3);
              -1 !== t4 && this._senders.splice(t4, 1);
            };
          }
          const i2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              this._senders.push(t3(this, e4));
            });
          };
          const n3 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], n3.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              const t4 = this._senders.find((t5) => t5.track === e4);
              t4 && this._senders.splice(this._senders.indexOf(t4), 1);
            });
          };
        } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function FS(e2) {
        if (!e2.RTCPeerConnection) return;
        const t3 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, i2, n3] = arguments;
          if (arguments.length > 0 && "function" == typeof e3) return t3.apply(this, arguments);
          if (0 === t3.length && (0 === arguments.length || "function" != typeof e3)) return t3.apply(this, []);
          const r2 = function(e4) {
            const t4 = {};
            return e4.result().forEach((e5) => {
              const i3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach((t5) => {
                i3[t5] = e5.stat(t5);
              }), t4[i3.id] = i3;
            }), t4;
          }, o2 = function(e4) {
            return new Map(Object.keys(e4).map((t4) => [t4, e4[t4]]));
          };
          if (arguments.length >= 2) {
            const n4 = function(e4) {
              i2(o2(r2(e4)));
            };
            return t3.apply(this, [n4, e3]);
          }
          return new ip2((e4, i3) => {
            t3.apply(this, [function(t4) {
              e4(o2(r2(t4)));
            }, i3]);
          }).then(i2, n3);
        };
      }
      function BS(e2) {
        if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver)) return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t4 = e2.RTCPeerConnection.prototype.getSenders;
          t4 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t4.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const i2 = e2.RTCPeerConnection.prototype.addTrack;
          i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t5) => LS(t5, e3.track, true));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t4 = e2.RTCPeerConnection.prototype.getReceivers;
          t4 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t4.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), IS(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t5) => LS(t5, e3.track, false));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype)) return;
        const t3 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t4, i2, n3;
            return this.getSenders().forEach((i3) => {
              i3.track === e3 && (t4 ? n3 = true : t4 = i3);
            }), this.getReceivers().forEach((t5) => (t5.track === e3 && (i2 ? n3 = true : i2 = t5), t5.track === e3)), n3 || t4 && i2 ? ip2.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t4 ? t4.getStats() : i2 ? i2.getStats() : ip2.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t3.apply(this, arguments);
        };
      }
      function jS(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
        };
        const t3 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, i3) {
          if (!i3) return t3.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const n4 = t3.apply(this, arguments);
          return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(n4) && this._shimmedLocalStreams[i3.id].push(n4) : this._shimmedLocalStreams[i3.id] = [i3, n4], n4;
        };
        const i2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
            const t5 = this.getSenders().find((t6) => t6.track === e4);
            if (t5) throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t4 = this.getSenders();
          i2.apply(this, arguments);
          const n4 = this.getSenders().filter((e4) => -1 === t4.indexOf(e4));
          this._shimmedLocalStreams[e3.id] = [e3].concat(n4);
        };
        const n3 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n3.apply(this, arguments);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t4) => {
            const i3 = this._shimmedLocalStreams[t4].indexOf(e3);
            -1 !== i3 && this._shimmedLocalStreams[t4].splice(i3, 1), 1 === this._shimmedLocalStreams[t4].length && delete this._shimmedLocalStreams[t4];
          }), r2.apply(this, arguments);
        };
      }
      function GS(e2, t3) {
        if (!e2.RTCPeerConnection) return;
        if (e2.RTCPeerConnection.prototype.addTrack && t3.version >= 65) return jS(e2);
        const i2 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = i2.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
        };
        const n3 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t4) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t4.getTracks().forEach((e3) => {
            const t5 = this.getSenders().find((t6) => t6.track === e3);
            if (t5) throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t4.id]) {
            const i3 = new e2.MediaStream(t4.getTracks());
            this._streams[t4.id] = i3, this._reverseStreams[i3.id] = t4, t4 = i3;
          }
          n3.apply(this, [t4]);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeStream;
        function o2(e3, t4) {
          let i3 = t4.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t5) => {
            const n4 = e3._reverseStreams[t5], r3 = e3._streams[n4.id];
            i3 = i3.replace(new RegExp(r3.id, "g"), n4.id);
          }), new RTCSessionDescription({ type: t4.type, sdp: i3 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t4, i3) {
          if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const n4 = [].slice.call(arguments, 1);
          if (1 !== n4.length || !n4[0].getTracks().find((e3) => e3 === t4)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const r3 = this.getSenders().find((e3) => e3.track === t4);
          if (r3) throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const o3 = this._streams[i3.id];
          if (o3) o3.addTrack(t4), ip2.resolve().then(() => {
            this.dispatchEvent(new Event("negotiationneeded"));
          });
          else {
            const n5 = new e2.MediaStream([t4]);
            this._streams[i3.id] = n5, this._reverseStreams[n5.id] = i3, this.addStream(n5);
          }
          return this.getSenders().find((e3) => e3.track === t4);
        }, ["createOffer", "createAnswer"].forEach(function(t4) {
          const i3 = e2.RTCPeerConnection.prototype[t4], n4 = { [t4]() {
            const e3 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t5) => {
              const i4 = o2(this, t5);
              e3[0].apply(null, [i4]);
            }, (t5) => {
              e3[1] && e3[1].apply(null, t5);
            }, arguments[2]]) : i3.apply(this, arguments).then((e4) => o2(this, e4));
          } };
          e2.RTCPeerConnection.prototype[t4] = n4[t4];
        });
        const s2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = function(e3, t4) {
            let i3 = t4.sdp;
            return Object.keys(e3._reverseStreams || []).forEach((t5) => {
              const n4 = e3._reverseStreams[t5], r3 = e3._streams[n4.id];
              i3 = i3.replace(new RegExp(n4.id, "g"), r3.id);
            }), new RTCSessionDescription({ type: t4.type, sdp: i3 });
          }(this, arguments[0]), s2.apply(this, arguments)) : s2.apply(this, arguments);
        };
        const a3 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = a3.get.apply(this);
          return "" === e3.type ? e3 : o2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this)) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t4;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((i3) => {
            this._streams[i3].getTracks().find((t5) => e3.track === t5) && (t4 = this._streams[i3]);
          }), t4 && (1 === t4.getTracks().length ? this.removeStream(this._reverseStreams[t4.id]) : t4.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function WS(e2, t3) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t3.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t4) {
          const i2 = e2.RTCPeerConnection.prototype[t4], n3 = { [t4]() {
            return arguments[0] = new ("addIceCandidate" === t4 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t4] = n3[t4];
        });
      }
      function HS(e2, t3) {
        IS(e2, "negotiationneeded", (e3) => {
          const i2 = e3.target;
          if (!(t3.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState) return e3;
        });
      }
      var KS = Object.freeze({ __proto__: null, fixNegotiationNeeded: HS, shimAddTrackRemoveTrack: GS, shimAddTrackRemoveTrackWithNative: jS, shimGetDisplayMedia: function(e2, t3) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t3 ? e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          return t3(i2).then((t4) => {
            const n3 = i2.video && i2.video.width, r2 = i2.video && i2.video.height, o2 = i2.video && i2.video.frameRate;
            return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t4, maxFrameRate: o2 || 3 } }, n3 && (i2.video.mandatory.maxWidth = n3), r2 && (i2.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i2);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      }, shimGetSendersWithDtmf: xS, shimGetStats: FS, shimGetUserMedia: MS, shimMediaStream: US, shimOnTrack: VS, shimPeerConnection: WS, shimSenderReceiverGetStats: BS });
      function YS(e2, t3) {
        const i2 = e2 && e2.navigator, n3 = e2 && e2.MediaStreamTrack;
        if (i2.getUserMedia = function(e3, t4, n4) {
          OS("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e3).then(t4, n4);
        }, !(t3.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t5, i3) {
            t5 in e4 && !(i3 in e4) && (e4[i3] = e4[t5], delete e4[t5]);
          }, t4 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          if (i2.mediaDevices.getUserMedia = function(i3) {
            return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3.audio, "autoGainControl", "mozAutoGainControl"), e3(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t4(i3);
          }, n3 && n3.prototype.getSettings) {
            const t5 = n3.prototype.getSettings;
            n3.prototype.getSettings = function() {
              const i3 = t5.apply(this, arguments);
              return e3(i3, "mozAutoGainControl", "autoGainControl"), e3(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
            };
          }
          if (n3 && n3.prototype.applyConstraints) {
            const t5 = n3.prototype.applyConstraints;
            n3.prototype.applyConstraints = function(i3) {
              return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3, "autoGainControl", "mozAutoGainControl"), e3(i3, "noiseSuppression", "mozNoiseSuppression")), t5.apply(this, [i3]);
            };
          }
        }
      }
      function zS(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function qS(e2, t3) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection) return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t3.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t4) {
          const i3 = e2.RTCPeerConnection.prototype[t4], n4 = { [t4]() {
            return arguments[0] = new ("addIceCandidate" === t4 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t4] = n4[t4];
        });
        const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n3 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, r2, o2] = arguments;
          return n3.apply(this, [e3 || null]).then((e4) => {
            if (t3.version < 53 && !r2) try {
              e4.forEach((e5) => {
                e5.type = i2[e5.type] || e5.type;
              });
            } catch (t4) {
              if ("TypeError" !== t4.name) throw t4;
              e4.forEach((t5, n4) => {
                e4.set(n4, Object.assign({}, t5, { type: i2[t5.type] || t5.type }));
              });
            }
            return e4;
          }).then(r2, o2);
        };
      }
      function XS(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender) return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype) return;
        const t3 = e2.RTCPeerConnection.prototype.getSenders;
        t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t3.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const i2 = e2.RTCPeerConnection.prototype.addTrack;
        i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i2.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : ip2.resolve(/* @__PURE__ */ new Map());
        };
      }
      function JS(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender) return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype) return;
        const t3 = e2.RTCPeerConnection.prototype.getReceivers;
        t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t3.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), IS(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function ZS(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          OS("removeStream", "removeTrack"), this.getSenders().forEach((t3) => {
            var i2;
            t3.track && Ln2(i2 = e3.getTracks()).call(i2, t3.track) && this.removeTrack(t3);
          });
        });
      }
      function QS(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function $S(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t3 = e2.RTCPeerConnection.prototype.addTransceiver;
        t3 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          let e3 = arguments[1] && arguments[1].sendEncodings;
          void 0 === e3 && (e3 = []), e3 = [...e3];
          const i2 = e3.length > 0;
          i2 && e3.forEach((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid)) throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
          });
          const n3 = t3.apply(this, arguments);
          if (i2) {
            const { sender: t4 } = n3, i3 = t4.getParameters();
            (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e3, t4.sendEncodings = e3, this.setParametersPromises.push(t4.setParameters(i3).then(() => {
              delete t4.sendEncodings;
            }).catch(() => {
              delete t4.sendEncodings;
            })));
          }
          return n3;
        });
      }
      function eg2(e2) {
        if ("object" != typeof e2 || !e2.RTCRtpSender) return;
        const t3 = e2.RTCRtpSender.prototype.getParameters;
        t3 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t3.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function tg2(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t3 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? ip2.all(this.setParametersPromises).then(() => t3.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t3.apply(this, arguments);
        };
      }
      function ig2(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t3 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? ip2.all(this.setParametersPromises).then(() => t3.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t3.apply(this, arguments);
        };
      }
      var ng2 = Object.freeze({ __proto__: null, shimAddTransceiver: $S, shimCreateAnswer: ig2, shimCreateOffer: tg2, shimGetDisplayMedia: function(e2, t3) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          if (!i2 || !i2.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, ip2.reject(e3);
          }
          return true === i2.video ? i2.video = { mediaSource: t3 } : i2.video.mediaSource = t3, e2.navigator.mediaDevices.getUserMedia(i2);
        });
      }, shimGetParameters: eg2, shimGetUserMedia: YS, shimOnTrack: zS, shimPeerConnection: qS, shimRTCDataChannel: QS, shimReceiverGetStats: JS, shimRemoveStream: ZS, shimSenderGetStats: XS });
      function rg2(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              var i2;
              this._localStreams || (this._localStreams = []), Ln2(i2 = this._localStreams).call(i2, e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i3) => t3.call(this, i3, e3)), e3.getVideoTracks().forEach((i3) => t3.call(this, i3, e3));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3) {
              for (var i2 = arguments.length, n3 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n3[r2 - 1] = arguments[r2];
              return n3 && n3.forEach((e4) => {
                var t4;
                this._localStreams ? Ln2(t4 = this._localStreams).call(t4, e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              }), t3.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t3 = this._localStreams.indexOf(e3);
            if (-1 === t3) return;
            this._localStreams.splice(t3, 1);
            const i2 = e3.getTracks();
            this.getSenders().forEach((e4) => {
              Ln2(i2).call(i2, e4.track) && this.removeTrack(e4);
            });
          });
        }
      }
      function og2(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach((e5) => {
                var t4;
                if (this._remoteStreams || (this._remoteStreams = []), Ln2(t4 = this._remoteStreams).call(t4, e5)) return;
                this._remoteStreams.push(e5);
                const i2 = new Event("addstream");
                i2.stream = e5, this.dispatchEvent(i2);
              });
            });
          } });
          const t3 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t4) {
              t4.streams.forEach((t5) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t5) >= 0) return;
                e3._remoteStreams.push(t5);
                const i2 = new Event("addstream");
                i2.stream = t5, e3.dispatchEvent(i2);
              });
            }), t3.apply(e3, arguments);
          };
        }
      }
      function sg2(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection) return;
        const t3 = e2.RTCPeerConnection.prototype, i2 = t3.createOffer, n3 = t3.createAnswer, r2 = t3.setLocalDescription, o2 = t3.setRemoteDescription, s2 = t3.addIceCandidate;
        t3.createOffer = function(e3, t4) {
          const n4 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i2.apply(this, [n4]);
          return t4 ? (r3.then(e3, t4), ip2.resolve()) : r3;
        }, t3.createAnswer = function(e3, t4) {
          const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n3.apply(this, [i3]);
          return t4 ? (r3.then(e3, t4), ip2.resolve()) : r3;
        };
        let a3 = function(e3, t4, i3) {
          const n4 = r2.apply(this, [e3]);
          return i3 ? (n4.then(t4, i3), ip2.resolve()) : n4;
        };
        t3.setLocalDescription = a3, a3 = function(e3, t4, i3) {
          const n4 = o2.apply(this, [e3]);
          return i3 ? (n4.then(t4, i3), ip2.resolve()) : n4;
        }, t3.setRemoteDescription = a3, a3 = function(e3, t4, i3) {
          const n4 = s2.apply(this, [e3]);
          return i3 ? (n4.then(t4, i3), ip2.resolve()) : n4;
        }, t3.addIceCandidate = a3;
      }
      function ag2(e2) {
        const t3 = e2 && e2.navigator;
        if (t3.mediaDevices && t3.mediaDevices.getUserMedia) {
          const e3 = t3.mediaDevices, i2 = e3.getUserMedia.bind(e3);
          t3.mediaDevices.getUserMedia = (e4) => i2(cg2(e4));
        }
        !t3.getUserMedia && t3.mediaDevices && t3.mediaDevices.getUserMedia && (t3.getUserMedia = (function(e3, i2, n3) {
          t3.mediaDevices.getUserMedia(e3).then(i2, n3);
        }).bind(t3));
      }
      function cg2(e2) {
        return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: DS(e2.video) }) : e2;
      }
      function dg2(e2) {
        if (!e2.RTCPeerConnection) return;
        const t3 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, i2) {
          if (e3 && e3.iceServers) {
            const t4 = [];
            for (let i3 = 0; i3 < e3.iceServers.length; i3++) {
              let n3 = e3.iceServers[i3];
              !n3.hasOwnProperty("urls") && n3.hasOwnProperty("url") ? (OS("RTCIceServer.url", "RTCIceServer.urls"), n3 = JSON.parse(JSON.stringify(n3)), n3.urls = n3.url, delete n3.url, t4.push(n3)) : t4.push(e3.iceServers[i3]);
            }
            e3.iceServers = t4;
          }
          return new t3(e3, i2);
        }, e2.RTCPeerConnection.prototype = t3.prototype, "generateCertificate" in t3 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t3.generateCertificate });
      }
      function lg2(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function ug2(e2) {
        const t3 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t4 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
            false === e3.offerToReceiveAudio && t4 ? "sendrecv" === t4.direction ? t4.setDirection ? t4.setDirection("sendonly") : t4.direction = "sendonly" : "recvonly" === t4.direction && (t4.setDirection ? t4.setDirection("inactive") : t4.direction = "inactive") : true !== e3.offerToReceiveAudio || t4 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const i2 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
            false === e3.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e3.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
          }
          return t3.apply(this, arguments);
        };
      }
      function hg2(e2) {
        "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var pg2 = Object.freeze({ __proto__: null, shimAudioContext: hg2, shimCallbacksAPI: sg2, shimConstraints: cg2, shimCreateOfferLegacy: ug2, shimGetUserMedia: ag2, shimLocalStreamsAPI: rg2, shimRTCIceServerUrls: dg2, shimRemoteStreamsAPI: og2, shimTrackEventTransceiver: lg2 }), _g = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF", Eg = z, mg2 = Sn2, fg2 = _g, Sg2 = d("".replace), gg2 = RegExp("^[" + fg2 + "]+"), Tg2 = RegExp("(^|[^" + fg2 + "])[" + fg2 + "]+$"), Rg2 = function(e2) {
        return function(t3) {
          var i2 = mg2(Eg(t3));
          return 1 & e2 && (i2 = Sg2(i2, gg2, "")), 2 & e2 && (i2 = Sg2(i2, Tg2, "$1")), i2;
        };
      }, vg2 = { start: Rg2(1), end: Rg2(2), trim: Rg2(3) }, Cg2 = Ra2.PROPER, yg2 = n2, Ig2 = _g, bg2 = vg2.trim;
      Oi2({ target: "String", proto: true, forced: function(e2) {
        return yg2(function() {
          return !!Ig2[e2]() || "âÂá " !== "âÂá "[e2]() || Cg2 && Ig2[e2].name !== e2;
        });
      }("trim") }, { trim: function() {
        return bg2(this);
      } });
      var Ag2 = Qi2("String", "trim"), wg2 = l, Og2 = Ag2, Ng2 = String.prototype, Dg2 = function(e2) {
        var t3 = e2.trim;
        return "string" == typeof e2 || e2 === Ng2 || wg2(Ng2, e2) && t3 === Ng2.trim ? Og2 : t3;
      }, Pg2 = i(Dg2), Lg2 = { exports: {} };
      !function(e2) {
        const t3 = { generateIdentifier: function() {
          return Math.random().toString(36).substring(2, 12);
        } };
        t3.localCName = t3.generateIdentifier(), t3.splitLines = function(e3) {
          return e3.trim().split("\n").map((e4) => e4.trim());
        }, t3.splitSections = function(e3) {
          return e3.split("\nm=").map((e4, t4) => (t4 > 0 ? "m=" + e4 : e4).trim() + "\r\n");
        }, t3.getDescription = function(e3) {
          const i2 = t3.splitSections(e3);
          return i2 && i2[0];
        }, t3.getMediaSections = function(e3) {
          const i2 = t3.splitSections(e3);
          return i2.shift(), i2;
        }, t3.matchPrefix = function(e3, i2) {
          return t3.splitLines(e3).filter((e4) => 0 === e4.indexOf(i2));
        }, t3.parseCandidate = function(e3) {
          let t4;
          t4 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
          const i2 = { foundation: t4[0], component: { 1: "rtp", 2: "rtcp" }[t4[1]] || t4[1], protocol: t4[2].toLowerCase(), priority: parseInt(t4[3], 10), ip: t4[4], address: t4[4], port: parseInt(t4[5], 10), type: t4[7] };
          for (let e4 = 8; e4 < t4.length; e4 += 2) switch (t4[e4]) {
            case "raddr":
              i2.relatedAddress = t4[e4 + 1];
              break;
            case "rport":
              i2.relatedPort = parseInt(t4[e4 + 1], 10);
              break;
            case "tcptype":
              i2.tcpType = t4[e4 + 1];
              break;
            case "ufrag":
              i2.ufrag = t4[e4 + 1], i2.usernameFragment = t4[e4 + 1];
              break;
            default:
              void 0 === i2[t4[e4]] && (i2[t4[e4]] = t4[e4 + 1]);
          }
          return i2;
        }, t3.writeCandidate = function(e3) {
          const t4 = [];
          t4.push(e3.foundation);
          const i2 = e3.component;
          "rtp" === i2 ? t4.push(1) : "rtcp" === i2 ? t4.push(2) : t4.push(i2), t4.push(e3.protocol.toUpperCase()), t4.push(e3.priority), t4.push(e3.address || e3.ip), t4.push(e3.port);
          const n3 = e3.type;
          return t4.push("typ"), t4.push(n3), "host" !== n3 && e3.relatedAddress && e3.relatedPort && (t4.push("raddr"), t4.push(e3.relatedAddress), t4.push("rport"), t4.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t4.push("tcptype"), t4.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t4.push("ufrag"), t4.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t4.join(" ");
        }, t3.parseIceOptions = function(e3) {
          return e3.substring(14).split(" ");
        }, t3.parseRtpMap = function(e3) {
          let t4 = e3.substring(9).split(" ");
          const i2 = { payloadType: parseInt(t4.shift(), 10) };
          return t4 = t4[0].split("/"), i2.name = t4[0], i2.clockRate = parseInt(t4[1], 10), i2.channels = 3 === t4.length ? parseInt(t4[2], 10) : 1, i2.numChannels = i2.channels, i2;
        }, t3.writeRtpMap = function(e3) {
          let t4 = e3.payloadType;
          void 0 !== e3.preferredPayloadType && (t4 = e3.preferredPayloadType);
          const i2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t4 + " " + e3.name + "/" + e3.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
        }, t3.parseExtmap = function(e3) {
          const t4 = e3.substring(9).split(" ");
          return { id: parseInt(t4[0], 10), direction: t4[0].indexOf("/") > 0 ? t4[0].split("/")[1] : "sendrecv", uri: t4[1], attributes: t4.slice(2).join(" ") };
        }, t3.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + (e3.attributes ? " " + e3.attributes : "") + "\r\n";
        }, t3.parseFmtp = function(e3) {
          const t4 = {};
          let i2;
          const n3 = e3.substring(e3.indexOf(" ") + 1).split(";");
          for (let e4 = 0; e4 < n3.length; e4++) i2 = n3[e4].trim().split("="), t4[i2[0].trim()] = i2[1];
          return t4;
        }, t3.writeFmtp = function(e3) {
          let t4 = "", i2 = e3.payloadType;
          if (void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            const n3 = [];
            Object.keys(e3.parameters).forEach((t5) => {
              void 0 !== e3.parameters[t5] ? n3.push(t5 + "=" + e3.parameters[t5]) : n3.push(t5);
            }), t4 += "a=fmtp:" + i2 + " " + n3.join(";") + "\r\n";
          }
          return t4;
        }, t3.parseRtcpFb = function(e3) {
          const t4 = e3.substring(e3.indexOf(" ") + 1).split(" ");
          return { type: t4.shift(), parameter: t4.join(" ") };
        }, t3.writeRtcpFb = function(e3) {
          let t4 = "", i2 = e3.payloadType;
          return void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
            t4 += "a=rtcp-fb:" + i2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t4;
        }, t3.parseSsrcMedia = function(e3) {
          const t4 = e3.indexOf(" "), i2 = { ssrc: parseInt(e3.substring(7, t4), 10) }, n3 = e3.indexOf(":", t4);
          return n3 > -1 ? (i2.attribute = e3.substring(t4 + 1, n3), i2.value = e3.substring(n3 + 1)) : i2.attribute = e3.substring(t4 + 1), i2;
        }, t3.parseSsrcGroup = function(e3) {
          const t4 = e3.substring(13).split(" ");
          return { semantics: t4.shift(), ssrcs: t4.map((e4) => parseInt(e4, 10)) };
        }, t3.getMid = function(e3) {
          const i2 = t3.matchPrefix(e3, "a=mid:")[0];
          if (i2) return i2.substring(6);
        }, t3.parseFingerprint = function(e3) {
          const t4 = e3.substring(14).split(" ");
          return { algorithm: t4[0].toLowerCase(), value: t4[1].toUpperCase() };
        }, t3.getDtlsParameters = function(e3, i2) {
          return { role: "auto", fingerprints: t3.matchPrefix(e3 + i2, "a=fingerprint:").map(t3.parseFingerprint) };
        }, t3.writeDtlsParameters = function(e3, t4) {
          let i2 = "a=setup:" + t4 + "\r\n";
          return e3.fingerprints.forEach((e4) => {
            i2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), i2;
        }, t3.parseCryptoLine = function(e3) {
          const t4 = e3.substring(9).split(" ");
          return { tag: parseInt(t4[0], 10), cryptoSuite: t4[1], keyParams: t4[2], sessionParams: t4.slice(3) };
        }, t3.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t3.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t3.parseCryptoKeyParams = function(e3) {
          if (0 !== e3.indexOf("inline:")) return null;
          const t4 = e3.substring(7).split("|");
          return { keyMethod: "inline", keySalt: t4[0], lifeTime: t4[1], mkiValue: t4[2] ? t4[2].split(":")[0] : void 0, mkiLength: t4[2] ? t4[2].split(":")[1] : void 0 };
        }, t3.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t3.getCryptoParameters = function(e3, i2) {
          return t3.matchPrefix(e3 + i2, "a=crypto:").map(t3.parseCryptoLine);
        }, t3.getIceParameters = function(e3, i2) {
          const n3 = t3.matchPrefix(e3 + i2, "a=ice-ufrag:")[0], r2 = t3.matchPrefix(e3 + i2, "a=ice-pwd:")[0];
          return n3 && r2 ? { usernameFragment: n3.substring(12), password: r2.substring(10) } : null;
        }, t3.writeIceParameters = function(e3) {
          let t4 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
          return e3.iceLite && (t4 += "a=ice-lite\r\n"), t4;
        }, t3.parseRtpParameters = function(e3) {
          const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n3 = t3.splitLines(e3)[0].split(" ");
          i2.profile = n3[2];
          for (let r3 = 3; r3 < n3.length; r3++) {
            const o2 = n3[r3], s2 = t3.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
            if (s2) {
              const n4 = t3.parseRtpMap(s2), r4 = t3.matchPrefix(e3, "a=fmtp:" + o2 + " ");
              switch (n4.parameters = r4.length ? t3.parseFmtp(r4[0]) : {}, n4.rtcpFeedback = t3.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t3.parseRtcpFb), i2.codecs.push(n4), n4.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i2.fecMechanisms.push(n4.name.toUpperCase());
              }
            }
          }
          t3.matchPrefix(e3, "a=extmap:").forEach((e4) => {
            i2.headerExtensions.push(t3.parseExtmap(e4));
          });
          const r2 = t3.matchPrefix(e3, "a=rtcp-fb:* ").map(t3.parseRtcpFb);
          return i2.codecs.forEach((e4) => {
            r2.forEach((t4) => {
              e4.rtcpFeedback.find((e5) => e5.type === t4.type && e5.parameter === t4.parameter) || e4.rtcpFeedback.push(t4);
            });
          }), i2;
        }, t3.writeRtpDescription = function(e3, i2) {
          let n3 = "";
          n3 += "m=" + e3 + " ", n3 += i2.codecs.length > 0 ? "9" : "0", n3 += " " + (i2.profile || "UDP/TLS/RTP/SAVPF") + " ", n3 += i2.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", n3 += "c=IN IP4 0.0.0.0\r\n", n3 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach((e4) => {
            n3 += t3.writeRtpMap(e4), n3 += t3.writeFmtp(e4), n3 += t3.writeRtcpFb(e4);
          });
          let r2 = 0;
          return i2.codecs.forEach((e4) => {
            e4.maxptime > r2 && (r2 = e4.maxptime);
          }), r2 > 0 && (n3 += "a=maxptime:" + r2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach((e4) => {
            n3 += t3.writeExtmap(e4);
          }), n3;
        }, t3.parseRtpEncodingParameters = function(e3) {
          const i2 = [], n3 = t3.parseRtpParameters(e3), r2 = -1 !== n3.fecMechanisms.indexOf("RED"), o2 = -1 !== n3.fecMechanisms.indexOf("ULPFEC"), s2 = t3.matchPrefix(e3, "a=ssrc:").map((e4) => t3.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a3 = s2.length > 0 && s2[0].ssrc;
          let c3;
          const d2 = t3.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substring(17).split(" ").map((e5) => parseInt(e5, 10)));
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === a3 && (c3 = d2[0][1]), n3.codecs.forEach((e4) => {
            if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
              let t4 = { ssrc: a3, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              a3 && c3 && (t4.rtx = { ssrc: c3 }), i2.push(t4), r2 && (t4 = JSON.parse(JSON.stringify(t4)), t4.fec = { ssrc: a3, mechanism: o2 ? "red+ulpfec" : "red" }, i2.push(t4));
            }
          }), 0 === i2.length && a3 && i2.push({ ssrc: a3 });
          let l2 = t3.matchPrefix(e3, "b=");
          return l2.length && (l2 = 0 === l2[0].indexOf("b=TIAS:") ? parseInt(l2[0].substring(7), 10) : 0 === l2[0].indexOf("b=AS:") ? 1e3 * parseInt(l2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i2.forEach((e4) => {
            e4.maxBitrate = l2;
          })), i2;
        }, t3.parseRtcpParameters = function(e3) {
          const i2 = {}, n3 = t3.matchPrefix(e3, "a=ssrc:").map((e4) => t3.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
          n3 && (i2.cname = n3.value, i2.ssrc = n3.ssrc);
          const r2 = t3.matchPrefix(e3, "a=rtcp-rsize");
          i2.reducedSize = r2.length > 0, i2.compound = 0 === r2.length;
          const o2 = t3.matchPrefix(e3, "a=rtcp-mux");
          return i2.mux = o2.length > 0, i2;
        }, t3.writeRtcpParameters = function(e3) {
          let t4 = "";
          return e3.reducedSize && (t4 += "a=rtcp-rsize\r\n"), e3.mux && (t4 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t4 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t4;
        }, t3.parseMsid = function(e3) {
          let i2;
          const n3 = t3.matchPrefix(e3, "a=msid:");
          if (1 === n3.length) return i2 = n3[0].substring(7).split(" "), { stream: i2[0], track: i2[1] };
          const r2 = t3.matchPrefix(e3, "a=ssrc:").map((e4) => t3.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
          return r2.length > 0 ? (i2 = r2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
        }, t3.parseSctpDescription = function(e3) {
          const i2 = t3.parseMLine(e3), n3 = t3.matchPrefix(e3, "a=max-message-size:");
          let r2;
          n3.length > 0 && (r2 = parseInt(n3[0].substring(19), 10)), isNaN(r2) && (r2 = 65536);
          const o2 = t3.matchPrefix(e3, "a=sctp-port:");
          if (o2.length > 0) return { port: parseInt(o2[0].substring(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
          const s2 = t3.matchPrefix(e3, "a=sctpmap:");
          if (s2.length > 0) {
            const e4 = s2[0].substring(10).split(" ");
            return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
          }
        }, t3.writeSctpDescription = function(e3, t4) {
          let i2 = [];
          return i2 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t4.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t4.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t4.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t4.port + " " + t4.protocol + " 65535\r\n"], void 0 !== t4.maxMessageSize && i2.push("a=max-message-size:" + t4.maxMessageSize + "\r\n"), i2.join("");
        }, t3.generateSessionId = function() {
          return Math.random().toString().substr(2, 22);
        }, t3.writeSessionBoilerplate = function(e3, i2, n3) {
          let r2;
          const o2 = void 0 !== i2 ? i2 : 2;
          r2 = e3 || t3.generateSessionId();
          return "v=0\r\no=" + (n3 || "thisisadapterortc") + " " + r2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t3.getDirection = function(e3, i2) {
          const n3 = t3.splitLines(e3);
          for (let e4 = 0; e4 < n3.length; e4++) switch (n3[e4]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return n3[e4].substring(2);
          }
          return i2 ? t3.getDirection(i2) : "sendrecv";
        }, t3.getKind = function(e3) {
          return t3.splitLines(e3)[0].split(" ")[0].substring(2);
        }, t3.isRejected = function(e3) {
          return "0" === e3.split(" ", 2)[1];
        }, t3.parseMLine = function(e3) {
          const i2 = t3.splitLines(e3)[0].substring(2).split(" ");
          return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
        }, t3.parseOLine = function(e3) {
          const i2 = t3.matchPrefix(e3, "o=")[0].substring(2).split(" ");
          return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
        }, t3.isValidSDP = function(e3) {
          if ("string" != typeof e3 || 0 === e3.length) return false;
          const i2 = t3.splitLines(e3);
          for (let e4 = 0; e4 < i2.length; e4++) if (i2[e4].length < 2 || "=" !== i2[e4].charAt(1)) return false;
          return true;
        }, e2.exports = t3;
      }(Lg2);
      var kg2 = Lg2.exports, Mg2 = i(kg2), Ug2 = e({ __proto__: null, default: Mg2 }, [kg2]);
      function Vg2(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype) return;
        const t3 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
            const i2 = new t3(e3), n3 = Mg2.parseCandidate(e3.candidate), r2 = Object.assign(i2, n3);
            return r2.toJSON = function() {
              return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
            }, r2;
          }
          return new t3(e3);
        }, e2.RTCIceCandidate.prototype = t3.prototype, IS(e2, "icecandidate", (t4) => (t4.candidate && Object.defineProperty(t4, "candidate", { value: new e2.RTCIceCandidate(t4.candidate), writable: "false" }), t4));
      }
      function xg2(e2) {
        !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || IS(e2, "icecandidate", (e3) => {
          if (e3.candidate) {
            const t3 = Mg2.parseCandidate(e3.candidate.candidate);
            "relay" === t3.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t3.priority >> 24]);
          }
          return e3;
        });
      }
      function Fg(e2, t3) {
        if (!e2.RTCPeerConnection) return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i2 = function(e3) {
          if (!e3 || !e3.sdp) return false;
          const t4 = Mg2.splitSections(e3.sdp);
          return t4.shift(), t4.some((e4) => {
            const t5 = Mg2.parseMLine(e4);
            return t5 && "application" === t5.kind && -1 !== t5.protocol.indexOf("SCTP");
          });
        }, n3 = function(e3) {
          const t4 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (null === t4 || t4.length < 2) return -1;
          const i3 = parseInt(t4[1], 10);
          return i3 != i3 ? -1 : i3;
        }, r2 = function(e3) {
          let i3 = 65536;
          return "firefox" === t3.browser && (i3 = t3.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t3.version < 60 ? 57 === t3.version ? 65535 : 65536 : 2147483637), i3;
        }, o2 = function(e3, i3) {
          let n4 = 65536;
          "firefox" === t3.browser && 57 === t3.version && (n4 = 65535);
          const r3 = Mg2.matchPrefix(e3.sdp, "a=max-message-size:");
          return r3.length > 0 ? n4 = parseInt(r3[0].substr(19), 10) : "firefox" === t3.browser && -1 !== i3 && (n4 = 2147483637), n4;
        }, s2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t3.browser && t3.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (i2(arguments[0])) {
            const e3 = n3(arguments[0]), t4 = r2(e3), i3 = o2(arguments[0], e3);
            let s3;
            s3 = 0 === t4 && 0 === i3 ? Number.POSITIVE_INFINITY : 0 === t4 || 0 === i3 ? Math.max(t4, i3) : Math.min(t4, i3);
            const a3 = {};
            Object.defineProperty(a3, "maxMessageSize", { get: () => s3 }), this._sctp = a3;
          }
          return s2.apply(this, arguments);
        };
      }
      function Bg2(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype)) return;
        function t3(e3, t4) {
          const i3 = e3.send;
          e3.send = function() {
            const n3 = arguments[0], r2 = n3.length || n3.size || n3.byteLength;
            if ("open" === e3.readyState && t4.sctp && r2 > t4.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t4.sctp.maxMessageSize + " bytes)");
            return i3.apply(e3, arguments);
          };
        }
        const i2 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = i2.apply(this, arguments);
          return t3(e3, this), e3;
        }, IS(e2, "datachannel", (e3) => (t3(e3.channel, e3.target), e3));
      }
      function jg2(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype) return;
        const t3 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t3, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t3, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
          const i2 = t3[e3];
          t3[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t4 = e4.target;
              if (t4._lastConnectionState !== t4.connectionState) {
                t4._lastConnectionState = t4.connectionState;
                const i3 = new Event("connectionstatechange", e4);
                t4.dispatchEvent(i3);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
          };
        });
      }
      function Gg2(e2, t3) {
        if (!e2.RTCPeerConnection) return;
        if ("chrome" === t3.browser && t3.version >= 71) return;
        if ("safari" === t3.browser && t3.version >= 605) return;
        const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t4) {
          if (t4 && t4.sdp && -1 !== t4.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i3 = t4.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== Pg2(e3).call(e3)).join("\n");
            e2.RTCSessionDescription && t4 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t4.type, sdp: i3 }) : t4.sdp = i3;
          }
          return i2.apply(this, arguments);
        };
      }
      function Wg2(e2, t3) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype) return;
        const i2 = e2.RTCPeerConnection.prototype.addIceCandidate;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t3.browser && t3.version < 78 || "firefox" === t3.browser && t3.version < 68 || "safari" === t3.browser) && arguments[0] && "" === arguments[0].candidate ? ip2.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), ip2.resolve());
        });
      }
      function Hg2(e2, t3) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype) return;
        const i2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          let e3 = arguments[0] || {};
          if ("object" != typeof e3 || e3.type && e3.sdp) return i2.apply(this, arguments);
          if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type) switch (this.signalingState) {
            case "stable":
            case "have-local-offer":
            case "have-remote-pranswer":
              e3.type = "offer";
              break;
            default:
              e3.type = "answer";
          }
          if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type) return i2.apply(this, [e3]);
          return ("offer" === e3.type ? this.createOffer : this.createAnswer).apply(this).then((e4) => i2.apply(this, [e4]));
        });
      }
      var Kg2 = Object.freeze({ __proto__: null, removeExtmapAllowMixed: Gg2, shimAddIceCandidateNullOrEmpty: Wg2, shimConnectionState: jg2, shimMaxMessageSize: Fg, shimParameterlessSetLocalDescription: Hg2, shimRTCIceCandidate: Vg2, shimRTCIceCandidateRelayProtocol: xg2, shimSendThrowTypeError: Bg2 });
      !function() {
        let { window: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
        const i2 = wS, n3 = function(e3) {
          const t4 = { browser: null, version: null };
          if (void 0 === e3 || !e3.navigator) return t4.browser = "Not a browser.", t4;
          const { navigator: i3 } = e3;
          if (i3.mozGetUserMedia) t4.browser = "firefox", t4.version = yS(i3.userAgent, /Firefox\/(\d+)\./, 1);
          else if (i3.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection) t4.browser = "chrome", t4.version = yS(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          else {
            if (!e3.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./)) return t4.browser = "Not a supported browser.", t4;
            t4.browser = "safari", t4.version = yS(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t4.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
          }
          return t4;
        }(e2), r2 = { browserDetails: n3, commonShim: Kg2, extractVersion: yS, disableLog: bS, disableWarnings: AS, sdp: Ug2 };
        switch (n3.browser) {
          case "chrome":
            if (!KS || !WS || !t3.shimChrome) return i2("Chrome shim is not included in this adapter release."), r2;
            if (null === n3.version) return i2("Chrome shim can not determine version, not shimming."), r2;
            i2("adapter.js shimming chrome."), r2.browserShim = KS, Wg2(e2, n3), Hg2(e2), MS(e2, n3), US(e2), WS(e2, n3), VS(e2), GS(e2, n3), xS(e2), FS(e2), BS(e2), HS(e2, n3), Vg2(e2), xg2(e2), jg2(e2), Fg(e2, n3), Bg2(e2), Gg2(e2, n3);
            break;
          case "firefox":
            if (!ng2 || !qS || !t3.shimFirefox) return i2("Firefox shim is not included in this adapter release."), r2;
            i2("adapter.js shimming firefox."), r2.browserShim = ng2, Wg2(e2, n3), Hg2(e2), YS(e2, n3), qS(e2, n3), zS(e2), ZS(e2), XS(e2), JS(e2), QS(e2), $S(e2), eg2(e2), tg2(e2), ig2(e2), Vg2(e2), jg2(e2), Fg(e2, n3), Bg2(e2);
            break;
          case "safari":
            if (!pg2 || !t3.shimSafari) return i2("Safari shim is not included in this adapter release."), r2;
            i2("adapter.js shimming safari."), r2.browserShim = pg2, Wg2(e2, n3), Hg2(e2), dg2(e2), ug2(e2), sg2(e2), rg2(e2), og2(e2), lg2(e2), ag2(e2), hg2(e2), Vg2(e2), xg2(e2), Fg(e2, n3), Bg2(e2), Gg2(e2, n3);
            break;
          default:
            i2("Unsupported browser!");
        }
      }({ window: "undefined" == typeof window ? void 0 : window });
      var Yg2 = h;
      Oi2({ global: true, forced: Yg2.globalThis !== Yg2 }, { globalThis: Yg2 });
      var zg2 = i(h), qg2 = { exports: {} };
      !function(e2, i2) {
        !function(t3, n3) {
          var r2 = "function", o2 = "undefined", s2 = "object", a3 = "string", c3 = "major", d2 = "model", l2 = "name", u3 = "type", h2 = "vendor", p2 = "version", _2 = "architecture", E3 = "console", m3 = "mobile", f2 = "tablet", S3 = "smarttv", g2 = "wearable", T3 = "embedded", R3 = "Amazon", v3 = "Apple", C2 = "ASUS", y3 = "BlackBerry", I3 = "Browser", b2 = "Chrome", A2 = "Firefox", w3 = "Google", O3 = "Huawei", N3 = "LG", D3 = "Microsoft", P2 = "Motorola", L3 = "Opera", k2 = "Samsung", M3 = "Sharp", U3 = "Sony", V3 = "Xiaomi", x2 = "Zebra", F3 = "Facebook", B2 = "Chromium OS", j2 = "Mac OS", G3 = " Browser", W3 = function(e3) {
            for (var t4 = {}, i3 = 0; i3 < e3.length; i3++) t4[e3[i3].toUpperCase()] = e3[i3];
            return t4;
          }, H2 = function(e3, t4) {
            return typeof e3 === a3 && -1 !== K3(t4).indexOf(K3(e3));
          }, K3 = function(e3) {
            return e3.toLowerCase();
          }, Y3 = function(e3, t4) {
            if (typeof e3 === a3) return e3 = e3.replace(/^\s\s*/, ""), typeof t4 === o2 ? e3 : e3.substring(0, 500);
          }, z2 = function(e3, t4) {
            for (var i3, o3, a4, c4, d3, l3, u4 = 0; u4 < t4.length && !d3; ) {
              var h3 = t4[u4], p3 = t4[u4 + 1];
              for (i3 = o3 = 0; i3 < h3.length && !d3 && h3[i3]; ) if (d3 = h3[i3++].exec(e3)) for (a4 = 0; a4 < p3.length; a4++) l3 = d3[++o3], typeof (c4 = p3[a4]) === s2 && c4.length > 0 ? 2 === c4.length ? typeof c4[1] == r2 ? this[c4[0]] = c4[1].call(this, l3) : this[c4[0]] = c4[1] : 3 === c4.length ? typeof c4[1] !== r2 || c4[1].exec && c4[1].test ? this[c4[0]] = l3 ? l3.replace(c4[1], c4[2]) : n3 : this[c4[0]] = l3 ? c4[1].call(this, l3, c4[2]) : n3 : 4 === c4.length && (this[c4[0]] = l3 ? c4[3].call(this, l3.replace(c4[1], c4[2])) : n3) : this[c4] = l3 || n3;
              u4 += 2;
            }
          }, q3 = function(e3, t4) {
            for (var i3 in t4) if (typeof t4[i3] === s2 && t4[i3].length > 0) {
              for (var r3 = 0; r3 < t4[i3].length; r3++) if (H2(t4[i3][r3], e3)) return "?" === i3 ? n3 : i3;
            } else if (H2(t4[i3], e3)) return "?" === i3 ? n3 : i3;
            return t4.hasOwnProperty("*") ? t4["*"] : e3;
          }, X3 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, J3 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p2, [l2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p2, [l2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [l2, p2], [/opios[\/ ]+([\w\.]+)/i], [p2, [l2, L3 + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [p2, [l2, L3 + " GX"]], [/\bopr\/([\w\.]+)/i], [p2, [l2, L3]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [p2, [l2, "Baidu"]], [/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i], [p2, [l2, "Maxthon"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i, /(heytap|ovi|115)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [l2, p2], [/quark(?:pc)?\/([-\w\.]+)/i], [p2, [l2, "Quark"]], [/\bddg\/([\w\.]+)/i], [p2, [l2, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p2, [l2, "UC" + I3]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [p2, [l2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p2, [l2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p2, [l2, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [p2, [l2, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [p2, [l2, "Smart Lenovo " + I3]], [/(avast|avg)\/([\w\.]+)/i], [[l2, /(.+)/, "$1 Secure " + I3], p2], [/\bfocus\/([\w\.]+)/i], [p2, [l2, A2 + " Focus"]], [/\bopt\/([\w\.]+)/i], [p2, [l2, L3 + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p2, [l2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p2, [l2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p2, [l2, L3 + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [p2, [l2, "MIUI" + G3]], [/fxios\/([\w\.-]+)/i], [p2, [l2, A2]], [/\bqihoobrowser\/?([\w\.]*)/i], [p2, [l2, "360"]], [/\b(qq)\/([\w\.]+)/i], [[l2, /(.+)/, "$1Browser"], p2], [/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i], [[l2, /(.+)/, "$1" + G3], p2], [/samsungbrowser\/([\w\.]+)/i], [p2, [l2, k2 + " Internet"]], [/metasr[\/ ]?([\d\.]+)/i], [p2, [l2, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[l2, "Sogou Mobile"], p2], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i], [l2, p2], [/(lbbrowser|rekonq)/i, /\[(linkedin)app\]/i], [l2], [/ome\/([\w\.]+) \w* ?(iron) saf/i, /ome\/([\w\.]+).+qihu (360)[es]e/i], [p2, l2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[l2, F3], p2], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [l2, p2], [/\bgsa\/([\w\.]+) .*safari\//i], [p2, [l2, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [p2, [l2, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p2, [l2, b2 + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[l2, b2 + " WebView"], p2], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p2, [l2, "Android " + I3]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [l2, p2], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p2, [l2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p2, l2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [l2, [p2, q3, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [l2, p2], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[l2, "Netscape"], p2], [/(wolvic|librewolf)\/([\w\.]+)/i], [l2, p2], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p2, [l2, A2 + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [l2, [p2, /_/g, "."]], [/(cobalt)\/([\w\.]+)/i], [l2, [p2, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[_2, "amd64"]], [/(ia32(?=;))/i], [[_2, K3]], [/((?:i[346]|x)86)[;\)]/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[_2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[_2, /ower/, "", K3]], [/(sun4\w)[;\)]/i], [[_2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[_2, K3]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [h2, k2], [u3, f2]], [/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]((?!sm-[lr])[-\w]+)/i, /sec-(sgh\w+)/i], [d2, [h2, k2], [u3, m3]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [d2, [h2, v3], [u3, m3]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [h2, v3], [u3, f2]], [/(macintosh);/i], [d2, [h2, v3]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [h2, M3], [u3, m3]], [/(?:honor)([-\w ]+)[;\)]/i], [d2, [h2, "Honor"], [u3, m3]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d2, [h2, O3], [u3, f2]], [/(?:huawei)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [h2, O3], [u3, m3]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i], [[d2, /_/g, " "], [h2, V3], [u3, m3]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d2, /_/g, " "], [h2, V3], [u3, f2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [h2, "OPPO"], [u3, m3]], [/\b(opd2\d{3}a?) bui/i], [d2, [h2, "OPPO"], [u3, f2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [h2, "Vivo"], [u3, m3]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [d2, [h2, "Realme"], [u3, m3]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [h2, P2], [u3, m3]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [h2, P2], [u3, f2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [h2, N3], [u3, f2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [h2, N3], [u3, m3]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d2, [h2, "Lenovo"], [u3, f2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d2, /_/g, " "], [h2, "Nokia"], [u3, m3]], [/(pixel c)\b/i], [d2, [h2, w3], [u3, f2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [h2, w3], [u3, m3]], [/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [h2, U3], [u3, m3]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [h2, U3], [u3, f2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [h2, "OnePlus"], [u3, m3]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [h2, R3], [u3, f2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [h2, R3], [u3, m3]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, h2, [u3, f2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [h2, y3], [u3, m3]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [h2, C2], [u3, f2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [h2, C2], [u3, m3]], [/(nexus 9)/i], [d2, [h2, "HTC"], [u3, f2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h2, [d2, /_/g, " "], [u3, m3]], [/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i], [d2, [h2, "TCL"], [u3, f2]], [/(itel) ((\w+))/i], [[h2, K3], d2, [u3, q3, { tablet: ["p10001l", "w7001"], "*": "mobile" }]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [h2, "Acer"], [u3, f2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [h2, "Meizu"], [u3, m3]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [d2, [h2, "Ulefone"], [u3, m3]], [/; (energy ?\w+)(?: bui|\))/i, /; energizer ([\w ]+)(?: bui|\))/i], [d2, [h2, "Energizer"], [u3, m3]], [/; cat (b35);/i, /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i], [d2, [h2, "Cat"], [u3, m3]], [/((?:new )?andromax[\w- ]+)(?: bui|\))/i], [d2, [h2, "Smartfren"], [u3, m3]], [/droid.+; (a(?:015|06[35]|142p?))/i], [d2, [h2, "Nothing"], [u3, m3]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i, /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h2, d2, [u3, m3]], [/(imo) (tab \w+)/i, /(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h2, d2, [u3, f2]], [/(surface duo)/i], [d2, [h2, D3], [u3, f2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [h2, "Fairphone"], [u3, m3]], [/(u304aa)/i], [d2, [h2, "AT&T"], [u3, m3]], [/\bsie-(\w*)/i], [d2, [h2, "Siemens"], [u3, m3]], [/\b(rct\w+) b/i], [d2, [h2, "RCA"], [u3, f2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [h2, "Dell"], [u3, f2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [h2, "Verizon"], [u3, f2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [h2, "Barnes & Noble"], [u3, f2]], [/\b(tm\d{3}\w+) b/i], [d2, [h2, "NuVision"], [u3, f2]], [/\b(k88) b/i], [d2, [h2, "ZTE"], [u3, f2]], [/\b(nx\d{3}j) b/i], [d2, [h2, "ZTE"], [u3, m3]], [/\b(gen\d{3}) b.+49h/i], [d2, [h2, "Swiss"], [u3, m3]], [/\b(zur\d{3}) b/i], [d2, [h2, "Swiss"], [u3, f2]], [/\b((zeki)?tb.*\b) b/i], [d2, [h2, "Zeki"], [u3, f2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h2, "Dragon Touch"], d2, [u3, f2]], [/\b(ns-?\w{0,9}) b/i], [d2, [h2, "Insignia"], [u3, f2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [h2, "NextBook"], [u3, f2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h2, "Voice"], d2, [u3, m3]], [/\b(lvtel\-)?(v1[12]) b/i], [[h2, "LvTel"], d2, [u3, m3]], [/\b(ph-1) /i], [d2, [h2, "Essential"], [u3, m3]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [h2, "Envizen"], [u3, f2]], [/\b(trio[-\w\. ]+) b/i], [d2, [h2, "MachSpeed"], [u3, f2]], [/\btu_(1491) b/i], [d2, [h2, "Rotor"], [u3, f2]], [/(shield[\w ]+) b/i], [d2, [h2, "Nvidia"], [u3, f2]], [/(sprint) (\w+)/i], [h2, d2, [u3, m3]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [h2, D3], [u3, m3]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [h2, x2], [u3, f2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [h2, x2], [u3, m3]], [/smart-tv.+(samsung)/i], [h2, [u3, S3]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [h2, k2], [u3, S3]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h2, N3], [u3, S3]], [/(apple) ?tv/i], [h2, [d2, v3 + " TV"], [u3, S3]], [/crkey/i], [[d2, b2 + "cast"], [h2, w3], [u3, S3]], [/droid.+aft(\w+)( bui|\))/i], [d2, [h2, R3], [u3, S3]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [h2, M3], [u3, S3]], [/(bravia[\w ]+)( bui|\))/i], [d2, [h2, U3], [u3, S3]], [/(mitv-\w{5}) bui/i], [d2, [h2, V3], [u3, S3]], [/Hbbtv.*(technisat) (.*);/i], [h2, d2, [u3, S3]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h2, Y3], [d2, Y3], [u3, S3]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[u3, S3]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h2, d2, [u3, E3]], [/droid.+; (shield) bui/i], [d2, [h2, "Nvidia"], [u3, E3]], [/(playstation [345portablevi]+)/i], [d2, [h2, U3], [u3, E3]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [h2, D3], [u3, E3]], [/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i], [d2, [h2, k2], [u3, g2]], [/((pebble))app/i], [h2, d2, [u3, g2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [h2, v3], [u3, g2]], [/droid.+; (glass) \d/i], [d2, [h2, w3], [u3, g2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [h2, x2], [u3, g2]], [/droid.+; (glass) \d/i], [d2, [h2, w3], [u3, g2]], [/(pico) (4|neo3(?: link|pro)?)/i], [h2, d2, [u3, g2]], [/; (quest( \d| pro)?)/i], [d2, [h2, F3], [u3, g2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h2, [u3, T3]], [/(aeobc)\b/i], [d2, [h2, R3], [u3, T3]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [d2, [u3, m3]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [u3, f2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[u3, f2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[u3, m3]], [/(android[-\w\. ]{0,9});.+buil/i], [d2, [h2, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p2, [l2, "EdgeHTML"]], [/(arkweb)\/([\w\.]+)/i], [l2, p2], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p2, [l2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [l2, p2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p2, l2]], os: [[/microsoft (windows) (vista|xp)/i], [l2, p2], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [l2, [p2, q3, X3]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[p2, q3, X3], [l2, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[p2, /_/g, "."], [l2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[l2, j2], [p2, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p2, l2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [l2, p2], [/\(bb(10);/i], [p2, [l2, y3]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [p2, [l2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p2, [l2, A2 + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p2, [l2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p2, [l2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p2, [l2, b2 + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[l2, B2], p2], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [l2, p2], [/(sunos) ?([\w\.\d]*)/i], [[l2, "Solaris"], p2], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [l2, p2]] }, Z3 = function(e3, i3) {
            if (typeof e3 === s2 && (i3 = e3, e3 = n3), !(this instanceof Z3)) return new Z3(e3, i3).getResult();
            var E4 = typeof t3 !== o2 && t3.navigator ? t3.navigator : n3, S4 = e3 || (E4 && E4.userAgent ? E4.userAgent : ""), g3 = E4 && E4.userAgentData ? E4.userAgentData : n3, T4 = i3 ? function(e4, t4) {
              var i4 = {};
              for (var n4 in e4) t4[n4] && t4[n4].length % 2 == 0 ? i4[n4] = t4[n4].concat(e4[n4]) : i4[n4] = e4[n4];
              return i4;
            }(J3, i3) : J3, R4 = E4 && E4.userAgent == S4;
            return this.getBrowser = function() {
              var e4 = {};
              return e4[l2] = n3, e4[p2] = n3, z2.call(e4, S4, T4.browser), e4[c3] = function(e5) {
                return typeof e5 === a3 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n3;
              }(e4[p2]), R4 && E4 && E4.brave && typeof E4.brave.isBrave == r2 && (e4[l2] = "Brave"), e4;
            }, this.getCPU = function() {
              var e4 = {};
              return e4[_2] = n3, z2.call(e4, S4, T4.cpu), e4;
            }, this.getDevice = function() {
              var e4 = {};
              return e4[h2] = n3, e4[d2] = n3, e4[u3] = n3, z2.call(e4, S4, T4.device), R4 && !e4[u3] && g3 && g3.mobile && (e4[u3] = m3), R4 && "Macintosh" == e4[d2] && E4 && typeof E4.standalone !== o2 && E4.maxTouchPoints && E4.maxTouchPoints > 2 && (e4[d2] = "iPad", e4[u3] = f2), e4;
            }, this.getEngine = function() {
              var e4 = {};
              return e4[l2] = n3, e4[p2] = n3, z2.call(e4, S4, T4.engine), e4;
            }, this.getOS = function() {
              var e4 = {};
              return e4[l2] = n3, e4[p2] = n3, z2.call(e4, S4, T4.os), R4 && !e4[l2] && g3 && g3.platform && "Unknown" != g3.platform && (e4[l2] = g3.platform.replace(/chrome os/i, B2).replace(/macos/i, j2)), e4;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return S4;
            }, this.setUA = function(e4) {
              return S4 = typeof e4 === a3 && e4.length > 500 ? Y3(e4, 500) : e4, this;
            }, this.setUA(S4), this;
          };
          Z3.VERSION = "0.7.40", Z3.BROWSER = W3([l2, p2, c3]), Z3.CPU = W3([_2]), Z3.DEVICE = W3([d2, h2, u3, E3, m3, S3, f2, g2, T3]), Z3.ENGINE = Z3.OS = W3([l2, p2]), e2.exports && (i2 = e2.exports = Z3), i2.UAParser = Z3;
          var Q3 = typeof t3 !== o2 && (t3.jQuery || t3.Zepto);
          if (Q3 && !Q3.ua) {
            var $2 = new Z3();
            Q3.ua = $2.getResult(), Q3.ua.get = function() {
              return $2.getUA();
            }, Q3.ua.set = function(e3) {
              $2.setUA(e3);
              var t4 = $2.getResult();
              for (var i3 in t4) Q3.ua[i3] = t4[i3];
            };
          }
        }("object" == typeof window ? window : t2);
      }(qg2, qg2.exports);
      var Xg2 = i(qg2.exports), Jg2 = Ud2.clear;
      Oi2({ global: true, bind: true, enumerable: true, forced: h.clearImmediate !== Jg2 }, { clearImmediate: Jg2 });
      var Zg2 = h, Qg2 = f, $g2 = b, eT = qn2, tT = ae2, iT = sd2, nT = cd2, rT = Zg2.Function, oT = /MSIE .\./.test(tT) || "BUN" === eT && function() {
        var e2 = Zg2.Bun.version.split(".");
        return e2.length < 3 || "0" === e2[0] && (e2[1] < 3 || "3" === e2[1] && "0" === e2[2]);
      }(), sT = Oi2, aT = h, cT = Ud2.set, dT = function(e2, t3) {
        var i2 = t3 ? 2 : 1;
        return oT ? function(n3, r2) {
          var o2 = nT(arguments.length, 1) > i2, s2 = $g2(n3) ? n3 : rT(n3), a3 = o2 ? iT(arguments, i2) : [], c3 = o2 ? function() {
            Qg2(s2, this, a3);
          } : s2;
          return t3 ? e2(c3, r2) : e2(c3);
        } : e2;
      }, lT = aT.setImmediate ? dT(cT, false) : cT;
      sT({ global: true, bind: true, enumerable: true, forced: aT.setImmediate !== lT }, { setImmediate: lT });
      var uT = i($.setImmediate), hT = h, pT = hl2, _T = Ne2, ET = cd2, mT = w2;
      Oi2({ global: true, enumerable: true, dontCallGetSet: true, forced: n2(function() {
        return mT && 1 !== Object.getOwnPropertyDescriptor(hT, "queueMicrotask").value.length;
      }) }, { queueMicrotask: function(e2) {
        ET(arguments.length, 1), pT(_T(e2));
      } });
      var fT = i($.queueMicrotask);
      function ST(e2, t3) {
        return function() {
          return e2.apply(t3, arguments);
        };
      }
      const { toString: gT } = Object.prototype, { getPrototypeOf: TT } = Object, { iterator: RT, toStringTag: vT } = Symbol, CT = (yT = /* @__PURE__ */ Object.create(null), (e2) => {
        const t3 = gT.call(e2);
        return yT[t3] || (yT[t3] = t3.slice(8, -1).toLowerCase());
      });
      var yT;
      const IT = (e2) => (e2 = e2.toLowerCase(), (t3) => CT(t3) === e2), bT = (e2) => (t3) => typeof t3 === e2, { isArray: AT } = Array, wT = bT("undefined");
      const OT = IT("ArrayBuffer");
      const NT = bT("string"), DT = bT("function"), PT = bT("number"), LT = (e2) => null !== e2 && "object" == typeof e2, kT = (e2) => {
        if ("object" !== CT(e2)) return false;
        const t3 = TT(e2);
        return !(null !== t3 && t3 !== Object.prototype && null !== Object.getPrototypeOf(t3) || vT in e2 || RT in e2);
      }, MT = IT("Date"), UT = IT("File"), VT = IT("Blob"), xT = IT("FileList"), FT = IT("URLSearchParams"), [BT, jT, GT, WT] = ["ReadableStream", "Request", "Response", "Headers"].map(IT);
      function HT(e2, t3) {
        let i2, n3, { allOwnKeys: r2 = false } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (null != e2) if ("object" != typeof e2 && (e2 = [e2]), AT(e2)) for (i2 = 0, n3 = e2.length; i2 < n3; i2++) t3.call(null, e2[i2], i2, e2);
        else {
          const n4 = r2 ? Object.getOwnPropertyNames(e2) : Object.keys(e2), o2 = n4.length;
          let s2;
          for (i2 = 0; i2 < o2; i2++) s2 = n4[i2], t3.call(null, e2[s2], s2, e2);
        }
      }
      function KT(e2, t3) {
        t3 = t3.toLowerCase();
        const i2 = Object.keys(e2);
        let n3, r2 = i2.length;
        for (; r2-- > 0; ) if (n3 = i2[r2], t3 === n3.toLowerCase()) return n3;
        return null;
      }
      const YT = void 0 !== zg2 ? zg2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, zT = (e2) => !wT(e2) && e2 !== YT;
      const qT = (XT = "undefined" != typeof Uint8Array && TT(Uint8Array), (e2) => XT && e2 instanceof XT);
      var XT;
      const JT = IT("HTMLFormElement"), ZT = ((e2) => {
        let { hasOwnProperty: t3 } = e2;
        return (e3, i2) => t3.call(e3, i2);
      })(Object.prototype), QT = IT("RegExp"), $T = (e2, t3) => {
        const i2 = Object.getOwnPropertyDescriptors(e2), n3 = {};
        HT(i2, (i3, r2) => {
          let o2;
          false !== (o2 = t3(i3, r2, e2)) && (n3[r2] = o2 || i3);
        }), Object.defineProperties(e2, n3);
      };
      const eR = IT("AsyncFunction"), tR = (iR = "function" == typeof uT, nR = DT(YT.postMessage), iR ? uT : nR ? (rR = "axios@".concat(Math.random()), oR = [], YT.addEventListener("message", (e2) => {
        let { source: t3, data: i2 } = e2;
        t3 === YT && i2 === rR && oR.length && oR.shift()();
      }, false), (e2) => {
        oR.push(e2), YT.postMessage(rR, "*");
      }) : (e2) => setTimeout(e2));
      var iR, nR, rR, oR;
      const sR = void 0 !== fT ? fT.bind(YT) : "undefined" != typeof process && process.nextTick || tR;
      var aR = { isArray: AT, isArrayBuffer: OT, isBuffer: function(e2) {
        return null !== e2 && !wT(e2) && null !== e2.constructor && !wT(e2.constructor) && DT(e2.constructor.isBuffer) && e2.constructor.isBuffer(e2);
      }, isFormData: (e2) => {
        let t3;
        return e2 && ("function" == typeof FormData && e2 instanceof FormData || DT(e2.append) && ("formdata" === (t3 = CT(e2)) || "object" === t3 && DT(e2.toString) && "[object FormData]" === e2.toString()));
      }, isArrayBufferView: function(e2) {
        let t3;
        return t3 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && OT(e2.buffer), t3;
      }, isString: NT, isNumber: PT, isBoolean: (e2) => true === e2 || false === e2, isObject: LT, isPlainObject: kT, isReadableStream: BT, isRequest: jT, isResponse: GT, isHeaders: WT, isUndefined: wT, isDate: MT, isFile: UT, isBlob: VT, isRegExp: QT, isFunction: DT, isStream: (e2) => LT(e2) && DT(e2.pipe), isURLSearchParams: FT, isTypedArray: qT, isFileList: xT, forEach: HT, merge: function e2() {
        const { caseless: t3 } = zT(this) && this || {}, i2 = {}, n3 = (n4, r2) => {
          const o2 = t3 && KT(i2, r2) || r2;
          kT(i2[o2]) && kT(n4) ? i2[o2] = e2(i2[o2], n4) : kT(n4) ? i2[o2] = e2({}, n4) : AT(n4) ? i2[o2] = n4.slice() : i2[o2] = n4;
        };
        for (let e3 = 0, t4 = arguments.length; e3 < t4; e3++) arguments[e3] && HT(arguments[e3], n3);
        return i2;
      }, extend: function(e2, t3, i2) {
        let { allOwnKeys: n3 } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        return HT(t3, (t4, n4) => {
          i2 && DT(t4) ? e2[n4] = ST(t4, i2) : e2[n4] = t4;
        }, { allOwnKeys: n3 }), e2;
      }, trim: (e2) => Pg2(e2) ? Pg2(e2).call(e2) : e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (e2) => (65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2), inherits: (e2, t3, i2, n3) => {
        e2.prototype = Object.create(t3.prototype, n3), e2.prototype.constructor = e2, Object.defineProperty(e2, "super", { value: t3.prototype }), i2 && Object.assign(e2.prototype, i2);
      }, toFlatObject: (e2, t3, i2, n3) => {
        let r2, o2, s2;
        const a3 = {};
        if (t3 = t3 || {}, null == e2) return t3;
        do {
          for (r2 = Object.getOwnPropertyNames(e2), o2 = r2.length; o2-- > 0; ) s2 = r2[o2], n3 && !n3(s2, e2, t3) || a3[s2] || (t3[s2] = e2[s2], a3[s2] = true);
          e2 = false !== i2 && TT(e2);
        } while (e2 && (!i2 || i2(e2, t3)) && e2 !== Object.prototype);
        return t3;
      }, kindOf: CT, kindOfTest: IT, endsWith: (e2, t3, i2) => {
        e2 = String(e2), (void 0 === i2 || i2 > e2.length) && (i2 = e2.length), i2 -= t3.length;
        const n3 = e2.indexOf(t3, i2);
        return -1 !== n3 && n3 === i2;
      }, toArray: (e2) => {
        if (!e2) return null;
        if (AT(e2)) return e2;
        let t3 = e2.length;
        if (!PT(t3)) return null;
        const i2 = new Array(t3);
        for (; t3-- > 0; ) i2[t3] = e2[t3];
        return i2;
      }, forEachEntry: (e2, t3) => {
        const i2 = (e2 && e2[RT]).call(e2);
        let n3;
        for (; (n3 = i2.next()) && !n3.done; ) {
          const i3 = n3.value;
          t3.call(e2, i3[0], i3[1]);
        }
      }, matchAll: (e2, t3) => {
        let i2;
        const n3 = [];
        for (; null !== (i2 = e2.exec(t3)); ) n3.push(i2);
        return n3;
      }, isHTMLForm: JT, hasOwnProperty: ZT, hasOwnProp: ZT, reduceDescriptors: $T, freezeMethods: (e2) => {
        $T(e2, (t3, i2) => {
          if (DT(e2) && -1 !== ["arguments", "caller", "callee"].indexOf(i2)) return false;
          const n3 = e2[i2];
          DT(n3) && (t3.enumerable = false, "writable" in t3 ? t3.writable = false : t3.set || (t3.set = () => {
            throw Error("Can not rewrite read-only method '" + i2 + "'");
          }));
        });
      }, toObjectSet: (e2, t3) => {
        const i2 = {}, n3 = (e3) => {
          e3.forEach((e4) => {
            i2[e4] = true;
          });
        };
        return AT(e2) ? n3(e2) : n3(String(e2).split(t3)), i2;
      }, toCamelCase: (e2) => e2.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e3, t3, i2) {
        return t3.toUpperCase() + i2;
      }), noop: () => {
      }, toFiniteNumber: (e2, t3) => null != e2 && Number.isFinite(e2 = +e2) ? e2 : t3, findKey: KT, global: YT, isContextDefined: zT, isSpecCompliantForm: function(e2) {
        return !!(e2 && DT(e2.append) && "FormData" === e2[vT] && e2[RT]);
      }, toJSONObject: (e2) => {
        const t3 = new Array(10), i2 = (e3, n3) => {
          if (LT(e3)) {
            if (t3.indexOf(e3) >= 0) return;
            if (!("toJSON" in e3)) {
              t3[n3] = e3;
              const r2 = AT(e3) ? [] : {};
              return HT(e3, (e4, t4) => {
                const o2 = i2(e4, n3 + 1);
                !wT(o2) && (r2[t4] = o2);
              }), t3[n3] = void 0, r2;
            }
          }
          return e3;
        };
        return i2(e2, 0);
      }, isAsyncFn: eR, isThenable: (e2) => e2 && (LT(e2) || DT(e2)) && DT(e2.then) && DT(e2.catch), setImmediate: tR, asap: sR, isIterable: (e2) => null != e2 && DT(e2[RT]) };
      function cR(e2, t3, i2, n3, r2) {
        Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e2, this.name = "AxiosError", t3 && (this.code = t3), i2 && (this.config = i2), n3 && (this.request = n3), r2 && (this.response = r2, this.status = r2.status ? r2.status : null);
      }
      aR.inherits(cR, Error, { toJSON: function() {
        return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: aR.toJSONObject(this.config), code: this.code, status: this.status };
      } });
      const dR = cR.prototype, lR = {};
      ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((e2) => {
        lR[e2] = { value: e2 };
      }), Object.defineProperties(cR, lR), Object.defineProperty(dR, "isAxiosError", { value: true }), cR.from = (e2, t3, i2, n3, r2, o2) => {
        const s2 = Object.create(dR);
        return aR.toFlatObject(e2, s2, function(e3) {
          return e3 !== Error.prototype;
        }, (e3) => "isAxiosError" !== e3), cR.call(s2, e2.message, t3, i2, n3, r2), s2.cause = e2, s2.name = e2.name, o2 && Object.assign(s2, o2), s2;
      };
      function uR(e2) {
        return aR.isPlainObject(e2) || aR.isArray(e2);
      }
      function hR(e2) {
        return aR.endsWith(e2, "[]") ? e2.slice(0, -2) : e2;
      }
      function pR(e2, t3, i2) {
        return e2 ? e2.concat(t3).map(function(e3, t4) {
          return e3 = hR(e3), !i2 && t4 ? "[" + e3 + "]" : e3;
        }).join(i2 ? "." : "") : t3;
      }
      const _R = aR.toFlatObject(aR, {}, null, function(e2) {
        return /^is[A-Z]/.test(e2);
      });
      function ER(e2, t3, i2) {
        if (!aR.isObject(e2)) throw new TypeError("target must be an object");
        t3 = t3 || new FormData();
        const n3 = (i2 = aR.toFlatObject(i2, { metaTokens: true, dots: false, indexes: false }, false, function(e3, t4) {
          return !aR.isUndefined(t4[e3]);
        })).metaTokens, r2 = i2.visitor || d2, o2 = i2.dots, s2 = i2.indexes, a3 = (i2.Blob || "undefined" != typeof Blob && Blob) && aR.isSpecCompliantForm(t3);
        if (!aR.isFunction(r2)) throw new TypeError("visitor must be a function");
        function c3(e3) {
          if (null === e3) return "";
          if (aR.isDate(e3)) return e3.toISOString();
          if (!a3 && aR.isBlob(e3)) throw new cR("Blob is not supported. Use a Buffer instead.");
          return aR.isArrayBuffer(e3) || aR.isTypedArray(e3) ? a3 && "function" == typeof Blob ? new Blob([e3]) : Buffer.from(e3) : e3;
        }
        function d2(e3, i3, r3) {
          let a4 = e3;
          if (e3 && !r3 && "object" == typeof e3) {
            if (aR.endsWith(i3, "{}")) i3 = n3 ? i3 : i3.slice(0, -2), e3 = JSON.stringify(e3);
            else if (aR.isArray(e3) && function(e4) {
              return aR.isArray(e4) && !e4.some(uR);
            }(e3) || (aR.isFileList(e3) || aR.endsWith(i3, "[]")) && (a4 = aR.toArray(e3))) return i3 = hR(i3), a4.forEach(function(e4, n4) {
              !aR.isUndefined(e4) && null !== e4 && t3.append(true === s2 ? pR([i3], n4, o2) : null === s2 ? i3 : i3 + "[]", c3(e4));
            }), false;
          }
          return !!uR(e3) || (t3.append(pR(r3, i3, o2), c3(e3)), false);
        }
        const l2 = [], u3 = Object.assign(_R, { defaultVisitor: d2, convertValue: c3, isVisitable: uR });
        if (!aR.isObject(e2)) throw new TypeError("data must be an object");
        return function e3(i3, n4) {
          if (!aR.isUndefined(i3)) {
            if (-1 !== l2.indexOf(i3)) throw Error("Circular reference detected in " + n4.join("."));
            l2.push(i3), aR.forEach(i3, function(i4, o3) {
              true === (!(aR.isUndefined(i4) || null === i4) && r2.call(t3, i4, aR.isString(o3) ? Pg2(o3).call(o3) : o3, n4, u3)) && e3(i4, n4 ? n4.concat(o3) : [o3]);
            }), l2.pop();
          }
        }(e2), t3;
      }
      function mR(e2) {
        const t3 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
        return encodeURIComponent(e2).replace(/[!'()~]|%20|%00/g, function(e3) {
          return t3[e3];
        });
      }
      function fR(e2, t3) {
        this._pairs = [], e2 && ER(e2, this, t3);
      }
      const SR = fR.prototype;
      function gR(e2) {
        return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      function TR(e2, t3, i2) {
        if (!t3) return e2;
        const n3 = i2 && i2.encode || gR;
        aR.isFunction(i2) && (i2 = { serialize: i2 });
        const r2 = i2 && i2.serialize;
        let o2;
        if (o2 = r2 ? r2(t3, i2) : aR.isURLSearchParams(t3) ? t3.toString() : new fR(t3, i2).toString(n3), o2) {
          const t4 = e2.indexOf("#");
          -1 !== t4 && (e2 = e2.slice(0, t4)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + o2;
        }
        return e2;
      }
      SR.append = function(e2, t3) {
        this._pairs.push([e2, t3]);
      }, SR.toString = function(e2) {
        const t3 = e2 ? function(t4) {
          return e2.call(this, t4, mR);
        } : mR;
        return this._pairs.map(function(e3) {
          return t3(e3[0]) + "=" + t3(e3[1]);
        }, "").join("&");
      };
      var RR = class {
        constructor() {
          this.handlers = [];
        }
        use(e2, t3, i2) {
          return this.handlers.push({ fulfilled: e2, rejected: t3, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
        }
        eject(e2) {
          this.handlers[e2] && (this.handlers[e2] = null);
        }
        clear() {
          this.handlers && (this.handlers = []);
        }
        forEach(e2) {
          aR.forEach(this.handlers, function(t3) {
            null !== t3 && e2(t3);
          });
        }
      }, vR = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, CR = { exports: {} }, yR = Oi2, IR = w2, bR = Qt2.f;
      yR({ target: "Object", stat: true, forced: Object.defineProperty !== bR, sham: !IR }, { defineProperty: bR });
      var AR = $.Object, wR = CR.exports = function(e2, t3, i2) {
        return AR.defineProperty(e2, t3, i2);
      };
      AR.defineProperty.sham && (wR.sham = true);
      var OR = i(CR.exports), NR = TypeError, DR = or2, PR = Zc2, LR = Q2, kR = pt2("species"), MR = Array, UR = function(e2) {
        var t3;
        return DR(e2) && (t3 = e2.constructor, (PR(t3) && (t3 === MR || DR(t3.prototype)) || LR(t3) && null === (t3 = t3[kR])) && (t3 = void 0)), void 0 === t3 ? MR : t3;
      }, VR = function(e2, t3) {
        return new (UR(e2))(0 === t3 ? 0 : t3);
      }, xR = n2, FR = _e, BR = pt2("species"), jR = function(e2) {
        return FR >= 51 || !xR(function() {
          var t3 = [];
          return (t3.constructor = {})[BR] = function() {
            return { foo: 1 };
          }, 1 !== t3[e2](Boolean).foo;
        });
      }, GR = Oi2, WR = n2, HR = or2, KR = Q2, YR = Je2, zR = Wi2, qR = function(e2) {
        if (e2 > 9007199254740991) throw NR("Maximum allowed index exceeded");
        return e2;
      }, XR = YE, JR = VR, ZR = jR, QR = _e, $R = pt2("isConcatSpreadable"), ev2 = QR >= 51 || !WR(function() {
        var e2 = [];
        return e2[$R] = false, e2.concat()[0] !== e2;
      }), tv2 = function(e2) {
        if (!KR(e2)) return false;
        var t3 = e2[$R];
        return void 0 !== t3 ? !!t3 : HR(e2);
      };
      GR({ target: "Array", proto: true, arity: 1, forced: !ev2 || !ZR("concat") }, { concat: function(e2) {
        var t3, i2, n3, r2, o2, s2 = YR(this), a3 = JR(s2, 0), c3 = 0;
        for (t3 = -1, n3 = arguments.length; t3 < n3; t3++) if (tv2(o2 = -1 === t3 ? s2 : arguments[t3])) for (r2 = zR(o2), qR(c3 + r2), i2 = 0; i2 < r2; i2++, c3++) i2 in o2 && XR(a3, c3, o2[i2]);
        else qR(c3 + 1), XR(a3, c3++, o2);
        return a3.length = c3, a3;
      } });
      var iv2 = {}, nv2 = R2, rv2 = J2, ov2 = Br2.f, sv2 = sd2, av2 = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      iv2.f = function(e2) {
        return av2 && "Window" === nv2(e2) ? function(e3) {
          try {
            return ov2(e3);
          } catch (e4) {
            return sv2(av2);
          }
        }(e2) : ov2(rv2(e2));
      };
      var cv2 = {}, dv2 = pt2;
      cv2.f = dv2;
      var lv2 = $, uv2 = $e2, hv2 = cv2, pv2 = Qt2.f, _v = function(e2) {
        var t3 = lv2.Symbol || (lv2.Symbol = {});
        uv2(t3, e2) || pv2(t3, e2, { value: hv2.f(e2) });
      }, Ev2 = D2, mv2 = re2, fv2 = pt2, Sv2 = Ca2, gv2 = function() {
        var e2 = mv2("Symbol"), t3 = e2 && e2.prototype, i2 = t3 && t3.valueOf, n3 = fv2("toPrimitive");
        t3 && !t3[n3] && Sv2(t3, n3, function(e3) {
          return Ev2(i2, this);
        }, { arity: 1 });
      }, Tv2 = Zt2, Rv2 = W2, vv2 = Je2, Cv2 = Wi2, yv2 = VR, Iv2 = d([].push), bv2 = function(e2) {
        var t3 = 1 === e2, i2 = 2 === e2, n3 = 3 === e2, r2 = 4 === e2, o2 = 6 === e2, s2 = 7 === e2, a3 = 5 === e2 || o2;
        return function(c3, d2, l2, u3) {
          for (var h2, p2, _2 = vv2(c3), E3 = Rv2(_2), m3 = Cv2(E3), f2 = Tv2(d2, l2), S3 = 0, g2 = u3 || yv2, T3 = t3 ? g2(c3, m3) : i2 || s2 ? g2(c3, 0) : void 0; m3 > S3; S3++) if ((a3 || S3 in E3) && (p2 = f2(h2 = E3[S3], S3, _2), e2)) if (t3) T3[S3] = p2;
          else if (p2) switch (e2) {
            case 3:
              return true;
            case 5:
              return h2;
            case 6:
              return S3;
            case 2:
              Iv2(T3, h2);
          }
          else switch (e2) {
            case 4:
              return false;
            case 7:
              Iv2(T3, h2);
          }
          return o2 ? -1 : n3 || r2 ? r2 : T3;
        };
      }, Av2 = { forEach: bv2(0), map: bv2(1), filter: bv2(2), some: bv2(3), every: bv2(4), find: bv2(5), findIndex: bv2(6), filterReject: bv2(7) }, wv2 = Oi2, Ov2 = h, Nv2 = D2, Dv2 = d, Pv2 = w2, Lv2 = Se2, kv2 = n2, Mv2 = $e2, Uv2 = l, Vv2 = ni2, xv2 = J2, Fv2 = Ct2, Bv2 = Sn2, jv2 = x, Gv2 = ko2, Wv2 = ho2, Hv2 = Br2, Kv2 = iv2, Yv2 = Zr2, zv2 = A, qv2 = Qt2, Xv2 = co2, Jv2 = P, Zv2 = Ca2, Qv2 = Cc2, $v2 = ze2, eC2 = jr2, tC2 = rt2, iC2 = pt2, nC2 = cv2, rC2 = _v, oC2 = gv2, sC2 = Ga2, aC2 = Ea2, cC2 = Av2.forEach, dC2 = gr2("hidden"), lC2 = "Symbol", uC2 = "prototype", hC2 = aC2.set, pC2 = aC2.getterFor(lC2), _C = Object[uC2], EC2 = Ov2.Symbol, mC2 = EC2 && EC2[uC2], fC2 = Ov2.RangeError, SC2 = Ov2.TypeError, gC2 = Ov2.QObject, TC2 = zv2.f, RC2 = qv2.f, vC2 = Kv2.f, CC2 = Jv2.f, yC2 = Dv2([].push), IC2 = $v2("symbols"), bC2 = $v2("op-symbols"), AC2 = $v2("wks"), wC2 = !gC2 || !gC2[uC2] || !gC2[uC2].findChild, OC2 = function(e2, t3, i2) {
        var n3 = TC2(_C, t3);
        n3 && delete _C[t3], RC2(e2, t3, i2), n3 && e2 !== _C && RC2(_C, t3, n3);
      }, NC2 = Pv2 && kv2(function() {
        return 7 !== Gv2(RC2({}, "a", { get: function() {
          return RC2(this, "a", { value: 7 }).a;
        } })).a;
      }) ? OC2 : RC2, DC2 = function(e2, t3) {
        var i2 = IC2[e2] = Gv2(mC2);
        return hC2(i2, { type: lC2, tag: e2, description: t3 }), Pv2 || (i2.description = t3), i2;
      }, PC2 = function(e2, t3, i2) {
        e2 === _C && PC2(bC2, t3, i2), Vv2(e2);
        var n3 = Fv2(t3);
        return Vv2(i2), Mv2(IC2, n3) ? (i2.enumerable ? (Mv2(e2, dC2) && e2[dC2][n3] && (e2[dC2][n3] = false), i2 = Gv2(i2, { enumerable: jv2(0, false) })) : (Mv2(e2, dC2) || RC2(e2, dC2, jv2(1, Gv2(null))), e2[dC2][n3] = true), NC2(e2, n3, i2)) : RC2(e2, n3, i2);
      }, LC2 = function(e2, t3) {
        Vv2(e2);
        var i2 = xv2(t3), n3 = Wv2(i2).concat(VC2(i2));
        return cC2(n3, function(t4) {
          Pv2 && !Nv2(kC2, i2, t4) || PC2(e2, t4, i2[t4]);
        }), e2;
      }, kC2 = function(e2) {
        var t3 = Fv2(e2), i2 = Nv2(CC2, this, t3);
        return !(this === _C && Mv2(IC2, t3) && !Mv2(bC2, t3)) && (!(i2 || !Mv2(this, t3) || !Mv2(IC2, t3) || Mv2(this, dC2) && this[dC2][t3]) || i2);
      }, MC2 = function(e2, t3) {
        var i2 = xv2(e2), n3 = Fv2(t3);
        if (i2 !== _C || !Mv2(IC2, n3) || Mv2(bC2, n3)) {
          var r2 = TC2(i2, n3);
          return !r2 || !Mv2(IC2, n3) || Mv2(i2, dC2) && i2[dC2][n3] || (r2.enumerable = true), r2;
        }
      }, UC2 = function(e2) {
        var t3 = vC2(xv2(e2)), i2 = [];
        return cC2(t3, function(e3) {
          Mv2(IC2, e3) || Mv2(eC2, e3) || yC2(i2, e3);
        }), i2;
      }, VC2 = function(e2) {
        var t3 = e2 === _C, i2 = vC2(t3 ? bC2 : xv2(e2)), n3 = [];
        return cC2(i2, function(e3) {
          !Mv2(IC2, e3) || t3 && !Mv2(_C, e3) || yC2(n3, IC2[e3]);
        }), n3;
      };
      Lv2 || (EC2 = function() {
        if (Uv2(mC2, this)) throw new SC2("Symbol is not a constructor");
        var e2 = arguments.length && void 0 !== arguments[0] ? Bv2(arguments[0]) : void 0, t3 = tC2(e2), i2 = function(e3) {
          var n3 = void 0 === this ? Ov2 : this;
          n3 === _C && Nv2(i2, bC2, e3), Mv2(n3, dC2) && Mv2(n3[dC2], t3) && (n3[dC2][t3] = false);
          var r2 = jv2(1, e3);
          try {
            NC2(n3, t3, r2);
          } catch (e4) {
            if (!(e4 instanceof fC2)) throw e4;
            OC2(n3, t3, r2);
          }
        };
        return Pv2 && wC2 && NC2(_C, t3, { configurable: true, set: i2 }), DC2(t3, e2);
      }, Zv2(mC2 = EC2[uC2], "toString", function() {
        return pC2(this).tag;
      }), Zv2(EC2, "withoutSetter", function(e2) {
        return DC2(tC2(e2), e2);
      }), Jv2.f = kC2, qv2.f = PC2, Xv2.f = LC2, zv2.f = MC2, Hv2.f = Kv2.f = UC2, Yv2.f = VC2, nC2.f = function(e2) {
        return DC2(iC2(e2), e2);
      }, Pv2 && Qv2(mC2, "description", { configurable: true, get: function() {
        return pC2(this).description;
      } })), wv2({ global: true, constructor: true, wrap: true, forced: !Lv2, sham: !Lv2 }, { Symbol: EC2 }), cC2(Wv2(AC2), function(e2) {
        rC2(e2);
      }), wv2({ target: lC2, stat: true, forced: !Lv2 }, { useSetter: function() {
        wC2 = true;
      }, useSimple: function() {
        wC2 = false;
      } }), wv2({ target: "Object", stat: true, forced: !Lv2, sham: !Pv2 }, { create: function(e2, t3) {
        return void 0 === t3 ? Gv2(e2) : LC2(Gv2(e2), t3);
      }, defineProperty: PC2, defineProperties: LC2, getOwnPropertyDescriptor: MC2 }), wv2({ target: "Object", stat: true, forced: !Lv2 }, { getOwnPropertyNames: UC2 }), oC2(), sC2(EC2, lC2), eC2[dC2] = true;
      var xC2 = Se2 && !!Symbol.for && !!Symbol.keyFor, FC2 = Oi2, BC2 = re2, jC2 = $e2, GC2 = Sn2, WC2 = ze2, HC2 = xC2, KC2 = WC2("string-to-symbol-registry"), YC2 = WC2("symbol-to-string-registry");
      FC2({ target: "Symbol", stat: true, forced: !HC2 }, { for: function(e2) {
        var t3 = GC2(e2);
        if (jC2(KC2, t3)) return KC2[t3];
        var i2 = BC2("Symbol")(t3);
        return KC2[t3] = i2, YC2[i2] = t3, i2;
      } });
      var zC2 = Oi2, qC2 = $e2, XC2 = ye2, JC2 = be2, ZC2 = xC2, QC2 = ze2("symbol-to-string-registry");
      zC2({ target: "Symbol", stat: true, forced: !ZC2 }, { keyFor: function(e2) {
        if (!XC2(e2)) throw new TypeError(JC2(e2) + " is not a symbol");
        if (qC2(QC2, e2)) return QC2[e2];
      } });
      var $C2 = or2, ey2 = b, ty2 = R2, iy2 = Sn2, ny2 = d([].push), ry2 = Oi2, oy2 = re2, sy2 = f, ay2 = D2, cy2 = d, dy2 = n2, ly2 = b, uy2 = ye2, hy2 = sd2, py2 = function(e2) {
        if (ey2(e2)) return e2;
        if ($C2(e2)) {
          for (var t3 = e2.length, i2 = [], n3 = 0; n3 < t3; n3++) {
            var r2 = e2[n3];
            "string" == typeof r2 ? ny2(i2, r2) : "number" != typeof r2 && "Number" !== ty2(r2) && "String" !== ty2(r2) || ny2(i2, iy2(r2));
          }
          var o2 = i2.length, s2 = true;
          return function(e3, t4) {
            if (s2) return s2 = false, t4;
            if ($C2(this)) return t4;
            for (var n4 = 0; n4 < o2; n4++) if (i2[n4] === e3) return t4;
          };
        }
      }, _y = Se2, Ey2 = String, my2 = oy2("JSON", "stringify"), fy2 = cy2(/./.exec), Sy2 = cy2("".charAt), gy2 = cy2("".charCodeAt), Ty2 = cy2("".replace), Ry2 = cy2(1 .toString), vy2 = /[\uD800-\uDFFF]/g, Cy2 = /^[\uD800-\uDBFF]$/, yy2 = /^[\uDC00-\uDFFF]$/, Iy2 = !_y || dy2(function() {
        var e2 = oy2("Symbol")("stringify detection");
        return "[null]" !== my2([e2]) || "{}" !== my2({ a: e2 }) || "{}" !== my2(Object(e2));
      }), by2 = dy2(function() {
        return '"\\udf06\\ud834"' !== my2("\uDF06\uD834") || '"\\udead"' !== my2("\uDEAD");
      }), Ay2 = function(e2, t3) {
        var i2 = hy2(arguments), n3 = py2(t3);
        if (ly2(n3) || void 0 !== e2 && !uy2(e2)) return i2[1] = function(e3, t4) {
          if (ly2(n3) && (t4 = ay2(n3, this, Ey2(e3), t4)), !uy2(t4)) return t4;
        }, sy2(my2, null, i2);
      }, wy2 = function(e2, t3, i2) {
        var n3 = Sy2(i2, t3 - 1), r2 = Sy2(i2, t3 + 1);
        return fy2(Cy2, e2) && !fy2(yy2, r2) || fy2(yy2, e2) && !fy2(Cy2, n3) ? "\\u" + Ry2(gy2(e2, 0), 16) : e2;
      };
      my2 && ry2({ target: "JSON", stat: true, arity: 3, forced: Iy2 || by2 }, { stringify: function(e2, t3, i2) {
        var n3 = hy2(arguments), r2 = sy2(Iy2 ? Ay2 : my2, null, n3);
        return by2 && "string" == typeof r2 ? Ty2(r2, vy2, wy2) : r2;
      } });
      var Oy2 = Zr2, Ny2 = Je2;
      Oi2({ target: "Object", stat: true, forced: !Se2 || n2(function() {
        Oy2.f(1);
      }) }, { getOwnPropertySymbols: function(e2) {
        var t3 = Oy2.f;
        return t3 ? t3(Ny2(e2)) : [];
      } }), _v("asyncIterator"), _v("hasInstance"), _v("isConcatSpreadable"), _v("iterator"), _v("match"), _v("matchAll"), _v("replace"), _v("search"), _v("species"), _v("split");
      var Dy2 = gv2;
      _v("toPrimitive"), Dy2();
      var Py2 = re2, Ly2 = Ga2;
      _v("toStringTag"), Ly2(Py2("Symbol"), "Symbol"), _v("unscopables"), Ga2(h.JSON, "JSON", true);
      var ky2 = $.Symbol, My2 = pt2, Uy2 = Qt2.f, Vy2 = My2("metadata"), xy2 = Function.prototype;
      void 0 === xy2[Vy2] && Uy2(xy2, Vy2, { value: null }), _v("asyncDispose"), _v("dispose"), _v("metadata");
      var Fy2 = ky2, By2 = d, jy2 = re2("Symbol"), Gy2 = jy2.keyFor, Wy2 = By2(jy2.prototype.valueOf), Hy2 = jy2.isRegisteredSymbol || function(e2) {
        try {
          return void 0 !== Gy2(Wy2(e2));
        } catch (e3) {
          return false;
        }
      };
      Oi2({ target: "Symbol", stat: true }, { isRegisteredSymbol: Hy2 });
      for (var Ky2 = ze2, Yy2 = re2, zy2 = d, qy2 = ye2, Xy2 = pt2, Jy2 = Yy2("Symbol"), Zy2 = Jy2.isWellKnownSymbol, Qy2 = Yy2("Object", "getOwnPropertyNames"), $y2 = zy2(Jy2.prototype.valueOf), eI = Ky2("wks"), tI = 0, iI = Qy2(Jy2), nI = iI.length; tI < nI; tI++) try {
        var rI = iI[tI];
        qy2(Jy2[rI]) && Xy2(rI);
      } catch (e2) {
      }
      var oI = function(e2) {
        if (Zy2 && Zy2(e2)) return true;
        try {
          for (var t3 = $y2(e2), i2 = 0, n3 = Qy2(eI), r2 = n3.length; i2 < r2; i2++) if (eI[n3[i2]] == t3) return true;
        } catch (e3) {
        }
        return false;
      };
      Oi2({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: oI }), _v("customMatcher"), _v("observable"), Oi2({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: Hy2 }), Oi2({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: oI }), _v("matcher"), _v("metadataKey"), _v("patternMatch"), _v("replaceAll");
      var sI = i(Fy2), aI = i(cv2.f("iterator"));
      function cI(e2) {
        return cI = "function" == typeof sI && "symbol" == typeof aI ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof sI && e3.constructor === sI && e3 !== sI.prototype ? "symbol" : typeof e3;
        }, cI(e2);
      }
      var dI = i(cv2.f("toPrimitive"));
      function lI(e2) {
        var t3 = function(e3, t4) {
          if ("object" != cI(e3) || !e3) return e3;
          var i2 = e3[dI];
          if (void 0 !== i2) {
            var n3 = i2.call(e3, t4 || "default");
            if ("object" != cI(n3)) return n3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t4 ? String : Number)(e3);
        }(e2, "string");
        return "symbol" == cI(t3) ? t3 : t3 + "";
      }
      function uI(e2, t3, i2) {
        return (t3 = lI(t3)) in e2 ? OR(e2, t3, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t3] = i2, e2;
      }
      var hI = i(AE), pI = { isBrowser: true, classes: { URLSearchParams: void 0 !== hI ? hI : fR, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
      const _I = "undefined" != typeof window && "undefined" != typeof document, EI = "object" == typeof navigator && navigator || void 0, mI = _I && (!EI || ["ReactNative", "NativeScript", "NS"].indexOf(EI.product) < 0), fI = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, SI = _I && window.location.href || "http://localhost";
      function gI(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function TI(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? gI(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : gI(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      var RI = TI(TI({}, Object.freeze({ __proto__: null, hasBrowserEnv: _I, hasStandardBrowserEnv: mI, hasStandardBrowserWebWorkerEnv: fI, navigator: EI, origin: SI })), pI);
      var vI = ni2, CI = D2, yI = $e2, II = l, bI = function() {
        var e2 = vI(this), t3 = "";
        return e2.hasIndices && (t3 += "d"), e2.global && (t3 += "g"), e2.ignoreCase && (t3 += "i"), e2.multiline && (t3 += "m"), e2.dotAll && (t3 += "s"), e2.unicode && (t3 += "u"), e2.unicodeSets && (t3 += "v"), e2.sticky && (t3 += "y"), t3;
      }, AI = RegExp.prototype, wI = function(e2) {
        var t3 = e2.flags;
        return void 0 !== t3 || "flags" in AI || yI(e2, "flags") || !II(AI, e2) ? t3 : CI(bI, e2);
      }, OI = Bh2.charAt, NI = D2, DI = ni2, PI = b, LI = R2, kI = /./.exec, MI = TypeError, UI = Oi2, VI = D2, xI = y2, FI = Xa2, BI = pc2, jI = z, GI = ji2, WI = Sn2, HI = ni2, KI = Q2, YI = R2, zI = rn2, qI = wI, XI = Le2, JI = n2, ZI = od2, QI = function(e2, t3, i2) {
        return t3 + (i2 ? OI(e2, t3).length : 1);
      }, $I = function(e2, t3) {
        var i2 = e2.exec;
        if (PI(i2)) {
          var n3 = NI(i2, e2, t3);
          return null !== n3 && DI(n3), n3;
        }
        if ("RegExp" === LI(e2)) return NI(kI, e2, t3);
        throw new MI("RegExp#exec called on incompatible receiver");
      }, eb2 = Ea2, tb2 = pt2("matchAll"), ib2 = "RegExp String", nb2 = ib2 + " Iterator", rb2 = eb2.set, ob2 = eb2.getterFor(nb2), sb2 = TypeError, ab2 = xI("".indexOf), cb2 = xI("".matchAll), db2 = !!cb2 && !JI(function() {
        cb2("a", /./);
      }), lb2 = FI(function(e2, t3, i2, n3) {
        rb2(this, { type: nb2, regexp: e2, string: t3, global: i2, unicode: n3, done: false });
      }, ib2, function() {
        var e2 = ob2(this);
        if (e2.done) return BI(void 0, true);
        var t3 = e2.regexp, i2 = e2.string, n3 = $I(t3, i2);
        return null === n3 ? (e2.done = true, BI(void 0, true)) : e2.global ? ("" === WI(n3[0]) && (t3.lastIndex = QI(i2, GI(t3.lastIndex), e2.unicode)), BI(n3, false)) : (e2.done = true, BI(n3, false));
      }), ub2 = function(e2) {
        var t3, i2, n3, r2 = HI(this), o2 = WI(e2), s2 = ZI(r2, RegExp), a3 = WI(qI(r2));
        return t3 = new s2(s2 === RegExp ? r2.source : r2, a3), i2 = !!~ab2(a3, "g"), n3 = !!~ab2(a3, "u"), t3.lastIndex = GI(r2.lastIndex), new lb2(t3, o2, i2, n3);
      };
      UI({ target: "String", proto: true, forced: db2 }, { matchAll: function(e2) {
        var t3, i2, n3, r2, o2 = jI(this);
        if (KI(e2)) {
          if (zI(e2) && (t3 = WI(jI(qI(e2))), !~ab2(t3, "g"))) throw new sb2("`.matchAll` does not allow non-global regexes");
          if (db2) return cb2(o2, e2);
          if (void 0 === (n3 = XI(e2, tb2)) && "RegExp" === YI(e2) && (n3 = ub2), n3) return VI(n3, e2, o2);
        } else if (db2) return cb2(o2, e2);
        return i2 = WI(o2), r2 = new RegExp(e2, "g"), VI(ub2, r2, i2);
      } });
      var hb2 = Qi2("String", "matchAll"), pb2 = l, _b = hb2, Eb2 = String.prototype, mb2 = function(e2) {
        var t3 = e2.matchAll;
        return "string" == typeof e2 || e2 === Eb2 || pb2(Eb2, e2) && t3 === Eb2.matchAll ? _b : t3;
      }, fb2 = i(mb2);
      function Sb2(e2) {
        function t3(e3, i2, n3, r2) {
          let o2 = e3[r2++];
          if ("__proto__" === o2) return true;
          const s2 = Number.isFinite(+o2), a3 = r2 >= e3.length;
          if (o2 = !o2 && aR.isArray(n3) ? n3.length : o2, a3) return aR.hasOwnProp(n3, o2) ? n3[o2] = [n3[o2], i2] : n3[o2] = i2, !s2;
          n3[o2] && aR.isObject(n3[o2]) || (n3[o2] = []);
          return t3(e3, i2, n3[o2], r2) && aR.isArray(n3[o2]) && (n3[o2] = function(e4) {
            const t4 = {}, i3 = Object.keys(e4);
            let n4;
            const r3 = i3.length;
            let o3;
            for (n4 = 0; n4 < r3; n4++) o3 = i3[n4], t4[o3] = e4[o3];
            return t4;
          }(n3[o2])), !s2;
        }
        if (aR.isFormData(e2) && aR.isFunction(e2.entries)) {
          const i2 = {};
          return aR.forEachEntry(e2, (e3, n3) => {
            t3(function(e4) {
              return fb2(aR).call(aR, /\w+|\[(\w*)]/g, e4).map((e5) => "[]" === e5[0] ? "" : e5[1] || e5[0]);
            }(e3), n3, i2, 0);
          }), i2;
        }
        return null;
      }
      const gb2 = { transitional: vR, adapter: ["xhr", "http", "fetch"], transformRequest: [function(e2, t3) {
        const i2 = t3.getContentType() || "", n3 = i2.indexOf("application/json") > -1, r2 = aR.isObject(e2);
        r2 && aR.isHTMLForm(e2) && (e2 = new FormData(e2));
        if (aR.isFormData(e2)) return n3 ? JSON.stringify(Sb2(e2)) : e2;
        if (aR.isArrayBuffer(e2) || aR.isBuffer(e2) || aR.isStream(e2) || aR.isFile(e2) || aR.isBlob(e2) || aR.isReadableStream(e2)) return e2;
        if (aR.isArrayBufferView(e2)) return e2.buffer;
        if (aR.isURLSearchParams(e2)) return t3.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e2.toString();
        let o2;
        if (r2) {
          if (i2.indexOf("application/x-www-form-urlencoded") > -1) return function(e3, t4) {
            return ER(e3, new RI.classes.URLSearchParams(), Object.assign({ visitor: function(e4, t5, i3, n4) {
              return RI.isNode && aR.isBuffer(e4) ? (this.append(t5, e4.toString("base64")), false) : n4.defaultVisitor.apply(this, arguments);
            } }, t4));
          }(e2, this.formSerializer).toString();
          if ((o2 = aR.isFileList(e2)) || i2.indexOf("multipart/form-data") > -1) {
            const t4 = this.env && this.env.FormData;
            return ER(o2 ? { "files[]": e2 } : e2, t4 && new t4(), this.formSerializer);
          }
        }
        return r2 || n3 ? (t3.setContentType("application/json", false), function(e3, t4, i3) {
          if (aR.isString(e3)) try {
            return (t4 || JSON.parse)(e3), Pg2(aR).call(aR, e3);
          } catch (e4) {
            if ("SyntaxError" !== e4.name) throw e4;
          }
          return (i3 || JSON.stringify)(e3);
        }(e2)) : e2;
      }], transformResponse: [function(e2) {
        const t3 = this.transitional || gb2.transitional, i2 = t3 && t3.forcedJSONParsing, n3 = "json" === this.responseType;
        if (aR.isResponse(e2) || aR.isReadableStream(e2)) return e2;
        if (e2 && aR.isString(e2) && (i2 && !this.responseType || n3)) {
          const i3 = !(t3 && t3.silentJSONParsing) && n3;
          try {
            return JSON.parse(e2);
          } catch (e3) {
            if (i3) {
              if ("SyntaxError" === e3.name) throw cR.from(e3, cR.ERR_BAD_RESPONSE, this, null, this.response);
              throw e3;
            }
          }
        }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: RI.classes.FormData, Blob: RI.classes.Blob }, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
      aR.forEach(["delete", "get", "head", "post", "put", "patch"], (e2) => {
        gb2.headers[e2] = {};
      });
      var Tb2 = gb2;
      const Rb2 = aR.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
      const vb2 = Symbol("internals");
      function Cb2(e2) {
        var t3;
        return e2 && Pg2(t3 = String(e2)).call(t3).toLowerCase();
      }
      function yb2(e2) {
        return false === e2 || null == e2 ? e2 : aR.isArray(e2) ? e2.map(yb2) : String(e2);
      }
      function Ib2(e2, t3, i2, n3, r2) {
        return aR.isFunction(n3) ? n3.call(this, t3, i2) : (r2 && (t3 = i2), aR.isString(t3) ? aR.isString(n3) ? -1 !== t3.indexOf(n3) : aR.isRegExp(n3) ? n3.test(t3) : void 0 : void 0);
      }
      class bb2 {
        constructor(e2) {
          e2 && this.set(e2);
        }
        set(e2, t3, i2) {
          const n3 = this;
          function r2(e3, t4, i3) {
            const r3 = Cb2(t4);
            if (!r3) throw new Error("header name must be a non-empty string");
            const o3 = aR.findKey(n3, r3);
            (!o3 || void 0 === n3[o3] || true === i3 || void 0 === i3 && false !== n3[o3]) && (n3[o3 || t4] = yb2(e3));
          }
          const o2 = (e3, t4) => aR.forEach(e3, (e4, i3) => r2(e4, i3, t4));
          if (aR.isPlainObject(e2) || e2 instanceof this.constructor) o2(e2, t3);
          else if (aR.isString(e2) && (e2 = Pg2(e2).call(e2)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(Pg2(s2 = e2).call(s2))) o2(((e3) => {
            const t4 = {};
            let i3, n4, r3;
            return e3 && e3.split("\n").forEach(function(e4) {
              var o3, s3;
              r3 = e4.indexOf(":"), i3 = Pg2(o3 = e4.substring(0, r3)).call(o3).toLowerCase(), n4 = Pg2(s3 = e4.substring(r3 + 1)).call(s3), !i3 || t4[i3] && Rb2[i3] || ("set-cookie" === i3 ? t4[i3] ? t4[i3].push(n4) : t4[i3] = [n4] : t4[i3] = t4[i3] ? t4[i3] + ", " + n4 : n4);
            }), t4;
          })(e2), t3);
          else if (aR.isObject(e2) && aR.isIterable(e2)) {
            let i3, n4, r3 = {};
            for (const t4 of e2) {
              if (!aR.isArray(t4)) throw TypeError("Object iterator must return a key-value pair");
              r3[n4 = t4[0]] = (i3 = r3[n4]) ? aR.isArray(i3) ? [...i3, t4[1]] : [i3, t4[1]] : t4[1];
            }
            o2(r3, t3);
          } else null != e2 && r2(t3, e2, i2);
          var s2;
          return this;
        }
        get(e2, t3) {
          if (e2 = Cb2(e2)) {
            const i2 = aR.findKey(this, e2);
            if (i2) {
              const e3 = this[i2];
              if (!t3) return e3;
              if (true === t3) return function(e4) {
                const t4 = /* @__PURE__ */ Object.create(null), i3 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                let n3;
                for (; n3 = i3.exec(e4); ) t4[n3[1]] = n3[2];
                return t4;
              }(e3);
              if (aR.isFunction(t3)) return t3.call(this, e3, i2);
              if (aR.isRegExp(t3)) return t3.exec(e3);
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(e2, t3) {
          if (e2 = Cb2(e2)) {
            const i2 = aR.findKey(this, e2);
            return !(!i2 || void 0 === this[i2] || t3 && !Ib2(0, this[i2], i2, t3));
          }
          return false;
        }
        delete(e2, t3) {
          const i2 = this;
          let n3 = false;
          function r2(e3) {
            if (e3 = Cb2(e3)) {
              const r3 = aR.findKey(i2, e3);
              !r3 || t3 && !Ib2(0, i2[r3], r3, t3) || (delete i2[r3], n3 = true);
            }
          }
          return aR.isArray(e2) ? e2.forEach(r2) : r2(e2), n3;
        }
        clear(e2) {
          const t3 = Object.keys(this);
          let i2 = t3.length, n3 = false;
          for (; i2--; ) {
            const r2 = t3[i2];
            e2 && !Ib2(0, this[r2], r2, e2, true) || (delete this[r2], n3 = true);
          }
          return n3;
        }
        normalize(e2) {
          const t3 = this, i2 = {};
          return aR.forEach(this, (n3, r2) => {
            var o2;
            const s2 = aR.findKey(i2, r2);
            if (s2) return t3[s2] = yb2(n3), void delete t3[r2];
            const a3 = e2 ? function(e3) {
              return Pg2(e3).call(e3).toLowerCase().replace(/([a-z\d])(\w*)/g, (e4, t4, i3) => t4.toUpperCase() + i3);
            }(r2) : Pg2(o2 = String(r2)).call(o2);
            a3 !== r2 && delete t3[r2], t3[a3] = yb2(n3), i2[a3] = true;
          }), this;
        }
        concat() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          return this.constructor.concat(this, ...t3);
        }
        toJSON(e2) {
          const t3 = /* @__PURE__ */ Object.create(null);
          return aR.forEach(this, (i2, n3) => {
            null != i2 && false !== i2 && (t3[n3] = e2 && aR.isArray(i2) ? i2.join(", ") : i2);
          }), t3;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map((e2) => {
            let [t3, i2] = e2;
            return t3 + ": " + i2;
          }).join("\n");
        }
        getSetCookie() {
          return this.get("set-cookie") || [];
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(e2) {
          return e2 instanceof this ? e2 : new this(e2);
        }
        static concat(e2) {
          const t3 = new this(e2);
          for (var i2 = arguments.length, n3 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n3[r2 - 1] = arguments[r2];
          return n3.forEach((e3) => t3.set(e3)), t3;
        }
        static accessor(e2) {
          const t3 = (this[vb2] = this[vb2] = { accessors: {} }).accessors, i2 = this.prototype;
          function n3(e3) {
            const n4 = Cb2(e3);
            t3[n4] || (!function(e4, t4) {
              const i3 = aR.toCamelCase(" " + t4);
              ["get", "set", "has"].forEach((n5) => {
                Object.defineProperty(e4, n5 + i3, { value: function(e5, i4, r2) {
                  return this[n5].call(this, t4, e5, i4, r2);
                }, configurable: true });
              });
            }(i2, e3), t3[n4] = true);
          }
          return aR.isArray(e2) ? e2.forEach(n3) : n3(e2), this;
        }
      }
      bb2.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), aR.reduceDescriptors(bb2.prototype, (e2, t3) => {
        let { value: i2 } = e2, n3 = t3[0].toUpperCase() + t3.slice(1);
        return { get: () => i2, set(e3) {
          this[n3] = e3;
        } };
      }), aR.freezeMethods(bb2);
      var Ab2 = bb2;
      function wb2(e2, t3) {
        const i2 = this || Tb2, n3 = t3 || i2, r2 = Ab2.from(n3.headers);
        let o2 = n3.data;
        return aR.forEach(e2, function(e3) {
          o2 = e3.call(i2, o2, r2.normalize(), t3 ? t3.status : void 0);
        }), r2.normalize(), o2;
      }
      function Ob2(e2) {
        return !(!e2 || !e2.__CANCEL__);
      }
      function Nb2(e2, t3, i2) {
        cR.call(this, null == e2 ? "canceled" : e2, cR.ERR_CANCELED, t3, i2), this.name = "CanceledError";
      }
      function Db2(e2, t3, i2) {
        const n3 = i2.config.validateStatus;
        i2.status && n3 && !n3(i2.status) ? t3(new cR("Request failed with status code " + i2.status, [cR.ERR_BAD_REQUEST, cR.ERR_BAD_RESPONSE][Math.floor(i2.status / 100) - 4], i2.config, i2.request, i2)) : e2(i2);
      }
      aR.inherits(Nb2, cR, { __CANCEL__: true });
      const Pb2 = function(e2, t3) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, n3 = 0;
        const r2 = function(e3, t4) {
          e3 = e3 || 10;
          const i3 = new Array(e3), n4 = new Array(e3);
          let r3, o2 = 0, s2 = 0;
          return t4 = void 0 !== t4 ? t4 : 1e3, function(a3) {
            const c3 = Date.now(), d2 = n4[s2];
            r3 || (r3 = c3), i3[o2] = a3, n4[o2] = c3;
            let l2 = s2, u3 = 0;
            for (; l2 !== o2; ) u3 += i3[l2++], l2 %= e3;
            if (o2 = (o2 + 1) % e3, o2 === s2 && (s2 = (s2 + 1) % e3), c3 - r3 < t4) return;
            const h2 = d2 && c3 - d2;
            return h2 ? Math.round(1e3 * u3 / h2) : void 0;
          };
        }(50, 250);
        return function(e3, t4) {
          let i3, n4, r3 = 0, o2 = 1e3 / t4;
          const s2 = function(t5) {
            let o3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Date.now();
            r3 = o3, i3 = null, n4 && (clearTimeout(n4), n4 = null), e3.apply(null, t5);
          };
          return [function() {
            const e4 = Date.now(), t5 = e4 - r3;
            for (var a3 = arguments.length, c3 = new Array(a3), d2 = 0; d2 < a3; d2++) c3[d2] = arguments[d2];
            t5 >= o2 ? s2(c3, e4) : (i3 = c3, n4 || (n4 = setTimeout(() => {
              n4 = null, s2(i3);
            }, o2 - t5)));
          }, () => i3 && s2(i3)];
        }((i3) => {
          const o2 = i3.loaded, s2 = i3.lengthComputable ? i3.total : void 0, a3 = o2 - n3, c3 = r2(a3);
          n3 = o2;
          e2({ loaded: o2, total: s2, progress: s2 ? o2 / s2 : void 0, bytes: a3, rate: c3 || void 0, estimated: c3 && s2 && o2 <= s2 ? (s2 - o2) / c3 : void 0, event: i3, lengthComputable: null != s2, [t3 ? "download" : "upload"]: true });
        }, i2);
      }, Lb = (e2, t3) => {
        const i2 = null != e2;
        return [(n3) => t3[0]({ lengthComputable: i2, total: e2, loaded: n3 }), t3[1]];
      }, kb2 = (e2) => function() {
        for (var t3 = arguments.length, i2 = new Array(t3), n3 = 0; n3 < t3; n3++) i2[n3] = arguments[n3];
        return aR.asap(() => e2(...i2));
      };
      var Mb = RI.hasStandardBrowserEnv ? /* @__PURE__ */ ((e2, t3) => (i2) => (i2 = new RS(i2, RI.origin), e2.protocol === i2.protocol && e2.host === i2.host && (t3 || e2.port === i2.port)))(new RS(RI.origin), RI.navigator && /(msie|trident)/i.test(RI.navigator.userAgent)) : () => true, Ub2 = RI.hasStandardBrowserEnv ? { write(e2, t3, i2, n3, r2, o2) {
        const s2 = [e2 + "=" + encodeURIComponent(t3)];
        aR.isNumber(i2) && s2.push("expires=" + new Date(i2).toGMTString()), aR.isString(n3) && s2.push("path=" + n3), aR.isString(r2) && s2.push("domain=" + r2), true === o2 && s2.push("secure"), document.cookie = s2.join("; ");
      }, read(e2) {
        const t3 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
        return t3 ? decodeURIComponent(t3[3]) : null;
      }, remove(e2) {
        this.write(e2, "", Date.now() - 864e5);
      } } : { write() {
      }, read: () => null, remove() {
      } };
      function Vb2(e2, t3, i2) {
        let n3 = !function(e3) {
          return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e3);
        }(t3);
        return e2 && (n3 || 0 == i2) ? function(e3, t4) {
          return t4 ? e3.replace(/\/?\/$/, "") + "/" + t4.replace(/^\/+/, "") : e3;
        }(e2, t3) : t3;
      }
      function xb2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      const Fb2 = (e2) => e2 instanceof Ab2 ? function(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? xb2(Object(i2), true).forEach(function(t4) {
            uI(e3, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : xb2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e3;
      }({}, e2) : e2;
      function Bb2(e2, t3) {
        t3 = t3 || {};
        const i2 = {};
        function n3(e3, t4, i3, n4) {
          return aR.isPlainObject(e3) && aR.isPlainObject(t4) ? aR.merge.call({ caseless: n4 }, e3, t4) : aR.isPlainObject(t4) ? aR.merge({}, t4) : aR.isArray(t4) ? t4.slice() : t4;
        }
        function r2(e3, t4, i3, r3) {
          return aR.isUndefined(t4) ? aR.isUndefined(e3) ? void 0 : n3(void 0, e3, 0, r3) : n3(e3, t4, 0, r3);
        }
        function o2(e3, t4) {
          if (!aR.isUndefined(t4)) return n3(void 0, t4);
        }
        function s2(e3, t4) {
          return aR.isUndefined(t4) ? aR.isUndefined(e3) ? void 0 : n3(void 0, e3) : n3(void 0, t4);
        }
        function a3(i3, r3, o3) {
          return o3 in t3 ? n3(i3, r3) : o3 in e2 ? n3(void 0, i3) : void 0;
        }
        const c3 = { url: o2, method: o2, data: o2, baseURL: s2, transformRequest: s2, transformResponse: s2, paramsSerializer: s2, timeout: s2, timeoutMessage: s2, withCredentials: s2, withXSRFToken: s2, adapter: s2, responseType: s2, xsrfCookieName: s2, xsrfHeaderName: s2, onUploadProgress: s2, onDownloadProgress: s2, decompress: s2, maxContentLength: s2, maxBodyLength: s2, beforeRedirect: s2, transport: s2, httpAgent: s2, httpsAgent: s2, cancelToken: s2, socketPath: s2, responseEncoding: s2, validateStatus: a3, headers: (e3, t4, i3) => r2(Fb2(e3), Fb2(t4), 0, true) };
        return aR.forEach(Object.keys(Object.assign({}, e2, t3)), function(n4) {
          const o3 = c3[n4] || r2, s3 = o3(e2[n4], t3[n4], n4);
          aR.isUndefined(s3) && o3 !== a3 || (i2[n4] = s3);
        }), i2;
      }
      var jb2 = (e2) => {
        const t3 = Bb2({}, e2);
        let i2, { data: n3, withXSRFToken: r2, xsrfHeaderName: o2, xsrfCookieName: s2, headers: a3, auth: c3 } = t3;
        if (t3.headers = a3 = Ab2.from(a3), t3.url = TR(Vb2(t3.baseURL, t3.url, t3.allowAbsoluteUrls), e2.params, e2.paramsSerializer), c3 && a3.set("Authorization", "Basic " + btoa((c3.username || "") + ":" + (c3.password ? unescape(encodeURIComponent(c3.password)) : ""))), aR.isFormData(n3)) {
          if (RI.hasStandardBrowserEnv || RI.hasStandardBrowserWebWorkerEnv) a3.setContentType(void 0);
          else if (false !== (i2 = a3.getContentType())) {
            const [e3, ...t4] = i2 ? i2.split(";").map((e4) => Pg2(e4).call(e4)).filter(Boolean) : [];
            a3.setContentType([e3 || "multipart/form-data", ...t4].join("; "));
          }
        }
        if (RI.hasStandardBrowserEnv && (r2 && aR.isFunction(r2) && (r2 = r2(t3)), r2 || false !== r2 && Mb(t3.url))) {
          const e3 = o2 && s2 && Ub2.read(s2);
          e3 && a3.set(o2, e3);
        }
        return t3;
      };
      var Gb2 = "undefined" != typeof XMLHttpRequest && function(e2) {
        return new ip2(function(t3, i2) {
          const n3 = jb2(e2);
          let r2 = n3.data;
          const o2 = Ab2.from(n3.headers).normalize();
          let s2, a3, c3, d2, l2, { responseType: u3, onUploadProgress: h2, onDownloadProgress: p2 } = n3;
          function _2() {
            d2 && d2(), l2 && l2(), n3.cancelToken && n3.cancelToken.unsubscribe(s2), n3.signal && n3.signal.removeEventListener("abort", s2);
          }
          let E3 = new XMLHttpRequest();
          function m3() {
            if (!E3) return;
            const n4 = Ab2.from("getAllResponseHeaders" in E3 && E3.getAllResponseHeaders());
            Db2(function(e3) {
              t3(e3), _2();
            }, function(e3) {
              i2(e3), _2();
            }, { data: u3 && "text" !== u3 && "json" !== u3 ? E3.response : E3.responseText, status: E3.status, statusText: E3.statusText, headers: n4, config: e2, request: E3 }), E3 = null;
          }
          E3.open(n3.method.toUpperCase(), n3.url, true), E3.timeout = n3.timeout, "onloadend" in E3 ? E3.onloadend = m3 : E3.onreadystatechange = function() {
            E3 && 4 === E3.readyState && (0 !== E3.status || E3.responseURL && 0 === E3.responseURL.indexOf("file:")) && setTimeout(m3);
          }, E3.onabort = function() {
            E3 && (i2(new cR("Request aborted", cR.ECONNABORTED, e2, E3)), E3 = null);
          }, E3.onerror = function() {
            i2(new cR("Network Error", cR.ERR_NETWORK, e2, E3)), E3 = null;
          }, E3.ontimeout = function() {
            let t4 = n3.timeout ? "timeout of " + n3.timeout + "ms exceeded" : "timeout exceeded";
            const r3 = n3.transitional || vR;
            n3.timeoutErrorMessage && (t4 = n3.timeoutErrorMessage), i2(new cR(t4, r3.clarifyTimeoutError ? cR.ETIMEDOUT : cR.ECONNABORTED, e2, E3)), E3 = null;
          }, void 0 === r2 && o2.setContentType(null), "setRequestHeader" in E3 && aR.forEach(o2.toJSON(), function(e3, t4) {
            E3.setRequestHeader(t4, e3);
          }), aR.isUndefined(n3.withCredentials) || (E3.withCredentials = !!n3.withCredentials), u3 && "json" !== u3 && (E3.responseType = n3.responseType), p2 && ([c3, l2] = Pb2(p2, true), E3.addEventListener("progress", c3)), h2 && E3.upload && ([a3, d2] = Pb2(h2), E3.upload.addEventListener("progress", a3), E3.upload.addEventListener("loadend", d2)), (n3.cancelToken || n3.signal) && (s2 = (t4) => {
            E3 && (i2(!t4 || t4.type ? new Nb2(null, e2, E3) : t4), E3.abort(), E3 = null);
          }, n3.cancelToken && n3.cancelToken.subscribe(s2), n3.signal && (n3.signal.aborted ? s2() : n3.signal.addEventListener("abort", s2)));
          const f2 = function(e3) {
            const t4 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e3);
            return t4 && t4[1] || "";
          }(n3.url);
          f2 && -1 === RI.protocols.indexOf(f2) ? i2(new cR("Unsupported protocol " + f2 + ":", cR.ERR_BAD_REQUEST, e2)) : E3.send(r2 || null);
        });
      };
      var Wb2 = (e2, t3) => {
        const { length: i2 } = e2 = e2 ? e2.filter(Boolean) : [];
        if (t3 || i2) {
          let i3, n3 = new AbortController();
          const r2 = function(e3) {
            if (!i3) {
              i3 = true, s2();
              const t4 = e3 instanceof Error ? e3 : this.reason;
              n3.abort(t4 instanceof cR ? t4 : new Nb2(t4 instanceof Error ? t4.message : t4));
            }
          };
          let o2 = t3 && setTimeout(() => {
            o2 = null, r2(new cR("timeout ".concat(t3, " of ms exceeded"), cR.ETIMEDOUT));
          }, t3);
          const s2 = () => {
            e2 && (o2 && clearTimeout(o2), o2 = null, e2.forEach((e3) => {
              e3.unsubscribe ? e3.unsubscribe(r2) : e3.removeEventListener("abort", r2);
            }), e2 = null);
          };
          e2.forEach((e3) => e3.addEventListener("abort", r2));
          const { signal: a3 } = n3;
          return a3.unsubscribe = () => aR.asap(s2), a3;
        }
      }, Hb2 = i(tp2), Kb2 = cv2.f("asyncIterator"), Yb2 = i(Kb2);
      function zb2(e2, t3) {
        this.v = e2, this.k = t3;
      }
      function qb2(e2) {
        return function() {
          return new Xb2(e2.apply(this, arguments));
        };
      }
      function Xb2(e2) {
        var t3, i2;
        function n3(t4, i3) {
          try {
            var o2 = e2[t4](i3), s2 = o2.value, a3 = s2 instanceof zb2;
            Hb2.resolve(a3 ? s2.v : s2).then(function(i4) {
              if (a3) {
                var c3 = "return" === t4 ? "return" : "next";
                if (!s2.k || i4.done) return n3(c3, i4);
                i4 = e2[c3](i4).value;
              }
              r2(o2.done ? "return" : "normal", i4);
            }, function(e3) {
              n3("throw", e3);
            });
          } catch (e3) {
            r2("throw", e3);
          }
        }
        function r2(e3, r3) {
          switch (e3) {
            case "return":
              t3.resolve({ value: r3, done: true });
              break;
            case "throw":
              t3.reject(r3);
              break;
            default:
              t3.resolve({ value: r3, done: false });
          }
          (t3 = t3.next) ? n3(t3.key, t3.arg) : i2 = null;
        }
        this._invoke = function(e3, r3) {
          return new Hb2(function(o2, s2) {
            var a3 = { key: e3, arg: r3, resolve: o2, reject: s2, next: null };
            i2 ? i2 = i2.next = a3 : (t3 = i2 = a3, n3(e3, r3));
          });
        }, "function" != typeof e2.return && (this.return = void 0);
      }
      function Jb2(e2) {
        return new zb2(e2, 0);
      }
      function Zb2(e2) {
        var t3 = {}, i2 = false;
        function n3(t4, n4) {
          return i2 = true, n4 = new Hb2(function(i3) {
            i3(e2[t4](n4));
          }), { done: false, value: new zb2(n4, 1) };
        }
        return t3[void 0 !== sI && aI || "@@iterator"] = function() {
          return this;
        }, t3.next = function(e3) {
          return i2 ? (i2 = false, e3) : n3("next", e3);
        }, "function" == typeof e2.throw && (t3.throw = function(e3) {
          if (i2) throw i2 = false, e3;
          return n3("throw", e3);
        }), "function" == typeof e2.return && (t3.return = function(e3) {
          return i2 ? (i2 = false, e3) : n3("return", e3);
        }), t3;
      }
      Xb2.prototype["function" == typeof sI && Yb2 || "@@asyncIterator"] = function() {
        return this;
      }, Xb2.prototype.next = function(e2) {
        return this._invoke("next", e2);
      }, Xb2.prototype.throw = function(e2) {
        return this._invoke("throw", e2);
      }, Xb2.prototype.return = function(e2) {
        return this._invoke("return", e2);
      };
      var Qb2 = i(Kb2);
      function $b2(e2) {
        var t3, i2, n3, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = Qb2, n3 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t3 = e2[i2])) return t3.call(e2);
          if (n3 && null != (t3 = e2[n3])) return new eA2(t3.call(e2));
          i2 = "@@asyncIterator", n3 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function eA2(e2) {
        function t3(e3) {
          if (Object(e3) !== e3) return ip2.reject(new TypeError(e3 + " is not an object."));
          var t4 = e3.done;
          return ip2.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t4 };
          });
        }
        return eA2 = function(e3) {
          this.s = e3, this.n = e3.next;
        }, eA2.prototype = { s: null, n: null, next: function() {
          return t3(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? ip2.resolve({ value: e3, done: true }) : t3(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? ip2.reject(e3) : t3(i2.apply(this.s, arguments));
        } }, new eA2(e2);
      }
      const tA2 = function* (e2, t3) {
        let i2 = e2.byteLength;
        if (!t3 || i2 < t3) return void (yield e2);
        let n3, r2 = 0;
        for (; r2 < i2; ) n3 = r2 + t3, yield e2.slice(r2, n3), r2 = n3;
      }, iA2 = function() {
        var e2 = qb2(function* (e3, t3) {
          var i2, n3 = false, r2 = false;
          try {
            for (var o2, s2 = $b2(nA2(e3)); n3 = !(o2 = yield Jb2(s2.next())).done; n3 = false) {
              const e4 = o2.value;
              yield* Zb2($b2(tA2(e4, t3)));
            }
          } catch (e4) {
            r2 = true, i2 = e4;
          } finally {
            try {
              n3 && null != s2.return && (yield Jb2(s2.return()));
            } finally {
              if (r2) throw i2;
            }
          }
        });
        return function(t3, i2) {
          return e2.apply(this, arguments);
        };
      }(), nA2 = function() {
        var e2 = qb2(function* (e3) {
          if (e3[Qb2]) return void (yield* Zb2($b2(e3)));
          const t3 = e3.getReader();
          try {
            for (; ; ) {
              const { done: e4, value: i2 } = yield Jb2(t3.read());
              if (e4) break;
              yield i2;
            }
          } finally {
            yield Jb2(t3.cancel());
          }
        });
        return function(t3) {
          return e2.apply(this, arguments);
        };
      }(), rA2 = (e2, t3, i2, n3) => {
        const r2 = iA2(e2, t3);
        let o2, s2 = 0, a3 = (e3) => {
          o2 || (o2 = true, n3 && n3(e3));
        };
        return new ReadableStream({ async pull(e3) {
          try {
            const { done: t4, value: n4 } = await r2.next();
            if (t4) return a3(), void e3.close();
            let o3 = n4.byteLength;
            if (i2) {
              let e4 = s2 += o3;
              i2(e4);
            }
            e3.enqueue(new Uint8Array(n4));
          } catch (e4) {
            throw a3(e4), e4;
          }
        }, cancel: (e3) => (a3(e3), r2.return()) }, { highWaterMark: 2 });
      };
      function oA2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function sA2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? oA2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : oA2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const aA2 = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response, cA2 = aA2 && "function" == typeof ReadableStream, dA2 = aA2 && ("function" == typeof TextEncoder ? (lA2 = new TextEncoder(), (e2) => lA2.encode(e2)) : async (e2) => new Uint8Array(await new Response(e2).arrayBuffer()));
      var lA2;
      const uA2 = function(e2) {
        try {
          for (var t3 = arguments.length, i2 = new Array(t3 > 1 ? t3 - 1 : 0), n3 = 1; n3 < t3; n3++) i2[n3 - 1] = arguments[n3];
          return !!e2(...i2);
        } catch (e3) {
          return false;
        }
      }, hA2 = cA2 && uA2(() => {
        let e2 = false;
        const t3 = new Request(RI.origin, { body: new ReadableStream(), method: "POST", get duplex() {
          return e2 = true, "half";
        } }).headers.has("Content-Type");
        return e2 && !t3;
      }), pA2 = cA2 && uA2(() => aR.isReadableStream(new Response("").body)), _A = { stream: pA2 && ((e2) => e2.body) };
      var EA2;
      aA2 && (EA2 = new Response(), ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e2) => {
        !_A[e2] && (_A[e2] = aR.isFunction(EA2[e2]) ? (t3) => t3[e2]() : (t3, i2) => {
          throw new cR("Response type '".concat(e2, "' is not supported"), cR.ERR_NOT_SUPPORT, i2);
        });
      }));
      const mA2 = async (e2, t3) => {
        const i2 = aR.toFiniteNumber(e2.getContentLength());
        return null == i2 ? (async (e3) => {
          if (null == e3) return 0;
          if (aR.isBlob(e3)) return e3.size;
          if (aR.isSpecCompliantForm(e3)) {
            const t4 = new Request(RI.origin, { method: "POST", body: e3 });
            return (await t4.arrayBuffer()).byteLength;
          }
          return aR.isArrayBufferView(e3) || aR.isArrayBuffer(e3) ? e3.byteLength : (aR.isURLSearchParams(e3) && (e3 += ""), aR.isString(e3) ? (await dA2(e3)).byteLength : void 0);
        })(t3) : i2;
      };
      var fA2 = aA2 && (async (e2) => {
        let { url: t3, method: i2, data: n3, signal: r2, cancelToken: o2, timeout: s2, onDownloadProgress: a3, onUploadProgress: c3, responseType: d2, headers: l2, withCredentials: u3 = "same-origin", fetchOptions: h2 } = jb2(e2);
        d2 = d2 ? (d2 + "").toLowerCase() : "text";
        let p2, _2 = Wb2([r2, o2 && o2.toAbortSignal()], s2);
        const E3 = _2 && _2.unsubscribe && (() => {
          _2.unsubscribe();
        });
        let m3;
        try {
          if (c3 && hA2 && "get" !== i2 && "head" !== i2 && 0 !== (m3 = await mA2(l2, n3))) {
            let e3, i3 = new Request(t3, { method: "POST", body: n3, duplex: "half" });
            if (aR.isFormData(n3) && (e3 = i3.headers.get("content-type")) && l2.setContentType(e3), i3.body) {
              const [e4, t4] = Lb(m3, Pb2(kb2(c3)));
              n3 = rA2(i3.body, 65536, e4, t4);
            }
          }
          aR.isString(u3) || (u3 = u3 ? "include" : "omit");
          const r3 = "credentials" in Request.prototype;
          p2 = new Request(t3, sA2(sA2({}, h2), {}, { signal: _2, method: i2.toUpperCase(), headers: l2.normalize().toJSON(), body: n3, duplex: "half", credentials: r3 ? u3 : void 0 }));
          let o3 = await fetch(p2);
          const s3 = pA2 && ("stream" === d2 || "response" === d2);
          if (pA2 && (a3 || s3 && E3)) {
            const e3 = {};
            ["status", "statusText", "headers"].forEach((t5) => {
              e3[t5] = o3[t5];
            });
            const t4 = aR.toFiniteNumber(o3.headers.get("content-length")), [i3, n4] = a3 && Lb(t4, Pb2(kb2(a3), true)) || [];
            o3 = new Response(rA2(o3.body, 65536, i3, () => {
              n4 && n4(), E3 && E3();
            }), e3);
          }
          d2 = d2 || "text";
          let f2 = await _A[aR.findKey(_A, d2) || "text"](o3, e2);
          return !s3 && E3 && E3(), await new ip2((t4, i3) => {
            Db2(t4, i3, { data: f2, headers: Ab2.from(o3.headers), status: o3.status, statusText: o3.statusText, config: e2, request: p2 });
          });
        } catch (t4) {
          if (E3 && E3(), t4 && "TypeError" === t4.name && /Load failed|fetch/i.test(t4.message)) throw Object.assign(new cR("Network Error", cR.ERR_NETWORK, e2, p2), { cause: t4.cause || t4 });
          throw cR.from(t4, t4 && t4.code, e2, p2);
        }
      });
      const SA2 = { http: null, xhr: Gb2, fetch: fA2 };
      aR.forEach(SA2, (e2, t3) => {
        if (e2) {
          try {
            Object.defineProperty(e2, "name", { value: t3 });
          } catch (e3) {
          }
          Object.defineProperty(e2, "adapterName", { value: t3 });
        }
      });
      const gA2 = (e2) => "- ".concat(e2), TA2 = (e2) => aR.isFunction(e2) || null === e2 || false === e2;
      var RA2 = { getAdapter: (e2) => {
        e2 = aR.isArray(e2) ? e2 : [e2];
        const { length: t3 } = e2;
        let i2, n3;
        const r2 = {};
        for (let o2 = 0; o2 < t3; o2++) {
          let t4;
          if (i2 = e2[o2], n3 = i2, !TA2(i2) && (n3 = SA2[(t4 = String(i2)).toLowerCase()], void 0 === n3)) throw new cR("Unknown adapter '".concat(t4, "'"));
          if (n3) break;
          r2[t4 || "#" + o2] = n3;
        }
        if (!n3) {
          const e3 = Object.entries(r2).map((e4) => {
            let [t4, i3] = e4;
            return "adapter ".concat(t4, " ") + (false === i3 ? "is not supported by the environment" : "is not available in the build");
          });
          throw new cR("There is no suitable adapter to dispatch the request " + (t3 ? e3.length > 1 ? "since :\n" + e3.map(gA2).join("\n") : " " + gA2(e3[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
        }
        return n3;
      }, adapters: SA2 };
      function vA2(e2) {
        if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted) throw new Nb2(null, e2);
      }
      function CA2(e2) {
        vA2(e2), e2.headers = Ab2.from(e2.headers), e2.data = wb2.call(e2, e2.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e2.method) && e2.headers.setContentType("application/x-www-form-urlencoded", false);
        return RA2.getAdapter(e2.adapter || Tb2.adapter)(e2).then(function(t3) {
          return vA2(e2), t3.data = wb2.call(e2, e2.transformResponse, t3), t3.headers = Ab2.from(t3.headers), t3;
        }, function(t3) {
          return Ob2(t3) || (vA2(e2), t3 && t3.response && (t3.response.data = wb2.call(e2, e2.transformResponse, t3.response), t3.response.headers = Ab2.from(t3.response.headers))), ip2.reject(t3);
        });
      }
      const yA2 = "1.9.0", IA2 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((e2, t3) => {
        IA2[e2] = function(i2) {
          return typeof i2 === e2 || "a" + (t3 < 1 ? "n " : " ") + e2;
        };
      });
      const bA2 = {};
      IA2.transitional = function(e2, t3, i2) {
        function n3(e3, t4) {
          return "[Axios v" + yA2 + "] Transitional option '" + e3 + "'" + t4 + (i2 ? ". " + i2 : "");
        }
        return (i3, r2, o2) => {
          if (false === e2) throw new cR(n3(r2, " has been removed" + (t3 ? " in " + t3 : "")), cR.ERR_DEPRECATED);
          return t3 && !bA2[r2] && (bA2[r2] = true, console.warn(n3(r2, " has been deprecated since v" + t3 + " and will be removed in the near future"))), !e2 || e2(i3, r2, o2);
        };
      }, IA2.spelling = function(e2) {
        return (t3, i2) => (console.warn("".concat(i2, " is likely a misspelling of ").concat(e2)), true);
      };
      var AA2 = { assertOptions: function(e2, t3, i2) {
        if ("object" != typeof e2) throw new cR("options must be an object", cR.ERR_BAD_OPTION_VALUE);
        const n3 = Object.keys(e2);
        let r2 = n3.length;
        for (; r2-- > 0; ) {
          const o2 = n3[r2], s2 = t3[o2];
          if (s2) {
            const t4 = e2[o2], i3 = void 0 === t4 || s2(t4, o2, e2);
            if (true !== i3) throw new cR("option " + o2 + " must be " + i3, cR.ERR_BAD_OPTION_VALUE);
          } else if (true !== i2) throw new cR("Unknown option " + o2, cR.ERR_BAD_OPTION);
        }
      }, validators: IA2 };
      const wA2 = AA2.validators;
      let OA2 = class {
        constructor(e2) {
          this.defaults = e2 || {}, this.interceptors = { request: new RR(), response: new RR() };
        }
        async request(e2, t3) {
          try {
            return await this._request(e2, t3);
          } catch (e3) {
            if (e3 instanceof Error) {
              let t4 = {};
              Error.captureStackTrace ? Error.captureStackTrace(t4) : t4 = new Error();
              const i2 = t4.stack ? t4.stack.replace(/^.+\n/, "") : "";
              try {
                e3.stack ? i2 && !String(e3.stack).endsWith(i2.replace(/^.+\n.+\n/, "")) && (e3.stack += "\n" + i2) : e3.stack = i2;
              } catch (e4) {
              }
            }
            throw e3;
          }
        }
        _request(e2, t3) {
          "string" == typeof e2 ? (t3 = t3 || {}).url = e2 : t3 = e2 || {}, t3 = Bb2(this.defaults, t3);
          const { transitional: i2, paramsSerializer: n3, headers: r2 } = t3;
          void 0 !== i2 && AA2.assertOptions(i2, { silentJSONParsing: wA2.transitional(wA2.boolean), forcedJSONParsing: wA2.transitional(wA2.boolean), clarifyTimeoutError: wA2.transitional(wA2.boolean) }, false), null != n3 && (aR.isFunction(n3) ? t3.paramsSerializer = { serialize: n3 } : AA2.assertOptions(n3, { encode: wA2.function, serialize: wA2.function }, true)), void 0 !== t3.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t3.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t3.allowAbsoluteUrls = true), AA2.assertOptions(t3, { baseUrl: wA2.spelling("baseURL"), withXsrfToken: wA2.spelling("withXSRFToken") }, true), t3.method = (t3.method || this.defaults.method || "get").toLowerCase();
          let o2 = r2 && aR.merge(r2.common, r2[t3.method]);
          r2 && aR.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (e3) => {
            delete r2[e3];
          }), t3.headers = Ab2.concat(o2, r2);
          const s2 = [];
          let a3 = true;
          this.interceptors.request.forEach(function(e3) {
            "function" == typeof e3.runWhen && false === e3.runWhen(t3) || (a3 = a3 && e3.synchronous, s2.unshift(e3.fulfilled, e3.rejected));
          });
          const c3 = [];
          let d2;
          this.interceptors.response.forEach(function(e3) {
            c3.push(e3.fulfilled, e3.rejected);
          });
          let l2, u3 = 0;
          if (!a3) {
            const e3 = [CA2.bind(this), void 0];
            for (e3.unshift.apply(e3, s2), e3.push.apply(e3, c3), l2 = e3.length, d2 = ip2.resolve(t3); u3 < l2; ) d2 = d2.then(e3[u3++], e3[u3++]);
            return d2;
          }
          l2 = s2.length;
          let h2 = t3;
          for (u3 = 0; u3 < l2; ) {
            const e3 = s2[u3++], t4 = s2[u3++];
            try {
              h2 = e3(h2);
            } catch (e4) {
              t4.call(this, e4);
              break;
            }
          }
          try {
            d2 = CA2.call(this, h2);
          } catch (e3) {
            return ip2.reject(e3);
          }
          for (u3 = 0, l2 = c3.length; u3 < l2; ) d2 = d2.then(c3[u3++], c3[u3++]);
          return d2;
        }
        getUri(e2) {
          return TR(Vb2((e2 = Bb2(this.defaults, e2)).baseURL, e2.url, e2.allowAbsoluteUrls), e2.params, e2.paramsSerializer);
        }
      };
      aR.forEach(["delete", "get", "head", "options"], function(e2) {
        OA2.prototype[e2] = function(t3, i2) {
          return this.request(Bb2(i2 || {}, { method: e2, url: t3, data: (i2 || {}).data }));
        };
      }), aR.forEach(["post", "put", "patch"], function(e2) {
        function t3(t4) {
          return function(i2, n3, r2) {
            return this.request(Bb2(r2 || {}, { method: e2, headers: t4 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n3 }));
          };
        }
        OA2.prototype[e2] = t3(), OA2.prototype[e2 + "Form"] = t3(true);
      });
      var NA2 = OA2;
      class DA2 {
        constructor(e2) {
          if ("function" != typeof e2) throw new TypeError("executor must be a function.");
          let t3;
          this.promise = new ip2(function(e3) {
            t3 = e3;
          });
          const i2 = this;
          this.promise.then((e3) => {
            if (!i2._listeners) return;
            let t4 = i2._listeners.length;
            for (; t4-- > 0; ) i2._listeners[t4](e3);
            i2._listeners = null;
          }), this.promise.then = (e3) => {
            let t4;
            const n3 = new ip2((e4) => {
              i2.subscribe(e4), t4 = e4;
            }).then(e3);
            return n3.cancel = function() {
              i2.unsubscribe(t4);
            }, n3;
          }, e2(function(e3, n3, r2) {
            i2.reason || (i2.reason = new Nb2(e3, n3, r2), t3(i2.reason));
          });
        }
        throwIfRequested() {
          if (this.reason) throw this.reason;
        }
        subscribe(e2) {
          this.reason ? e2(this.reason) : this._listeners ? this._listeners.push(e2) : this._listeners = [e2];
        }
        unsubscribe(e2) {
          if (!this._listeners) return;
          const t3 = this._listeners.indexOf(e2);
          -1 !== t3 && this._listeners.splice(t3, 1);
        }
        toAbortSignal() {
          const e2 = new AbortController(), t3 = (t4) => {
            e2.abort(t4);
          };
          return this.subscribe(t3), e2.signal.unsubscribe = () => this.unsubscribe(t3), e2.signal;
        }
        static source() {
          let e2;
          const t3 = new DA2(function(t4) {
            e2 = t4;
          });
          return { token: t3, cancel: e2 };
        }
      }
      var PA2 = DA2;
      const LA2 = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
      Object.entries(LA2).forEach((e2) => {
        let [t3, i2] = e2;
        LA2[i2] = t3;
      });
      var kA2 = LA2;
      const MA2 = function e2(t3) {
        const i2 = new NA2(t3), n3 = ST(NA2.prototype.request, i2);
        return aR.extend(n3, NA2.prototype, i2, { allOwnKeys: true }), aR.extend(n3, i2, null, { allOwnKeys: true }), n3.create = function(i3) {
          return e2(Bb2(t3, i3));
        }, n3;
      }(Tb2);
      MA2.Axios = NA2, MA2.CanceledError = Nb2, MA2.CancelToken = PA2, MA2.isCancel = Ob2, MA2.VERSION = yA2, MA2.toFormData = ER, MA2.AxiosError = cR, MA2.Cancel = MA2.CanceledError, MA2.all = function(e2) {
        return ip2.all(e2);
      }, MA2.spread = function(e2) {
        return function(t3) {
          return e2.apply(null, t3);
        };
      }, MA2.isAxiosError = function(e2) {
        return aR.isObject(e2) && true === e2.isAxiosError;
      }, MA2.mergeConfig = Bb2, MA2.AxiosHeaders = Ab2, MA2.formToJSON = (e2) => Sb2(aR.isHTMLForm(e2) ? new FormData(e2) : e2), MA2.getAdapter = RA2.getAdapter, MA2.HttpStatusCode = kA2, MA2.default = MA2;
      var UA2 = MA2;
      const VA2 = () => {
      };
      function xA2() {
        const e2 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: VA2 };
        return e2.promise = new ip2((t3, i2) => {
          e2.resolve = (i3) => {
            e2.isFinished || (e2.isResolved = true, e2.isFinished = true, t3(i3), e2.value = i3);
          }, e2.reject = (t4) => {
            e2.isFinished || (e2.isRejected = true, e2.isFinished = true, i2(t4));
          };
        }), e2;
      }
      const FA2 = /* @__PURE__ */ new Map(), BA2 = /* @__PURE__ */ new Map(), jA2 = /* @__PURE__ */ new Map();
      let GA2 = function(e2) {
        return e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.CHROMIUM_OS = "Chromium OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot", e2;
      }({}), WA2 = function(e2) {
        return e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger", e2;
      }({});
      const HA2 = new Xg2();
      let KA2 = HA2.getResult(), YA2 = null;
      function zA2(e2) {
        if (!YA2) {
          e2 && HA2.setUA(e2), KA2 = HA2.getResult();
          const t3 = function(e3) {
            if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name) return WA2.CHROME;
            switch (e3.browser.name) {
              case "Chrome Headless":
              case "Chrome":
              case "Chromium":
                return WA2.CHROME;
              case "Safari":
              case "Mobile Safari":
                return WA2.SAFARI;
              case "Edge":
                return WA2.EDGE;
              case "Firefox":
                return WA2.FIREFOX;
              case "QQ":
              case "QQBrowser":
                return WA2.QQ;
              case "Opera":
                return WA2.OPERA;
              case "WeChat":
                return WA2.WECHAT;
              default:
                return e3.browser.name || "";
            }
          }(KA2), i2 = qA2(KA2), n3 = function(e3) {
            return "Windows" === e3.os.name ? e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name : e3.os.name || "";
          }(KA2), r2 = KA2.os.version, o2 = qA2(KA2, false), s2 = KA2.device.type;
          if (!(t3 && i2 && n3 && r2)) return { name: t3, version: i2, os: n3, osVersion: r2, browserVersion: o2, deviceType: s2 };
          YA2 = { name: t3, version: i2, os: n3, osVersion: r2, browserVersion: o2, deviceType: s2 };
        }
        return YA2;
      }
      function qA2(e2) {
        let t3, i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        return t3 = "Blink" === e2.engine.name ? e2.engine.version || "" : e2.browser.version || "", i2 ? t3.split(".")[0] : t3;
      }
      function XA2() {
        return zA2().os;
      }
      function JA2() {
        const e2 = zA2();
        return "".concat(e2.os, " ").concat(e2.osVersion);
      }
      function ZA2() {
        const e2 = zA2();
        return !!("WebKit" === KA2.engine.name && e2.os === GA2.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== WA2.SAFARI || nw2() && e2.name !== WA2.SAFARI);
      }
      function QA2() {
        return zA2().name === WA2.CHROME;
      }
      function $A2() {
        return zA2().name === WA2.SAFARI;
      }
      function ew2() {
        const e2 = zA2();
        if (e2.name !== WA2.SAFARI || !e2.browserVersion) return false;
        const t3 = e2.browserVersion.split(".");
        return Number(t3[0]) > 15 || 15 === Number(t3[0]) && Number(t3[1]) >= 4;
      }
      function tw2() {
        return zA2().name === WA2.EDGE;
      }
      function iw2() {
        return zA2().name === WA2.FIREFOX;
      }
      function nw2() {
        return zA2().os === GA2.IOS;
      }
      function rw2(e2) {
        const t3 = zA2();
        return !(t3.name !== WA2.CHROME || !t3.osVersion) && Number(t3.version) >= e2;
      }
      function ow2(e2) {
        const t3 = zA2();
        return !(t3.name !== WA2.CHROME || !t3.osVersion) && Number(t3.version) < e2;
      }
      function sw2(e2, t3, i2) {
        const n3 = zA2();
        return !(n3.name !== e2 || !n3.osVersion) && (i2 ? Number(n3.version) >= t3 && Number(n3.version) <= i2 : Number(n3.version) === t3);
      }
      function aw2(e2) {
        const t3 = zA2();
        return !(t3.name !== WA2.EDGE || !t3.osVersion) && Number(t3.version) >= e2;
      }
      function cw2(e2) {
        const t3 = zA2();
        return !(t3.name !== WA2.FIREFOX || !t3.osVersion) && Number(t3.version) >= e2;
      }
      function dw2(e2) {
        const t3 = zA2();
        return !(t3.name !== WA2.SAFARI || !t3.osVersion) && Number(t3.version) >= e2;
      }
      function lw2(e2, t3, i2) {
        const n3 = zA2();
        if (n3.os !== GA2.IOS || !n3.osVersion) return false;
        const r2 = n3.osVersion.split(".");
        return i2 ? t3 && Number(r2[0]) === e2 && Number(r2[1]) > t3 || Number(r2[0]) > e2 : t3 ? Number(r2[0]) === e2 && Number(r2[1]) >= t3 || Number(r2[0]) > e2 : Number(r2[0]) >= e2;
      }
      function uw2(e2, t3, i2) {
        const n3 = zA2();
        if (n3.os !== GA2.IOS || !n3.osVersion) return false;
        const r2 = n3.osVersion.split(".");
        return i2 ? t3 && Number(r2[0]) === e2 && Number(r2[1]) < t3 || Number(r2[0]) < e2 : t3 ? Number(r2[0]) === e2 && Number(r2[1]) <= t3 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
      }
      function hw2(e2, t3, i2) {
        const n3 = zA2();
        if (n3.name !== WA2.SAFARI || !n3.osVersion || !n3.browserVersion) return false;
        const r2 = n3.browserVersion.split(".");
        return i2 ? t3 && Number(r2[0]) === e2 && Number(r2[1]) < t3 || Number(r2[0]) < e2 : t3 ? Number(r2[0]) === e2 && Number(r2[1]) <= t3 || Number(r2[0]) < e2 : Number(r2[0]) <= e2;
      }
      function pw2(e2) {
        const t3 = zA2();
        return !(t3.name !== WA2.OPERA || !t3.osVersion) && Number(t3.version) >= e2;
      }
      function _w() {
        const e2 = zA2();
        if (e2.os !== GA2.IOS || !e2.osVersion) return false;
        const t3 = e2.osVersion.split(".");
        return Number(t3[0]) < 14 || 14 === Number(t3[0]) && Number(t3[1]) <= 6;
      }
      function Ew2() {
        const e2 = zA2();
        if (e2.os !== GA2.IOS || !e2.osVersion) return false;
        const t3 = e2.osVersion.split(".");
        return 15 === Number(t3[0]);
      }
      function mw2() {
        const e2 = zA2();
        if (e2.os !== GA2.IOS || !e2.osVersion) return false;
        const t3 = e2.osVersion.split(".");
        return 16 === Number(t3[0]);
      }
      function fw2() {
        const e2 = zA2();
        if (e2.os !== GA2.IOS || !e2.osVersion) return false;
        const t3 = e2.osVersion.split(".");
        return 15 === Number(t3[0]) && Number(t3[1]) >= 1;
      }
      function Sw2() {
        return $A2() && navigator.maxTouchPoints > 0;
      }
      function gw2() {
        return zA2().name === WA2.WECHAT;
      }
      function Tw2() {
        return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function Rw2() {
        const e2 = XA2();
        return function() {
          const { deviceType: e3 } = zA2();
          return "mobile" === e3 || "tablet" === e3;
        }() || e2 === GA2.ANDROID || e2 === GA2.IOS || e2 === GA2.HARMONY_OS;
      }
      function vw2() {
        const e2 = zA2();
        return e2.name !== WA2.EDGE && e2.name !== WA2.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function Cw2() {
        return XA2() === GA2.ANDROID;
      }
      function yw2() {
        const e2 = zA2();
        return Cw2() && (e2.name === WA2.CHROME || e2.name === WA2.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
      }
      function Iw2(e2, t3, i2) {
        return (t3 = function(e3) {
          var t4 = function(e4, t5) {
            if ("object" != typeof e4 || !e4) return e4;
            var i3 = e4[Symbol.toPrimitive];
            if (void 0 !== i3) {
              var n3 = i3.call(e4, "string");
              if ("object" != typeof n3) return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          }(e3);
          return "symbol" == typeof t4 ? t4 : t4 + "";
        }(t3)) in e2 ? Object.defineProperty(e2, t3, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t3] = i2, e2;
      }
      function bw2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function Aw2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? bw2(Object(i2), true).forEach(function(t4) {
            Iw2(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : bw2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      let ww2 = function(e2) {
        return e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", e2.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", e2.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED", e2;
      }({}), Ow2 = class extends Error {
        constructor(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i2 = arguments.length > 2 ? arguments[2] : void 0;
          super(t3), Iw2(this, "code", void 0), Iw2(this, "message", void 0), Iw2(this, "data", void 0), Iw2(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t3), this.data = i2;
        }
        toString() {
          return this.data ? "".concat(this.message, "\ndata: ").concat(JSON.stringify(this.data)) : this.message;
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error", t3 = arguments.length > 1 ? arguments[1] : void 0;
          return "error" === e2 && (t3 || console).error(this.toString()), "warning" === e2 && (t3 || console).warn(this.toString()), this;
        }
        throw(e2) {
          throw this.print("error", e2), this;
        }
      };
      function Nw2(e2, t3) {
        if ("boolean" != typeof e2) throw new Ow2(ww2.INVALID_PARAMS, "Invalid ".concat(t3, ": The value is of the boolean type."));
      }
      function Dw2(e2, t3, i2) {
        if (!Ln2(i2).call(i2, e2)) throw new Ow2(ww2.INVALID_PARAMS, "".concat(t3, " can only be set as ").concat(JSON.stringify(i2)));
      }
      function Pw2(e2, t3) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4;
        if (e2 < i2 || e2 > n3 || (!(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]) && !function(e3) {
          return "number" == typeof e3 && e3 % 1 == 0;
        }(e2)) throw new Ow2(ww2.INVALID_PARAMS, "invalid ".concat(t3, ": the value range is [").concat(i2, ", ").concat(n3, "]. integer only"));
      }
      function Lw2(e2, t3) {
        if ("number" != typeof e2) {
          if (!(e2.min || e2.max || e2.ideal || e2.exact)) throw new Ow2(ww2.INVALID_PARAMS, "".concat(t3, " is not a valid ConstrainLong"));
          void 0 !== e2.min && Pw2(e2.min, "".concat(t3, ".min"), 0, 1 / 0), void 0 !== e2.max && Pw2(e2.max, "".concat(t3, ".max"), 1, 1 / 0), void 0 !== e2.exact && Pw2(e2.exact, "".concat(t3, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && Pw2(e2.ideal, "".concat(t3, ".ideal"), 1, 1 / 0);
        } else Pw2(e2, t3, 1, 1 / 0);
      }
      function kw2(e2, t3) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if (null == e2) throw new Ow2(ww2.INVALID_PARAMS, "".concat(t3 || "param", " cannot be empty"));
        if (!Vw2(e2, i2, n3, r2)) throw new Ow2(ww2.INVALID_PARAMS, "Invalid ".concat(t3 || "string param", ": Length of the string: [").concat(i2, ",").concat(n3, "].").concat(r2 ? " ASCII characters only." : ""));
      }
      function Mw2(e2, t3) {
        if (!Array.isArray(e2)) throw new Ow2(ww2.INVALID_PARAMS, "".concat(t3, " should be an array"));
      }
      function Uw2(e2) {
        return null == e2;
      }
      function Vw2(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        return "string" == typeof e2 && e2.length <= i2 && e2.length >= t3 && (!n3 || function(e3) {
          if ("string" != typeof e3) return false;
          for (let t4 = 0; t4 < e3.length; t4 += 1) {
            const i3 = e3.charCodeAt(t4);
            if (i3 < 0 || i3 > 255) return false;
          }
          return true;
        }(e2));
      }
      var xw2 = function(e2) {
        return e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE", e2;
      }(xw2 || {}), Fw2 = function(e2) {
        return e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT", e2;
      }(Fw2 || {});
      const Bw2 = new class {
        constructor() {
          Iw2(this, "_clientSize", null), Iw2(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), Iw2(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), Iw2(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), Iw2(this, "checkCssVisibleProperty", (e2) => {
            var t3;
            let i2 = true;
            const n3 = this.getStyle(e2), { display: r2, visibility: o2, opacity: s2, filter: a3 } = n3;
            return ("none" === r2 || Ln2(t3 = ["hidden", "collapse"]).call(t3, o2) || Number(s2) < 0.1) && (i2 = false), !!i2 && (a3 && a3.split(" ").filter((e3) => {
              var t4;
              const i3 = e3.split("(")[0];
              return Ln2(t4 = ["brightness", "blur", "opacity"]).call(t4, i3);
            }).map((e3) => {
              const [t4, i3] = e3.split(/\(|\)/);
              return [t4, Number(i3.match(/^[0-9\.]+/))];
            }).forEach((e3) => {
              const [t4, n4] = e3;
              switch (t4) {
                case "brightness":
                  (n4 < 0.1 || n4 > 3) && (i2 = false);
                  break;
                case "blur":
                  n4 > 3 && (i2 = false);
                  break;
                case "opacity":
                  n4 < 0.1 && (i2 = false);
              }
            }), i2);
          }), Iw2(this, "checkPropertyUpToAllParentNodes", (e2, t3) => {
            let i2 = true, n3 = true;
            const r2 = (e3) => t3(e3);
            let o2 = e2;
            for (; o2 && n3; ) r2(o2) || (i2 = false, n3 = false), o2 = o2.parentElement, o2 || (n3 = false);
            return i2;
          }), Iw2(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), Iw2(this, "getSizeAboutClient", (e2) => {
            const { width: t3, height: i2, left: n3, right: r2, top: o2, bottom: s2 } = e2.getBoundingClientRect(), a3 = this.getClientWidth(), c3 = this.getClientHeight();
            return { width: t3, height: i2, left: n3, right: r2, top: o2, bottom: s2, clientWidth: a3, clientHeight: c3, clientMin: Math.min(a3, c3) };
          }), Iw2(this, "checkActualSize", () => {
            const { width: e2, height: t3, clientMin: i2 } = this._clientSize;
            return this.checkSizeIsVisible(e2, t3, i2);
          }), Iw2(this, "elementFromPoint", (e2, t3) => document.elementFromPoint ? document.elementFromPoint(e2, t3) : null), Iw2(this, "checkCoverForAPoint", (e2, t3, i2) => {
            const n3 = this.elementFromPoint(e2, t3);
            return null !== n3 && n3 !== i2;
          }), Iw2(this, "getPointPositionList", () => {
            const { width: e2, height: t3, left: i2, top: n3 } = this._clientSize, r2 = e2 / 6, o2 = t3 / 6, s2 = [], a3 = 10 ** 6;
            for (let e3 = 0; e3 < 5; e3++) for (let t4 = 0; t4 < 5; t4++) {
              const c3 = (i2 * a3 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a3 - 1e5) / a3 : r2 * e3) * a3) / a3, d2 = (n3 * a3 + (0 === t4 ? 0.1 : 4 === t4 ? (o2 * t4 * a3 - 1e5) / a3 : o2 * t4) * a3) / a3;
              s2.push({ x: c3, y: d2 });
            }
            return [...s2];
          }), Iw2(this, "checkElementCover", (e2) => this.getPointPositionList().map((t3) => this.checkCoverForAPoint(t3.x, t3.y, e2)).filter((e3) => !!e3).length > 6), Iw2(this, "checkSizeIsVisible", (e2, t3, i2) => (e2 > 50 || i2 / e2 <= 10) && (t3 > 50 || i2 / t3 <= 10)), Iw2(this, "checkSizeOfPartInClient", () => {
            const { left: e2, right: t3, top: i2, bottom: n3, clientHeight: r2, clientWidth: o2, clientMin: s2 } = this._clientSize;
            let a3, c3, d2, l2;
            if (e2 < 0) a3 = 0;
            else {
              if (!(e2 < o2)) return false;
              a3 = e2;
            }
            if (t3 < 0) return false;
            if (c3 = t3 < o2 ? t3 : o2, i2 < 0) d2 = 0;
            else {
              if (!(i2 < r2)) return false;
              d2 = i2;
            }
            if (n3 < 0) return false;
            l2 = n3 < r2 ? n3 : r2;
            const u3 = c3 - a3, h2 = l2 - d2;
            return this.checkSizeIsVisible(u3, h2, s2);
          }), Iw2(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), Iw2(this, "checkOneElementVisible", (e2) => {
            if (e2 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e2)) {
                if (this.checkActualCssVisibleIncludeInherit(e2)) {
                  if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2)) return this.returnHiddenResult(xw2.COVERED);
                  {
                    const e3 = this.checkActualSize(), t3 = this.checkSizeOfPartInClient();
                    return e3 && !t3 ? this.returnHiddenResult(xw2.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(xw2.SIZE);
                  }
                }
                return this.returnHiddenResult(xw2.STYLE);
              }
              return this.returnHiddenResult(Fw2.UNMOUNTED);
            }
            return this.returnHiddenResult(Fw2.INVALID_HTML_ELEMENT);
          }), Iw2(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement));
        }
      }();
      function jw2(e2) {
        return new TextEncoder().encode(e2);
      }
      const Gw2 = function(e2, t3) {
        const i2 = new Uint8Array(e2.byteLength + t3.byteLength);
        return i2.set(new Uint8Array(e2), 0), i2.set(new Uint8Array(t3), e2.byteLength), i2;
      };
      const Ww2 = async (e2) => function(e3, t3) {
        let i2 = "";
        return new Uint8Array(e3).forEach((e4) => {
          i2 += e4.toString(t3).padStart(2, "0");
        }), i2;
      }(await crypto.subtle.digest("SHA-256", jw2(e2)), 16);
      class Hw2 {
        constructor() {
          Iw2(this, "_events", {}), Iw2(this, "addListener", this.on);
        }
        getListeners(e2) {
          return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
        }
        on(e2, t3) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t3) && i2.push({ listener: t3, once: false });
        }
        once(e2, t3) {
          this._events[e2] || (this._events[e2] = []);
          const i2 = this._events[e2];
          -1 === this._indexOfListener(i2, t3) && i2.push({ listener: t3, once: true });
        }
        off(e2, t3) {
          if (!this._events[e2]) return;
          const i2 = this._events[e2], n3 = this._indexOfListener(i2, t3);
          -1 !== n3 && i2.splice(n3, 1), 0 === this._events[e2].length && delete this._events[e2];
        }
        removeAllListeners(e2) {
          e2 ? delete this._events[e2] : this._events = {};
        }
        emit(e2) {
          this._events[e2] || (this._events[e2] = []);
          const t3 = this._events[e2].map((e3) => e3);
          for (var i2 = arguments.length, n3 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) n3[r2 - 1] = arguments[r2];
          for (let i3 = 0; i3 < t3.length; i3 += 1) {
            const r3 = t3[i3];
            r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n3 || []);
          }
        }
        safeEmit(e2) {
          for (var t3 = arguments.length, i2 = new Array(t3 > 1 ? t3 - 1 : 0), n3 = 1; n3 < t3; n3++) i2[n3 - 1] = arguments[n3];
          [...this._events[e2] || []].forEach((t4) => {
            t4.once && this.off(e2, t4.listener);
            try {
              t4.listener.apply(this, i2);
            } catch (t5) {
              console.error("safeEmit event:".concat(e2, " error ").concat(null == t5 ? void 0 : t5.toString()));
            }
          });
        }
        _indexOfListener(e2, t3) {
          let i2 = e2.length;
          for (; i2--; ) if (e2[i2].listener === t3) return i2;
          return -1;
        }
      }
      let Kw2 = null;
      function Yw2() {
        if (Kw2) return Kw2;
        if (window.electron) return Kw2 = window.electron;
        if (!window.require) return null;
        try {
          return Kw2 = window.require("electron"), Kw2;
        } catch (e2) {
          return null;
        }
      }
      let zw2 = function(e2) {
        return e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.PRELOAD = "PRELOAD", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload", e2.REPUB_AFTER_PC_CONNECTED = "repubAfterPCConnected", e2.PRELOAD_MEDIA_FAILED = "preloadMediaFailed", e2.MISMATCH_DTLS_PARAMETERS = "mismatchDtlsParameters", e2;
      }({}), qw2 = function(e2) {
        return e2.TRACER = "tracer", e2;
      }({});
      function Xw2(e2) {
        return Pw2(e2.timeout, "config.timeout", 0, 1e5), Pw2(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), Pw2(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), Pw2(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      let Jw2 = function(e2) {
        return e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY", e2;
      }({}), Zw2 = function(e2) {
        return e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.FALLBACK = "FALLBACK", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", e2.TOKEN_EXPIRE = "TOKEN_EXPIRE", e2;
      }({});
      function Qw2(e2) {
        if (!Array.isArray(e2) || e2.length < 1) return false;
        try {
          e2.forEach((e3) => {
            if (!e3.urls) throw Error();
          });
        } catch (e3) {
          return false;
        }
        return true;
      }
      function $w2(e2) {
        return kw2(e2.turnServerURL, "turnServerURL"), kw2(e2.username, "username"), kw2(e2.password, "password"), e2.udpport && Pw2(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && Nw2(e2.forceturn, "forceturn"), e2.security && Nw2(e2.security, "security"), e2.tcpport && Pw2(e2.tcpport, "tcpport", 1, 99999, true), true;
      }
      function eO(e2) {
        return void 0 !== e2.level && Dw2(e2.level, "level", [1, 2, 3]), void 0 !== e2.delay && Pw2(e2.delay, "delay", 0, 3e3, true), true;
      }
      let tO = function(e2) {
        return e2.PEERCONNECTION_STATE_CHANGE = "peerconnection-state-change", e2.AUDIO_METADATA = "audio-metadata", e2.AUDIO_PTS = "audio-pts", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change", e2;
      }({}), iO = function(e2) {
        return e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK", e2.REGIONAL_DISTRIBUTION = "REGIONAL_DISTRIBUTION", e2;
      }({}), nO = function(e2) {
        return e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE", e2;
      }({}), rO = function(e2) {
        return e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE", e2;
      }({});
      function oO(e2, t3) {
        for (var i2 = arguments.length, n3 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n3[r2 - 2] = arguments[r2];
        return 0 === e2.getListeners(t3).length ? ip2.reject(new Ow2(ww2.UNEXPECTED_ERROR, "can not emit promise")) : new ip2((i3, r3) => {
          e2.emit(t3, ...n3, i3, r3);
        });
      }
      function sO(e2, t3) {
        if (0 === e2.getListeners(t3).length) return ip2.resolve();
        for (var i2 = arguments.length, n3 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n3[r2 - 2] = arguments[r2];
        return oO(e2, t3, ...n3);
      }
      function aO(e2, t3) {
        if (0 === e2.getListeners(t3).length) return null;
        for (var i2 = arguments.length, n3 = new Array(i2 > 2 ? i2 - 2 : 0), r2 = 2; r2 < i2; r2++) n3[r2 - 2] = arguments[r2];
        return cO(e2, t3, ...n3);
      }
      function cO(e2, t3) {
        let i2 = null, n3 = null;
        for (var r2 = arguments.length, o2 = new Array(r2 > 2 ? r2 - 2 : 0), s2 = 2; s2 < r2; s2++) o2[s2 - 2] = arguments[s2];
        if (e2.emit(t3, ...o2, (e3) => {
          i2 = e3;
        }, (e3) => {
          n3 = e3;
        }), null !== n3) throw n3;
        if (null === i2) throw new Ow2(ww2.UNEXPECTED_ERROR, "handler is not sync");
        return i2;
      }
      const dO = new class extends Hw2 {
        set networkState(e2) {
          this.emit(rO.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === nO.ONLINE ? this.emit(rO.ONLINE) : e2 === nO.OFFLINE && (this.onlineWaiter = new ip2((e3) => {
            this.once(rO.ONLINE, () => {
              this.onlineWaiter = void 0, e3(nO.ONLINE);
            });
          }), this.emit(rO.OFFLINE)), this._networkState = e2;
        }
        get networkState() {
          return this._networkState;
        }
        get isOnline() {
          return this._networkState === nO.ONLINE;
        }
        constructor() {
          super(), Iw2(this, "_moduleName", "network-indicator"), Iw2(this, "_networkState", nO.ONLINE), Iw2(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
            this.networkState = nO.ONLINE;
          }), window.addEventListener("offline", () => {
            this.networkState = nO.OFFLINE;
          });
        }
      }();
      function lO(e2, t3) {
        const i2 = e2.indexOf(t3);
        -1 !== i2 && e2.splice(i2, 1);
      }
      function uO(e2) {
        const t3 = [];
        return e2.forEach((e3) => {
          -1 === t3.indexOf(e3) && t3.push(e3);
        }), t3;
      }
      function hO(e2) {
        void 0 !== ip2 ? ip2.resolve().then(e2) : setTimeout(e2, 0);
      }
      function pO(e2) {
        return JSON.parse(JSON.stringify(e2));
      }
      function _O(e2) {
        try {
          return pO(e2);
        } catch (t3) {
          return e2;
        }
      }
      const EO = {};
      function mO(e2, t3) {
        EO[t3] || (EO[t3] = true, e2());
      }
      function fO(e2) {
        const t3 = window.atob(e2), i2 = new Uint8Array(new ArrayBuffer(t3.length));
        for (let e3 = 0; e3 < t3.length; e3 += 1) i2[e3] = t3.charCodeAt(e3);
        return i2;
      }
      function SO(e2) {
        let t3 = "";
        for (let i2 = 0; i2 < e2.length; i2 += 1) t3 += String.fromCharCode(e2[i2]);
        return window.btoa(t3);
      }
      function gO(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 16, i2 = new TextEncoder().encode(e2);
        if (i2.length > t3) i2 = i2.slice(0, t3);
        else if (i2.length < t3) {
          const e3 = new Uint8Array(t3);
          e3.set(i2), i2 = e3;
        }
        return i2;
      }
      function TO() {
        for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
        const n3 = nr2(t3).call(t3, (e3, t4) => e3 + t4.length, 0), r2 = new Uint8Array(new ArrayBuffer(n3));
        let o2 = 0;
        return t3.forEach((e3) => {
          r2.set(e3, o2), o2 += e3.length;
        }), r2;
      }
      function RO(e2) {
        return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
      }
      function vO(e2) {
        let t3 = 0;
        return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && e2.realFormData && (e2 = e2.realFormData), e2.forEach((e3) => {
          t3 += "string" == typeof e3 ? RO(e3) : e3.size;
        }), t3 + 138;
      }
      function CO(e2) {
        const t3 = new Ow2(ww2.TIMEOUT, "timeout");
        return new ip2((i2, n3) => {
          window.setTimeout(() => n3(t3), e2);
        });
      }
      function yO(e2) {
        return new ip2((t3) => {
          window.setTimeout(t3, e2);
        });
      }
      function IO() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t3 = arguments.length > 1 ? arguments[1] : void 0;
        const i2 = Math.random().toString(16).substr(2, e2).toLowerCase();
        return i2.length === e2 ? "".concat(t3).concat(i2) : "".concat(t3).concat(i2) + IO(e2 - i2.length, "");
      }
      function bO() {
        return IO(32, "").toUpperCase();
      }
      const AO = () => {
      }, wO = new class {
        constructor() {
          Iw2(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e2, t3, i2, n3) {
          for (var r2 = arguments.length, o2 = new Array(r2 > 4 ? r2 - 4 : 0), s2 = 4; s2 < r2; s2++) o2[s2 - 4] = arguments[s2];
          if (this.fnMap.has(t3)) {
            const r3 = this.fnMap.get(t3);
            if (r3.threshold !== i2) {
              r3.fn(...r3.args), clearTimeout(r3.timer);
              const s3 = window.setTimeout(() => {
                const e3 = this.fnMap.get(t3);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t3);
              }, i2);
              this.fnMap.set(t3, { fn: e2, threshold: i2, timer: s3, args: o2, skipFn: n3 });
            } else r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t3, Aw2(Aw2({}, r3), {}, { fn: e2, args: o2, skipFn: n3 }));
          } else {
            const r3 = window.setTimeout(() => {
              const e3 = this.fnMap.get(t3);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t3);
            }, i2);
            this.fnMap.set(t3, { fn: e2, threshold: i2, timer: r3, args: o2, skipFn: n3 });
          }
        }
      }(), OO = wO.throttleByKey.bind(wO);
      function NO(e2) {
        return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
      }
      function DO(e2, t3) {
        if (!NO(e2) || !NO(t3)) return t3;
        if (Array.isArray(e2) && !Array.isArray(t3) || !Array.isArray(e2) && Array.isArray(t3)) return t3;
        if (Array.isArray(t3) && Array.isArray(e2)) {
          const i2 = [...e2];
          for (let n3 = 0; n3 < t3.length; n3++) i2[n3] = DO(e2[n3], t3[n3]);
          return i2;
        }
        {
          const i2 = Aw2({}, e2);
          for (const n3 in t3) Object.prototype.hasOwnProperty.call(t3, n3) && (Object.prototype.hasOwnProperty.call(e2, n3) ? i2[n3] = DO(e2[n3], t3[n3]) : i2[n3] = t3[n3]);
          return i2;
        }
      }
      function PO(e2, t3) {
        let i2 = [0];
        if (t3 && (i2 = new Array(t3).fill(0)), 0 === e2) return i2;
        let n3 = 0;
        for (; e2 > 0 && (i2[n3] = 255 & e2, e2 >>= 8, n3++, !t3 || n3 !== t3); ) ;
        return i2;
      }
      function LO(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function kO(e2) {
        return nr2(e2).call(e2, (e3, t3) => e3 + t3, 0);
      }
      function MO(e2) {
        const t3 = "0123456789abcdef";
        function i2(e3) {
          let i3, n4 = "";
          for (i3 = 0; i3 <= 3; i3++) n4 += t3.charAt(e3 >> 8 * i3 + 4 & 15) + t3.charAt(e3 >> 8 * i3 & 15);
          return n4;
        }
        function n3(e3, t4) {
          const i3 = (65535 & e3) + (65535 & t4);
          return (e3 >> 16) + (t4 >> 16) + (i3 >> 16) << 16 | 65535 & i3;
        }
        function r2(e3, t4, i3, r3, o3, s3) {
          return n3(function(e4, t5) {
            return e4 << t5 | e4 >>> 32 - t5;
          }(n3(n3(t4, e3), n3(r3, s3)), o3), i3);
        }
        function o2(e3, t4, i3, n4, o3, s3, a4) {
          return r2(t4 & i3 | ~t4 & n4, e3, t4, o3, s3, a4);
        }
        function s2(e3, t4, i3, n4, o3, s3, a4) {
          return r2(t4 & n4 | i3 & ~n4, e3, t4, o3, s3, a4);
        }
        function a3(e3, t4, i3, n4, o3, s3, a4) {
          return r2(t4 ^ i3 ^ n4, e3, t4, o3, s3, a4);
        }
        function c3(e3, t4, i3, n4, o3, s3, a4) {
          return r2(i3 ^ (t4 | ~n4), e3, t4, o3, s3, a4);
        }
        const d2 = function(e3) {
          let t4;
          const i3 = 1 + (e3.length + 8 >> 6), n4 = new Array(16 * i3);
          for (t4 = 0; t4 < 16 * i3; t4++) n4[t4] = 0;
          for (t4 = 0; t4 < e3.length; t4++) n4[t4 >> 2] |= e3.charCodeAt(t4) << t4 % 4 * 8;
          return n4[t4 >> 2] |= 128 << t4 % 4 * 8, n4[16 * i3 - 2] = 8 * e3.length, n4;
        }(e2);
        let l2, u3, h2, p2, _2, E3 = 1732584193, m3 = -271733879, f2 = -1732584194, S3 = 271733878;
        for (l2 = 0; l2 < d2.length; l2 += 16) u3 = E3, h2 = m3, p2 = f2, _2 = S3, E3 = o2(E3, m3, f2, S3, d2[l2 + 0], 7, -680876936), S3 = o2(S3, E3, m3, f2, d2[l2 + 1], 12, -389564586), f2 = o2(f2, S3, E3, m3, d2[l2 + 2], 17, 606105819), m3 = o2(m3, f2, S3, E3, d2[l2 + 3], 22, -1044525330), E3 = o2(E3, m3, f2, S3, d2[l2 + 4], 7, -176418897), S3 = o2(S3, E3, m3, f2, d2[l2 + 5], 12, 1200080426), f2 = o2(f2, S3, E3, m3, d2[l2 + 6], 17, -1473231341), m3 = o2(m3, f2, S3, E3, d2[l2 + 7], 22, -45705983), E3 = o2(E3, m3, f2, S3, d2[l2 + 8], 7, 1770035416), S3 = o2(S3, E3, m3, f2, d2[l2 + 9], 12, -1958414417), f2 = o2(f2, S3, E3, m3, d2[l2 + 10], 17, -42063), m3 = o2(m3, f2, S3, E3, d2[l2 + 11], 22, -1990404162), E3 = o2(E3, m3, f2, S3, d2[l2 + 12], 7, 1804603682), S3 = o2(S3, E3, m3, f2, d2[l2 + 13], 12, -40341101), f2 = o2(f2, S3, E3, m3, d2[l2 + 14], 17, -1502002290), m3 = o2(m3, f2, S3, E3, d2[l2 + 15], 22, 1236535329), E3 = s2(E3, m3, f2, S3, d2[l2 + 1], 5, -165796510), S3 = s2(S3, E3, m3, f2, d2[l2 + 6], 9, -1069501632), f2 = s2(f2, S3, E3, m3, d2[l2 + 11], 14, 643717713), m3 = s2(m3, f2, S3, E3, d2[l2 + 0], 20, -373897302), E3 = s2(E3, m3, f2, S3, d2[l2 + 5], 5, -701558691), S3 = s2(S3, E3, m3, f2, d2[l2 + 10], 9, 38016083), f2 = s2(f2, S3, E3, m3, d2[l2 + 15], 14, -660478335), m3 = s2(m3, f2, S3, E3, d2[l2 + 4], 20, -405537848), E3 = s2(E3, m3, f2, S3, d2[l2 + 9], 5, 568446438), S3 = s2(S3, E3, m3, f2, d2[l2 + 14], 9, -1019803690), f2 = s2(f2, S3, E3, m3, d2[l2 + 3], 14, -187363961), m3 = s2(m3, f2, S3, E3, d2[l2 + 8], 20, 1163531501), E3 = s2(E3, m3, f2, S3, d2[l2 + 13], 5, -1444681467), S3 = s2(S3, E3, m3, f2, d2[l2 + 2], 9, -51403784), f2 = s2(f2, S3, E3, m3, d2[l2 + 7], 14, 1735328473), m3 = s2(m3, f2, S3, E3, d2[l2 + 12], 20, -1926607734), E3 = a3(E3, m3, f2, S3, d2[l2 + 5], 4, -378558), S3 = a3(S3, E3, m3, f2, d2[l2 + 8], 11, -2022574463), f2 = a3(f2, S3, E3, m3, d2[l2 + 11], 16, 1839030562), m3 = a3(m3, f2, S3, E3, d2[l2 + 14], 23, -35309556), E3 = a3(E3, m3, f2, S3, d2[l2 + 1], 4, -1530992060), S3 = a3(S3, E3, m3, f2, d2[l2 + 4], 11, 1272893353), f2 = a3(f2, S3, E3, m3, d2[l2 + 7], 16, -155497632), m3 = a3(m3, f2, S3, E3, d2[l2 + 10], 23, -1094730640), E3 = a3(E3, m3, f2, S3, d2[l2 + 13], 4, 681279174), S3 = a3(S3, E3, m3, f2, d2[l2 + 0], 11, -358537222), f2 = a3(f2, S3, E3, m3, d2[l2 + 3], 16, -722521979), m3 = a3(m3, f2, S3, E3, d2[l2 + 6], 23, 76029189), E3 = a3(E3, m3, f2, S3, d2[l2 + 9], 4, -640364487), S3 = a3(S3, E3, m3, f2, d2[l2 + 12], 11, -421815835), f2 = a3(f2, S3, E3, m3, d2[l2 + 15], 16, 530742520), m3 = a3(m3, f2, S3, E3, d2[l2 + 2], 23, -995338651), E3 = c3(E3, m3, f2, S3, d2[l2 + 0], 6, -198630844), S3 = c3(S3, E3, m3, f2, d2[l2 + 7], 10, 1126891415), f2 = c3(f2, S3, E3, m3, d2[l2 + 14], 15, -1416354905), m3 = c3(m3, f2, S3, E3, d2[l2 + 5], 21, -57434055), E3 = c3(E3, m3, f2, S3, d2[l2 + 12], 6, 1700485571), S3 = c3(S3, E3, m3, f2, d2[l2 + 3], 10, -1894986606), f2 = c3(f2, S3, E3, m3, d2[l2 + 10], 15, -1051523), m3 = c3(m3, f2, S3, E3, d2[l2 + 1], 21, -2054922799), E3 = c3(E3, m3, f2, S3, d2[l2 + 8], 6, 1873313359), S3 = c3(S3, E3, m3, f2, d2[l2 + 15], 10, -30611744), f2 = c3(f2, S3, E3, m3, d2[l2 + 6], 15, -1560198380), m3 = c3(m3, f2, S3, E3, d2[l2 + 13], 21, 1309151649), E3 = c3(E3, m3, f2, S3, d2[l2 + 4], 6, -145523070), S3 = c3(S3, E3, m3, f2, d2[l2 + 11], 10, -1120210379), f2 = c3(f2, S3, E3, m3, d2[l2 + 2], 15, 718787259), m3 = c3(m3, f2, S3, E3, d2[l2 + 9], 21, -343485551), E3 = n3(E3, u3), m3 = n3(m3, h2), f2 = n3(f2, p2), S3 = n3(S3, _2);
        return i2(E3) + i2(m3) + i2(f2) + i2(S3);
      }
      let UO = 1, VO = console, xO = class {
        static setLogger(e2) {
          VO = e2;
        }
        constructor(e2, t3) {
          Iw2(this, "id", void 0), Iw2(this, "lockingPromise", ip2.resolve()), Iw2(this, "locks", 0), Iw2(this, "name", ""), Iw2(this, "lockId", void 0), this.lockId = UO++, e2 && (this.name = e2), t3 && (this.id = t3), this.logger("created");
        }
        logger(e2, t3) {
          const i2 = (this.id ? "[".concat(this.id, "]") : "") + "[lock-".concat(this.name, "-").concat(this.lockId, "]"), n3 = "created" === e2 ? "is ".concat(e2, ".") : "is ".concat(e2, ", current queue ").concat(this.locks, ". ").concat(null != t3 ? t3 : "");
          VO.debug("".concat(i2, " ").concat(n3));
        }
        setId(e2) {
          this.id = e2;
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e2) {
          let t3;
          this.locks += 1, this.logger("locked", e2);
          const i2 = new ip2((i3) => {
            t3 = () => {
              this.locks -= 1, this.logger("unlocked", e2), i3();
            };
          }), n3 = this.lockingPromise.then(() => t3);
          return this.lockingPromise = this.lockingPromise.then(() => i2), n3;
        }
      };
      function FO(e2, t3) {
        return function(i2, n3, r2) {
          const o2 = r2.value;
          if ("function" != typeof o2) throw new Error("Cannot use mutex on object property.");
          return r2.value = async function() {
            const i3 = this[t3];
            if (!i3) throw new Error("mutex property key ".concat(t3, " doesn't exist on ").concat(e2));
            const r3 = await i3.lock("From ".concat(e2, ".").concat(n3));
            try {
              for (var s2 = arguments.length, a3 = new Array(s2), c3 = 0; c3 < s2; c3++) a3[c3] = arguments[c3];
              return await o2.apply(this, a3);
            } finally {
              r3();
            }
          }, r2;
        };
      }
      const BO = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function jO(e2, t3) {
        const i2 = Math.floor(t3.timeout * Math.pow(t3.timeoutFactor, e2));
        return Math.min(t3.maxRetryTimeout, i2);
      }
      function GO(e2, t3, i2, n3) {
        const r2 = Object.assign({}, BO, n3);
        let o2 = r2.timeout;
        const s2 = async () => {
          await function(e3) {
            return new ip2((t4) => {
              window.setTimeout(t4, e3);
            });
          }(o2), o2 *= r2.timeoutFactor, o2 = Math.min(r2.maxRetryTimeout, o2);
        };
        let a3 = false;
        const c3 = new ip2(async (n4, o3) => {
          t3 = t3 || (() => false), i2 = i2 || (() => true);
          for (let c4 = 0; c4 < r2.maxRetryCount; c4 += 1) {
            if (a3) return o3(new Ow2(ww2.OPERATION_ABORTED));
            try {
              const i3 = await e2();
              if (!t3(i3, c4)) return n4(i3);
              if (c4 + 1 === r2.maxRetryCount) return n4(i3);
              await s2();
            } catch (e3) {
              if (!i2(e3, c4)) return o3(e3);
              if (c4 + 1 === r2.maxRetryCount) return o3(e3);
              await s2();
            }
          }
        });
        return c3.cancel = () => a3 = true, c3;
      }
      let WO, HO = class {
        constructor(e2) {
          Iw2(this, "input", []), Iw2(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e2;
          return 0 === this.input.length ? 0 : nr2(e2 = this.input).call(e2, (e3, t3) => e3 + t3) / this.input.length;
        }
      }, KO = 0, YO = 0;
      function zO(e2, t3, i2, n3) {
        return new ip2((r2, o2) => {
          t3.responseType = t3.responseType || "json", t3.data && !i2 ? (t3.data = JSON.stringify(t3.data), KO += RO(t3.data)) : i2 && (t3.data.size ? KO += t3.data.size : t3.data instanceof FormData ? KO += vO(t3.data) : KO += RO(JSON.stringify(t3.data))), t3.headers = t3.headers || {}, t3.headers["Content-Type"] = t3.headers["Content-Type"] || "application/json", t3.method = "POST", t3.url = e2, UA2.request(t3).then((e3) => {
            "string" == typeof e3.data ? YO += RO(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? YO += e3.data.byteLength : YO += RO(JSON.stringify(e3.data)), n3 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            UA2.isCancel(e3) ? o2(new Ow2(ww2.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new Ow2(ww2.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new Ow2(ww2.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new Ow2(ww2.NETWORK_ERROR, e3.message));
          });
        });
      }
      async function qO(e2, t3) {
        const i2 = new Blob([t3.data], { type: "buffer" });
        return await zO(e2, Aw2(Aw2({}, t3), {}, { data: i2, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const XO = () => void 0 !== window.isSecureContext;
      function JO(e2) {
        if (Array.isArray(e2)) return e2.map((e3) => e3);
        if (!ZO(e2)) return e2;
        const t3 = {};
        for (const i2 in e2) {
          const n3 = e2[i2];
          ZO(n3) || Array.isArray(n3) ? t3[i2] = JO(n3) : t3[i2] = n3;
        }
        return t3;
      }
      function ZO(e2) {
        return !("object" != typeof e2 || Array.isArray(e2) || !e2);
      }
      let QO = class {
        constructor(e2) {
          Iw2(this, "input", []), Iw2(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        diffMean() {
          return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }
      };
      const $O = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, eN = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: $O, remoteCandidate: $O }, updateInterval: 0 }, tN = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0, framesDroppedCount: 0, outputFrameRate: 0, packetsDiscarded: 0, framesAssembledFromMultiplePackets: 0, totalProcessingDelay: 0, avgDecodeMs: 0, avgFramesAssembledFromMultiplePacketsMs: 0, avgProcessingDelayMs: 0, avgInterFrameDelayMs: 0, totalAssemblyTime: 0 }, iN = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 }, nN = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 }, rN = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packetsDiscarded: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0, totalSamplesReceived: 0, silentConcealedSamples: 0, concealmentEvents: 0, freezeMs80: 0, freezeMs200: 0, freezeSamples80: 0, freezeSamples200: 0 };
      let oN = class {
        constructor(e2, t3) {
          Iw2(this, "onFirstVideoReceived", void 0), Iw2(this, "onFirstVideoDecoded", void 0), Iw2(this, "onFirstAudioReceived", void 0), Iw2(this, "onFirstVideoDecodedTimeout", void 0), Iw2(this, "onFirstAudioDecoded", void 0), Iw2(this, "onSelectedLocalCandidateChanged", void 0), Iw2(this, "onSelectedRemoteCandidateChanged", void 0), Iw2(this, "videoIsReady", false), Iw2(this, "videoIsReady2", {}), Iw2(this, "pc", void 0), Iw2(this, "options", void 0), Iw2(this, "intervalTimer", void 0), Iw2(this, "stats", JO(eN)), Iw2(this, "isFirstVideoReceived", {}), Iw2(this, "isFirstVideoDecoded", {}), Iw2(this, "isFirstAudioReceived", {}), Iw2(this, "isFirstAudioDecoded", {}), Iw2(this, "isFirstVideoDecodedTimeout", {}), Iw2(this, "lossRateWindowStats", []), this.pc = e2, this.options = t3, this.intervalTimer = window.setInterval(async () => {
            this.updateStats();
          }, this.options.updateInterval);
        }
        getStats() {
          return this.stats;
        }
        getSelectedCandidatePair() {
          return new ip2((e2) => {
            e2({ local: Aw2({}, $O), remote: Aw2({}, $O) });
          });
        }
        setVideoIsReady(e2) {
          this.videoIsReady = e2;
        }
        setVideoIsReady2(e2, t3) {
          this.videoIsReady2[e2] = t3;
        }
        getVideoIsReady(e2) {
          return this.videoIsReady2[e2] || false;
        }
        setIsFirstAudioDecoded(e2) {
        }
        destroy() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }
        calcLossRate(e2) {
          this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          const t3 = this.lossRateWindowStats.length, i2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
          let n3 = 0, r2 = 0, o2 = 0, s2 = 0;
          for (const a3 of i2) e2[a3].forEach((e3, i3) => {
            if (!this.lossRateWindowStats[t3 - 1][a3][i3] || !this.lossRateWindowStats[0][a3][i3]) return;
            const c3 = this.lossRateWindowStats[t3 - 1][a3][i3].packets - this.lossRateWindowStats[0][a3][i3].packets, d2 = this.lossRateWindowStats[t3 - 1][a3][i3].packetsLost - this.lossRateWindowStats[0][a3][i3].packetsLost;
            "videoSend" === a3 || "audioSend" === a3 ? (n3 += c3, o2 += d2) : (r2 += c3, s2 += d2), Number.isNaN(c3) || Number.isNaN(c3) ? e3.packetLostRate = 0 : e3.packetLostRate = c3 <= 0 || d2 <= 0 ? 0 : d2 / (c3 + d2);
          });
          e2.sendPacketLossRate = n3 <= 0 || o2 <= 0 ? 0 : o2 / (n3 + o2), e2.recvPacketLossRate = r2 <= 0 || s2 <= 0 ? 0 : s2 / (r2 + s2);
        }
      }, sN = class extends oN {
        constructor() {
          super(...arguments), Iw2(this, "_stats", eN), Iw2(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          const e2 = await this._getStats(), t3 = this.statsResponsesToObjects(e2);
          this._stats = JO(eN);
          const i2 = t3.filter((e3) => "ssrc" === e3.type);
          this.processSSRCStats(i2);
          const n3 = t3.find((e3) => "VideoBwe" === e3.type);
          n3 && this.processBandwidthStats(n3), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        processBandwidthStats(e2) {
          this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
        }
        processSSRCStats(e2) {
          e2.forEach((e3) => {
            var t3;
            const i2 = Ln2(t3 = e3.id).call(t3, "send");
            switch ("".concat(e3.mediaType, "_").concat(i2 ? "send" : "recv")) {
              case "video_send": {
                const t4 = JO(iN);
                t4.codec = e3.googCodecName, t4.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t4.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t4.adaptionChangeReason = "bandwidth"), t4.avgEncodeMs = Number(e3.googAvgEncodeMs), t4.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t4.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t4.firsCount = Number(e3.googFirReceived), t4.nacksCount = Number(e3.googNacksReceived), t4.plisCount = Number(e3.googPlisReceived), t4.frameCount = Number(e3.framesEncoded), t4.bytes = Number(e3.bytesSent), t4.packets = Number(e3.packetsSent), t4.packetsLost = Number(e3.packetsLost), t4.ssrc = Number(e3.ssrc), t4.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t4), this._stats.rtt = t4.rttMs;
                break;
              }
              case "video_recv": {
                const t4 = JO(tN), i3 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
                if (t4.codec = e3.googCodecName, t4.targetDelayMs = Number(e3.googTargetDelayMs), t4.renderDelayMs = Number(e3.googRenderDelayMs), t4.currentDelayMs = Number(e3.googCurrentDelayMs), t4.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t4.decodeMs = Number(e3.googDecodeMs), t4.maxDecodeMs = Number(e3.googMaxDecodeMs), t4.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t4.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t4.decodeFrameRate = Number(e3.googFrameRateDecoded), t4.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t4.jitterBufferMs = Number(e3.googJitterBufferMs), t4.firsCount = Number(e3.googFirsSent), t4.nacksCount = Number(e3.googNacksSent), t4.plisCount = Number(e3.googPlisSent), t4.framesDecodeCount = Number(e3.framesDecoded), t4.bytes = Number(e3.bytesReceived), t4.packets = Number(e3.packetsReceived), t4.packetsLost = Number(e3.packetsLost), t4.ssrc = Number(e3.ssrc), t4.packets > 0 && !this.isFirstVideoReceived[t4.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t4.ssrc), this.isFirstVideoReceived[t4.ssrc] = true), t4.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t4.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t4.ssrc, t4.decodedFrame.width, t4.decodedFrame.height), this.isFirstVideoDecoded[t4.ssrc] = true), i3) {
                  const n3 = i3.stats, r2 = Date.now() - i3.lts;
                  t4.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t4.framesDecodeInterval = n3.framesDecodeInterval, t4.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t4.ssrc] ? (i3.lts = Date.now(), t4.framesDecodeInterval = r2, t4.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t4.framesDecodeFreezeTime += t4.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t4.framesDecodeCount < i3.stats.framesDecodeCount && (t4.framesDecodeInterval = 0);
                }
                this.lastDecodeVideoReceiverStats.set(t4.ssrc, { stats: Aw2({}, t4), lts: Date.now() }), this._stats.videoRecv.push(t4);
                break;
              }
              case "audio_recv": {
                const t4 = JO(rN);
                t4.codec = e3.googCodecName, t4.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t4.decodingCNG = Number(e3.googDecodingCNG), t4.decodingCTN = Number(e3.googDecodingCTN), t4.decodingCTSG = Number(e3.googDecodingCTSG), t4.decodingNormal = Number(e3.googDecodingNormal), t4.decodingPLC = Number(e3.googDecodingPLC), t4.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t4.expandRate = Number(e3.googExpandRate), t4.accelerateRate = Number(e3.googAccelerateRate), t4.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t4.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t4.speechExpandRate = Number(e3.googSpeechExpandRate), t4.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t4.jitterBufferMs = Number(e3.googJitterBufferMs), t4.jitterMs = Number(e3.googJitterReceived), t4.bytes = Number(e3.bytesReceived), t4.packets = Number(e3.packetsReceived), t4.packetsLost = Number(e3.packetsLost), t4.ssrc = Number(e3.ssrc), t4.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t4.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t4.receivedFrames > 0 && !this.isFirstAudioReceived[t4.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t4.ssrc), this.isFirstAudioReceived[t4.ssrc] = true), t4.decodingNormal > 0 && !this.isFirstAudioDecoded[t4.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t4.ssrc), this.isFirstAudioDecoded[t4.ssrc] = true), this._stats.audioRecv.push(t4);
                break;
              }
              case "audio_send": {
                const t4 = JO(nN);
                t4.codec = e3.googCodecName, t4.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t4.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t4.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t4.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t4.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t4.bytes = Number(e3.bytesSent), t4.packets = Number(e3.packetsSent), t4.packetsLost = Number(e3.packetsLost), t4.ssrc = Number(e3.ssrc), t4.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t4.rttMs, this._stats.audioSend.push(t4);
                break;
              }
            }
          });
        }
        _getStats() {
          return new ip2((e2, t3) => {
            this.pc.getStats(e2, t3);
          });
        }
        statsResponsesToObjects(e2) {
          const t3 = [];
          return e2.result().forEach((e3) => {
            const i2 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
            e3.names().forEach((t4) => {
              i2[t4] = e3.stat(t4);
            }), t3.push(i2);
          }), t3;
        }
      }, aN = function(e2) {
        return e2.BANDWIDTH = "bandwidth", e2.CPU = "cpu", e2.NONE = "none", e2.OTHER = "other", e2;
      }({}), cN = function(e2) {
        return e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L1T3_KEY = "L1T3_KEY", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY", e2;
      }({}), dN = function(e2) {
        return e2[e2.new = 0] = "new", e2[e2.connecting = 1] = "connecting", e2[e2.connected = 2] = "connected", e2[e2.disconnected = 3] = "disconnected", e2[e2.failed = 4] = "failed", e2[e2.closed = 5] = "closed", e2;
      }({}), lN = function(e2) {
        return e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver", e2;
      }({});
      var uN = function(e2) {
        return e2[e2.kNone = 1] = "kNone", e2[e2.kMillisecondsFromSeconds = 1e3] = "kMillisecondsFromSeconds", e2[e2.kBytesToBits = 8] = "kBytesToBits", e2;
      }(uN || {});
      function hN(e2, t3, i2, n3) {
        let r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : uN.kNone;
        if (!t3) return;
        const o2 = Number(t3[i2]);
        if ("number" != typeof o2) return;
        const s2 = Number(t3[n3]);
        if ("number" != typeof s2) return;
        if (!e2) return s2 ? o2 / s2 * r2 : void 0;
        const a3 = Number(e2[i2]);
        if ("number" != typeof a3) return;
        const c3 = Number(e2[n3]);
        if ("number" != typeof c3) return;
        const d2 = s2 - c3;
        return d2 ? (o2 - a3) / d2 * r2 : void 0;
      }
      let pN = class extends oN {
        constructor() {
          super(...arguments), Iw2(this, "_stats", eN), Iw2(this, "report", void 0), Iw2(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), Iw2(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), Iw2(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), Iw2(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), Iw2(this, "lastVideoFramesOutput", /* @__PURE__ */ new Map()), Iw2(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), Iw2(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), Iw2(this, "mediaBytesSent", /* @__PURE__ */ new Map()), Iw2(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), Iw2(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), Iw2(this, "lastDecodeAudioReceiverStats", /* @__PURE__ */ new Map()), Iw2(this, "lastAudioConcealment", /* @__PURE__ */ new Map()), Iw2(this, "lastEncoderMs", /* @__PURE__ */ new Map());
        }
        async updateStats() {
          this.report = await this.pc.getStats(), this._stats = JO(eN), this.report.forEach((e2) => {
            switch (e2.type) {
              case lN.OUTBOUND:
              case lN.INBOUND: {
                const t3 = e2.mediaType || e2.kind, i2 = !t3 && "frameWidth" in e2, n3 = !t3 && !("frameWidth" in e2);
                e2.type === lN.OUTBOUND ? "audio" === t3 || n3 ? this.processAudioOutboundStats(e2) : ("video" === t3 || i2) && this.processVideoOutboundStats(e2) : e2.type === lN.INBOUND && ("audio" === t3 || n3 ? this.processAudioInboundStats(e2) : ("video" === t3 || i2) && this.processVideoInboundStats(e2));
                break;
              }
              case lN.TRANSPORT: {
                const t3 = this.report.get(e2.selectedCandidatePairId);
                t3 && this.processCandidatePairStats(t3);
                break;
              }
              case lN.CANDIDATE_PAIR:
                e2.selected && this.processCandidatePairStats(e2);
            }
          }), this.updateSendBitrate(), this._stats.updateInterval = Date.now() - this.stats.timestamp, this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
        }
        async getSelectedCandidatePair() {
          const e2 = await this.pc.getStats(), t3 = { local: Aw2({}, $O), remote: Aw2({}, $O) };
          return e2.forEach((i2) => {
            let n3;
            if (i2.type === lN.TRANSPORT && (n3 = e2.get(i2.selectedCandidatePairId)), i2.type === lN.CANDIDATE_PAIR && i2.selected && (n3 = i2), n3) {
              const i3 = (e3, t4) => {
                e3.type = t4.type, e3.id = t4.id, t4.address && (e3.address = t4.address), t4.candidateType && (e3.candidateType = t4.candidateType), t4.port && (e3.port = t4.port), t4.priority && (e3.priority = t4.priority), t4.protocol && (e3.protocol = t4.protocol), t4.relayProtocol && (e3.relayProtocol = t4.relayProtocol);
              };
              if (n3.localCandidateId) {
                const r2 = e2.get(n3.localCandidateId);
                r2 && i3(t3.local, r2);
              }
              if (n3.remoteCandidateId) {
                const r2 = e2.get(n3.remoteCandidateId);
                r2 && i3(t3.remote, r2);
              }
            }
          }), t3;
        }
        processCandidatePairStats(e2) {
          if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach((t3) => {
            e2.currentRoundTripTime && (t3.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.audioSend.forEach((t3) => {
            e2.currentRoundTripTime && (t3.rttMs = 1e3 * e2.currentRoundTripTime);
          }), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
            const t3 = this.report.get(e2.localCandidateId);
            t3 && this.processCandidateStats(t3);
          }
          if (e2.remoteCandidateId) {
            const t3 = this.report.get(e2.remoteCandidateId);
            t3 && this.processCandidateStats(t3);
          }
        }
        processCandidateStats(e2) {
          let t3;
          e2.type === lN.LOCAL_CANDIDATE && (t3 = this._stats.selectedCandidatePair.localCandidate), e2.type === lN.REMOTE_CANDIDATE && (t3 = this._stats.selectedCandidatePair.remoteCandidate), t3 && (t3.type = e2.type, t3.id = e2.id, e2.address && (t3.address = e2.address), e2.candidateType && (t3.candidateType = e2.candidateType), e2.port && (t3.port = e2.port), e2.priority && (t3.priority = e2.priority), e2.protocol && (t3.protocol = e2.protocol), e2.relayProtocol && (t3.relayProtocol = e2.relayProtocol), e2.type === lN.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t3.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(Aw2({}, t3), Aw2({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === lN.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t3.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(Aw2({}, t3), Aw2({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }
        processAudioInboundStats(e2) {
          let t3 = this._stats.audioRecv.find((t4) => t4.ssrc === e2.ssrc);
          t3 || (t3 = JO(rN), this._stats.audioRecv.push(t3)), t3.ssrc = e2.ssrc, t3.packets = e2.packetsReceived, t3.packetsLost = e2.packetsLost, t3.packetsDiscarded = e2.packetsDiscarded, t3.bytes = e2.bytesReceived, t3.jitterMs = 1e3 * e2.jitter, t3.retransmittedBytesReceived = e2.retransmittedBytesReceived, t3.retransmittedPacketsReceived = e2.retransmittedPacketsReceived, t3.totalProcessingDelay = e2.totalProcessingDelay, t3.jitterBufferEmittedCount = e2.jitterBufferEmittedCount;
          const i2 = this.lastDecodeAudioReceiverStats.get(t3.ssrc);
          t3.avgProcessingDelayMs = hN(i2, t3, "totalProcessingDelay", "jitterBufferEmittedCount", uN.kMillisecondsFromSeconds), this.processAudioTrackReceiverStats(e2, e2.trackId, t3), this.calculateAudioFreeze(t3, i2, e2), e2.codecId && (t3.codec = this.getCodecFromCodecStats(e2.codecId)), t3.receivedFrames || (t3.receivedFrames = e2.packetsReceived), t3.droppedFrames || (t3.droppedFrames = e2.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.outputLevel && t3.outputLevel > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), "number" == typeof e2.concealedSamples && (t3.concealedSamples = e2.concealedSamples), this.lastDecodeAudioReceiverStats.set(t3.ssrc, Aw2({}, t3));
        }
        calculateAudioFreeze(e2, t3, i2) {
          const n3 = this.lastAudioConcealment.get(e2.ssrc);
          if (null != t3 && null != n3) {
            const r2 = n3.lts, o2 = i2.timestamp, s2 = o2 - r2;
            if (s2 <= 0) return;
            const a3 = e2.concealedSamples - t3.concealedSamples - 0, c3 = n3.nonSilent + a3, d2 = e2.totalSamplesReceived - t3.totalSamplesReceived;
            if (d2 <= 0) return;
            const l2 = 80 * d2 / s2, u3 = 200 * d2 / s2, h2 = s2 / d2;
            let p2 = 0;
            e2.freezeSamples80 = t3.freezeSamples80, e2.freezeMs80 = t3.freezeMs80, c3 > l2 && (n3.plc80 > 0 ? (e2.freezeSamples80 += a3, e2.freezeMs80 += Math.round(a3 * h2)) : (e2.freezeSamples80 += c3, e2.freezeMs80 += Math.round(c3 * h2)), p2 = n3.plc80 + 1);
            let _2 = 0;
            e2.freezeSamples200 = t3.freezeSamples200, e2.freezeMs200 = t3.freezeMs200, c3 > u3 && (n3.plc200 > 0 ? (e2.freezeSamples200 += a3, e2.freezeMs200 += Math.round(a3 * h2)) : (e2.freezeSamples200 += c3, e2.freezeMs200 += Math.round(c3 * h2)), _2 = n3.plc200 + 1), this.lastAudioConcealment.set(e2.ssrc, { nonSilent: a3, lts: o2, plc80: p2, plc200: _2 });
          } else e2.freezeSamples80 = 0, e2.freezeSamples200 = 0, e2.freezeMs80 = 0, e2.freezeMs200 = 0, this.lastAudioConcealment.set(e2.ssrc, { nonSilent: 0, lts: i2.timestamp, plc80: 0, plc200: 0 });
        }
        processVideoInboundStats(e2) {
          let t3 = this._stats.videoRecv.find((t4) => t4.ssrc === e2.ssrc);
          t3 || (t3 = JO(tN), this._stats.videoRecv.push(t3)), t3.ssrc = e2.ssrc, t3.packets = e2.packetsReceived, t3.packetsLost = e2.packetsLost, t3.bytes = e2.bytesReceived, t3.firsCount = e2.firCount, t3.nacksCount = e2.nackCount, t3.plisCount = e2.pliCount, t3.framesDecodeCount = e2.framesDecoded, t3.framesDroppedCount = e2.framesDropped, t3.totalInterFrameDelay = e2.totalInterFrameDelay, t3.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay, t3.totalFreezesDuration = e2.totalFreezesDuration, t3.totalProcessingDelay = e2.totalProcessingDelay, t3.packetsDiscarded = e2.packetsDiscarded, t3.framesAssembledFromMultiplePackets = e2.framesAssembledFromMultiplePackets, t3.totalAssemblyTime = e2.totalAssemblyTime, t3.keyFramesDecoded = e2.keyFramesDecoded, t3.retransmittedBytesReceived = e2.retransmittedBytesReceived, t3.retransmittedPacketsReceived = e2.retransmittedPacketsReceived;
          const i2 = this.lastDecodeVideoReceiverStats.get(t3.ssrc), n3 = this.lastVideoFramesDecode.get(t3.ssrc), r2 = this.lastVideoFramesOutput.get(t3.ssrc), o2 = Date.now();
          if (t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc]) {
            const e3 = t3.decodedFrame ? t3.decodedFrame.width : 0, i3 = t3.decodedFrame ? t3.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, e3, i3), this.isFirstVideoDecoded[t3.ssrc] = true;
          }
          if (i2) {
            const n4 = i2.stats, r3 = o2 - i2.lts;
            t3.framesDecodeFreezeTime = n4.framesDecodeFreezeTime, t3.framesDecodeInterval = n4.framesDecodeInterval, !this.isFirstVideoDecoded[t3.ssrc] && r3 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t3.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t3.ssrc), this.isFirstVideoDecodedTimeout[t3.ssrc] = true), t3.framesDecodeCount > n4.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i2.lts = Date.now(), t3.framesDecodeInterval = r3, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t3.framesDecodeCount < n4.framesDecodeCount && (t3.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i2.stats.framesDecodeCount > e2.framesDecoded ? t3.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t3.qpSumPerFrame = (e2.qpSum - i2.qpSum) / (e2.framesDecoded - i2.stats.framesDecodeCount));
          }
          e2.totalDecodeTime && (t3.decodeMs = 1e3 * e2.totalDecodeTime, t3.avgDecodeMs = hN(null == i2 ? void 0 : i2.stats, t3, "decodeMs", "framesDecodeCount")), t3.avgProcessingDelayMs = hN(null == i2 ? void 0 : i2.stats, t3, "totalProcessingDelay", "framesDecodeCount", uN.kMillisecondsFromSeconds), t3.avgFramesAssembledFromMultiplePacketsMs = hN(null == i2 ? void 0 : i2.stats, t3, "totalAssemblyTime", "framesAssembledFromMultiplePackets", uN.kMillisecondsFromSeconds), t3.avgInterFrameDelayMs = hN(null == i2 ? void 0 : i2.stats, t3, "totalInterFrameDelay", "framesDecodeCount", uN.kMillisecondsFromSeconds), n3 && o2 - n3.lts >= 800 ? (t3.decodeFrameRate = Math.round((t3.framesDecodeCount - n3.count) / ((o2 - n3.lts) / 1e3)), this.lastVideoFramesDecode.set(t3.ssrc, { count: t3.framesDecodeCount, lts: o2, rate: t3.decodeFrameRate })) : n3 ? t3.decodeFrameRate = n3.rate : this.lastVideoFramesDecode.set(t3.ssrc, { count: t3.framesDecodeCount, lts: o2, rate: 0 }), t3.framesDroppedCount && e2.framesReceived && (r2 && o2 - r2.lts >= 800 ? (t3.outputFrameRate = Math.round((e2.framesReceived - t3.framesDroppedCount - r2.count) / ((o2 - r2.lts) / 1e3)), this.lastVideoFramesOutput.set(t3.ssrc, { count: e2.framesReceived - t3.framesDroppedCount, lts: o2, rate: Math.max(t3.outputFrameRate, 0) })) : r2 ? t3.outputFrameRate = r2.rate : this.lastVideoFramesOutput.set(t3.ssrc, { count: e2.framesReceived - t3.framesDroppedCount, lts: o2, rate: 0 })), this.processVideoTrackReceiverStats(e2, e2.trackId, t3), e2.codecId && (t3.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t3.framesRateFirefox = e2.framerateMean), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: Aw2({}, t3), lts: i2 ? i2.lts : Date.now(), qpSum: e2.qpSum });
        }
        processVideoOutboundStats(e2) {
          let t3 = this._stats.videoSend.find((t4) => t4.ssrc === e2.ssrc);
          t3 || (t3 = JO(iN), this._stats.videoSend.push(t3));
          const i2 = this.mediaBytesSent.get(e2.ssrc);
          if (i2) i2.add(e2.bytesSent);
          else {
            const t4 = new QO(10);
            t4.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t4);
          }
          if (void 0 !== e2.retransmittedBytesSent) {
            const t4 = this.mediaBytesRetransmit.get(e2.ssrc);
            if (t4) t4.add(e2.retransmittedBytesSent);
            else {
              const t5 = new QO(10);
              t5.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t5);
            }
          }
          if (e2.totalEncodedBytesTarget) {
            const t4 = this.mediaBytesTargetEncode.get(e2.ssrc);
            if (t4) t4.add(e2.totalEncodedBytesTarget);
            else {
              const t5 = new QO(10);
              t5.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t5);
            }
          }
          if (t3.ssrc = e2.ssrc, t3.bytes = e2.bytesSent, t3.packets = e2.packetsSent, t3.firsCount = e2.firCount, t3.nacksCount = e2.nackCount, t3.plisCount = e2.pliCount, t3.frameCount = e2.framesEncoded, t3.adaptionChangeReason = e2.qualityLimitationReason, t3.scalabilityMode = e2.scalabilityMode, t3.retransmittedBytesSent = e2.retransmittedBytesSent, t3.retransmittedPacketsSent = e2.retransmittedPacketsSent, t3.hugeFramesSent = e2.hugeFramesSent, t3.keyFramesEncoded = e2.keyFramesEncoded, t3.targetBitrate = e2.targetBitrate, e2.totalEncodeTime && e2.framesEncoded) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            if (!i3 || i3.lastFrameCount > e2.framesEncoded) t3.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
            else {
              const n3 = e2.framesEncoded - i3.lastFrameCount, r2 = e2.totalEncodeTime - i3.lastEncoderTime;
              t3.avgEncodeMs = 1e3 * r2 / n3;
            }
          }
          if (e2.framesEncoded && e2.qpSum) {
            const i3 = this.lastEncoderMs.get(e2.ssrc);
            !i3 || i3.lastFrameCount > e2.framesEncoded ? t3.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t3.qpSumPerFrame = (e2.qpSum - i3.lastQpSum) / (e2.framesEncoded - i3.lastFrameCount);
          }
          if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t3.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t3), this.processVideoTrackSenderStats(e2, e2.trackId, t3), e2.remoteId) this.processRemoteInboundStats(e2.remoteId, t3);
          else {
            const i3 = this.findRemoteStatsId(e2.ssrc, lN.REMOTE_INBOUND);
            i3 && this.processRemoteInboundStats(i3, t3);
          }
        }
        processAudioOutboundStats(e2) {
          let t3 = this._stats.audioSend.find((t4) => t4.ssrc === e2.ssrc);
          if (t3 || (t3 = JO(nN), this._stats.audioSend.push(t3)), t3.ssrc = e2.ssrc, t3.packets = e2.packetsSent, t3.bytes = e2.bytesSent, t3.retransmittedBytesSent = e2.retransmittedBytesSent, t3.retransmittedPacketsSent = e2.retransmittedPacketsSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t3), e2.codecId && (t3.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t3), e2.remoteId) this.processRemoteInboundStats(e2.remoteId, t3);
          else {
            const i2 = this.findRemoteStatsId(e2.ssrc, lN.REMOTE_INBOUND);
            i2 && this.processRemoteInboundStats(i2, t3);
          }
        }
        findRemoteStatsId(e2, t3) {
          var i2;
          const n3 = Array.from(up2(i2 = this.report).call(i2)).find((i3) => i3.type === t3 && i3.ssrc === e2);
          return n3 ? n3.id : null;
        }
        processVideoMediaSource(e2, t3) {
          const i2 = this.report.get(e2);
          i2 && i2.width && i2.height && i2.framesPerSecond && (t3.inputFrame = { width: i2.width, height: i2.height, frameRate: i2.framesPerSecond });
        }
        processAudioMediaSource(e2, t3) {
          const i2 = this.report.get(e2);
          i2 && (t3.inputLevel = i2.audioLevel);
        }
        processVideoTrackSenderStats(e2, t3, i2) {
          var n3, r2, o2, s2;
          const a3 = t3 ? this.report.get(t3) : void 0, c3 = null !== (n3 = null == a3 ? void 0 : a3.framesSent) && void 0 !== n3 ? n3 : e2.framesSent;
          if ("number" != typeof c3) return;
          let d2 = null !== (r2 = null == a3 ? void 0 : a3.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (o2 = null == a3 ? void 0 : a3.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, u3 = null !== (s2 = null == a3 ? void 0 : a3.framesPerSecond) && void 0 !== s2 ? s2 : e2.framesPerSecond;
          if ("number" == typeof d2 && "number" == typeof l2 || (d2 = 0, l2 = 0), null == u3) {
            const e3 = Date.now(), t4 = this.lastVideoFramesSent.get(i2.ssrc);
            t4 && e3 - t4.lts >= 800 ? (u3 = Math.round((c3 - t4.count) / ((e3 - t4.lts) / 1e3)), this.lastVideoFramesSent.set(i2.ssrc, { count: c3, lts: e3, rate: u3 })) : t4 ? u3 = t4.rate : this.lastVideoFramesSent.set(i2.ssrc, { count: c3, lts: e3, rate: 0 });
          }
          i2.sentFrame = { width: d2, height: l2, frameRate: Math.max(0, u3) };
        }
        processVideoTrackReceiverStats(e2, t3, i2) {
          var n3, r2, o2, s2, a3;
          const c3 = t3 ? this.report.get(t3) : void 0, d2 = null !== (n3 = null == c3 ? void 0 : c3.framesReceived) && void 0 !== n3 ? n3 : e2.framesReceived, l2 = null !== (r2 = null == c3 ? void 0 : c3.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, u3 = null !== (o2 = null == c3 ? void 0 : c3.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, h2 = null !== (s2 = null == c3 ? void 0 : c3.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, p2 = null !== (a3 = null == c3 ? void 0 : c3.jitterBufferEmittedCount) && void 0 !== a3 ? a3 : e2.jitterBufferEmittedCount;
          if ("number" == typeof d2) {
            const e3 = this.lastVideoFramesRecv.get(i2.ssrc), t4 = Date.now();
            i2.framesReceivedCount = d2;
            let n4 = 0;
            e3 && t4 - e3.lts >= 800 ? (n4 = Math.round((d2 - e3.count) / ((t4 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t4, rate: n4 })) : e3 ? n4 = e3.rate : this.lastVideoFramesRecv.set(i2.ssrc, { count: d2, lts: t4, rate: 0 }), i2.receivedFrame = { width: l2 || 0, height: u3 || 0, frameRate: n4 || 0 }, i2.decodedFrame = { width: l2 || 0, height: u3 || 0, frameRate: i2.decodeFrameRate || 0 }, i2.outputFrame = { width: l2 || 0, height: u3 || 0, frameRate: i2.outputFrameRate || i2.decodeFrameRate || 0 };
          }
          if (h2 && p2) {
            const e3 = this.lastVideoJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t4 = e3.jitterBufferMs;
            const n4 = p2 - e3.jitterBufferEmittedCount;
            n4 > 0 && (t4 = 1e3 * (h2 - e3.jitterBufferDelay) / n4), i2.jitterBufferMs = t4, i2.currentDelayMs = Math.round(t4), this.lastVideoJBDelay.set(i2.ssrc, { jitterBufferDelay: h2, jitterBufferEmittedCount: p2, jitterBufferMs: i2.currentDelayMs });
          }
        }
        processAudioTrackSenderStats(e2, t3, i2) {
          var n3, r2, o2, s2;
          const a3 = t3 ? this.report.get(t3) : void 0, c3 = null !== (n3 = null !== (r2 = null == a3 ? void 0 : a3.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n3 ? n3 : 0, d2 = null !== (o2 = null !== (s2 = null == a3 ? void 0 : a3.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : e2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : 0;
          i2.aecReturnLoss = c3, i2.aecReturnLossEnhancement = d2;
        }
        processAudioTrackReceiverStats(e2, t3, i2) {
          var n3, r2, o2, s2, a3, c3, d2, l2, u3;
          const h2 = t3 ? this.report.get(t3) : void 0, p2 = null !== (n3 = null == h2 ? void 0 : h2.removedSamplesForAcceleration) && void 0 !== n3 ? n3 : e2.removedSamplesForAcceleration, _2 = null !== (r2 = null == h2 ? void 0 : h2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, E3 = null !== (o2 = null == h2 ? void 0 : h2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, m3 = null !== (s2 = null == h2 ? void 0 : h2.jitterBufferEmittedCount) && void 0 !== s2 ? s2 : e2.jitterBufferEmittedCount, f2 = null !== (a3 = null == h2 ? void 0 : h2.audioLevel) && void 0 !== a3 ? a3 : null == e2 ? void 0 : e2.audioLevel, S3 = null !== (c3 = null == h2 ? void 0 : h2.totalSamplesDuration) && void 0 !== c3 ? c3 : null == e2 ? void 0 : e2.totalSamplesDuration, g2 = null !== (d2 = null == h2 ? void 0 : h2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples, T3 = null !== (l2 = null == h2 ? void 0 : h2.silentConcealedSamples) && void 0 !== l2 ? l2 : e2.silentConcealedSamples, R3 = null !== (u3 = null == h2 ? void 0 : h2.concealmentEvents) && void 0 !== u3 ? u3 : e2.concealmentEvents;
          if ("number" == typeof _2 && (i2.totalSamplesReceived = _2), "number" == typeof T3 && (i2.silentConcealedSamples = T3), "number" == typeof R3 && (i2.concealmentEvents = R3), "number" == typeof g2 && (i2.concealedSamples = g2), p2 && _2 && (i2.accelerateRate = p2 / _2), E3 && m3) {
            const e3 = this.lastAudioJBDelay.get(i2.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 };
            let t4 = e3.jitterBufferMs;
            const n4 = m3 - e3.jitterBufferEmittedCount;
            n4 > 0 && (t4 = 1e3 * (E3 - e3.jitterBufferDelay) / n4), i2.jitterBufferMs = Math.round(t4), this.lastAudioJBDelay.set(i2.ssrc, { jitterBufferDelay: E3, jitterBufferEmittedCount: m3, jitterBufferMs: i2.jitterBufferMs });
          }
          i2.outputLevel = f2;
          let v3 = 1920;
          S3 && _2 && (v3 = _2 / S3 / 50, i2.receivedFrames = Math.round(_2 / v3)), g2 && (i2.droppedFrames = Math.round(g2 / v3));
        }
        processRemoteInboundStats(e2, t3) {
          const i2 = this.report.get(e2);
          i2 && (t3.packetsLost = i2.packetsLost, i2.roundTripTime && (t3.rttMs = 1e3 * i2.roundTripTime), i2.jitter && (t3.jitterMs = 1e3 * i2.jitter), i2.timestamp && (t3.timestamp = i2.timestamp));
        }
        getCodecFromCodecStats(e2) {
          const t3 = this.report.get(e2);
          if (!t3) return "";
          const i2 = t3.mimeType.match(/\/(.*)$/);
          return i2 && i2[1] ? i2[1] : "";
        }
        updateSendBitrate() {
          let e2 = 0, t3 = null, i2 = null;
          this.mediaBytesSent.forEach((t4) => {
            e2 += t4.diffMean();
          }), this.mediaBytesRetransmit.forEach((e3) => {
            t3 = null === t3 ? e3.diffMean() : t3 + e3.diffMean();
          }), this.mediaBytesTargetEncode.forEach((e3) => {
            i2 = null === i2 ? e3.diffMean() : i2 + e3.diffMean();
          });
          const n3 = null !== t3 ? e2 - t3 : e2;
          this._stats.bitrate = { actualEncoded: 8 * n3 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t3 && (this._stats.bitrate.retransmit = 8 * t3 / (this.options.updateInterval / 1e3)), null !== i2 && (this._stats.bitrate.targetEncoded = 8 * i2 / (this.options.updateInterval / 1e3));
        }
      }, _N = class extends oN {
        updateStats() {
          return ip2.resolve();
        }
      };
      function EN(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
        const o2 = function() {
          const e3 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
          return e3 && e3[0] ? Number(e3[0].split("/")[1]) : null;
        }();
        return o2 ? o2 < 76 ? new sN(e2, { updateInterval: t3, lossRateInterval: i2, freezeRateLimit: n3, firstVideoDecodedTimeout: r2 }) : new pN(e2, { updateInterval: t3, lossRateInterval: i2, freezeRateLimit: n3, firstVideoDecodedTimeout: r2 }) : function(e3) {
          if (!window.RTCStatsReport) return false;
          const t4 = e3.getStats();
          return !!(t4 instanceof ip2 || function(e4) {
            return !!e4 && ("object" == typeof e4 || "function" == typeof e4) && "function" == typeof e4.then;
          }(t4));
        }(e2) ? new pN(e2, { updateInterval: t3, lossRateInterval: i2, freezeRateLimit: n3, firstVideoDecodedTimeout: r2 }) : new _N(e2, { updateInterval: t3, lossRateInterval: i2, freezeRateLimit: n3, firstVideoDecodedTimeout: r2 });
      }
      const mN = "websdk_ng_install_id";
      function fN() {
        try {
          if (wN("INSTALL_ID")) return wN("INSTALL_ID");
          let e2 = window.localStorage.getItem(mN);
          return e2 || (e2 = bO(), window.localStorage.setItem(mN, e2)), AN("INSTALL_ID", e2), e2;
        } catch (e2) {
          return;
        }
      }
      const SN = function(e2) {
        if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e2;
        const t3 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-([0-9]+)/);
        if (t3 && t3[1] && t3[2]) {
          const e3 = t3[1], i2 = t3[2];
          return "".concat(e3, ".").concat(i2);
        }
        return "4.0.0.999";
      }("4.24.0"), gN = function() {
        try {
          return true === JSON.parse("true");
        } catch (e2) {
          return true;
        }
      }();
      let TN = function(e2) {
        return e2.Default = "default", e2.Auto = "auto", e2.Relay = "relay", e2.SdRtn = "sd-rtn", e2;
      }({});
      const RN = function() {
        const e2 = "us".concat("erna", "me"), t3 = "pa".concat("sswo", "rd"), i2 = ["t", "s", "t"];
        i2.splice(1, 0, "e");
        const n3 = i2.join(""), r2 = [];
        for (let e3 = 0; e3 < 6; e3++) r2.push("1");
        const o2 = r2.join(""), s2 = {};
        return s2[e2] = n3, s2[t3] = o2, Object.assign(s2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
      }();
      window.DEFAULT_TURN_CONFIG = RN;
      const vN = { ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, ENABLE_USER_LICENSE_CHECK: true, DISABLE_FEC: void 0, ENABLE_NTP_REPORT: false, ENABLE_INSTANT_VIDEO: false, ENABLE_USER_AUTO_REBALANCE_CHECK: true, ENABLE_LOSSBASED_BWE: true, ENABLE_AUT_CC: true, FORCE_ENABLE_AUT_CC: false, ENABLE_CC_FALLBACK: void 0, SUBSCRIBE_TWCC: true, PUBLISH_TWCC: false, ENABLE_SVC_DEFAULT_CODECS: ["H264", "VP8", "VP9", "AV1"], SVC: [], ENABLE_FULL_LINK_AV_SYNC: false, SVC_MODE: null, PRE_SUB_NUM: 1, ENABLE_AUT_FEEDBACK: true, SVC_EXTENDED: ["VP9"] }, CN = { MIN_FRAME_RATE: 1, MAX_FRAME_RATE: 30, MAX_THRESHOLD_FRAMERATE: 30, BITRATE_MIN_THRESHOLD: 100, BITRATE_MAX_THRESHOLD: 100, MAX_SCALE: 5, BWE_SCALE_UP_THRESHOLD: 0.6, BWE_SCALE_DOWN_THRESHOLD: 0.6, PERF_SCALE_UP_THRESHOLD: 0.7, PERF_SCALE_DOWN_THRESHOLD: 0.6, MOTION_RESOLUTION_FACTOR: 0.8, MOTION_BITRATE_FACTOR: 0.6, DETAIL_FRAMERATE_FACTOR: 0.8, DETAIL_BITRATE_FACTOR: 0.6, BALANCE_RESOLUTION_FACTOR: 0.9, BALANCE_FRAMERATE_FACTOR: 0.9, BALANCE_BITRATE_FACTOR: 0.6, OVERUSE_TIMES_THRESHOLD: 10, UNDERUSE_TIMES_THRESHOLD: 40 }, yN = "v4.24.0-0-gf2267710-dirty(7/31/2025, 7:00:42 PM)", IN = { ENABLE_EVENT_REPORT: true, UPLOAD_LOG: false, ENABLE_AG_ADAPTATION: true, FORCE_AG_HIGH_FRAMERATE: false, FORCE_SUPPORT_AG_ADAPTATION: false, ENCODER_CONFIG_LIMIT: {}, CAMERA_CAPTURE_CONFIG: void 0, ENABLE_PRELOAD: true, NEW_ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, RESTART_SEQUENCE: ["udp_tcp_relay", "relay"], FIRST_TCP_CANDIDATE: false, FIRST_TCP_CANDIDATE_INTERVAL: 1e3, TURN_DOMAIN: "edge.agora.io", USE_TURN_IP: true, NEW_TURN_MODE: 4, NEW_FORCE_TURN: false, USE_NEW_RENDER_FREEZE_TIME: false, ENCODE_EXCEPTION_TIMES: 5, ENABLE_ENCODE_EXCEPTION: true, ENCODE_EXCEPTION_VALIDATE_CODEC: ["h264"], VIDEO_ENCODER_CONFIG_LIST: [{ width: 240, height: 180 }, { width: 320, height: 240 }, { width: 400, height: 300 }, { width: 480, height: 360 }, { width: 560, height: 420 }, { width: 640, height: 480 }], DELETE_NEQ_AFTER_USER_LEAVE: true }, bN = Aw2(Aw2(Aw2(Aw2({}, IN), {}, { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, NOT_REPORT_EVENT: [], PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, SHOW_REPORT_USER_INVOKER_LOG: true, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], CONNECT_GATEWAY_WITHOUT_DOMAIN: false, WORKER_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 250, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: false, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: { excludedLinks: [] }, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, FIRST_H264_PROFILE_LEVEL_ID: "42001f", FIRST_PACKETIZATION_MODE: "", X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, FINGERPRINT: null, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, ENABLE_AUDIO_TOPN: false, ENABLE_AUDIO_METADATA: false, ENABLE_AUDIO_PTS: false, TOPN_SMOOTH_LEVEL: void 0, TOPN_NEW_SPEAKER_DELAY: void 0, TOPN_SWITCH_HOLD_MS: void 0, TOPN_AUDIO_GAIN: void 0, TOPN_SILENCE_THRESHOLD: 250, AP_AREA: true, ENABLE_ENCODED_TRANSFORM: false, ENABLE_VIDEO_SEI: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, DATASTREAM_MAX_RETRANSMITS: 10, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3, SHOW_P2P_LOG: false, MAX_P2P_TIMEOUT: 3e4, P2P_TOKEN_INTERVAL: 1e3, SHOW_DATASTREAM2_LOG: false, RESTRICTION_SET_PLAYBACK_DEVICE: true, USE_PURE_ENCRYPTION_MASTER_KEY: false, ENABLE_AUDIO_RED: false, OPUS_PTIME: void 0, AUDIO_DUPLICATE_NUM: void 0, ENABLE_ABSSENDTIME_AS_SENTTS: true, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [], UNSUPPORTED_VIDEO_UPLINK_CODEC: [], UNSUPPORTED_VIDEO_DOWNLINK_CODEC: [], USE_NEW_NETWORK_CONFIG: false, AUTO_RESET_AUDIO_ROUTE: false, PLUGIN_INFO: [], OVERUSE_DETECTOR_PARAMS: CN, CUSTOM_ADAPTATION_DEFAULT_MODE: "", HIDE_NO_POSTER: false, AP_CACHE_NUM: 10, AP_UPDATE_INTERVAL: 12e4, AP_CACHE_LIFETIME: 12e4, MAX_PRELOAD_ASYNC_LENGTH: 3, DISABLE_SCREEN_SHARE_REMB: false }, vN), {}, { USE_CANDIDATE_FROM_AP_DETAIL: false, AP_REQUEST_DETAIL: void 0, ENABLE_ROLE_SELECT_EDGE: false, CLIENT_ROLE_OPTIONS: void 0, COMPATIBLE_SDP_EXTENSION: ["gdpr_forbidden"], LIMIT_BITRATE: void 0, EXPERIMENTS: {}, USE_PUB_RTX: true, USE_SUB_RTX: true, ENABLE_DATASTREAM_2: false, USE_XR: true, ENABLE_PREALLOC_PC: false, ENABLE_PRE_SUB: false, ENABLE_SVC: false, ENABLE_PRE_RENDER: false, FORCE_DISABLE_AUTO_SUB: false, ENABLE_PRE_SUB_WITH_PRE_PC: false, PRE_USE_LOCAL_CODECS: true }, { INSTALL_ID: "" }), {}, { K_MIN_RENDER_DELAY: 66, USE_STANDARD_BITRATE_DEFAULT: false, VIDEO_NEW_BITRATE_RATIO: void 0, VIDEO_STANDARD_BITRATE_VERSION: 2, BASELINE_MORE_H264_BITRATE_RATIO: 1.1 });
      function AN(e2, t3, i2) {
        var n3, r2, o2;
        Ln2(n3 = Object.keys(bN)).call(n3, e2) && (!i2 && Ln2(r2 = Object.keys(NN)).call(r2, e2) || (bN[e2] = t3, "ENABLE_VIDEO_SEI" !== e2 && "ENABLE_AUDIO_TOPN" !== e2 && "ENABLE_AUDIO_METADATA" !== e2 && "ENABLE_AUDIO_PTS" !== e2 || true !== t3 || (bN.ENABLE_ENCODED_TRANSFORM = true), "USE_NEW_NETWORK_CONFIG" === e2 && t3 && (o2 = !!t3, bN.USE_NEW_NETWORK_CONFIG = o2, o2 && (bN.WEBCS_DOMAIN = ["webrtc2-2.ap.sd-rtn.com"], bN.WEBCS_DOMAIN_BACKUP_LIST = ["webrtc2-4.ap.sd-rtn.com"], bN.CDS_AP = ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], bN.ACCOUNT_REGISTER = ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], bN.EVENT_REPORT_DOMAIN = "web-2.statscollector.sd-rtn.com", bN.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-1.agora.io", bN.GATEWAY_DOMAINS = ["edge.sd-rtn.com"])), "ENABLE_PRE_SUB" === e2 && t3 && (bN.ENABLE_INSTANT_VIDEO = true, bN.ENABLE_PREALLOC_PC = true), "ENABLE_SVC" === e2 && t3 && (bN.ENABLE_AUT_CC = true), "NEW_FORCE_TURN" === e2 && t3 && (bN.NEW_TURN_MODE || (bN.NEW_TURN_MODE = 4))));
      }
      function wN(e2) {
        return bN[e2];
      }
      gN || (bN.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], bN.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], bN.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], bN.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], bN.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], bN.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], bN.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", bN.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", bN.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", bN.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", bN.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      let ON = function(e2) {
        return e2[e2.REALTIME = 1] = "REALTIME", e2;
      }({});
      const NN = {};
      var DN = function(e2) {
        return e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_INT_UID = "SET_INT_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.KEY_METRIC_PRELOAD_START = "KEY_METRIC_PRELOAD_START", e2.KEY_METRIC_PRELOAD_END = "KEY_METRIC_PRELOAD_END", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_REQUEST_SUA_END = "KEY_METRIC_REQUEST_SUA_END", e2.KEY_METRIC_BEFORE_CONNECT = "KEY_METRIC_BEFORE_CONNECT", e2.KEY_METRIC_PEER_RECEIVER = "KEY_METRIC_PEER_RECEIVER", e2.KEY_METRIC_SIGNAL_CONNECTED = "KEY_METRIC_SIGNAL_CONNECTED", e2.KEY_METRIC_JOIN_REQ = "KEY_METRIC_JOIN_REQ", e2.KEY_METRIC_JOIN_REP = "KEY_METRIC_JOIN_REP", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED = "KEY_METRIC_FIRST_VIDEO_FRAME_DECODED", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.RESET_FIRST_VIDEO_FRAME_DECODED = "RESET_FIRST_VIDEO_FRAME_DECODED", e2.SET_USE_P2P = "SET_USE_P2P", e2.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE", e2;
      }(DN || {});
      let PN = function(e2) {
        return e2.h264 = "h264", e2.h265 = "h265", e2.vp8 = "vp8", e2.vp9 = "vp9", e2.av1 = "av1", e2;
      }({});
      !function(e2) {
        e2.opus = "opus", e2.pcma = "pcma", e2.pcmu = "pcmu", e2.g722 = "g722";
      }({});
      const LN = 128, kN = 96, MN = 1e3, UN = 10;
      let VN = 0;
      var xN = (() => {
        var e2 = { 8: (e3, t4, i3) => {
          i3.r(t4), i3.d(t4, { Parser: () => v3, Printer: () => A2, parse: () => D3, print: () => P2 });
          const n3 = "\n", r2 = "".concat("\r").concat(n3), o2 = " ";
          let s2;
          function a3(e4) {
            return e4 >= "0" && e4 <= "9";
          }
          function c3(e4) {
            return e4 >= "!" && e4 <= "~";
          }
          function d2(e4) {
            return c3(e4) || e4 >= "Â" && e4 <= "Ã¿";
          }
          function l2(e4) {
            return "!" === e4 || e4 >= "#" && e4 <= "'" || e4 >= "*" && e4 <= "+" || e4 >= "-" && e4 <= "." || e4 >= "0" && e4 <= "9" || e4 >= "A" && e4 <= "Z" || e4 >= "^" && e4 <= "~";
          }
          function u3(e4) {
            return e4 >= "1" && e4 <= "9";
          }
          function h2(e4) {
            return e4 >= "A" && e4 <= "Z" || e4 >= "a" && e4 <= "z";
          }
          function p2(e4) {
            return "d" === e4 || "h" === e4 || "m" === e4 || "s" === e4;
          }
          function _2(e4) {
            return e4 > "" && e4 < "	" || e4 > "\v" && e4 < "\f" || e4 > "" && e4 < "Ã¿";
          }
          function E3(e4) {
            return h2(e4) || a3(e4) || "+" === e4 || "/" === e4;
          }
          function m3(e4) {
            return a3(e4) || h2(e4) || "+" === e4 || "/" === e4 || "-" === e4 || "_" === e4;
          }
          function f2(e4) {
            return h2(e4) || a3(e4) || "+" === e4 || "/" === e4;
          }
          function S3(e4, t5) {
            var i4 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var n4 = Object.getOwnPropertySymbols(e4);
              t5 && (n4 = n4.filter(function(t6) {
                return Object.getOwnPropertyDescriptor(e4, t6).enumerable;
              })), i4.push.apply(i4, n4);
            }
            return i4;
          }
          function g2(e4) {
            for (var t5 = 1; t5 < arguments.length; t5++) {
              var i4 = null != arguments[t5] ? arguments[t5] : {};
              t5 % 2 ? S3(Object(i4), true).forEach(function(t6) {
                T3(e4, t6, i4[t6]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : S3(Object(i4)).forEach(function(t6) {
                Object.defineProperty(e4, t6, Object.getOwnPropertyDescriptor(i4, t6));
              });
            }
            return e4;
          }
          function T3(e4, t5, i4) {
            return t5 in e4 ? Object.defineProperty(e4, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e4[t5] = i4, e4;
          }
          !function(e4) {
            e4.VERSION = "v", e4.ORIGIN = "o", e4.SESSION_NAME = "s", e4.INFORMATION = "i", e4.URI = "u", e4.EMAIL = "e", e4.PHONE = "p", e4.CONNECTION = "c", e4.BANDWIDTH = "b", e4.TIME = "t", e4.REPEAT = "r", e4.ZONE_ADJUSTMENTS = "z", e4.KEY = "k", e4.ATTRIBUTE = "a", e4.MEDIA = "m";
          }(s2 || (s2 = {}));
          class R3 {
            consumeText(e4, t5) {
              let i4 = t5;
              for (; i4 < e4.length; ) {
                const t6 = e4[i4];
                if ("\0" === t6 || "\r" === t6 || t6 === n3) break;
                i4 += 1;
              }
              if (i4 - t5 == 0) throw new Error("Invalid text, at ".concat(e4));
              return i4;
            }
            consumeUnicastAddress(e4, t5, i4) {
              return this.consumeTill(e4, t5, o2);
            }
            consumeOneOrMore(e4, t5, i4) {
              let n4 = t5;
              for (; i4(e4[n4]); ) n4++;
              if (n4 - t5 == 0) throw new Error("Invalid rule at ".concat(t5, "."));
              return n4;
            }
            consumeSpace(e4, t5) {
              if (e4[t5] === o2) return t5 + 1;
              throw new Error("Invalid space at ".concat(t5, "."));
            }
            consumeIP4Address(e4, t5) {
              let i4 = t5;
              for (let t6 = 0; t6 < 4; t6++) if (i4 = this.consumeDecimalUChar(e4, i4), 3 !== t6) {
                if ("." !== e4[i4]) throw new Error("Invalid IP4 address.");
                i4++;
              }
              return i4;
            }
            consumeDecimalUChar(e4, t5) {
              let i4 = t5;
              for (let t6 = 0; t6 < 3 && a3(e4[i4]); t6++, i4++) ;
              if (i4 - t5 == 0) throw new Error("Invalid decimal uchar.");
              const n4 = parseInt(e4.slice(t5, i4));
              if (n4 >= 0 && n4 <= 255) return i4;
              throw new Error("Invalid decimal uchar");
            }
            consumeIP6Address(e4, t5) {
              let i4 = this.consumeHexpart(e4, t5);
              return ":" === e4[i4] ? (i4 += 1, i4 = this.consumeIP4Address(e4, i4), i4) : i4;
            }
            consumeHexpart(e4, t5) {
              let i4 = t5;
              if (":" === e4[i4] && ":" === e4[i4 + 1]) {
                i4 += 2;
                try {
                  i4 = this.consumeHexseq(e4, i4);
                } catch (e5) {
                }
                return i4;
              }
              if (i4 = this.consumeHexseq(e4, i4), ":" === e4[i4] && ":" === e4[i4 + 1]) {
                i4 += 2;
                try {
                  i4 = this.consumeHexseq(e4, i4);
                } catch (e5) {
                }
                return i4;
              }
              return i4;
            }
            consumeHexseq(e4, t5) {
              let i4 = t5;
              for (; i4 = this.consumeHex4(e4, i4), ":" === e4[i4] && ":" !== e4[i4 + 1]; ) i4 += 1;
              return i4;
            }
            consumeHex4(e4, t5) {
              let i4 = 0;
              for (; i4 < 4; i4++) if (!((n4 = e4[t5 + i4]) >= "0" && n4 <= "9" || n4 >= "a" && n4 <= "f" || n4 >= "A" && n4 <= "F")) {
                if (0 === i4) throw new Error("Invalid hex 4");
                break;
              }
              var n4;
              return t5 + i4;
            }
            consumeFQDN(e4, t5) {
              let i4 = t5;
              for (; a3(e4[i4]) || h2(e4[i4]) || "-" === e4[i4] || "." === e4[i4]; ) i4 += 1;
              if (i4 - t5 < 4) throw new Error("Invalid FQDN");
              return i4;
            }
            consumeExtnAddr(e4, t5) {
              return this.consumeOneOrMore(e4, t5, d2);
            }
            consumeMulticastAddress(e4, t5, i4) {
              switch (i4) {
                case "IP4":
                case "ip4":
                  return this.consumeIP4MulticastAddress(e4, t5);
                case "IP6":
                case "ip6":
                  return this.consumeIP6MulticastAddress(e4, t5);
                default:
                  try {
                    return this.consumeFQDN(e4, t5);
                  } catch (i5) {
                    return this.consumeExtnAddr(e4, t5);
                  }
              }
            }
            consumeIP6MulticastAddress(e4, t5) {
              const i4 = this.consumeHexpart(e4, t5);
              return "/" === e4[i4] ? this.consumeInteger(e4, i4 + 1) : i4;
            }
            consumeIP4MulticastAddress(e4, t5) {
              let i4 = t5 + 3;
              const n4 = e4.slice(t5, i4), r3 = parseInt(n4);
              if (r3 < 224 || r3 > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
              for (let t6 = 0; t6 < 3; t6++) {
                if ("." !== e4[i4]) throw new Error("Invalid IP4 multicast address.");
                i4 += 1, i4 = this.consumeDecimalUChar(e4, i4);
              }
              return "/" === e4[i4] && (i4 += 1), i4 = this.consumeTTL(e4, i4), "/" === e4[i4] && (i4 = this.consumeInteger(e4, i4)), i4;
            }
            consumeInteger(e4, t5) {
              if (!u3(e4[t5])) throw new Error("Invalid integer.");
              for (t5 += 1; a3(e4[t5]); ) t5 += 1;
              return t5;
            }
            consumeTTL(e4, t5) {
              if ("0" === e4[t5]) return t5 + 1;
              if (!u3(e4[t5])) throw new Error("Invalid TTL.");
              t5 += 1;
              for (let i4 = 0; i4 < 2 && a3(e4[t5]); i4++) t5 += 1;
              return t5;
            }
            consumeToken(e4, t5) {
              return this.consumeOneOrMore(e4, t5, l2);
            }
            consumeTime(e4, t5) {
              let i4 = t5;
              if ("0" === e4[i4]) return i4 + 1;
              for (u3(e4[i4]) && (i4 += 1); a3(e4[i4]); ) i4++;
              if (i4 - t5 < 10) throw new Error("Invalid time");
              return i4;
            }
            consumeAddress(e4, t5) {
              return this.consumeTill(e4, t5, o2);
            }
            consumeTypedTime(e4, t5) {
              let i4 = t5;
              return i4 = this.consumeOneOrMore(e4, i4, a3), p2(e4[i4]) ? i4 + 1 : i4;
            }
            consumeRepeatInterval(e4, t5) {
              if (!u3(e4[t5])) throw new Error("Invalid repeat interval");
              for (t5 += 1; a3(e4[t5]); ) t5 += 1;
              return p2(e4[t5]) && (t5 += 1), t5;
            }
            consumePort(e4, t5) {
              return this.consumeOneOrMore(e4, t5, a3);
            }
            consume(e4, t5, i4) {
              for (let n4 = 0; n4 < i4.length; n4++) {
                if (t5 + n4 >= e4.length) throw new Error("consume exceeding value length");
                if (e4[t5 + n4] !== i4[n4]) throw new Error("consume ".concat(i4, " failed at ").concat(n4));
              }
              return t5 + i4.length;
            }
            consumeTill(e4, t5, i4) {
              let n4 = t5;
              for (; n4 < e4.length && ("string" != typeof i4 || e4[n4] !== i4) && ("function" != typeof i4 || !i4(e4[n4])); ) n4++;
              return n4;
            }
          }
          class v3 extends R3 {
            constructor() {
              super(), T3(this, "records", []), T3(this, "currentLine", 0);
            }
            parse(e4) {
              const t5 = this.probeEOL(e4);
              this.records = e4.split(t5).filter((e5) => !!Pg2(e5).call(e5)).map(this.parseLine), this.currentLine = 0;
              const i4 = this.parseVersion(), n4 = this.parseOrigin(), r3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a4 = this.parseEmail(), c4 = this.parsePhone(), d3 = this.parseConnection(), l3 = this.parseBandWidth(), u4 = this.parseTimeFields(), h3 = this.parseKey(), p3 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
              if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines.");
              return { version: i4, origin: n4, sessionName: r3, information: o3, uri: s3, emails: a4, phones: c4, connection: d3, bandwidths: l3, timeFields: u4, key: h3, attributes: p3, mediaDescriptions: _3 };
            }
            getCurrentRecord() {
              const e4 = this.records[this.currentLine];
              if (!e4) throw new Error("Record doesn't exit.");
              return e4;
            }
            probeEOL(e4) {
              for (let t5 = 0; t5 < e4.length; t5++) if (e4[t5] === n3) return "\r" === e4[t5 - 1] ? r2 : n3;
              throw new Error("Invalid newline character.");
            }
            parseLine(e4, t5) {
              if (e4.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
              const i4 = e4[0];
              if ("=" !== e4[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
              return { type: i4, value: e4.slice(2), line: t5, cur: 0 };
            }
            parseSessionAttribute() {
              const e4 = new y3();
              for (; this.currentLine < this.records.length; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.ATTRIBUTE) break;
                const i4 = { attField: this.extractOneOrMore(t5, (e5) => l2(e5) && ":" !== e5), _cur: 0 };
                ":" === t5.value[t5.cur] && (t5.cur += 1, i4.attValue = this.extractOneOrMore(t5, _2)), e4.parse(i4), this.currentLine++;
              }
              return e4.digest();
            }
            parseMediaAttributes(e4) {
              const t5 = new I3(e4);
              for (; this.currentLine < this.records.length; ) {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.ATTRIBUTE) break;
                const i4 = { attField: this.extractOneOrMore(e5, (e6) => l2(e6) && ":" !== e6), _cur: 0 };
                ":" === e5.value[e5.cur] && (e5.cur += 1, i4.attValue = this.extractOneOrMore(e5, _2)), t5.parse(i4), this.currentLine++;
              }
              return t5.digest();
            }
            parseKey() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.KEY) {
                if ("prompt" === e4.value || "clear:" === e4.value || "base64:" === e4.value || "uri:" === e4.value) return e4.value;
                throw this.currentLine++, new Error("Invalid key.");
              }
            }
            parseZone() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.ZONE_ADJUSTMENTS) {
                const t5 = [];
                for (; ; ) try {
                  const i4 = this.extract(e4, this.consumeTime);
                  this.consumeSpaceForRecord(e4);
                  let n4 = false;
                  "-" === e4.value[e4.cur] && (n4 = true, e4.cur += 1);
                  const r3 = this.extract(e4, this.consumeTypedTime);
                  t5.push({ time: i4, typedTime: r3, back: n4 });
                } catch (e5) {
                  break;
                }
                if (0 === t5.length) throw new Error("Invalid zone adjustments");
                return this.currentLine++, t5;
              }
              return [];
            }
            parseRepeat() {
              const e4 = [];
              for (; ; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.REPEAT) break;
                {
                  const i4 = this.extract(t5, this.consumeRepeatInterval), n4 = this.parseTypedTime(t5);
                  e4.push({ repeatInterval: i4, typedTimes: n4 }), this.currentLine++;
                }
              }
              return e4;
            }
            parseTypedTime(e4) {
              const t5 = [];
              for (; ; ) try {
                this.consumeSpaceForRecord(e4), t5.push(this.extract(e4, this.consumeTypedTime));
              } catch (e5) {
                break;
              }
              if (0 === t5.length) throw new Error("Invalid typed time.");
              return t5;
            }
            parseTime() {
              const e4 = this.getCurrentRecord(), t5 = this.extract(e4, this.consumeTime);
              this.consumeSpaceForRecord(e4);
              const i4 = this.extract(e4, this.consumeTime);
              return this.currentLine++, { startTime: t5, stopTime: i4 };
            }
            parseBandWidth() {
              const e4 = [];
              for (; this.currentLine < this.records.length; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.BANDWIDTH) break;
                {
                  const i4 = this.extractOneOrMore(t5, l2);
                  if (":" !== t5.value[t5.cur]) throw new Error("Invalid bandwidth field.");
                  t5.cur++;
                  const n4 = this.extractOneOrMore(t5, a3);
                  e4.push({ bwtype: i4, bandwidth: n4 }), this.currentLine++;
                }
              }
              return e4;
            }
            parseVersion() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.VERSION) throw new Error("first sdp record must be version");
              const t5 = e4.value.slice(0, this.consumeOneOrMore(e4.value, 0, a3));
              if (t5.length !== e4.value.length) throw new Error('invalid proto version, "v='.concat(e4.value, '"'));
              return this.currentLine++, t5;
            }
            parseOrigin() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.ORIGIN) throw new Error("second line of sdp must be origin");
              const t5 = this.extractOneOrMore(e4, d2);
              this.consumeSpaceForRecord(e4);
              const i4 = this.extractOneOrMore(e4, a3);
              this.consumeSpaceForRecord(e4);
              const n4 = this.extractOneOrMore(e4, a3);
              this.consumeSpaceForRecord(e4);
              const r3 = this.extractOneOrMore(e4, l2);
              this.consumeSpaceForRecord(e4);
              const o3 = this.extractOneOrMore(e4, l2);
              this.consumeSpaceForRecord(e4);
              const c4 = this.extract(e4, this.consumeUnicastAddress);
              return this.currentLine++, { username: t5, sessId: i4, sessVersion: n4, nettype: r3, addrtype: o3, unicastAddress: c4 };
            }
            parseSessionName() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.SESSION_NAME) {
                const t5 = this.extract(e4, this.consumeText);
                return this.currentLine++, t5;
              }
            }
            parseInformation() {
              const e4 = this.getCurrentRecord();
              if (e4.type !== s2.INFORMATION) return;
              const t5 = this.extract(e4, this.consumeText);
              return this.currentLine++, t5;
            }
            parseUri() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.URI) return this.currentLine++, e4.value;
            }
            parseEmail() {
              const e4 = [];
              for (; ; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.EMAIL) break;
                e4.push(t5.value), this.currentLine++;
              }
              return e4;
            }
            parsePhone() {
              const e4 = [];
              for (; ; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.PHONE) break;
                e4.push(t5.value), this.currentLine++;
              }
              return e4;
            }
            parseConnection() {
              const e4 = this.getCurrentRecord();
              if (e4.type === s2.CONNECTION) {
                const t5 = this.extractOneOrMore(e4, l2);
                this.consumeSpaceForRecord(e4);
                const i4 = this.extractOneOrMore(e4, l2);
                this.consumeSpaceForRecord(e4);
                const n4 = this.extract(e4, this.consumeAddress);
                return this.currentLine++, { nettype: t5, addrtype: i4, address: n4 };
              }
            }
            parseMedia() {
              const e4 = this.getCurrentRecord(), t5 = this.extract(e4, this.consumeToken);
              this.consumeSpaceForRecord(e4);
              let i4 = this.extract(e4, this.consumePort);
              "/" === e4.value[e4.cur] && (e4.cur += 1, i4 += this.extract(e4, this.consumeInteger)), this.consumeSpaceForRecord(e4);
              const n4 = [];
              for (n4.push(this.extract(e4, this.consumeToken)); "/" === e4.value[e4.cur]; ) e4.cur += 1, n4.push(this.extract(e4, this.consumeToken));
              if (0 === n4.length) throw new Error("Invalid proto");
              const r3 = this.parseFmt(e4);
              return this.currentLine++, { mediaType: t5, port: i4, protos: n4, fmts: r3 };
            }
            parseTimeFields() {
              const e4 = [];
              for (; this.getCurrentRecord().type === s2.TIME; ) {
                const t5 = this.parseTime(), i4 = this.parseRepeat(), n4 = this.parseZone();
                e4.push({ time: t5, repeats: i4, zones: n4 });
              }
              return e4;
            }
            parseMediaDescription() {
              const e4 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
                const t5 = this.parseMedia(), i4 = this.parseInformation(), n4 = this.parseConnections(), r3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t5);
                e4.push({ media: t5, information: i4, connections: n4, bandwidths: r3, key: o3, attributes: s3 });
              }
              return e4;
            }
            parseConnections() {
              const e4 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; ) e4.push(this.parseConnection());
              return e4;
            }
            parseFmt(e4) {
              const t5 = [];
              for (; ; ) try {
                this.consumeSpaceForRecord(e4), t5.push(this.extract(e4, this.consumeToken));
              } catch (e5) {
                break;
              }
              if (0 === t5.length) throw new Error("Invalid fmts");
              return t5;
            }
            extract(e4, t5) {
              for (var i4 = arguments.length, n4 = new Array(i4 > 2 ? i4 - 2 : 0), r3 = 2; r3 < i4; r3++) n4[r3 - 2] = arguments[r3];
              const o3 = t5.call(this, e4.value, e4.cur, ...n4), s3 = e4.value.slice(e4.cur, o3);
              return e4.cur = o3, s3;
            }
            extractOneOrMore(e4, t5) {
              const i4 = this.consumeOneOrMore(e4.value, e4.cur, t5), n4 = e4.value.slice(e4.cur, i4);
              return e4.cur = i4, n4;
            }
            consumeSpaceForRecord(e4) {
              if (e4.value[e4.cur] !== o2) throw new Error("Invalid space at ".concat(e4.cur, "."));
              e4.cur += 1;
            }
          }
          class C2 extends R3 {
            constructor() {
              super(...arguments), T3(this, "attributes", void 0), T3(this, "digested", false);
            }
            extractOneOrMore(e4, t5, i4) {
              const n4 = this.consumeOneOrMore(e4.attValue, e4._cur, t5), r3 = e4.attValue.slice(e4._cur, n4), [o3, s3] = i4 || [];
              if ("number" == typeof o3 && r3.length < o3) throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
              if ("number" == typeof s3 && r3.length > s3) throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
              return e4._cur = n4, r3;
            }
            consumeAttributeSpace(e4) {
              if (e4.attValue[e4._cur] !== o2) throw new Error("Invalid space at ".concat(e4._cur, "."));
              e4._cur += 1;
            }
            extract(e4, t5) {
              if (!e4.attValue) throw new Error("Nothing to extract from attValue.");
              for (var i4 = arguments.length, n4 = new Array(i4 > 2 ? i4 - 2 : 0), r3 = 2; r3 < i4; r3++) n4[r3 - 2] = arguments[r3];
              const o3 = t5.call(this, e4.attValue, e4._cur, ...n4), s3 = e4.attValue.slice(e4._cur, o3);
              return e4._cur = o3, s3;
            }
            atEnd(e4) {
              if (!e4.attValue) throw new Error();
              return e4._cur >= e4.attValue.length;
            }
            peekChar(e4) {
              if (!e4.attValue) throw new Error();
              return e4.attValue[e4._cur];
            }
            peek(e4, t5) {
              if (!e4.attValue) throw new Error();
              for (let i4 = 0; i4 < t5.length; i4++) if (t5[i4] !== e4.attValue[e4._cur + i4]) return false;
              return true;
            }
            parseIceUfrag(e4) {
              if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
              this.attributes.iceUfrag = this.extractOneOrMore(e4, E3, [4, 256]);
            }
            parseIcePwd(e4) {
              if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
              this.attributes.icePwd = this.extractOneOrMore(e4, E3, [22, 256]);
            }
            parseIceOptions(e4) {
              if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line");
              const t5 = [];
              for (; !this.atEnd(e4); ) {
                t5.push(this.extractOneOrMore(e4, E3));
                try {
                  this.consumeAttributeSpace(e4);
                } catch (t6) {
                  if (this.atEnd(e4)) break;
                  throw t6;
                }
              }
              this.attributes.iceOptions = t5;
            }
            parseFingerprint(e4) {
              const t5 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill);
              this.attributes.fingerprints.push({ hashFunction: t5, fingerprint: i4 });
            }
            parseExtmap(e4) {
              const t5 = this.extractOneOrMore(e4, a3);
              let i4;
              "/" === this.peekChar(e4) && (this.extract(e4, this.consume, "/"), i4 = this.extract(e4, this.consumeToken)), this.consumeAttributeSpace(e4);
              const n4 = this.extract(e4, this.consumeTill, o2), r3 = g2(g2({ entry: parseInt(t5, 10) }, i4 && { direction: i4 }), {}, { extensionName: n4 });
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), r3.extensionAttributes = this.extract(e4, this.consumeTill)), this.attributes.extmaps.push(r3);
            }
            parseSetup(e4) {
              if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line.");
              const t5 = this.extract(e4, this.consumeTill);
              if ("active" !== t5 && "passive" !== t5 && "actpass" !== t5 && "holdconn" !== t5) throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
              this.attributes.setup = t5;
            }
          }
          class y3 extends C2 {
            constructor() {
              super(...arguments), T3(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
            }
            parse(e4) {
              if (this.digested) throw new Error("already digested");
              try {
                switch (e4.attField) {
                  case "group":
                    this.parseGroup(e4);
                    break;
                  case "ice-lite":
                    this.parseIceLite();
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e4);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e4);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e4);
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e4);
                    break;
                  case "setup":
                    this.parseSetup(e4);
                    break;
                  case "tls-id":
                    this.parseTlsId(e4);
                    break;
                  case "identity":
                    this.parseIdentity(e4);
                    break;
                  case "extmap":
                    this.parseExtmap(e4);
                    break;
                  case "msid-semantic":
                    this.parseMsidSemantic(e4);
                    break;
                  default:
                    e4.ignored = true, this.attributes.unrecognized.push(e4);
                }
              } catch (t5) {
                throw console.error("parsing session attribute ".concat(e4.attField, ' error, "a=').concat(e4.attField, ":").concat(e4.attValue, '"')), t5;
              }
              if (!e4.ignored && e4.attValue && !this.atEnd(e4)) throw new Error("attribute parsing error");
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseGroup(e4) {
              const t5 = this.extract(e4, this.consumeToken), i4 = [];
              for (; !this.atEnd(e4) && this.peekChar(e4) === o2; ) this.consumeAttributeSpace(e4), i4.push(this.extract(e4, this.consumeToken));
              this.attributes.groups.push({ semantic: t5, identificationTag: i4 });
            }
            parseIceLite() {
              if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
              this.attributes.iceLite = true;
            }
            parseTlsId(e4) {
              if (this.attributes.tlsId) throw new Error("must be only one tld-id line");
              this.attributes.tlsId = this.extractOneOrMore(e4, m3);
            }
            parseIdentity(e4) {
              const t5 = this.extractOneOrMore(e4, f2), i4 = [];
              for (; !this.atEnd(e4) && this.peekChar(e4) === o2; ) {
                this.consumeAttributeSpace(e4);
                const t6 = this.extract(e4, this.consumeToken);
                this.extract(e4, this.consume, "=");
                const n4 = this.extractOneOrMore(e4, (e5) => e5 !== o2 && _2(e5));
                i4.push({ name: t6, value: n4 });
              }
              this.attributes.identities.push({ assertionValue: t5, extensions: i4 });
            }
            parseMsidSemantic(e4) {
              this.peekChar(e4) === o2 && this.consumeAttributeSpace(e4);
              const t5 = { semantic: this.extract(e4, this.consumeToken), identifierList: [] };
              for (; ; ) {
                try {
                  this.consumeAttributeSpace(e4);
                } catch (e5) {
                  break;
                }
                if ("*" === this.peekChar(e4)) {
                  this.extract(e4, this.consume, "*"), t5.applyForAll = true;
                  break;
                }
                {
                  const i4 = this.extract(e4, this.consumeTill, o2);
                  t5.identifierList.push(i4);
                }
              }
              this.attributes.msidSemantic = t5;
            }
          }
          class I3 extends C2 {
            constructor(e4) {
              super(), T3(this, "attributes", void 0), -1 !== e4.protos.indexOf("RTP") || e4.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
            }
            parse(e4) {
              if (this.digested) throw new Error("already digested");
              try {
                switch (e4.attField) {
                  case "extmap":
                    this.parseExtmap(e4);
                    break;
                  case "setup":
                    this.parseSetup(e4);
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e4);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e4);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e4);
                    break;
                  case "candidate":
                    this.parseCandidate(e4);
                    break;
                  case "remote-candidate":
                    this.parseRemoteCandidate(e4);
                    break;
                  case "end-of-candidates":
                    this.parseEndOfCandidates();
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e4);
                    break;
                  case "rtpmap":
                    this.parseRtpmap(e4);
                    break;
                  case "ptime":
                    this.parsePtime(e4);
                    break;
                  case "maxptime":
                    this.parseMaxPtime(e4);
                    break;
                  case "sendrecv":
                  case "recvonly":
                  case "sendonly":
                  case "inactive":
                    this.parseDirection(e4);
                    break;
                  case "ssrc":
                    this.parseSSRC(e4);
                    break;
                  case "fmtp":
                    this.parseFmtp(e4);
                    break;
                  case "rtcp-fb":
                    this.parseRtcpFb(e4);
                    break;
                  case "rtcp-mux":
                    this.parseRTCPMux();
                    break;
                  case "rtcp-mux-only":
                    this.parseRTCPMuxOnly();
                    break;
                  case "rtcp-rsize":
                    this.parseRTCPRsize();
                    break;
                  case "rtcp":
                    this.parseRTCP(e4);
                    break;
                  case "mid":
                    this.parseMid(e4);
                    break;
                  case "msid":
                    this.parseMsid(e4);
                    break;
                  case "imageattr":
                    this.parseImageAttr(e4);
                    break;
                  case "rid":
                    this.parseRid(e4);
                    break;
                  case "simulcast":
                    this.parseSimulcast(e4);
                    break;
                  case "sctp-port":
                    this.parseSctpPort(e4);
                    break;
                  case "max-message-size":
                    this.parseMaxMessageSize(e4);
                    break;
                  case "ssrc-group":
                    this.parseSSRCGroup(e4);
                    break;
                  default:
                    e4.ignored = true, this.attributes.unrecognized.push(e4);
                }
              } catch (t5) {
                throw console.error("parsing media attribute ".concat(e4.attField, ' error, "a=').concat(e4.attField, ":").concat(e4.attValue, '"')), t5;
              }
              if (!e4.ignored && e4.attValue && !this.atEnd(e4)) throw new Error("attribute parsing error");
            }
            parseCandidate(e4) {
              const t5 = this.extractOneOrMore(e4, E3, [1, 32]);
              this.consumeAttributeSpace(e4);
              const i4 = this.extractOneOrMore(e4, a3, [1, 5]);
              this.consumeAttributeSpace(e4);
              const n4 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const r3 = this.extractOneOrMore(e4, a3, [1, 10]);
              this.consumeAttributeSpace(e4);
              const s3 = this.extract(e4, this.consumeAddress);
              this.consumeAttributeSpace(e4);
              const d3 = this.extract(e4, this.consumePort);
              this.consumeAttributeSpace(e4), this.extract(e4, this.consume, "typ"), this.consumeAttributeSpace(e4);
              const l3 = { foundation: t5, componentId: i4, transport: n4, priority: r3, connectionAddress: s3, port: d3, type: this.extract(e4, this.consumeToken), extension: {} };
              for (this.peek(e4, " raddr") && (this.extract(e4, this.consume, " raddr"), this.consumeAttributeSpace(e4), l3.relAddr = this.extract(e4, this.consumeAddress)), this.peek(e4, " rport") && (this.extract(e4, this.consume, " rport"), this.consumeAttributeSpace(e4), l3.relPort = this.extract(e4, this.consumePort)); this.peekChar(e4) === o2; ) {
                this.consumeAttributeSpace(e4);
                const t6 = this.extract(e4, this.consumeToken);
                this.consumeAttributeSpace(e4), l3.extension[t6] = this.extractOneOrMore(e4, c3);
              }
              this.attributes.candidates.push(l3);
            }
            parseRemoteCandidate(e4) {
              const t5 = [];
              for (; ; ) {
                const i4 = this.extractOneOrMore(e4, a3, [1, 5]);
                this.consumeAttributeSpace(e4);
                const n4 = this.extract(e4, this.consumeAddress);
                this.consumeAttributeSpace(e4);
                const r3 = this.extract(e4, this.consumePort);
                t5.push({ componentId: i4, connectionAddress: n4, port: r3 });
                try {
                  this.consumeAttributeSpace(e4);
                } catch (e5) {
                  break;
                }
              }
              this.attributes.remoteCandidatesList.push(t5);
            }
            parseEndOfCandidates() {
              if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates");
              this.attributes.endOfCandidates = true;
            }
            parseRtpmap(e4) {
              const t5 = this.extract(e4, this.consumeToken);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill, "/");
              this.extract(e4, this.consume, "/");
              const n4 = { encodingName: i4, clockRate: this.extractOneOrMore(e4, a3) };
              this.atEnd(e4) || "/" !== this.peekChar(e4) || (this.extract(e4, this.consume, "/"), n4.encodingParameters = parseInt(this.extract(e4, this.consumeTill), 10));
              const r3 = this.attributes.payloads.find((e5) => e5.payloadType === parseInt(t5, 10));
              r3 ? r3.rtpMap = n4 : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtpMap: n4, rtcpFeedbacks: [] });
            }
            parsePtime(e4) {
              if (this.attributes.ptime) throw new Error("must be only one line of ptime");
              this.attributes.ptime = this.extract(e4, this.consumeTill);
            }
            parseMaxPtime(e4) {
              if (this.attributes.maxPtime) throw new Error("must be only one line of ptime");
              this.attributes.maxPtime = this.extract(e4, this.consumeTill);
            }
            parseDirection(e4) {
              if (this.attributes.direction) throw new Error("must be only one line of direction info");
              this.attributes.direction = e4.attField;
            }
            parseSSRC(e4) {
              const t5 = this.extractOneOrMore(e4, a3);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill, ":");
              let n4;
              ":" === this.peekChar(e4) && (this.extract(e4, this.consume, ":"), n4 = this.extract(e4, this.consumeTill));
              const r3 = this.attributes.ssrcs.find((e5) => e5.ssrcId === parseInt(t5, 10));
              r3 ? r3.attributes[i4] = n4 : this.attributes.ssrcs.push({ ssrcId: parseInt(t5, 10), attributes: { [i4]: n4 } });
            }
            parseFmtp(e4) {
              const t5 = this.extract(e4, this.consumeTill, o2);
              this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill), n4 = {};
              i4.split(";").forEach((e5) => {
                let [t6, i5] = e5.split("=");
                t6 = Pg2(t6).call(t6);
                const r4 = "string" == typeof i5 ? Pg2(i5).call(i5) : null;
                "string" == typeof t6 && t6.length > 0 && (n4[t6] = r4);
              });
              const r3 = this.attributes.payloads.find((e5) => e5.payloadType === parseInt(t5, 10));
              r3 ? r3.fmtp = { parameters: n4 } : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [], fmtp: { parameters: n4 } });
            }
            parseFmtParameters(e4) {
              const t5 = {}, i4 = this.extract(e4, this.consumeTill, "=");
              e4._cur++;
              const n4 = this.extract(e4, this.consumeTill, ";");
              for (t5[i4] = n4; ";" === e4.attValue[e4._cur]; ) {
                const i5 = this.extract(e4, this.consumeTill, "=");
                e4._cur++;
                const n5 = this.extract(e4, this.consumeTill, ";");
                t5[i5] = n5;
              }
              return t5;
            }
            parseRtcpFb(e4) {
              let t5 = "";
              t5 = "*" === this.peekChar(e4) ? this.extract(e4, this.consume, "*") : this.extract(e4, this.consumeTill, o2), this.consumeAttributeSpace(e4);
              const i4 = this.extract(e4, this.consumeTill, o2);
              let n4;
              if ("trr-int" === i4) n4 = { type: i4, interval: this.extract(e4, this.consumeTill) };
              else {
                const t6 = { type: i4 };
                this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t6.parameter = this.extract(e4, this.consumeToken), this.peekChar(e4) === o2 && (t6.additional = this.extract(e4, this.consumeTill))), n4 = t6;
              }
              if ("*" === t5) this.attributes.rtcpFeedbackWildcards.push(n4);
              else {
                const e5 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                e5 ? e5.rtcpFeedbacks.push(n4) : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [n4] });
              }
            }
            parseRTCPMux() {
              if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux");
              this.attributes.rtcpMux = true;
            }
            parseRTCPMuxOnly() {
              if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only");
              this.attributes.rtcpMuxOnly = true;
            }
            parseRTCPRsize() {
              if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize");
              this.attributes.rtcpRsize = true;
            }
            parseRTCP(e4) {
              if (this.attributes.rtcp) throw new Error("must be single line of rtcp");
              const t5 = { port: this.extract(e4, this.consumePort) };
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t5.netType = this.extractOneOrMore(e4, l2), this.consumeAttributeSpace(e4), t5.addressType = this.extractOneOrMore(e4, l2), this.consumeAttributeSpace(e4), t5.address = this.extract(e4, this.consumeAddress)), this.attributes.rtcp = t5;
            }
            parseMsid(e4) {
              const t5 = { id: this.extractOneOrMore(e4, l2, [1, 64]) };
              this.peekChar(e4) === o2 && (this.consumeAttributeSpace(e4), t5.appdata = this.extractOneOrMore(e4, l2, [1, 64])), this.attributes.msids.push(t5);
            }
            parseImageAttr(e4) {
              this.attributes.imageattr.push(e4.attValue);
            }
            parseRid(e4) {
              const t5 = this.extractOneOrMore(e4, (e5) => h2(e5) || a3(e5) || "_" === e5 || "-" === e5);
              this.consumeAttributeSpace(e4);
              const i4 = { id: t5, direction: this.extract(e4, this.consumeToken), params: [] };
              if (this.peekChar(e4) === o2) {
                if (this.consumeAttributeSpace(e4), this.peek(e4, "pt=")) {
                  this.extract(e4, this.consume, "pt=");
                  const t6 = [];
                  for (; ; ) {
                    const i5 = this.extract(e4, this.consumeToken);
                    t6.push(i5);
                    try {
                      this.extract(e4, this.consume, ",");
                    } catch (e5) {
                      break;
                    }
                  }
                  i4.payloads = t6, this.peekChar(e4) === o2 && this.extract(e4, this.consume, o2);
                }
                for (; ; ) {
                  const t6 = this.extract(e4, this.consumeToken);
                  switch (t6) {
                    case "depend": {
                      const n4 = { type: t6, rids: this.extract(e4, this.consume, "=").split(",") };
                      i4.params.push(n4);
                      break;
                    }
                    default: {
                      const n4 = { type: t6 };
                      "=" === this.peekChar(e4) && (this.extract(e4, this.consume, "="), n4.val = this.extract(e4, this.consumeTill, ";")), i4.params.push(n4);
                    }
                  }
                  try {
                    this.extract(e4, this.consume, ";");
                  } catch (e5) {
                    break;
                  }
                }
              }
              this.attributes.rids.push(i4);
            }
            parseSimulcast(e4) {
              if (this.attributes.simulcast) throw new Error("must be single line of simulcast");
              this.attributes.simulcast = e4.attValue, this.extract(e4, this.consumeTill);
            }
            parseSctpPort(e4) {
              this.attributes.sctpPort = this.extractOneOrMore(e4, a3, [1, 5]);
            }
            parseMaxMessageSize(e4) {
              this.attributes.maxMessageSize = this.extractOneOrMore(e4, a3, [1, void 0]);
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseMid(e4) {
              this.attributes.mid = this.extract(e4, this.consumeToken);
            }
            parseSSRCGroup(e4) {
              const t5 = this.extract(e4, this.consumeToken), i4 = [];
              for (; ; ) try {
                this.consumeAttributeSpace(e4);
                const t6 = this.extract(e4, this.consumeInteger);
                i4.push(parseInt(t6, 10));
              } catch (e5) {
                break;
              }
              this.attributes.ssrcGroups.push({ semantic: t5, ssrcIds: i4 });
            }
          }
          function b2(e4, t5, i4) {
            return t5 in e4 ? Object.defineProperty(e4, t5, { value: i4, enumerable: true, configurable: true, writable: true }) : e4[t5] = i4, e4;
          }
          class A2 {
            constructor() {
              b2(this, "eol", r2);
            }
            print(e4, t5) {
              let i4 = "";
              return t5 && (this.eol = t5), i4 += this.printVersion(e4.version), i4 += this.printOrigin(e4.origin), i4 += this.printSessionName(e4.sessionName), i4 += this.printInformation(e4.information), i4 += this.printUri(e4.uri), i4 += this.printEmail(e4.emails), i4 += this.printPhone(e4.phones), i4 += this.printConnection(e4.connection), i4 += this.printBandwidth(e4.bandwidths), i4 += this.printTimeFields(e4.timeFields), i4 += this.printKey(e4.key), i4 += this.printSessionAttributes(e4.attributes), i4 += this.printMediaDescription(e4.mediaDescriptions), i4;
            }
            printVersion(e4) {
              return "v=".concat(e4).concat(this.eol);
            }
            printOrigin(e4) {
              return "o=".concat(e4.username, " ").concat(e4.sessId, " ").concat(e4.sessVersion, " ").concat(e4.nettype, " ").concat(e4.addrtype, " ").concat(e4.unicastAddress).concat(this.eol);
            }
            printSessionName(e4) {
              return e4 ? "s=".concat(e4).concat(this.eol) : "";
            }
            printInformation(e4) {
              return e4 ? "i=".concat(e4).concat(this.eol) : "";
            }
            printUri(e4) {
              return e4 ? "u=".concat(e4).concat(this.eol) : "";
            }
            printEmail(e4) {
              let t5 = "";
              for (const i4 of e4) t5 += "e=".concat(i4).concat(this.eol);
              return t5;
            }
            printPhone(e4) {
              let t5 = "";
              for (const i4 of e4) t5 += "e=".concat(i4).concat(this.eol);
              return t5;
            }
            printConnection(e4) {
              return e4 ? "c=".concat(e4.nettype, " ").concat(e4.addrtype, " ").concat(e4.address).concat(this.eol) : "";
            }
            printBandwidth(e4) {
              let t5 = "";
              for (const i4 of e4) t5 += "b=".concat(i4.bwtype, ":").concat(i4.bandwidth).concat(this.eol);
              return t5;
            }
            printTimeFields(e4) {
              let t5 = "";
              for (const i4 of e4) {
                t5 += "t=".concat(i4.time.startTime, " ").concat(i4.time.startTime).concat(this.eol);
                for (const e5 of i4.repeats) t5 += "r=".concat(e5.repeatInterval, " ").concat(e5.typedTimes.join(" ")).concat(this.eol);
                i4.zoneAdjustments && (t5 += "z=", t5 += "z=".concat(i4.zoneAdjustments.map((e5) => "".concat(e5.time, " ").concat(e5.back ? "-" : "", " ").concat(e5.typedTime)).join(" ")).concat(this.eol), t5 += this.eol);
              }
              return t5;
            }
            printKey(e4) {
              return e4 ? "k=".concat(e4).concat(this.eol) : "";
            }
            printAttributes(e4) {
              let t5 = "";
              for (const i4 of e4) t5 += "a=".concat(i4.attField).concat(i4.attValue ? ":".concat(i4.attValue) : "").concat(this.eol);
              return t5;
            }
            printMediaDescription(e4) {
              let t5 = "";
              for (const i4 of e4) t5 += this.printMedia(i4.media), t5 += this.printInformation(i4.information), t5 += this.printConnections(i4.connections), t5 += this.printBandwidth(i4.bandwidths), t5 += this.printKey(i4.key), t5 += this.printMediaAttributes(i4);
              return t5;
            }
            printConnections(e4) {
              let t5 = "";
              for (const i4 of e4) t5 += this.printConnection(i4);
              return t5;
            }
            printMedia(e4) {
              return "m=".concat(e4.mediaType, " ").concat(e4.port, " ").concat(e4.protos.join("/"), " ").concat(e4.fmts.join(" ")).concat(this.eol);
            }
            printSessionAttributes(e4) {
              return new O3(this.eol).print(e4);
            }
            printMediaAttributes(e4) {
              return new N3(this.eol).print(e4);
            }
          }
          class w3 {
            constructor(e4) {
              b2(this, "eol", void 0), this.eol = e4;
            }
            printIceUfrag(e4) {
              return void 0 === e4 ? "" : "a=ice-ufrag:".concat(e4).concat(this.eol);
            }
            printIcePwd(e4) {
              return void 0 === e4 ? "" : "a=ice-pwd:".concat(e4).concat(this.eol);
            }
            printIceOptions(e4) {
              return void 0 === e4 ? "" : "a=ice-options:".concat(e4.join(o2)).concat(this.eol);
            }
            printFingerprints(e4) {
              return e4.length > 0 ? e4.map((e5) => "a=fingerprint:".concat(e5.hashFunction).concat(o2).concat(e5.fingerprint)).join(this.eol) + this.eol : "";
            }
            printExtmap(e4) {
              return e4.map((e5) => "a=extmap:".concat(e5.entry).concat(e5.direction ? "/".concat(e5.direction) : "").concat(o2).concat(e5.extensionName).concat(e5.extensionAttributes ? "".concat(o2).concat(e5.extensionAttributes) : "").concat(this.eol)).join("");
            }
            printSetup(e4) {
              return void 0 === e4 ? "" : "a=setup:".concat(e4).concat(this.eol);
            }
            printUnrecognized(e4) {
              return e4.map((e5) => "a=".concat(e5.attField).concat(e5.attValue ? ":".concat(e5.attValue) : "").concat(this.eol)).join("");
            }
          }
          class O3 extends w3 {
            print(e4) {
              let t5 = "";
              return t5 += this.printGroups(e4.groups), t5 += this.printMsidSemantic(e4.msidSemantic), t5 += this.printIceLite(e4.iceLite), t5 += this.printIceUfrag(e4.iceUfrag), t5 += this.printIcePwd(e4.icePwd), t5 += this.printIceOptions(e4.iceOptions), t5 += this.printFingerprints(e4.fingerprints), t5 += this.printSetup(e4.setup), t5 += this.printTlsId(e4.tlsId), t5 += this.printIdentity(e4.identities), t5 += this.printExtmap(e4.extmaps), t5 += this.printUnrecognized(e4.unrecognized), t5;
            }
            printGroups(e4) {
              let t5 = "";
              return e4.length > 0 && (t5 += e4.map((e5) => "a=group:".concat(e5.semantic).concat(e5.identificationTag.map((e6) => "".concat(o2).concat(e6)).join("")).concat(this.eol)).join("")), t5;
            }
            printIceLite(e4) {
              return void 0 === e4 ? "" : "a=ice-lite" + this.eol;
            }
            printTlsId(e4) {
              return e4 ? "a=tls-id:".concat(e4).concat(this.eol) : "";
            }
            printIdentity(e4) {
              return 0 === e4.length ? "" : e4.map((e5) => "a=identity:".concat(e5.assertionValue).concat(e5.extensions.map((e6) => "".concat(o2).concat(e6.name).concat(e6.value ? "=".concat(e6.value) : "")))).join(this.eol) + this.eol;
            }
            printMsidSemantic(e4) {
              if (!e4) return "";
              let t5 = "a=msid-semantic:".concat(e4.semantic);
              return e4.applyForAll ? t5 += "".concat(o2, "*") : e4.identifierList.length > 0 && (t5 += e4.identifierList.map((e5) => "".concat(o2).concat(e5))), t5 + this.eol;
            }
          }
          class N3 extends w3 {
            print(e4) {
              const t5 = e4.attributes;
              let i4 = "";
              return i4 += this.printRTCP(t5.rtcp), i4 += this.printIceUfrag(t5.iceUfrag), i4 += this.printIcePwd(t5.icePwd), i4 += this.printIceOptions(t5.iceOptions), i4 += this.printCandidates(t5.candidates), i4 += this.printRemoteCandidatesList(t5.remoteCandidatesList), i4 += this.printEndOfCandidates(t5.endOfCandidates), i4 += this.printFingerprints(t5.fingerprints), i4 += this.printSetup(t5.setup), i4 += this.printMid(t5.mid), i4 += this.printExtmap(t5.extmaps), i4 += this.printRTPRelated(t5), i4 += this.printPtime(t5.ptime), i4 += this.printMaxPtime(t5.maxPtime), i4 += this.printDirection(t5.direction), i4 += this.printSSRCGroups(t5.ssrcGroups), i4 += this.printSSRC(t5.ssrcs), i4 += this.printRTCPMux(t5.rtcpMux), i4 += this.printRTCPMuxOnly(t5.rtcpMuxOnly), i4 += this.printRTCPRsize(t5.rtcpRsize), i4 += this.printMSId(t5.msids), i4 += this.printImageattr(t5.imageattr), i4 += this.printRid(t5.rids), i4 += this.printSimulcast(t5.simulcast), i4 += this.printSCTPPort(t5.sctpPort), i4 += this.printMaxMessageSize(t5.maxMessageSize), i4 += this.printUnrecognized(t5.unrecognized), i4;
            }
            printCandidates(e4) {
              return e4.map((e5) => "a=candidate:".concat(e5.foundation).concat(o2).concat(e5.componentId).concat(o2).concat(e5.transport).concat(o2).concat(e5.priority).concat(o2).concat(e5.connectionAddress).concat(o2).concat(e5.port).concat(o2, "typ").concat(o2).concat(e5.type).concat(e5.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e5.relAddr) : "").concat(e5.relPort ? "".concat(o2, "rport").concat(o2).concat(e5.relPort) : "").concat(Object.keys(e5.extension).map((t5) => "".concat(o2).concat(t5).concat(o2).concat(e5.extension[t5])).join("")).concat(this.eol)).join("");
            }
            printRemoteCandidatesList(e4) {
              return e4.map((e5) => "a=remote-candidates:".concat(e5.join(o2)).concat(this.eol)).join("");
            }
            printEndOfCandidates(e4) {
              return void 0 === e4 ? "" : "a=end-of-candidates" + this.eol;
            }
            printRTPRelated(e4) {
              if (!e4.payloads) return "";
              const t5 = e4.payloads;
              let i4 = "";
              i4 += e4.rtcpFeedbackWildcards.map((e5) => this.printRTCPFeedback("*", e5)).join("");
              for (const e5 of t5) i4 += this.printRtpMap(e5.payloadType, e5.rtpMap), i4 += this.printFmtp(e5.payloadType, e5.fmtp), i4 += e5.rtcpFeedbacks.map((t6) => this.printRTCPFeedback(e5.payloadType, t6)).join("");
              return i4;
            }
            printFmtp(e4, t5) {
              if (!t5) return "";
              const i4 = Object.keys(t5.parameters);
              return 1 === i4.length && null === t5.parameters[i4[0]] ? "a=fmtp:".concat(e4).concat(o2).concat(i4[0]).concat(this.eol) : "a=fmtp:".concat(e4).concat(o2).concat(Object.keys(t5.parameters).map((e5) => "".concat(e5, "=").concat(t5.parameters[e5])).join(";")).concat(this.eol);
            }
            printRtpMap(e4, t5) {
              return t5 ? "a=rtpmap:".concat(e4).concat(o2).concat(t5.encodingName, "/").concat(t5.clockRate).concat(t5.encodingParameters ? "/".concat(t5.encodingParameters) : "").concat(this.eol) : "";
            }
            printRTCPFeedback(e4, t5) {
              let i4 = "a=rtcp-fb:".concat(e4).concat(o2), n4 = t5;
              return "trr-int" === n4.type ? i4 += "ttr-int".concat(o2).concat(n4.interval) : (i4 += "".concat(n4.type), n4.parameter && (i4 += "".concat(o2).concat(n4.parameter), n4.additional && (i4 += "".concat(o2).concat(n4.additional)))), i4 + this.eol;
            }
            printPtime(e4) {
              return void 0 === e4 ? "" : "a=ptime:".concat(e4).concat(this.eol);
            }
            printMaxPtime(e4) {
              return void 0 === e4 ? "" : "a=maxptime:".concat(e4).concat(this.eol);
            }
            printDirection(e4) {
              return void 0 === e4 ? "" : "a=".concat(e4).concat(this.eol);
            }
            printSSRC(e4) {
              return e4.map((e5) => Object.keys(e5.attributes).map((t5) => "a=ssrc:".concat(e5.ssrcId.toString(10)).concat(o2).concat(t5).concat(e5.attributes[t5] ? ":".concat(e5.attributes[t5]) : "").concat(this.eol)).join("")).join("");
            }
            printRTCPMux(e4) {
              return void 0 === e4 ? "" : "a=rtcp-mux".concat(this.eol);
            }
            printRTCPMuxOnly(e4) {
              return void 0 === e4 ? "" : "a=rtcp-mux-only".concat(this.eol);
            }
            printRTCPRsize(e4) {
              return void 0 === e4 ? "" : "a=rtcp-rsize".concat(this.eol);
            }
            printRTCP(e4) {
              if (void 0 === e4) return "";
              let t5 = "a=rtcp:".concat(e4.port);
              return e4.netType && (t5 += "".concat(o2).concat(e4.netType)), e4.addressType && (t5 += "".concat(o2).concat(e4.addressType)), e4.address && (t5 += "".concat(o2).concat(e4.address)), t5 + this.eol;
            }
            printMSId(e4) {
              return e4.map((e5) => "a=msid:".concat(e5.id).concat(e5.appdata ? "".concat(o2).concat(e5.appdata) : "").concat(this.eol)).join("");
            }
            printImageattr(e4) {
              return e4.map((e5) => "a=imageattr:".concat(e5).concat(this.eol)).join("");
            }
            printRid(e4) {
              return e4.map((e5) => {
                let t5 = "a=rid:".concat(e5.id).concat(o2).concat(e5.direction);
                return e5.payloads && (t5 += "".concat(o2, "pt=").concat(e5.payloads.join(","))), e5.params.length > 0 && (t5 += "".concat(o2).concat(e5.params.map((e6) => "depend" === e6.type ? "depend=".concat(e6.rids.join(",")) : "".concat(e6.type, "=").concat(e6.val)).join(";"))), t5 + this.eol;
              }).join("");
            }
            printSimulcast(e4) {
              return void 0 === e4 ? "" : "a=simulcast:".concat(e4).concat(this.eol);
            }
            printSCTPPort(e4) {
              return void 0 === e4 ? "" : "a=sctp-port:".concat(e4).concat(this.eol);
            }
            printMaxMessageSize(e4) {
              return void 0 === e4 ? "" : "a=max-message-size:".concat(e4).concat(this.eol);
            }
            printMid(e4) {
              return void 0 === e4 ? "" : "a=mid:".concat(e4).concat(this.eol);
            }
            printSSRCGroups(e4) {
              return e4.map((e5) => "a=ssrc-group:".concat(e5.semantic).concat(e5.ssrcIds.map((e6) => "".concat(o2).concat(e6.toString(10))).join("")).concat(this.eol)).join("");
            }
          }
          function D3(e4) {
            return new v3().parse(e4);
          }
          function P2(e4, t5) {
            return new A2().print(e4, t5);
          }
        } }, t3 = {};
        function i2(n3) {
          if (t3[n3]) return t3[n3].exports;
          var r2 = t3[n3] = { exports: {} };
          return e2[n3](r2, r2.exports, i2), r2.exports;
        }
        return i2.d = (e3, t4) => {
          for (var n3 in t4) i2.o(t4, n3) && !i2.o(e3, n3) && Object.defineProperty(e3, n3, { enumerable: true, get: t4[n3] });
        }, i2.o = (e3, t4) => Object.prototype.hasOwnProperty.call(e3, t4), i2.r = (e3) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, i2(8);
      })();
      function FN(e2) {
        return xN.parse(e2);
      }
      function BN(e2, t3) {
        return xN.print(e2, t3);
      }
      var jN = Qi2("Array", "keys"), GN = En2, WN = $e2, HN = l, KN = jN, YN = Array.prototype, zN = { DOMTokenList: true, NodeList: true }, qN = function(e2) {
        var t3 = e2.keys;
        return e2 === YN || HN(YN, e2) && t3 === YN.keys || WN(zN, GN(e2)) ? KN : t3;
      }, XN = i(qN);
      function JN(e2, t3, i2) {
        return (t3 = function(e3) {
          var t4 = function(e4, t5) {
            if ("object" != typeof e4 || !e4) return e4;
            var i3 = e4[Symbol.toPrimitive];
            if (void 0 !== i3) {
              var n3 = i3.call(e4, "string");
              if ("object" != typeof n3) return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          }(e3);
          return "symbol" == typeof t4 ? t4 : t4 + "";
        }(t3)) in e2 ? Object.defineProperty(e2, t3, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t3] = i2, e2;
      }
      function ZN(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function QN(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? ZN(Object(i2), true).forEach(function(t4) {
            JN(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ZN(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const $N = new class extends Hw2 {
        constructor() {
          super(...arguments), JN(this, "currentUploadLogID", 0);
        }
        reportLogUploadError(e2) {
          const { errorRange: t3 } = e2;
          t3[t3.length - 1] && t3[t3.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = t3[t3.length - 1], this.emit("REPORT_LOG_UPLOAD", e2));
        }
      }();
      class eD2 {
        constructor(e2) {
          JN(this, "logger", void 0), JN(this, "prefixLists", []), this.logger = e2;
        }
        debug() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          this.logger.debug(...this.prefixLists, ...t3);
        }
        info() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          this.logger.info(...this.prefixLists, ...t3);
        }
        warning() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          this.logger.warning(...this.prefixLists, ...t3);
        }
        error() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          this.logger.error(...this.prefixLists, ...t3);
        }
        prefix(e2) {
          return this.prefixLists.push(e2), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      function tD() {
        const e2 = /* @__PURE__ */ new Date();
        return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      function iD2() {
        const e2 = /* @__PURE__ */ new Date(), t3 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
        return t3 ? (null == t3 ? void 0 : t3[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      const nD2 = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, rD2 = Date.now(), oD2 = (e2) => {
        for (const t3 in nD2) if (Object.prototype.hasOwnProperty.call(nD2, t3) && nD2[t3] === e2) return t3;
        return "DEFAULT";
      };
      const sD = new class {
        constructor() {
          JN(this, "proxyServerURL", void 0), JN(this, "logLevel", nD2.DEBUG), JN(this, "uploadState", "collecting"), JN(this, "uploadLogWaitingList", []), JN(this, "uploadLogUploadingList", []), JN(this, "uploadErrorCount", 0), JN(this, "currentLogID", 0), JN(this, "url", void 0), JN(this, "extLog", (e2, t3) => {
            this.appendLogToWaitingList(e2, ...t3);
          });
        }
        debug() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          const n3 = [nD2.DEBUG].concat(t3);
          this.log.apply(this, n3);
        }
        info() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          const n3 = [nD2.INFO].concat(t3);
          this.log.apply(this, n3);
        }
        warning() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          const n3 = [nD2.WARNING].concat(t3);
          this.log.apply(this, n3);
        }
        warn() {
          this.warning(...arguments);
        }
        error() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          const n3 = [nD2.ERROR].concat(t3);
          this.log.apply(this, n3);
        }
        upload() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          const n3 = [nD2.DEBUG].concat(t3);
          this.uploadLog.apply(this, n3);
        }
        setLogLevel(e2) {
          e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
        }
        enableLogUpload() {
          AN("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          AN("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e2) {
          this.proxyServerURL = e2;
        }
        prefix(e2) {
          return new eD2(this).prefix(e2);
        }
        log() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          if (Date.now() - rD2 < 100) return void setTimeout(() => {
            this.log(...t3);
          }, Date.now() - rD2);
          const n3 = Math.max(0, Math.min(4, t3[0]));
          if (t3[0] = tD() + " Agora-SDK [".concat(oD2(n3), "]:"), this.appendLogToWaitingList(n3, ...t3), n3 < this.logLevel) return;
          const r2 = tD() + " %cAgora-SDK [".concat(oD2(n3), "]:");
          let o2 = [];
          if (!wN("USE_NEW_LOG")) switch (n3) {
            case nD2.DEBUG:
              o2 = [r2, "color: #64B5F6;"].concat(t3.slice(1)), console.log.apply(console, o2);
              break;
            case nD2.INFO:
              o2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t3.slice(1)), console.log.apply(console, o2);
              break;
            case nD2.WARNING:
              o2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t3.slice(1)), console.warn.apply(console, o2);
              break;
            case nD2.ERROR:
              o2 = [r2, "color: #B00020; font-weight: bold;"].concat(t3.slice(1)), console.error.apply(console, o2);
          }
        }
        uploadLog() {
          for (var e2 = arguments.length, t3 = new Array(e2), i2 = 0; i2 < e2; i2++) t3[i2] = arguments[i2];
          if (Date.now() - rD2 < 100) return void setTimeout(() => {
            this.uploadLog(...t3);
          }, Date.now() - rD2);
          const n3 = Math.max(0, Math.min(4, t3[0]));
          t3[0] = tD() + " Agora-SDK [".concat(oD2(n3), "]:"), this.appendLogToWaitingList(n3, ...t3);
        }
        appendLogToWaitingList(e2) {
          if (!wN("UPLOAD_LOG")) return;
          for (var t3 = arguments.length, i2 = new Array(t3 > 1 ? t3 - 1 : 0), n3 = 1; n3 < t3; n3++) i2[n3 - 1] = arguments[n3];
          Array.isArray(i2[0]) ? i2[0][0] = iD2() + " Agora-SDK [".concat(oD2(e2), "]:") : i2[0] = iD2() + " Agora-SDK [".concat(oD2(e2), "]:");
          let r2 = "";
          i2.forEach((e3) => {
            "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
          }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e2 = this.uploadLogUploadingList, t3 = { sdk_version: SN, process_id: wN("PROCESS_ID"), payload: JSON.stringify(e2) };
          return GO(async () => {
            const e3 = await UA2.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(wN("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(wN("LOG_UPLOAD_SERVER"), "/upload/v1")), t3, { responseType: "text" });
            if ("OK" !== e3.data) {
              const t4 = new Error("unexpected upload log response");
              throw t4.response = e3, t4;
            }
          }, () => (this.uploadLogUploadingList = [], false), (t4) => {
            const i2 = { status: -1, message: t4.message, errorRange: e2.map((e3) => e3.log_item_id) };
            return t4.response ? (i2.status = t4.response.status, i2.data = t4.response.data, i2.headers = t4.response.headers) : t4.request && (i2.status = t4.request.status), $N.reportLogUploadError(i2), true;
          }, { timeout: wN("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: wN("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
        }
        uploadLogInterval() {
          0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, wN("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), wN("UPLOAD_LOG_INTERVAL"));
          }).catch((e2) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), wN("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), wN("UPLOAD_LOG_RETRY_INTERVAL_V1"));
          }));
        }
      }();
      var aD2;
      function cD2(e2) {
        return kw2(e2.reportId, "params.reportId", 0, 100, false), kw2(e2.category, "params.category", 0, 100, false), kw2(e2.event, "params.event", 0, 100, false), kw2(e2.label, "params.label", 0, 100, false), Pw2(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      (aD2 = {}).FREE = "free", aD2.UPLOADING = "uploading", function(e2) {
        e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
      }({});
      const dD2 = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      let lD2 = function(e2) {
        return e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.XLA_PEER_FIRST_VIDEO_FRAME = "xla_peer_first_video_frame", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities", e2.AB_TEST = "ab_test", e2;
      }({}), uD = function(e2) {
        return e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.XLA_PEER_FIRST_VIDEO_FRAME = "io.agora.pb.Wrtc.XLAPeerFirstVideoFrame", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats", e2.UPDATE_REMOTE_RTPCAPABILITIES = "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities", e2.AB_TEST = "io.agora.pb.Wrtc.ABTest", e2;
      }({});
      !function(e2) {
        e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      }({});
      let hD2 = function(e2) {
        return e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED", e2;
      }({});
      function pD2() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return function(t3, i2, n3) {
          const r2 = n3.value;
          if ("function" == typeof r2) {
            const o2 = e2.className || t3.__className__ || ("AgoraRTCClient" === t3.constructor.name ? "Client" : t3.constructor.name);
            n3.value = function() {
              for (var t4, n4 = arguments.length, s2 = new Array(n4), a3 = 0; a3 < n4; a3++) s2[a3] = arguments[a3];
              let c3 = s2;
              if (e2.argsMap) try {
                c3 = e2.argsMap(this, ...s2);
              } catch (e3) {
                sD.warning(e3), c3 = [];
              }
              try {
                JSON.stringify(c3);
              } catch (e3) {
                sD.warning("arguments for method ".concat(o2, ".").concat(String(i2), " not serializable for apiInvoke.")), c3 = [];
              }
              const d2 = (e2.report || _D).reportApiInvoke(this._sessionId || null, { id: this._clientId || (null === (t4 = this.store) || void 0 === t4 ? void 0 : t4.clientId) || this._ID, name: "".concat(o2, ".").concat(String(i2)), options: c3, tag: qw2.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
              try {
                const t5 = r2.apply(this, s2);
                return t5 instanceof ip2 ? t5.then((t6) => (d2.onSuccess(e2.reportResult && t6), t6)).catch((e3) => {
                  throw d2.onError(e3), e3;
                }) : (d2.onSuccess(e2.reportResult && t5), t5);
              } catch (e3) {
                throw d2.onError(e3), e3;
              }
            };
          }
          return n3;
        };
      }
      const _D = new class {
        constructor() {
          JN(this, "baseInfoMap", /* @__PURE__ */ new Map()), JN(this, "proxyServer", void 0), JN(this, "eventUploadTimer", void 0), JN(this, "setSessionIdTimer", void 0), JN(this, "url", void 0), JN(this, "sids", /* @__PURE__ */ new Set()), JN(this, "backupUrl", void 0), JN(this, "_appId", void 0), JN(this, "_aid", 0), JN(this, "keyEventUploadPendingItems", []), JN(this, "normalEventUploadPendingItems", []), JN(this, "apiInvokeUploadPendingItems", []), JN(this, "apiInvokeCount", 0), JN(this, "apiInvokeLoggedCount", 0), JN(this, "ltsList", []), JN(this, "lastSendNormalEventTime", Date.now()), JN(this, "customReportCounterTimer", void 0), JN(this, "customReportCount", 0), JN(this, "extApiInvoke", async (e2) => {
            for (const t3 of e2) {
              const e3 = QN(QN({}, t3), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: qw2.TRACER });
              this.sendApiInvoke(e3);
            }
          }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), wN("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), wN("EVENT_REPORT_SEND_INTERVAL"));
        }
        getBaseInfoBySessionId(e2) {
          return this.baseInfoMap.get(e2);
        }
        setAppId(e2) {
          this._appId = e2, this._aid = parseInt(e2.replace(/[a-fA-F0-9]{8}/g, (e3) => {
            let [t3, i2] = e3;
            return t3 + i2;
          }), 16) || 0;
        }
        reportApiInvoke(e2, t3, i2) {
          t3.timeout = t3.timeout || 6e4, t3.reportResult = void 0 === t3.reportResult || t3.reportResult;
          const n3 = Date.now();
          this.apiInvokeCount += 1;
          const r2 = this.apiInvokeCount, o2 = !!wN("SHOW_REPORT_INVOKER_LOG"), s2 = !!wN("SHOW_REPORT_USER_INVOKER_LOG"), a3 = o2 || s2 && t3.id;
          a3 && (this.apiInvokeLoggedCount += 1);
          const c3 = this.apiInvokeLoggedCount;
          function d2(e3, i3) {
            if (a3) {
              let n4 = "[apiInvoke-".concat(c3, "]");
              if (t3.id && (n4 += "[".concat(t3.id, "]")), t3.name && (n4 += "[".concat(t3.name, "]"), t3.name === zw2.JOIN)) return sD.info("".concat(n4, " ").concat(e3));
              sD.info("".concat(n4, " ").concat(e3), "start" === e3 ? t3.options : i3 || "");
            }
          }
          const l2 = () => ({ tag: t3.tag, invokeId: r2, sid: e2, name: t3.name, apiInvokeTime: n3, options: t3.options, states: t3.states || null });
          d2("start");
          let u3 = false;
          yO(t3.timeout).then(() => {
            u3 || (this.sendApiInvoke(QN(QN({}, l2()), {}, { error: ww2.API_INVOKE_TIMEOUT, success: false })), d2("timeout"));
          });
          const h2 = new Ow2(ww2.UNEXPECTED_ERROR, "".concat(t3.name, ": this api invoke is end"));
          return { onSuccess: (e3) => {
            const n4 = () => {
              if (u3) throw h2;
              return u3 = true, this.sendApiInvoke(QN(QN({}, l2()), {}, { success: true }, t3.reportResult && { result: e3 })), d2("onSuccess"), e3;
            };
            return i2 ? OO(n4, t3.name + "Success", i2, () => u3 = true) : n4();
          }, onError: (e3) => {
            const n4 = () => {
              if (u3) throw e3;
              u3 = true, this.sendApiInvoke(QN(QN({}, l2()), {}, { success: false, error: e3 })), d2("onFailure", e3.toString());
            };
            return i2 ? OO(n4, t3.name + "Error", i2, () => u3 = true) : n4();
          } };
        }
        sessionInit(e2, t3) {
          if (this.baseInfoMap.has(e2)) return;
          const i2 = Date.now(), n3 = this.createBaseInfo(e2, i2);
          n3.cname = t3.cname;
          const r2 = Object.assign({}, { willUploadConsoleLog: wN("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: gN ? "global" : "oversea", areas: wN("AREAS") && wN("AREAS").join(",") }, t3.extend), { stringUid: o2, channelProfile: s2, channelMode: a3, isABTestSuccess: c3, lsid: d2, clientRole: l2 } = t3, u3 = Date.now(), h2 = QN(QN({}, n3), {}, { eventType: lD2.SESSION_INIT, appid: t3.appid, browser: navigator.userAgent, buildFormat: t3.buildFormat, build: yN, lts: u3, elapse: u3 - i2, extend: JSON.stringify(r2), mode: t3.mode, process: wN("PROCESS_ID"), appType: wN("APP_TYPE"), success: true, version: SN, stringUid: o2, channelProfile: s2, channelMode: a3, isABTestSuccess: c3, lsid: d2, clientType: Ln2(p2 = window.navigator.userAgent).call(p2, "AgoraWebView") ? 42 : 20, clientRole: l2, serviceId: wN("PROCESS_ID"), extensionID: wN("PLUGIN_INFO").join(",") || "" });
          var p2;
          this.send({ type: uD.SESSION, data: h2 }, true);
        }
        joinChooseServer(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { role: t3.role, eventType: lD2.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: t3.elapse || r2 - t3.lts, chooseServerAddr: t3.csAddr, errorCode: t3.ec, elapse: r2 - i2.startTime, success: t3.succ, chooseServerAddrList: JSON.stringify(t3.serverList), uid: t3.uid ? parseInt(t3.uid) : null, cid: t3.cid ? parseInt(t3.cid) : null, chooseServerIp: t3.csIp || "", opid: t3.opid, unilbsServerIds: t3.unilbsServerIds, extend: t3.extend || void 0, isHttp3: t3.isHttp3, corssRegionTagReq: t3.corssRegionTagReq || void 0, corssRegionTagRes: t3.corssRegionTagRes || void 0, resourceTimingInfo: t3.resourceTimingInfo || void 0 });
          this.send({ type: uD.JOIN_CHOOSE_SERVER, data: o2 }, true);
        }
        reqUserAccount(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { eventType: lD2.REQ_USER_ACCOUNT, lts: r2, success: t3.success, serverAddress: t3.serverAddr, stringUid: t3.stringUid, uid: t3.uid, errorCode: t3.errorCode, elapse: t3.elapse || r2 - i2.startTime, eventElapse: r2 - t3.lts, extend: JSON.stringify(t3.extend) });
          this.send({ type: uD.REQ_USER_ACCOUNT, data: o2 }, true);
        }
        joinGateway(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info;
          t3.vid && (n3.vid = t3.vid), n3.uid = t3.uid, n3.cid = t3.cid;
          const r2 = Date.now(), { firstSuccess: o2, addr: s2, isProxy: a3 } = t3, c3 = r2 - i2.startTime, d2 = QN(QN({}, n3), {}, { eventType: lD2.JOIN_GATEWAY, lts: r2, gatewayAddr: t3.addr, success: t3.succ, errorCode: t3.ec, errorMsg: t3.errorMsg || "", elapse: c3, eventElapse: r2 - t3.lts, firstSuccess: o2, signalChannel: t3.signalChannel, preload: t3.preload ? 1 : 0, installId: fN(), isABTestSuccess: t3.isABTestSuccess ? 1 : 0 }), l2 = d2.success ? 1 : 0;
          if (t3.succ && (i2.lastJoinSuccessTime = r2), o2) this.send({ type: uD.JOIN_GATEWAY, data: d2 }, true);
          else {
            let e3;
            if (s2) if (a3) {
              const t5 = s2.match(/h=(\d{1,3}-){3}\d{1,3}/g), i3 = s2.match(/p=[0-9]{1,6}/g);
              e3 = { isSuccess: l2, gatewayIp: t5 && t5.length ? t5[0].split("=")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split("=")[1] : "", isProxy: a3 ? 1 : 0 };
            } else {
              const t5 = s2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i3 = s2.match(/(:|p=)[0-9]{1,6}/g);
              e3 = { isSuccess: l2, gatewayIp: t5 && t5.length ? t5[0].split("//")[1].replace(/-/g, ".") : "", port: i3 && i3.length ? i3[0].split(/:|p=/g)[1] : "", isProxy: a3 ? 1 : 0 };
            }
            else e3 = { isSuccess: l2, gatewayIp: "", port: "", isProxy: a3 ? 1 : 0 };
            delete d2.success, delete d2.eventType, delete d2.firstSuccess, d2.vid = Number(d2.vid);
            const t4 = Object.assign({}, d2, e3, { eventType: lD2.REJOIN_GATEWAY });
            this.send({ type: uD.RE_JOIN_GATEWAY, data: t4 }, true);
          }
        }
        joinChannelTimeout(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = Date.now(), r2 = QN(QN({}, i2.info), {}, { lts: n3, timeout: t3, elapse: n3 - i2.startTime });
          this.send({ type: uD.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
        }
        publish(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { eventType: lD2.PUBLISH, lts: r2, eventElapse: t3.eventElapse, elapse: r2 - i2.startTime, success: t3.succ, errorCode: t3.ec, videoName: t3.videoName, audioName: t3.audioName, screenName: t3.screenName, screenshare: t3.screenshare, audio: t3.audio, video: t3.video, p2pid: t3.p2pid, publishRequestid: t3.publishRequestid });
          this.send({ type: uD.PUBLISH, data: o2 }, true);
        }
        subscribe(e2, t3, i2) {
          const n3 = this.baseInfoMap.get(e2);
          if (!n3) return;
          const r2 = n3.info, o2 = Date.now(), s2 = QN(QN({}, r2), {}, { eventType: lD2.SUBSCRIBE, lts: o2, eventElapse: t3.eventElapse, elapse: o2 - n3.startTime, success: t3.succ, errorCode: t3.ec, video: t3.video, audio: t3.audio, subscribeRequestid: t3.subscribeRequestid, p2pid: t3.p2pid, preSsrc: t3.preSsrc ? 1 : 0 }, i2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          "string" == typeof t3.peerid ? s2.peerSuid = t3.peerid : s2.peer = t3.peerid, this.send({ type: uD.SUBSCRIBE, data: s2 }, true);
        }
        wsCompressorInit(e2) {
          var t3;
          const i2 = [...XN(t3 = this.baseInfoMap).call(t3)], n3 = i2.length ? i2[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n3);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a3 = QN(QN({}, o2), {}, { eventType: lD2.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e2.eventElapse, elapse: s2 - r2.startTime, status: e2.status ? 1 : 2 });
          this.send({ type: uD.WS_COMPRESSOR_INIT, data: a3 }, true);
        }
        firstXLAPeerFirstVideoFrame(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = t3.peerPubStatusMs - (i2.lastJoinSuccessTime || r2), s2 = QN(QN({}, n3), {}, { elapse: r2 - i2.startTime, eventType: lD2.XLA_PEER_FIRST_VIDEO_FRAME, lts: r2, peer: t3.peer, width: t3.width, height: t3.height, ssrc: t3.ssrc, p2pid: t3.p2pid, peerPublishDuration: t3.peerPublishDuration, joinChannelSuccessElapse: o2, peerPubStatusMs: t3.peerPubStatusMs - t3.joinChannelStart, availablePublish: t3.peerPublishDuration > o2 ? 1 : 0, preloadStart: Math.max(t3.preloadStart - t3.joinChannelStart, 0), preloadEnd: Math.max(t3.preloadEnd - t3.joinChannelStart, 0), encrypt: Math.max(t3.apStart - t3.joinChannelStart, 0), ap: Math.max(t3.apEnd - t3.joinChannelStart, 0), sua: Math.max(t3.suaEnd - t3.joinChannelStart, 0), beforeConnect: Math.max(t3.beforeConnect - t3.joinChannelStart, 0), peerRecevier: Math.max(t3.peerReceiver - t3.joinChannelStart, 0), ice: Math.max(t3.ice - t3.joinChannelStart, 0), pc: Math.max(t3.pc - t3.joinChannelStart, 0), signalConnected: Math.max(t3.signalConnected - t3.joinChannelStart, 0), joinReq: Math.max(t3.joinReq - t3.joinChannelStart, 0), joinRes: Math.max(t3.joinRes - t3.joinChannelStart, 0), userJoinNotify: Math.max(t3.userJoinNotify - t3.joinChannelStart, 0), videoSsrcNotify: Math.max(t3.videoAddNotify - t3.joinChannelStart, 0), subscribeDelayMs: Math.max(t3.subscribeStart - t3.videoAddNotify, 0), subscribeStart: Math.max(t3.subscribeStart - t3.joinChannelStart, 0), subscribeEnd: Math.max(t3.subscribeEnd - t3.joinChannelStart, 0), firstReceived: Math.max(t3.firstReceived - t3.joinChannelStart, 0), firstDecoded: Math.max(t3.firstDecoded - t3.joinChannelStart, 0), firstPreRender: Math.max(t3.firstPreRender - t3.joinChannelStart, 0), firstRender: Math.max(t3.firstRender - t3.joinChannelStart, 0), playDelayMs: Math.max(t3.playStart - t3.subscribeEnd, 0), playStart: Math.max(t3.playStart - t3.joinChannelStart, 0), playEnd: Math.max(t3.playEnd - t3.joinChannelStart, 0), isPreSub: t3.isPreSub ? 1 : 0, isPrePc: t3.isPrePc ? 1 : 0, isPreInstantVideo: t3.isPreInstantVideo ? 1 : 0 });
          this.send({ type: uD.XLA_PEER_FIRST_VIDEO_FRAME, data: s2 }, true);
        }
        firstRemoteVideoDecode(e2, t3, i2, n3) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a3 = QN(QN(QN({}, o2), n3), {}, { elapse: s2 - r2.startTime, eventType: t3, lts: s2, firstDecodeFrame: Math.max((n3.firstFrame || s2) - r2.startTime, 0), apEnd: Math.max(n3.apEnd - r2.startTime, 0), apStart: Math.max(n3.apStart - r2.startTime, 0), joinGwEnd: Math.max(n3.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n3.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n3.pcEnd - r2.startTime, 0), pcStart: Math.max(n3.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n3.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n3.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n3.videoAddNotify - r2.startTime, 0) });
          this.send({ type: i2, data: a3 }, true);
        }
        firstRemoteFrame(e2, t3, i2, n3) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a3 = QN(QN(QN({}, o2), n3), {}, { elapse: s2 - r2.startTime, eventType: t3, lts: s2 });
          this.send({ type: i2, data: a3 }, true);
        }
        abTest(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN(QN({}, n3), t3), {}, { vid: void 0 === n3.vid ? 0 : Number(n3.vid), elapse: r2 - i2.startTime, eventType: lD2.AB_TEST, lts: r2 });
          this.send({ type: uD.AB_TEST, data: o2 }, true);
        }
        pcStats(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN(QN({}, n3), t3), {}, { vid: void 0 === n3.vid ? 0 : Number(n3.vid), elapse: r2 - i2.startTime, eventType: lD2.PC_STATS, lts: r2, preallocation: t3.preallocation ? 1 : 0 });
          this.send({ type: uD.PC_STATS, data: o2 }, true);
        }
        updateRemoteRTPCapabilities(e2, t3) {
          if (e2) {
            const i2 = this.baseInfoMap.get(e2);
            if (!i2) return;
            const n3 = i2.info, r2 = Date.now(), o2 = QN(QN(QN({}, n3), t3), {}, { vid: void 0 === n3.vid ? 0 : Number(n3.vid), eventType: lD2.UPDATE_REMOTE_RTPCAPABILITIES, lts: r2 });
            this.send({ type: uD.UPDATE_REMOTE_RTPCAPABILITIES, data: o2 }, true);
          }
        }
        onGatewayStream(e2, t3, i2, n3) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2) return;
          const o2 = r2.info, s2 = Date.now(), a3 = QN(QN(QN({}, o2), n3), {}, { eventType: t3, lts: s2 });
          this.send({ type: i2, data: a3 }, true);
        }
        streamSwitch(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { eventType: lD2.STREAM_SWITCH, lts: r2, isDual: t3.isdual, elapse: r2 - i2.startTime, success: t3.succ });
          this.send({ type: uD.STREAM_SWITCH, data: o2 }, true);
        }
        requestProxyAppCenter(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { eventType: lD2.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t3.lts, elapse: r2 - i2.startTime, APAddr: t3.APAddr, workerManagerList: t3.workerManagerList, response: t3.response, errorCode: t3.ec, success: t3.succ });
          this.send({ type: uD.REQUEST_PROXY_APPCENTER, data: o2 }, true);
        }
        requestProxyWorkerManager(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { eventType: lD2.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t3.lts, elapse: r2 - i2.startTime, workerManagerAddr: t3.workerManagerAddr, response: t3.response, errorCode: t3.ec, success: t3.succ });
          this.send({ type: uD.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
        }
        setProxyServer(e2) {
          this.proxyServer = e2, e2 ? sD.debug("reportProxyServerurl: ".concat(e2)) : sD.debug("disable reportProxyServerurl: ".concat(e2));
        }
        peerPublishStatus(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN({}, n3), {}, { subscribeElapse: t3.subscribeElapse, peer: t3.peer, peerPublishDuration: Math.max(t3.audioPublishDuration, t3.videoPublishDuration), audiotag: t3.audioPublishDuration > 0 ? 1 : -1, videotag: t3.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i2.startTime, joinChannelSuccessElapse: r2 - (i2.lastJoinSuccessTime || r2), peerPublishDurationVideo: t3.videoPublishDuration, peerPublishDurationAudio: t3.audioPublishDuration });
          this.send({ type: uD.PEER_PUBLISH_STATUS, data: o2 }, true);
        }
        workerEvent(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now();
          (function(e3, t4, i3) {
            const n4 = e3[t4];
            if (!n4 || "string" != typeof n4) return [e3];
            e3[t4] = "";
            const r3 = RO(JSON.stringify(e3));
            let o2 = 0;
            const s2 = [];
            let a3 = 0;
            for (let c3 = 0; c3 < n4.length; c3++) a3 += n4.charCodeAt(c3) <= 127 ? 1 : 3, a3 <= i3 - r3 || (s2[s2.length] = Aw2(Aw2({}, e3), {}, { [t4]: n4.substring(o2, c3) }), o2 = c3, a3 = n4.charCodeAt(c3) <= 127 ? 1 : 3);
            return o2 !== n4.length - 1 && (s2[s2.length] = Aw2(Aw2({}, e3), {}, { [t4]: n4.substring(o2) })), s2;
          })(QN(QN(QN({}, n3), t3), {}, { elapse: r2 - i2.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300).forEach((e3) => this.send({ type: uD.WORKER_EVENT, data: e3 }, true));
        }
        apworkerEvent(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN(QN({}, n3), t3), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: uD.AP_WORKER_EVENT, data: o2 }, true);
        }
        joinWebProxyAP(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN(QN({}, n3), t3), {}, { elapse: r2 - i2.startTime, lts: r2, extend: t3.extend || void 0 });
          this.send({ type: uD.JOIN_WEB_PROXY_AP, data: o2 }, true);
        }
        WebSocketQuit(e2, t3) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2) return;
          const n3 = i2.info, r2 = Date.now(), o2 = QN(QN(QN({}, n3), t3), {}, { elapse: r2 - i2.startTime, lts: r2 });
          this.send({ type: uD.WEBSOCKET_QUIT, data: o2 }, true);
        }
        async sendCustomReportMessage(e2, t3) {
          if (this.customReportCount += t3.length, this.customReportCount > wN("CUSTOM_REPORT_LIMIT")) throw new Ow2(ww2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
            this.customReportCount = 0;
          }, 5e3));
          const i2 = Date.now(), n3 = t3.map((t4) => ({ type: uD.USER_ANALYTICS, data: QN(QN({ sid: e2 }, t4), {}, { lts: i2 }) }));
          try {
            wN("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n3) : await this.postDataToStatsCollector(n3);
          } catch (e3) {
            throw sD.error("send custom report message failed", e3.toString()), new Ow2(ww2.CUSTOM_REPORT_SEND_FAILED, e3.message);
          }
        }
        sendApiInvoke(e2) {
          const t3 = wN("NOT_REPORT_EVENT");
          if (e2.tag && Ln2(t3) && Ln2(t3).call(t3, e2.tag)) return false;
          if (null === e2.sid) return this.apiInvokeUploadPendingItems.push(e2), false;
          const i2 = this.baseInfoMap.get(e2.sid);
          if (!i2) return this.apiInvokeUploadPendingItems.push(e2), false;
          const { cname: n3, uid: r2, cid: o2 } = i2.info;
          let s2;
          if (e2.lts = e2.lts || Date.now(), e2.error) if (e2.error instanceof Ow2) {
            const { code: t4, message: i3 } = e2.error;
            s2 = t4 || i3 || e2.error.toString();
          } else s2 = e2.error.toString();
          const a3 = { invokeId: e2.invokeId, sid: e2.sid, cname: n3, cid: o2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i2.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? s2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
          return this.send({ type: uD.API_INVOKE, data: a3 }, false), true;
        }
        addSid(e2) {
          this.sids.add(e2);
        }
        removeSid(e2) {
          this.sids.delete(e2);
        }
        appendSessionId() {
          const e2 = this.apiInvokeUploadPendingItems;
          if (0 === e2.length) return;
          const t3 = Array.from(this.sids).find((e3) => null !== e3);
          t3 && e2.forEach((e3) => {
            e3 && (e3.sid = t3, this.sendApiInvoke(Object.assign({}, e3)));
          }), e2.length = 0;
        }
        send(e2, t3) {
          if (t3) return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > wN("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e2, t3) {
          const i2 = [], n3 = [];
          for (; e2.length; ) {
            const t4 = e2.shift();
            i2.length < 20 ? i2.push(t4) : n3.push(t4);
          }
          e2.push(...n3);
          for (const e3 of [...i2]) {
            var r2;
            -1 !== this.ltsList.indexOf(e3.data.lts) ? (e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts)) : (this.ltsList.push(e3.data.lts), Xp2(r2 = this.ltsList).call(r2, (e4, t4) => e4 - t4));
          }
          return t3 || (this.lastSendNormalEventTime = Date.now()), wN("ENABLE_EVENT_REPORT") ? (i2.length && (wN("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i2) : this.postDataToStatsCollector(i2)).catch(/* @__PURE__ */ ((e3) => (i3) => {
            wN("EVENT_REPORT_RETRY") && (t3 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > wN("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - wN("NORMAL_EVENT_QUEUE_CAPACITY")), sD.warning("report: drop normal events"))));
          })(i2)), e2) : e2;
        }
        async postDataToStatsCollector2(e2) {
          dO.networkState === nO.OFFLINE && await ip2.race([dO.onlineWaiter, yO(2 * BO.maxRetryTimeout)]);
          const t3 = (e3) => {
            let t4 = new Uint8Array();
            return e3.forEach((e4) => {
              const i3 = jw2(JSON.stringify(e4.data)), n4 = new ArrayBuffer(5), r2 = ((e5) => {
                let t5 = 0;
                return Object.entries(uD).forEach((i4) => {
                  let [n5, r3] = i4;
                  r3 === e5.type && (t5 = hD2[n5]);
                }), t5;
              })(e4), o2 = new DataView(n4);
              o2.setUint16(0, i3.byteLength, true), o2.setUint8(2, 255 & r2), o2.setUint8(3, r2 >>> 8 & 255), o2.setUint8(4, r2 >>> 16 & 255), t4 = Gw2(t4, new Uint8Array(n4)), t4 = Gw2(t4, i3);
            }), t4;
          }, i2 = "event";
          let n3 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(wN("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i2) : "https://".concat(wN("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i2);
          for (let r2 = 0; r2 < 2; r2 += 1) {
            1 === r2 && (n3 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(wN("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i2) : "https://".concat(wN("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i2));
            try {
              await zO(n3, { timeout: 1e4, data: t3(e2), headers: QN(QN({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
            } catch (e3) {
              if (1 === r2) throw e3;
              continue;
            }
            return;
          }
        }
        async postDataToStatsCollector(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          const i2 = ((e3) => {
            const t4 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
            return t4 && t4.info.vid && +t4.info.vid || 0;
          })(e2[0]), n3 = i2 ? void 0 : this._aid, r2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map((e3) => JSON.stringify(e3)), vid: i2, aid: n3 };
          dO.networkState === nO.OFFLINE && await ip2.race([dO.onlineWaiter, yO(2 * BO.maxRetryTimeout)]);
          const o2 = t3 ? "/events/proto-raws" : "/events/messages";
          let s2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(wN("EVENT_REPORT_DOMAIN"), "&p=").concat(wN("STATS_COLLECTOR_PORT"), "&d=").concat(o2) : "https://".concat(wN("EVENT_REPORT_DOMAIN"), ":").concat(wN("STATS_COLLECTOR_PORT")).concat(o2));
          for (let e3 = 0; e3 < 2; e3 += 1) {
            1 === e3 && (s2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(wN("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(wN("STATS_COLLECTOR_PORT"), "&d=").concat(o2) : "https://".concat(wN("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(wN("STATS_COLLECTOR_PORT")).concat(o2)));
            try {
              t3 ? await qO(s2, { timeout: 1e4, data: r2 }) : await zO(s2, { timeout: 1e4, data: r2 });
            } catch (t4) {
              if (1 === e3) throw t4;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e2, t3) {
          const i2 = Object.assign({}, dD2);
          return i2.sid = e2, this.baseInfoMap.set(e2, { info: i2, startTime: t3 }), i2;
        }
        reportResourceTiming(e2, t3) {
          const i2 = performance.getEntriesByName(e2), n3 = i2[i2.length - 1];
          n3 && this.reportApiInvoke(t3, { name: "Client.resourceTiming", options: n3, tag: qw2.TRACER }).onSuccess();
        }
      }();
      $N.on("REPORT_LOG_UPLOAD", (e2) => {
        e2.networkState = dO.networkState, _D.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: qw2.TRACER }).onSuccess("logUploadError");
      });
      class ED extends Ow2 {
        constructor(e2) {
          super(e2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), JN(this, "name", "AgoraRTCException");
        }
        print() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
          return super.print(e2, sD);
        }
        throw() {
          super.throw(sD);
        }
      }
      const mD2 = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false, supportRequestVideoFrameCallback: false, supportWebCrypto: false };
      function fD2() {
        return mD2;
      }
      function SD() {
        return "setSinkId" in HTMLAudioElement.prototype && (!wN("RESTRICTION_SET_PLAYBACK_DEVICE") || (QA2() || tw2()) && !Rw2());
      }
      function gD2() {
        return !mD2.supportUnifiedPlan || wN("CHROME_FORCE_PLAN_B") && vw2();
      }
      function TD(e2) {
        return !(iw2() || ow2(87) || gD2() || !wN("ENABLE_PRE_SUB") && (null == e2 || !e2.autoSubscribe || wN("FORCE_DISABLE_AUTO_SUB")));
      }
      function RD(e2) {
        return !!wN("ENABLE_INSTANT_VIDEO") || !(null == e2 || !e2.autoSubscribe || wN("FORCE_DISABLE_AUTO_SUB"));
      }
      let vD = function(e2) {
        return e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change", e2;
      }({});
      function CD(e2, t3, i2) {
        return { sampleRate: e2, stereo: t3, bitrate: i2 };
      }
      function yD(e2, t3, i2, n3, r2) {
        return { width: e2, height: t3, frameRate: i2, bitrateMin: n3, bitrateMax: r2 };
      }
      function ID(e2, t3, i2, n3, r2) {
        return { width: { max: e2 }, height: { max: t3 }, frameRate: i2, bitrateMin: n3, bitrateMax: r2 };
      }
      function bD2(e2, t3) {
        return { numSpatialLayers: e2, numTemporalLayers: t3 };
      }
      const AD = { "90p": yD(160, 90), "90p_1": yD(160, 90), "120p": yD(160, 120, 15, 30, 65), "120p_1": yD(160, 120, 15, 30, 65), "120p_3": yD(120, 120, 15, 30, 50), "120p_4": yD(212, 120), "180p": yD(320, 180, 15, 30, 140), "180p_1": yD(320, 180, 15, 30, 140), "180p_3": yD(180, 180, 15, 30, 100), "180p_4": yD(240, 180, 15, 30, 120), "240p": yD(320, 240, 15, 40, 200), "240p_1": yD(320, 240, 15, 40, 200), "240p_3": yD(240, 240, 15, 40, 140), "240p_4": yD(424, 240, 15, 40, 220), "360p": yD(640, 360, 15, 80, 400), "360p_1": yD(640, 360, 15, 80, 400), "360p_3": yD(360, 360, 15, 80, 260), "360p_4": yD(640, 360, 30, 80, 600), "360p_6": yD(360, 360, 30, 80, 400), "360p_7": yD(480, 360, 15, 80, 320), "360p_8": yD(480, 360, 30, 80, 490), "360p_9": yD(640, 360, 15, 80, 800), "360p_10": yD(640, 360, 24, 80, 800), "360p_11": yD(640, 360, 24, 80, 1e3), "480p": yD(640, 480, 15, 100, 500), "480p_1": yD(640, 480, 15, 100, 500), "480p_2": yD(640, 480, 30, 100, 1e3), "480p_3": yD(480, 480, 15, 100, 400), "480p_4": yD(640, 480, 30, 100, 750), "480p_6": yD(480, 480, 30, 100, 600), "480p_8": yD(848, 480, 15, 100, 610), "480p_9": yD(848, 480, 30, 100, 930), "480p_10": yD(640, 480, 10, 100, 400), "720p": yD(1280, 720, 15, 120, 1130), "720p_auto": yD(1280, 720, 30, 900, 3e3), "720p_1": yD(1280, 720, 15, 120, 1130), "720p_2": yD(1280, 720, 30, 120, 2e3), "720p_3": yD(1280, 720, 30, 120, 1710), "720p_5": yD(960, 720, 15, 120, 910), "720p_6": yD(960, 720, 30, 120, 1380), "1080p": yD(1920, 1080, 15, 120, 2080), "1080p_1": yD(1920, 1080, 15, 120, 2080), "1080p_2": yD(1920, 1080, 30, 120, 3e3), "1080p_3": yD(1920, 1080, 30, 120, 3150), "1080p_5": yD(1920, 1080, 60, 120, 4780), "1440p": yD(2560, 1440, 30, 120, 4850), "1440p_1": yD(2560, 1440, 30, 120, 4850), "1440p_2": yD(2560, 1440, 60, 120, 7350), "4k": yD(3840, 2160, 30, 120, 8910), "4k_1": yD(3840, 2160, 30, 120, 8910), "4k_3": yD(3840, 2160, 60, 120, 13500) }, wD = { "480p": ID(640, 480, 5), "480p_1": ID(640, 480, 5), "480p_2": ID(640, 480, 30), "480p_3": ID(640, 480, 15), "720p": ID(1280, 720, 5), "720p_auto": yD(1280, 720, 30, 900, 3e3), "720p_1": ID(1280, 720, 5), "720p_2": ID(1280, 720, 30), "720p_3": ID(1280, 720, 15), "1080p": ID(1920, 1080, 5), "1080p_1": ID(1920, 1080, 5), "1080p_2": ID(1920, 1080, 30), "1080p_3": ID(1920, 1080, 15) }, OD = { "1SL1TL": bD2(1, 1), "3SL3TL": bD2(3, 3), "2SL3TL": bD2(2, 3) };
      function ND(e2) {
        return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, AD[e2]) : e2;
      }
      function DD(e2) {
        return "string" == typeof e2 ? Object.assign({}, wD[e2]) : e2;
      }
      function PD(e2) {
        return "string" == typeof e2 ? Object.assign({}, OD[e2]) : e2;
      }
      const LD = { speech_low_quality: CD(16e3, false), speech_standard: CD(32e3, false, 18), music_standard: CD(48e3, false), standard_stereo: CD(48e3, true, 56), high_quality: CD(48e3, false, 128), high_quality_stereo: CD(48e3, true, 192) };
      function kD2(e2) {
        return "string" == typeof e2 ? Object.assign({}, LD[e2]) : e2;
      }
      const MD = [];
      function UD(e2) {
        return Dw2(e2, "mediaSource", ["screen", "window", "application"]), true;
      }
      let VD = function(e2) {
        return e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_RTC_STATS = "@get_rtc_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_UPDATE_VIDEO_SEND_PARAMETERS = "@need_update_video_send_parameters", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track", e2;
      }({}), xD = function(e2) {
        return e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream", e2.SCREEN_LOW_TRACK = "screen_low_track", e2;
      }({});
      let FD = function(e2) {
        return e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2;
      }({}), BD = function(e2) {
        return e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.HIGH_STREAM_LAYER1 = 4] = "HIGH_STREAM_LAYER1", e2[e2.HIGH_STREAM_LAYER2 = 5] = "HIGH_STREAM_LAYER2", e2[e2.HIGH_STREAM_LAYER3 = 6] = "HIGH_STREAM_LAYER3", e2[e2.HIGH_STREAM_LAYER4 = 7] = "HIGH_STREAM_LAYER4", e2[e2.HIGH_STREAM_LAYER5 = 8] = "HIGH_STREAM_LAYER5", e2[e2.HIGH_STREAM_LAYER6 = 9] = "HIGH_STREAM_LAYER6", e2;
      }({}), jD2 = function(e2) {
        return e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY", e2[e2.HIGH_STREAM_LAYER1 = 3] = "HIGH_STREAM_LAYER1", e2[e2.HIGH_STREAM_LAYER2 = 4] = "HIGH_STREAM_LAYER2", e2[e2.HIGH_STREAM_LAYER3 = 5] = "HIGH_STREAM_LAYER3", e2[e2.HIGH_STREAM_LAYER4 = 6] = "HIGH_STREAM_LAYER4", e2[e2.HIGH_STREAM_LAYER5 = 7] = "HIGH_STREAM_LAYER5", e2[e2.HIGH_STREAM_LAYER6 = 8] = "HIGH_STREAM_LAYER6", e2;
      }({}), GD = function(e2) {
        return e2.TRANSCEIVER_UPDATED = "transceiver-updated", e2.SEI_TO_SEND = "sei-to-send", e2.SEI_RECEIVED = "sei-received", e2.TRACK_UPDATED = "track-updated", e2;
      }({}), WD = function(e2) {
        return e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed", e2;
      }({}), HD = function(e2) {
        return e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.VIDEO_STATE_CHANGED = "video-state-changed", e2.PLAY_START = "play-start", e2.PLAY_END = "play-end", e2.FIRST_FRAME_RENDER = "first-frame-render", e2;
      }({}), KD = function(e2) {
        return e2.AUDIO = "audio", e2.VIDEO = "video", e2.DATA = "data", e2;
      }({}), YD = function(e2) {
        return e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source", e2;
      }({});
      !function(e2) {
        e2.UPDATE_TRACK_SOURCE = "update-track-source";
      }({});
      const zD = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 }, qD2 = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, XD = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receivePacketsDiscarded: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, JD = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, ZD = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      let QD = function(e2) {
        return e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node", e2;
      }({}), $D = function(e2) {
        return e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints", e2;
      }({}), eP = function(e2) {
        return e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND", e2;
      }({}), tP = function(e2) {
        return e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged", e2;
      }({}), iP = function(e2) {
        return e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata", e2;
      }({}), nP = function(e2) {
        return e2[e2.VideoStateStopped = 0] = "VideoStateStopped", e2[e2.VideoStateStarting = 1] = "VideoStateStarting", e2[e2.VideoStateDecoding = 2] = "VideoStateDecoding", e2[e2.VideoStateFrozen = 3] = "VideoStateFrozen", e2;
      }({});
      const rP = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      let oP = function(e2) {
        return e2.OPEN = "open", e2.MESSAGE = "message", e2.CLOSE = "close", e2.CLOSING = "closing", e2.ERROR = "error", e2;
      }({});
      function sP(e2, t3, i2, n3, r2) {
        var o2, s2, a3 = {};
        return Object.keys(n3).forEach(function(e3) {
          a3[e3] = n3[e3];
        }), a3.enumerable = !!a3.enumerable, a3.configurable = !!a3.configurable, ("value" in a3 || a3.initializer) && (a3.writable = true), a3 = nr2(o2 = mr2(s2 = i2.slice()).call(s2)).call(o2, function(i3, n4) {
          return n4(e2, t3, i3) || i3;
        }, a3), r2 && void 0 !== a3.initializer && (a3.value = a3.initializer ? a3.initializer.call(r2) : void 0, a3.initializer = void 0), void 0 === a3.initializer ? (Object.defineProperty(e2, t3, a3), null) : a3;
      }
      function aP(e2, t3, i2) {
        return (t3 = function(e3) {
          var t4 = function(e4, t5) {
            if ("object" != typeof e4 || !e4) return e4;
            var i3 = e4[Symbol.toPrimitive];
            if (void 0 !== i3) {
              var n3 = i3.call(e4, "string");
              if ("object" != typeof n3) return n3;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(e4);
          }(e3);
          return "symbol" == typeof t4 ? t4 : t4 + "";
        }(t3)) in e2 ? Object.defineProperty(e2, t3, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t3] = i2, e2;
      }
      function cP(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function dP(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? cP(Object(i2), true).forEach(function(t4) {
            aP(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : cP(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      class lP extends Hw2 {
        set _mediaStreamTrack(e2) {
          e2 !== this.mediaStreamTrack && (this.safeEmit(GD.TRACK_UPDATED, e2), this.mediaStreamTrack = e2);
        }
        get _mediaStreamTrack() {
          return this.mediaStreamTrack;
        }
        constructor(e2, t3) {
          super(), aP(this, "trackMediaType", void 0), aP(this, "_ID", void 0), aP(this, "_rtpTransceiver", void 0), aP(this, "_lowRtpTransceiver", void 0), aP(this, "_hints", []), aP(this, "_isClosed", false), aP(this, "_originMediaStreamTrack", void 0), aP(this, "mediaStreamTrack", void 0), aP(this, "_external", {}), this._ID = t3 || IO(8, "track-"), this._originMediaStreamTrack = e2, this.mediaStreamTrack = e2, function(e3) {
            Ln2(MD).call(MD, e3) || MD.push(e3);
          }(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e2) {
          return e2 || mO(() => {
            var e3;
            _D.reportApiInvoke(null, { name: zw2.GET_MEDIA_STREAM_TRACK, options: [], tag: qw2.TRACER }).onSuccess((null === (e3 = this._mediaStreamTrack) || void 0 === e3 ? void 0 : e3.label) || "");
          }, this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;
        }
        getRTCRtpTransceiver(e2) {
          return e2 === FD.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e2) {
            const t3 = MD.indexOf(e2);
            -1 !== t3 && MD.splice(t3, 1);
          }(this), this.emit(WD.CLOSED), this.removeAllListeners(GD.SEI_RECEIVED);
        }
        _updateRtpTransceiver(e2, t3) {
          if (t3 === FD.LOW_STREAM) {
            if (this._lowRtpTransceiver === e2) return;
            this._lowRtpTransceiver = e2;
          } else {
            if (this._rtpTransceiver === e2) return;
            this._rtpTransceiver = e2;
          }
          this.emit(GD.TRANSCEIVER_UPDATED, e2, t3);
        }
      }
      class uP extends lP {
        get isExternalTrack() {
          return this._isExternalTrack;
        }
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        get processorContext() {
          return this._processorContext;
        }
        constructor(e2, t3) {
          super(e2, t3), aP(this, "_enabled", true), aP(this, "_muted", false), aP(this, "_isExternalTrack", false), aP(this, "_isClosed", false), aP(this, "_enabledMutex", void 0), aP(this, "processor", void 0), aP(this, "_processorContext", void 0), aP(this, "_handleTrackEnded", () => {
            this.onTrackEnded();
          }), this._enabledMutex = new xO("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          var e2, t3;
          return null !== (e2 = null === (t3 = this._originMediaStreamTrack) || void 0 === t3 ? void 0 : t3.label) && void 0 !== e2 ? e2 : "";
        }
        close() {
          this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, sD.debug("[".concat(this.getTrackId(), "] close")), this.emit(VD.NEED_CLOSE), super.close());
        }
        async _updateOriginMediaStreamTrack(e2, t3) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          this._isExternalTrack = i2, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t3 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await sO(this, VD.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this._processorContext }));
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          sD.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(WD.TRACK_ENDED);
        }
        stateCheck(e2, t3) {
          if (sD.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t3, "]")), Nw2(t3, e2), this._enabled && this._muted && "enabled" === e2 && false === t3) throw new Ow2(ww2.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", sD);
          if (!this._enabled && !this._muted && "muted" === e2 && true === t3) throw new Ow2(ww2.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", sD);
        }
        getProcessorStats() {
          return this._processorContext && this._processorContext.gatherStats() || [];
        }
        getProcessorUsage() {
          return this._processorContext ? this._processorContext.gatherUsage() : ip2.resolve([]);
        }
      }
      const hP = window.AudioContext || window.webkitAudioContext;
      let pP = null;
      const _P = new class extends Hw2 {
        constructor() {
          super(...arguments), aP(this, "prevState", void 0), aP(this, "curState", void 0), aP(this, "currentTime", void 0), aP(this, "currentTimeStuckAt", void 0), aP(this, "interruptDetectorTrack", void 0), aP(this, "onLocalAudioTrackMute", () => {
            sD.info("ios15-interruption-start"), this.emit(vD.IOS_15_16_INTERRUPTION_START);
          }), aP(this, "onLocalAudioTrackUnmute", async () => {
            sD.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? sD.info("ios15-interruption-end-canceled") : (pP && await pP.suspend(), this.emit(vD.IOS_15_16_INTERRUPTION_END));
          });
        }
        get duringInterruption() {
          return "running" === this.prevState && "interrupted" === this.curState;
        }
        bindInterruptDetectorTrack(e2) {
          sD.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e2) {
          sD.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function EP() {
        if (!pP) {
          if (function() {
            if (!hP) return void sD.error("your browser is not support web audio");
            sD.info("create audio context");
            const e2 = dP({}, wN("WEBAUDIO_INIT_OPTIONS"));
            sD.debug("audio context init option:", JSON.stringify(e2)), pP = new hP(e2), _P.curState = pP.state, pP.onstatechange = () => {
              _P.prevState = _P.curState, _P.curState = pP ? pP.state : void 0;
              const { prevState: e3, curState: t3 } = _P, i2 = "running" === t3, n3 = "interrupted" === t3, r2 = "running" === e3, o2 = "suspended" === e3, s2 = "interrupted" === e3, a3 = zA2().osVersion;
              (nw2() || Sw2()) && r2 && n3 && (sD.info("ios".concat(a3, "-interruption-start")), _P.emit(vD.IOS_INTERRUPTION_START)), (nw2() || Sw2()) && (o2 || s2) && i2 && (sD.info("ios".concat(a3, "-interruption-end")), _P.emit(vD.IOS_INTERRUPTION_END)), e3 !== t3 && _P.emit(vD.STATE_CHANGE, t3, e3);
            }, setInterval(() => {
              var e3;
              const t3 = null === (e3 = pP) || void 0 === e3 ? void 0 : e3.currentTime;
              _P.currentTime !== t3 ? (_P.currentTimeStuckAt && (sD.debug("AudioContext current time resume at ".concat(t3)), _P.currentTimeStuckAt = void 0), _P.currentTime = t3) : (t3 !== _P.currentTimeStuckAt && (_D.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t3 }, tag: qw2.TRACER }).onSuccess(), sD.warning("AudioContext current time stuck at ".concat(t3))), _P.currentTimeStuckAt = t3);
            }, 5e3), async function(e3) {
              const t3 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
              let i2, n3 = false, r2 = false, o2 = false;
              function s2(t4) {
                "running" === e3.state ? a3(false) : nw2() || Sw2() ? "suspended" === e3.state && (a3(true), t4 && e3.resume().then(c3, c3)) : "closed" !== e3.state && (a3(true), t4 && e3.resume().then(c3, c3));
              }
              function a3(e4) {
                if (n3 !== e4) {
                  n3 = e4;
                  for (let i3 = 0, n4 = t3; i3 < n4.length; i3 += 1) {
                    const t4 = n4[i3];
                    e4 ? window.addEventListener(t4, d2, { capture: true, passive: true }) : window.removeEventListener(t4, d2, { capture: true, passive: true });
                  }
                }
              }
              function c3() {
                s2(false);
              }
              function d2() {
                s2(true);
              }
              function l2(e4) {
                if (!o2) if (i2.paused) if (e4) {
                  let t4;
                  u3(false), o2 = true;
                  try {
                    t4 = i2.play(), t4 ? t4.then(h2, h2) : (i2.addEventListener("playing", h2), i2.addEventListener("abort", h2), i2.addEventListener("error", h2));
                  } catch (e5) {
                    h2();
                  }
                } else u3(true);
                else u3(false);
              }
              function u3(e4) {
                if (r2 !== e4) {
                  r2 = e4;
                  for (let i3 = 0, n4 = t3; i3 < n4.length; i3++) {
                    const t4 = n4[i3];
                    e4 ? window.addEventListener(t4, p2, { capture: true, passive: true }) : window.removeEventListener(t4, p2, { capture: true, passive: true });
                  }
                }
              }
              function h2() {
                i2.removeEventListener("playing", h2), i2.removeEventListener("abort", h2), i2.removeEventListener("error", h2), o2 = false, l2(false);
              }
              function p2() {
                l2(true);
              }
              if (nw2()) {
                const t4 = e3.createMediaStreamDestination(), n4 = document.createElement("div");
                n4.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i2 = n4.children.item(0), i2.controls = false, i2.disableRemotePlayback = true, i2.preload = "auto", i2.srcObject = t4.stream, l2(true);
              }
              _P.on(vD.STATE_CHANGE, function() {
                s2(true);
              }), s2(false);
            }(pP);
          }(), !pP) throw new Ow2(ww2.NOT_SUPPORTED, "can not create audio context");
          return pP;
        }
        return pP;
      }
      function mP(e2) {
        if (function() {
          if (null !== fP) return fP;
          const e3 = EP(), t4 = e3.createBufferSource(), i3 = e3.createGain(), n3 = e3.createGain();
          t4.connect(i3), t4.connect(n3), t4.disconnect(i3);
          let r2 = false;
          try {
            t4.disconnect(i3);
          } catch (e4) {
            r2 = true;
          }
          return t4.disconnect(), fP = r2, r2;
        }()) return;
        const t3 = e2.connect, i2 = e2.disconnect;
        e2.connect = (i3, n3, r2) => {
          var o2;
          return e2._inputNodes || (e2._inputNodes = []), Ln2(o2 = e2._inputNodes).call(o2, i3) || (i3 instanceof AudioNode ? (e2._inputNodes.push(i3), t3.call(e2, i3, n3, r2)) : t3.call(e2, i3, n3)), e2;
        }, e2.disconnect = (n3, r2, o2) => {
          i2.call(e2), n3 ? lO(e2._inputNodes, n3) : e2._inputNodes = [];
          for (const i3 of e2._inputNodes) t3.call(e2, i3);
        };
      }
      let fP = null;
      function SP(e2, t3) {
        let i2 = false;
        const n3 = 1 / t3;
        if (wN("DISABLE_WEBAUDIO")) {
          const t4 = window.setInterval(() => {
            i2 ? window.clearInterval(t4) : e2(performance.now() / 1e3);
          }, 1e3 * n3);
        } else {
          const t4 = EP();
          let r2 = t4.createGain();
          r2.gain.value = 0, r2.connect(t4.destination);
          const o2 = () => {
            if (i2) return void (r2 = null);
            const s2 = t4.createOscillator();
            s2.onended = o2, s2.connect(r2), s2.start(0), s2.stop(t4.currentTime + n3), e2(t4.currentTime);
          };
          o2();
        }
        return () => {
          i2 = true;
        };
      }
      class gP {
        constructor() {
          aP(this, "context", void 0), aP(this, "analyserNode", void 0), aP(this, "sourceNode", void 0), this.context = EP(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
        }
        updateSource(e2) {
          if (e2 !== this.sourceNode) {
            if (this.sourceNode) try {
              this.sourceNode.disconnect(this.analyserNode);
            } catch (e3) {
            }
            this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
          }
        }
        getVolumeLevel() {
          if (!this.sourceNode) return 0;
          if (!this.context || nw2() || Sw2() || "running" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;
          const e2 = new Float32Array(this.analyserNode.fftSize);
          if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e2);
          else {
            const t4 = new Uint8Array(this.analyserNode.fftSize);
            this.analyserNode.getByteTimeDomainData(t4);
            for (let i2 = 0; i2 < e2.length; ++i2) e2[i2] = t4[i2] / 128 - 1;
          }
          const t3 = nr2(e2).call(e2, (e3, t4) => e3 + t4 * t4, 0) / e2.length;
          return Math.max(10 * Math.log10(t3) + 100, 0) / 100;
        }
        getAnalyserNode() {
          return this.analyserNode;
        }
        rebuildAnalyser() {
          try {
            var e2, t3;
            null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t3 = this.sourceNode) || void 0 === t3 || t3.connect(this.analyserNode);
          } catch (e3) {
            sD.warning("rebuild analyser node failed.");
          }
        }
        destroy() {
          this.updateSource(void 0);
        }
      }
      class TP extends Hw2 {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e2) {
          var t3;
          if (!this.isDestroyed && this._processedNode !== e2) {
            try {
              var i2;
              null === (i2 = this.sourceNode) || void 0 === i2 || i2.disconnect(this.outputNode);
            } catch (e3) {
            }
            null === (t3 = this._processedNode) || void 0 === t3 || t3.disconnect(), this._processedNode = e2, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), aP(this, "outputNode", void 0), aP(this, "outputTrack", void 0), aP(this, "isPlayed", false), aP(this, "sourceNode", void 0), aP(this, "context", void 0), aP(this, "audioBufferNode", void 0), aP(this, "destNode", void 0), aP(this, "audioOutputLevel", 0), aP(this, "volumeLevelAnalyser", void 0), aP(this, "_processedNode", void 0), aP(this, "playNode", void 0), aP(this, "isDestroyed", false), aP(this, "onNoAudioInput", void 0), aP(this, "isNoAudioInput", false), aP(this, "_noAudioInputCount", 0), this.context = EP(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), mP(this.outputNode), this.volumeLevelAnalyser = new gP();
        }
        startGetAudioBuffer(e2) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
            this.emit(YD.ON_AUDIO_BUFFER, function(e4) {
              for (let t3 = 0; t3 < e4.outputBuffer.numberOfChannels; t3 += 1) {
                const i2 = e4.outputBuffer.getChannelData(t3);
                for (let e5 = 0; e5 < i2.length; e5 += 1) i2[e5] = 0;
              }
              return e4.inputBuffer;
            }(e3));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!fD2().webAudioMediaStreamDest) throw new Ow2(ww2.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e2) {
          "running" !== this.context.state && hO(() => {
            _P.emit("autoplay-failed");
          }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed) try {
            this.outputNode.disconnect(this.playNode);
          } catch (e2) {
          }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          return this.volumeLevelAnalyser.getVolumeLevel();
        }
        async checkHasAudioInput() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          if (e2 > 5) return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          nw2() || Sw2() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
          const t3 = this.volumeLevelAnalyser.getAnalyserNode();
          let i2;
          t3.getFloatTimeDomainData ? (i2 = new Float32Array(t3.fftSize), t3.getFloatTimeDomainData(i2)) : (i2 = new Uint8Array(t3.fftSize), t3.getByteTimeDomainData(i2));
          let n3 = false;
          for (let e3 = 0; e3 < i2.length; e3++) 0 !== i2[e3] && (n3 = true);
          return n3 ? (this.isNoAudioInput = false, true) : (await yO(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n3);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e2) {
          this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        disconnect() {
          var e2, t3;
          null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t3 = this.sourceNode) || void 0 === t3 || t3.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e2;
          this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);
        }
      }
      class RP extends TP {
        get isFreeze() {
          return false;
        }
        constructor(e2, t3, i2) {
          var n3;
          if (super(), aP(this, "sourceNode", void 0), aP(this, "track", void 0), aP(this, "clonedTrack", void 0), aP(this, "audioElement", void 0), aP(this, "isCurrentTrackCloned", false), aP(this, "isRemoteTrack", false), aP(this, "originVolumeLevelAnalyser", void 0), aP(this, "rebuildWebAudio", async () => {
            if (sD.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, true), void sD.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then(() => sD.info("resume success")), sD.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e3 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
            const t4 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t4), mP(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
            const i3 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i3, this.context.currentTime), mP(this.outputNode), this.emit(YD.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t4, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          }), "audio" !== e2.kind) throw new Ow2(ww2.UNEXPECTED_ERROR);
          this.track = e2;
          const r2 = new MediaStream([this.track]);
          if (this.isRemoteTrack = !!t3, this.sourceNode = this.context.createMediaStreamSource(r2), mP(this.sourceNode), i2) {
            const e3 = i2.clone();
            e3.enabled = true, this.clonedTrack = e3, sD.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i2.id, " to get the volume"));
            const t4 = this.context.createMediaStreamSource(new MediaStream([e3]));
            mP(t4), this.originVolumeLevelAnalyser = new gP(), this.originVolumeLevelAnalyser.updateSource(t4);
          }
          this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
          const o2 = zA2();
          t3 && o2.os === GA2.IOS && Number(null === (n3 = o2.osVersion) || void 0 === n3 ? void 0 : n3.split(".")[0]) < 15 && (_P.on(vD.STATE_CHANGE, () => {
            "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
          }), this.checkHasAudioInput().then((e3) => {
            e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          }));
        }
        updateTrack(e2) {
          this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
          const t3 = new MediaStream([e2]);
          this.sourceNode = this.context.createMediaStreamSource(t3), mP(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(YD.UPDATE_SOURCE), this.audioElement.srcObject = t3;
        }
        destroy() {
          var e2;
          this.audioElement.srcObject = null, this.audioElement.remove(), _P.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
        }
        createMediaStreamSourceNode(e2) {
          return this.context.createMediaStreamSource(new MediaStream([e2]));
        }
        updateOriginTrack(e2) {
          const t3 = e2.clone();
          t3.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t3), sD.debug("create an unmuted track ".concat(t3.id, " from the original track ").concat(e2.id, " to get the volume"));
          const i2 = this.context.createMediaStreamSource(new MediaStream([t3]));
          mP(i2), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i2);
        }
        getOriginVolumeLevel() {
          return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
        }
      }
      async function vP(e2, t3, i2) {
        const n3 = (e3, t4) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t4 : e3 : t4, r2 = { audio: !!i2 && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: n3(t3.height, 1080), maxWidth: n3(t3.width, 1920) } } };
        return t3.frameRate && "number" != typeof t3.frameRate ? (r2.video.mandatory.maxFrameRate = t3.frameRate.max, r2.video.mandatory.minFrameRate = t3.frameRate.min) : "number" == typeof t3.frameRate && (r2.video.mandatory.maxFrameRate = t3.frameRate), await navigator.mediaDevices.getUserMedia(r2);
      }
      async function CP(e2, t3) {
        const i2 = await yP(e2.mediaSource), { sourceId: n3, audio: r2 } = await function(e3) {
          let t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return new ip2((i3, n4) => {
            const r3 = document.createElement("div");
            r3.innerText = "share screen", r3.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const o2 = document.createElement("div");
            o2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const s2 = document.createElement("div");
            s2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", s2.setAttribute("style", "height: 12%;");
            const a3 = document.createElement("div");
            a3.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const c3 = document.createElement("div");
            c3.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
            const d2 = document.createElement("button");
            d2.innerHTML = "cancel", d2.setAttribute("style", "width: 85px;"), d2.onclick = () => {
              document.body.removeChild(h2);
              const e4 = new Error("NotAllowedError");
              e4.name = "NotAllowedError", n4(e4);
            };
            let l2 = t4;
            const u3 = document.createElement("div");
            if (t4) {
              const e4 = document.createElement("input");
              e4.setAttribute("type", "checkbox");
              const t5 = document.createElement("span");
              e4.setAttribute("style", "margin-right: 6px;"), t5.innerText = "Share audio", e4.checked = l2, e4.onchange = () => {
                l2 = e4.checked;
              }, u3.appendChild(e4), u3.appendChild(t5);
            }
            c3.appendChild(u3), c3.appendChild(d2), o2.appendChild(s2), o2.appendChild(a3), o2.appendChild(c3);
            const h2 = document.createElement("div");
            h2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), h2.appendChild(r3), h2.appendChild(o2), document.body.appendChild(h2), e3.map((e4) => {
              if (e4.id) {
                const t5 = document.createElement("div");
                t5.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let n5 = e4.thumbnail;
                try {
                  const { width: e5 } = n5.getSize();
                  e5 > 1920 && (n5 = n5.resize({ width: 1920 }));
                } catch (e5) {
                  throw e5 && e5.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), e5;
                }
                t5.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n5.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                  return "&#" + e5.charCodeAt(0) + ";";
                }) + "</span>", t5.onclick = () => {
                  document.body.removeChild(h2), i3({ sourceId: e4.id, audio: l2 });
                }, a3.appendChild(t5);
              }
            });
          });
        }(i2, t3);
        return await vP(n3, e2, r2);
      }
      async function yP(e2) {
        let t3 = ["window", "screen"];
        "application" !== e2 && "window" !== e2 || (t3 = ["window"]), "screen" === e2 && (t3 = ["screen"]);
        const i2 = Yw2();
        if (!i2) throw console.error("failed to fetch electron, please mount it to window"), new Ow2(ww2.ELECTRON_IS_NULL);
        let n3 = null;
        try {
          var r2;
          n3 = (null === (r2 = i2.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t3 })) || i2.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t3 });
        } catch (e3) {
          n3 = null;
        }
        n3 && n3.then || (n3 = new ip2((e3, n4) => {
          i2.desktopCapturer.getSources({ types: t3 }, (t4, i3) => {
            t4 ? n4(t4) : e3(i3);
          });
        }));
        try {
          return await n3;
        } catch (e3) {
          throw new Ow2(ww2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
        }
      }
      const IP = new xO("safari");
      let bP = false, AP = false;
      async function wP(e2, t3) {
        let i2 = 0, n3 = null;
        for (; i2 < 2; ) try {
          n3 = await OP(e2, t3, i2 > 0);
          break;
        } catch (e3) {
          if (e3 instanceof Ow2) throw sD.error("[".concat(t3, "] ").concat(e3.toString())), e3;
          const n4 = NP(e3.name || e3.code || e3, e3.message);
          if (n4.code === ww2.MEDIA_OPTION_INVALID) {
            sD.debug("[".concat(t3, "] detect media option invalid, retry")), i2 += 1, await yO(500);
            continue;
          }
          throw sD.error("[".concat(t3, "] ").concat(n4.toString())), n4;
        }
        if (!n3) throw new Ow2(ww2.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return n3;
      }
      async function OP(e2, t3, i2) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Ow2(ww2.NOT_SUPPORTED, "can not find getUserMedia");
        i2 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
        const n3 = fD2(), r2 = new MediaStream();
        if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen) return sD.debug("Using Video Source/ Audio Source"), r2;
        if (e2.screen) if (Yw2()) e2.screen.sourceId ? DP(r2, await vP(e2.screen.sourceId, e2.screen, !!e2.screenAudio)) : DP(r2, await CP(e2.screen, !!e2.screenAudio));
        else if (QA2() && e2.screen.extensionId && e2.screen.mandatory) {
          if (!n3.getStreamFromExtension) throw new Ow2(ww2.NOT_SUPPORTED, "This browser does not support screen sharing");
          sD.debug("[".concat(t3, '] Screen access on chrome stable, looking for extension"'));
          const i3 = await (s2 = e2.screen.extensionId, a3 = t3, new ip2((e3, t4) => {
            try {
              chrome.runtime.sendMessage(s2, { getStream: true }, (i4) => {
                if (!i4 || !i4.streamId) return sD.error("[".concat(a3, "] No response from Chrome Plugin. Plugin not installed properly"), i4), void t4(new Ow2(ww2.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                e3(i4.streamId);
              });
            } catch (e4) {
              sD.error("[".concat(a3, "] AgoraRTC screensharing plugin is not accessible(").concat(s2, ")"), e4.toString()), t4(new Ow2(ww2.CHROME_PLUGIN_NOT_INSTALL));
            }
          }));
          e2.screen.mandatory.chromeMediaSourceId = i3, DP(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
        } else if (n3.getDisplayMedia) {
          var o2;
          e2.screen.mediaSource && UD(e2.screen.mediaSource);
          const i3 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (o2 = e2.screen.displaySurface) && void 0 !== o2 ? o2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n4, surfaceSwitching: s3, systemAudio: a4, preferCurrentTab: c4 } = e2.screen, d3 = { selfBrowserSurface: n4, surfaceSwitching: s3, systemAudio: a4, preferCurrentTab: c4 };
          !n4 && delete d3.selfBrowserSurface, !s3 && delete d3.surfaceSwitching, !a4 && delete d3.systemAudio, !c4 && delete d3.preferCurrentTab, sD.debug("[".concat(t3, "] getDisplayMedia:"), JSON.stringify({ video: i3, audio: e2.screenAudio, controls: d3 })), DP(r2, await navigator.mediaDevices.getDisplayMedia(dP({ video: i3, audio: e2.screenAudio }, d3)));
        } else {
          if (!iw2()) throw sD.error("[".concat(t3, "] This browser does not support screenSharing")), new Ow2(ww2.NOT_SUPPORTED, "This browser does not support screen sharing");
          {
            e2.screen.mediaSource && UD(e2.screen.mediaSource);
            const i3 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
            sD.debug("[".concat(t3, "] getUserMedia: ").concat(JSON.stringify(i3))), DP(r2, await navigator.mediaDevices.getUserMedia(i3));
          }
        }
        var s2, a3;
        if (!e2.video && !e2.audio) return r2;
        let c3 = { video: e2.video, audio: e2.audio }, d2 = wN("MEDIA_DEVICE_CONSTRAINTS");
        if (d2) try {
          "string" == typeof d2 && (d2 = JSON.parse(d2)), c3 = DO(c3, d2);
        } catch (e3) {
        }
        sD.debug("[".concat(t3, "] GetUserMedia"), JSON.stringify(c3)), zA2();
        let l2, u3 = null;
        ($A2() || nw2() || ZA2()) && (u3 = await IP.lock());
        try {
          l2 = await navigator.mediaDevices.getUserMedia(c3);
        } catch (e3) {
          throw u3 && u3(), e3;
        }
        return c3.audio && (bP = true), c3.video && (AP = true), DP(r2, l2), u3 && u3(), r2;
      }
      function NP(e2, t3) {
        switch (e2) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new Ow2(ww2.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t3));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new Ow2(ww2.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t3));
          case "NotSupportedError":
            return new Ow2(ww2.NOT_SUPPORTED, "".concat(e2, ": ").concat(t3));
          case "NotReadableError":
            return new Ow2(ww2.NOT_READABLE, "".concat(e2, ": ").concat(t3));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new Ow2(ww2.PERMISSION_DENIED, "".concat(e2, ": ").concat(t3));
          case "ConstraintNotSatisfiedError":
            return new Ow2(ww2.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t3));
          default:
            return sD.error("getUserMedia unexpected error", e2), new Ow2(ww2.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t3));
        }
      }
      function DP(e2, t3) {
        const i2 = e2.getVideoTracks()[0], n3 = e2.getAudioTracks()[0], r2 = t3.getVideoTracks()[0], o2 = t3.getAudioTracks()[0];
        o2 && (n3 && e2.removeTrack(n3), e2.addTrack(o2)), r2 && (i2 && e2.removeTrack(i2), e2.addTrack(r2));
      }
      const PP = new class extends Hw2 {
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this.emit(tP.STATE_CHANGE, e2), this._state = e2);
        }
        constructor() {
          super(), aP(this, "_state", eP.IDLE), aP(this, "isAccessMicrophonePermission", false), aP(this, "isAccessCameraPermission", false), aP(this, "lastAccessMicrophonePermission", false), aP(this, "lastAccessCameraPermission", false), aP(this, "checkdeviceMatched", false), aP(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
              (wN("ENUMERATE_DEVICES_INTERVAL") || (Cw2() || XA2() === GA2.HARMONY_OS) && vw2()) && this.updateDevicesInfo();
            }, wN("ENUMERATE_DEVICES_INTERVAL_TIME"));
          }).catch((e2) => sD.error(e2.toString()));
        }
        async enumerateDevices(e2, t3) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new Ow2(ww2.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
          const n3 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n3);
          let o2 = !this.isAccessMicrophonePermission && e2, s2 = !this.isAccessCameraPermission && t3;
          r2.audio && (o2 = false), r2.video && (s2 = false);
          let a3 = null, c3 = null, d2 = null;
          if (!i2 && (o2 || s2)) {
            if (IP.isLocked && (sD.debug("[device manager] wait GUM lock"), (await IP.lock())(), sD.debug("[device manager] GUM unlock")), bP && (o2 = false, this.isAccessMicrophonePermission = true), AP && (s2 = false, this.isAccessCameraPermission = true), sD.debug("[device manager] check media device permissions", e2, t3, o2, s2), o2 && s2) {
              try {
                d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e3) {
                const t4 = NP(e3.name || e3.code || e3, e3.message);
                if (t4.code === ww2.PERMISSION_DENIED) throw t4;
                sD.warning("getUserMedia failed in getDevices", t4);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (o2) {
              try {
                a3 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
              } catch (e3) {
                const t4 = NP(e3.name || e3.code || e3, e3.message);
                if (t4.code === ww2.PERMISSION_DENIED) throw t4;
                sD.warning("getUserMedia failed in getDevices", t4);
              }
              this.isAccessMicrophonePermission = true;
            } else if (s2) {
              try {
                c3 = await navigator.mediaDevices.getUserMedia({ video: t3 });
              } catch (e3) {
                const t4 = NP(e3.name || e3.code || e3, e3.message);
                if (t4.code === ww2.PERMISSION_DENIED) throw t4;
                sD.warning("getUserMedia failed in getDevices", t4);
              }
              this.isAccessCameraPermission = true;
            }
            sD.debug("[device manager] mic permission", e2, "cam permission", t3);
          }
          try {
            const e3 = await navigator.mediaDevices.enumerateDevices();
            return a3 && a3.getTracks().forEach((e4) => e4.stop()), c3 && c3.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a3 = null, c3 = null, d2 = null, e3;
          } catch (e3) {
            return a3 && a3.getTracks().forEach((e4) => e4.stop()), c3 && c3.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a3 = null, c3 = null, d2 = null, new Ow2(ww2.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audioinput" === e3.kind);
        }
        async getCamerasDevices() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(false, true, e2)).filter((e3) => "videoinput" === e3.kind);
        }
        async getSpeakers() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audiooutput" === e3.kind);
        }
        searchDeviceIdByName(e2) {
          let t3 = null;
          return this.deviceInfoMap.forEach((i2) => {
            i2.device.label === e2 && (t3 = i2.device.deviceId);
          }), t3;
        }
        async getDeviceById(e2) {
          const t3 = (await this.enumerateDevices(true, true, true)).find((t4) => t4.deviceId === e2);
          if (!t3) throw new Ow2(ww2.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
          return t3;
        }
        async init() {
          this.state = eP.INITING;
          try {
            await this.updateDevicesInfo(), this.state = eP.INITEND;
          } catch (e2) {
            throw sD.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = eP.IDLE, ("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname) || new Ow2(ww2.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw(), e2;
          }
        }
        async updateDevicesInfo() {
          const e2 = await this.enumerateDevices(true, true, true), t3 = Date.now(), i2 = [];
          if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
            this.checkdeviceMatched = true;
            const t4 = e2.find((e3) => "audioinput" === e3.kind && "default" === e3.deviceId), i3 = e2.find((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId);
            t4 && i3 ? i3.groupId === t4.groupId ? sD.debug("[device-check] default input ".concat(t4.label, " and output ").concat(i3.label, " is the same group")) : sD.debug("[device-check] default input ".concat(t4.label, " and output ").concat(i3.label, " is not the same group")) : sD.debug("[device-check] default input or output not found");
          }
          const n3 = this.checkMediaDeviceInfoIsOk(e2);
          if (e2.forEach((e3) => {
            if (!e3.deviceId) return;
            const n4 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
            if ("ACTIVE" !== (n4 ? n4.state : "INACTIVE")) {
              const n5 = { initAt: t3, updateAt: t3, device: e3, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n5), i2.push(n5);
            }
            n4 && (n4.updateAt = t3);
          }), this.deviceInfoMap.forEach((e3, n4) => {
            "ACTIVE" === e3.state && e3.updateAt !== t3 && (e3.state = "INACTIVE", i2.push(e3));
          }), this.state !== eP.INITEND) return n3.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n3.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          i2.forEach((e3) => {
            switch (e3.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(tP.RECORDING_DEVICE_CHANGED, e3);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(tP.CAMERA_DEVICE_CHANGED, e3);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(tP.PLAYOUT_DEVICE_CHANGED, e3);
            }
          }), n3.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n3.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e2) {
          const t3 = e2.filter((e3) => "audioinput" === e3.kind), i2 = e2.filter((e3) => "videoinput" === e3.kind), n3 = { audio: false, video: false };
          for (const e3 of t3) if (e3.label && e3.deviceId) {
            n3.audio = true;
            break;
          }
          for (const e3 of i2) if (e3.label && e3.deviceId) {
            n3.video = true;
            break;
          }
          return n3;
        }
      }();
      let LP = false;
      const kP = new class extends Hw2 {
        constructor() {
          super(...arguments), aP(this, "onAutoplayFailed", void 0), aP(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function MP() {
        if (zA2(), !LP) {
          const e2 = (t3) => {
            t3.preventDefault(), LP = false, yw2() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          LP = true, yw2() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), sD.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), kP.onAutoplayFailed ? kP.onAutoplayFailed() : kP.onAudioAutoplayFailed ? sD.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : sD.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), kP.emit("autoplay-failed");
        }
      }
      function UP(e2, t3, i2, n3) {
        if (!e2) return;
        const r2 = _D.getBaseInfoBySessionId(e2);
        if (!r2) return;
        const o2 = r2.info, s2 = Date.now(), a3 = dP(dP({}, o2), {}, { vid: void 0 === o2.vid ? 0 : Number(o2.vid), lts: s2, elapse: s2 - r2.startTime, cbRegistered: kP.onAutoplayFailed || kP.onAudioAutoplayFailed ? 1 : -1, errorMsg: i2, mediaType: t3, trackId: n3, extend: void 0 });
        _D.send({ type: uD.AUTOPLAY_FAILED, data: a3 }, true);
      }
      const VP = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], xP = new class {
        constructor() {
          aP(this, "onAutoplayFailed", void 0), aP(this, "elementMap", /* @__PURE__ */ new Map()), aP(this, "elementStateMap", /* @__PURE__ */ new Map()), aP(this, "elementsNeedToResume", []), aP(this, "sinkIdMap", /* @__PURE__ */ new Map()), aP(this, "autoResumeAfterInterruption", (e2) => {
            Array.from(this.elementMap.entries()).forEach((t3) => {
              let [i2, n3] = t3;
              const r2 = this.elementStateMap.get(i2), o2 = n3.srcObject.getAudioTracks()[0], s2 = o2 && o2.readyState;
              if (sD.debug("resume after interrupted, ele: ".concat(r2, " audio: ").concat(s2, " ").concat(e2)), "live" === s2) {
                if (e2) return n3.pause(), void n3.play();
                if ("running" === _P.curState) return Ew2() ? (n3.pause(), void n3.play()) : void (r2 && "paused" === r2 && n3.play());
              }
            });
          }), aP(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t3, i2] = e2;
              const n3 = i2.srcObject.getAudioTracks()[0];
              n3 && "live" === n3.readyState && (sD.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i2.pause(), i2.play());
            });
          }), this.autoResumeAudioElement(), _P.on(vD.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _P.on(vD.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), _P.on(vD.STATE_CHANGE, () => {
            nw2() && "suspended" === _P.prevState && "running" === _P.curState && this.autoResumeAfterInterruption();
          });
        }
        async setSinkID(e2, t3) {
          const i2 = this.elementMap.get(e2);
          if (this.sinkIdMap.set(e2, t3), i2) try {
            await i2.setSinkId(t3);
          } catch (e3) {
            throw new Ow2(ww2.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
          }
        }
        play(e2, t3, i2, n3) {
          if (this.elementMap.has(t3)) return;
          const r2 = document.createElement("audio");
          r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t3, r2), this.elementMap.set(t3, r2), this.elementStateMap.set(t3, iP.INIT), this.setVolume(t3, i2);
          const o2 = this.sinkIdMap.get(t3);
          if (o2) try {
            r2.setSinkId(o2).catch((e3) => {
              sD.warning("[".concat(t3, "] set sink id failed"), e3.toString());
            });
          } catch (e3) {
            sD.warning("[".concat(t3, "] set sink id failed"), e3.toString());
          }
          const s2 = r2.play();
          s2 && s2.then && s2.catch((e3) => {
            n3 && UP(n3, "audio", e3.message, t3), sD.warning("audio element play warning", e3.toString()), this.elementMap.has(t3) && "NotAllowedError" === e3.name && (sD.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), hO(() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), MP();
            }));
          });
        }
        updateTrack(e2, t3) {
          const i2 = this.elementMap.get(e2);
          i2 && (i2.srcObject = new MediaStream([t3]));
        }
        isPlaying(e2) {
          return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
        }
        setVolume(e2, t3) {
          const i2 = this.elementMap.get(e2);
          i2 && (t3 = Math.max(0, Math.min(100, t3)), i2.volume = t3 / 100);
        }
        stop(e2) {
          const t3 = this.elementMap.get(e2);
          if (this.sinkIdMap.delete(e2), !t3) return;
          const i2 = this.elementsNeedToResume.indexOf(t3);
          this.elementsNeedToResume.splice(i2, 1), t3.srcObject = null, t3.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
        }
        bindAudioElementEvents(e2, t3) {
          VP.forEach((i2) => {
            t3.addEventListener(i2, (i3) => {
              const n3 = this.elementStateMap.get(e2), r2 = "pause" === i3.type ? "paused" : i3.type;
              if (sD.debug("[".concat(e2, "] audio-element-status change ").concat(n3, " => ").concat(r2)), "error" === i3.type) {
                const i4 = null == t3 ? void 0 : t3.error;
                i4 && sD.error("[".concat(e2, "] media error, code: ").concat(i4.code, ", message: ").concat(i4.message));
              }
              this.elementStateMap.set(e2, r2);
            });
          });
        }
        getPlayerState(e2) {
          return this.elementStateMap.get(e2) || "uninit";
        }
        autoResumeAudioElement() {
          const e2 = () => {
            this.elementsNeedToResume.forEach((e3) => {
              e3.play().then((e4) => {
                sD.debug("Auto resume audio element success");
              }).catch((e4) => {
                sD.warning("Auto resume audio element failed!", e4);
              });
            }), this.elementsNeedToResume = [];
          };
          new ip2((e3) => {
            document.body ? e3() : window.addEventListener("load", () => e3());
          }).then(() => {
            yw2() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
          });
        }
      }();
      function FP() {
        return function(e2, t3, i2) {
          const n3 = i2.value;
          return "function" == typeof n3 && (i2.value = function() {
            this._isClosed && new Ow2(ww2.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", sD);
            for (var e3 = arguments.length, t4 = new Array(e3), i3 = 0; i3 < e3; i3++) t4[i3] = arguments[i3];
            const r2 = n3.apply(this, t4);
            return r2 instanceof ip2 ? new ip2((e4, t5) => {
              r2.then(e4).catch(t5);
            }) : r2;
          }), i2;
        };
      }
      class BP extends Hw2 {
        constructor(e2) {
          super(), aP(this, "name", "VideoProcessorDestination"), aP(this, "ID", "0"), aP(this, "_source", void 0), aP(this, "videoContext", void 0), aP(this, "inputTrack", void 0), this.videoContext = e2;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new Ow2(ww2.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new Ow2(ww2.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e2) {
          if (e2.context !== this.videoContext) throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(QD.ON_TRACK, e2.track));
        }
        reset() {
          this.inputTrack = void 0, this.videoContext.chained = false, this.emit(QD.ON_TRACK, void 0);
        }
      }
      class jP extends Hw2 {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t3) {
          super(), aP(this, "constraintsMap", /* @__PURE__ */ new Map()), aP(this, "statsRegistry", []), aP(this, "usageRegistry", []), aP(this, "trackId", void 0), aP(this, "direction", void 0), aP(this, "_chained", false), this.trackId = e2, this.direction = t3;
        }
        async getConstraints() {
          return await oO(this, $D.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e2, t3) {
          var i2;
          return sD.info("processor ".concat(t3.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t3, e2), sO(this, $D.REQUEST_UPDATE_CONSTRAINTS, Array.from(up2(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t3;
          if (this.constraintsMap.has(e2)) return sD.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), sO(this, $D.REQUEST_UPDATE_CONSTRAINTS, Array.from(up2(t3 = this.constraintsMap).call(t3)));
        }
        registerStats(e2, t3, i2) {
          this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t3) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t3, cb: i2 });
        }
        unregisterStats(e2, t3) {
          const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t3);
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t3, processorName: i2, type: n3, cb: r2 } of this.statsRegistry) try {
            const o2 = r2();
            e2.push({ processorID: t3, processorName: i2, type: n3, stats: o2 });
          } catch (e3) {
            sD.error(new Ow2(ww2.UNEXPECTED_ERROR, e3.message));
          }
          return e2;
        }
        registerUsage(e2, t3) {
          this.usageRegistry.find((t4) => t4.processorID === e2.ID && t4.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t3 });
        }
        unregisterUsage(e2) {
          const t3 = this.usageRegistry.findIndex((t4) => t4.processorID === e2.ID && t4.processorName === e2.name);
          -1 !== t3 && this.usageRegistry.splice(t3, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained) return [];
          for (const { cb: t3 } of this.usageRegistry) try {
            let i2 = t3();
            i2 instanceof ip2 && (i2 = await i2), e2.push(dP(dP({}, i2), {}, { direction: this.direction }));
          } catch (e3) {
            sD.error("gather extension usage error", e3);
          }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class GP extends Hw2 {
        constructor(e2) {
          super(), aP(this, "name", "AudioProcessorDestination"), aP(this, "ID", "0"), aP(this, "inputTrack", void 0), aP(this, "inputNode", void 0), aP(this, "audioProcessorContext", void 0), aP(this, "_source", void 0), this.audioProcessorContext = e2;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new Ow2(ww2.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new Ow2(ww2.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(QD.ON_TRACK, void 0), this.emit(QD.ON_NODE, void 0);
        }
        updateInput(e2) {
          if (e2.context !== this.audioProcessorContext) throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(QD.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(QD.ON_NODE, this.inputNode));
        }
      }
      class WP extends Hw2 {
        set chained(e2) {
          this._chained = e2;
        }
        get chained() {
          return this._chained;
        }
        constructor(e2, t3, i2) {
          super(), aP(this, "constraintsMap", /* @__PURE__ */ new Map()), aP(this, "statsRegistry", []), aP(this, "audioContext", void 0), aP(this, "trackId", void 0), aP(this, "direction", void 0), aP(this, "usageRegistry", []), aP(this, "_chained", false), this.audioContext = e2, this.trackId = t3, this.direction = i2;
        }
        async getConstraints() {
          return oO(this, $D.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e2, t3) {
          var i2;
          return sD.info("processor ".concat(t3.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t3, e2), sO(this, $D.REQUEST_UPDATE_CONSTRAINTS, Array.from(up2(i2 = this.constraintsMap).call(i2)));
        }
        async requestRevertConstraints(e2) {
          var t3;
          if (this.constraintsMap.has(e2)) return this.constraintsMap.delete(e2), sO(this, $D.REQUEST_UPDATE_CONSTRAINTS, Array.from(up2(t3 = this.constraintsMap).call(t3)));
        }
        registerStats(e2, t3, i2) {
          this.statsRegistry.find((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t3) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t3, cb: i2 });
        }
        unregisterStats(e2, t3) {
          const i2 = this.statsRegistry.findIndex((i3) => i3.processorID === e2.ID && i3.processorName === e2.name && i3.type === t3);
          -1 !== i2 && this.statsRegistry.splice(i2, 1);
        }
        gatherStats() {
          const e2 = [];
          for (const { processorID: t3, processorName: i2, type: n3, cb: r2 } of this.statsRegistry) try {
            const o2 = r2();
            e2.push({ processorID: t3, processorName: i2, type: n3, stats: o2 });
          } catch (e3) {
            sD.error(new Ow2(ww2.UNEXPECTED_ERROR, e3.message));
          }
          return e2;
        }
        registerUsage(e2, t3) {
          this.usageRegistry.find((t4) => t4.processorID === e2.ID && t4.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t3 });
        }
        unregisterUsage(e2) {
          const t3 = this.usageRegistry.findIndex((t4) => t4.processorID === e2.ID && t4.processorName === e2.name);
          -1 !== t3 && this.usageRegistry.splice(t3, 1);
        }
        async gatherUsage() {
          const e2 = [];
          if (!this.chained) return [];
          for (const { cb: t3 } of this.usageRegistry) try {
            let i2 = t3();
            i2 instanceof ip2 && (i2 = await i2), e2.push(dP(dP({}, i2), {}, { direction: this.direction }));
          } catch (e3) {
            sD.error("gather extension usage error", e3);
          }
          return e2;
        }
        getDirection() {
          return this.direction;
        }
      }
      class HP extends Hw2 {
        get isPlayed() {
          return true;
        }
        get isFreeze() {
          return false;
        }
        constructor() {
          super(), aP(this, "context", void 0), aP(this, "processSourceNode", void 0), aP(this, "outputTrack", void 0), aP(this, "processedNode", void 0), aP(this, "clonedTrack", void 0), aP(this, "outputNode", void 0), this.outputNode = new KP();
        }
        setVolume() {
        }
        createOutputTrack() {
          throw new Ow2(ww2.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
        }
        getOriginVolumeLevel() {
          return 0;
        }
        getAccurateVolumeLevel() {
          return 0;
        }
        stopGetAudioBuffer() {
        }
        startGetAudioBuffer() {
        }
        play() {
        }
        stop() {
        }
        destroy() {
        }
        updateTrack() {
        }
        updateOriginTrack() {
        }
        createMediaStreamSourceNode() {
        }
      }
      class KP {
        disconnect() {
        }
        connect() {
        }
      }
      function YP(e2) {
        return new ip2((t3, i2) => {
          let n3 = false;
          const r2 = document.createElement("video");
          r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
          const o2 = nw2() ? "canplay" : "playing";
          r2.addEventListener(o2, () => {
            const e3 = r2.videoWidth, i3 = r2.videoHeight;
            !e3 && iw2() || (n3 = true, r2.srcObject = null, r2.remove(), t3([e3, i3]));
          }), r2.srcObject = new MediaStream([e2]), r2.play().catch(AO), setTimeout(() => {
            n3 || (r2.srcObject = null, r2.remove(), t3([r2.videoWidth, r2.videoHeight]));
          }, 4e3);
        });
      }
      function zP(e2) {
        const t3 = {};
        e2.facingMode && (t3.facingMode = e2.facingMode), e2.cameraId && (t3.deviceId = { exact: e2.cameraId });
        const i2 = ND(e2.encoderConfig);
        return null != i2.width && (t3.width = i2.width), null != i2.height && (t3.height = i2.height), !Tw2() && i2.frameRate && (t3.frameRate = i2.frameRate), tw2() && "object" == typeof t3.frameRate && (t3.frameRate.max = 60), iw2() && (t3.frameRate = { ideal: 30, max: 30 }), t3;
      }
      function qP(e2) {
        const t3 = {};
        return Tw2() || (void 0 !== e2.AGC && (t3.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t3.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t3.noiseSuppression = e2.ANS, QA2() && e2.ANS && (t3.googHighpassFilter = e2.ANS))), t3;
      }
      function XP(e2) {
        const t3 = qP(e2);
        if (e2.encoderConfig) {
          const i2 = kD2(e2.encoderConfig);
          t3.channelCount = i2.stereo ? 2 : 1, t3.sampleRate = i2.sampleRate, t3.sampleSize = i2.sampleSize;
        }
        return e2.microphoneId && (t3.deviceId = { exact: e2.microphoneId }), Cw2() && (t3.sampleRate = void 0), t3;
      }
      const JP = (e2) => {
        const t3 = e2._encoderConfig;
        if (!t3) return;
        const { frameRate: i2, width: n3, height: r2 } = e2.getMediaStreamTrackSettings();
        let { frameRate: o2 = i2, width: s2 = n3, height: a3 = r2 } = t3;
        if (!o2 || !s2 || !a3) return;
        s2 = LO(s2), a3 = LO(a3), o2 = LO(o2);
        const { max: c3, min: d2 } = function(e3, t4, i3) {
          const n4 = 200 * Math.pow(i3 / 15, 0.6) * Math.pow(e3 * t4 / 640 / 360, 0.75);
          return { min: Math.floor(n4), max: Math.floor(4 * n4) };
        }(s2, a3, o2), { bitrateMax: l2, bitrateMin: u3 } = t3 || {};
        l2 || sD.debug("calculate bitrate: [w: ".concat(s2, ", h: ").concat(a3, ", fps: ").concat(o2, "] => [brMax: ").concat(l2, ", brMin: ").concat(u3, "]"));
        const { maxFramerate: h2 } = wN("ENCODER_CONFIG_LIMIT");
        return h2 && "number" == typeof h2 && (o2 = Math.min(o2, h2)), { frameRate: o2, bitrateMax: l2 || c3, bitrateMin: u3 || d2, scaleResolutionDownBy: 1, scale: 0 };
      }, ZP = async (e2, t3, i2) => await (async (e3, t4, i3) => {
        const n3 = function(e4) {
          const t5 = [];
          for (let i4 = 0; i4 < e4.length; i4 += 2) t5.push(parseInt(e4.slice(i4, i4 + 2), 16));
          return Uint8Array.from(t5);
        }(MO("" + t4 + i3)).slice(0, 16), r2 = n3.slice(0, 12), o2 = await window.crypto.subtle.importKey("raw", n3, "AES-GCM", true, ["encrypt"]);
        return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, o2, e3));
      })(e2.buffer, t3, i2), QP = (e2) => {
        const t3 = document.createElement("canvas");
        return t3.width = 2, t3.height = 2, new ip2((i2, n3) => {
          t3.toBlob(async (e3) => {
            if (t3.remove(), e3) {
              const n4 = await $P(e3);
              i2({ buffer: n4, width: t3.width, height: t3.height });
            } else n3(new Ow2(ww2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }, e2, 1);
        });
      }, $P = async (e2) => {
        const t3 = await e2.arrayBuffer();
        return new Uint8Array(t3);
      };
      var eL, tL, iL, nL, rL, oL, sL, aL, cL, dL, lL, uL, hL, pL, _L, EL, mL, fL, SL, gL, TL, RL, vL, CL, yL, IL, bL, AL, wL, OL, NL, DL, PL, LL, kL, ML, UL, VL, xL, FL;
      let BL = (eL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3], throttleTime: 300 }), tL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), iL = FP(), nL = FO("LocalAudioTrack", "_enabledMutex"), rL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), oL = FP(), sL = FO("LocalAudioTrack", "_enabledMutex"), aL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), cL = FP(), dL = FP(), lL = FP(), uL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), hL = FP(), pL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), _L = FP(), EL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), mL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3.name] }), fL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), sP((SL = class extends uP {
        get _source() {
          return this.initWebAudio();
        }
        set _source(e2) {
          this._trackSource = e2;
        }
        get processorContext() {
          return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;
        }
        get processorDestination() {
          return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;
        }
        get isPlaying() {
          return this._useAudioElement ? xP.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "LocalAudioTrack";
        }
        constructor(e2, t3, i2, n3) {
          super(e2, i2), aP(this, "trackMediaType", KD.AUDIO), aP(this, "_encoderConfig", void 0), aP(this, "_trackSource", void 0), aP(this, "metadata", []), aP(this, "_enabled", true), aP(this, "_volume", 100), aP(this, "_useAudioElement", true), aP(this, "_bypassWebAudio", false), aP(this, "processor", void 0), aP(this, "_processorContext", void 0), aP(this, "_processorDestination", void 0), aP(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t3, this._getOriginVolumeLevel = !!n3, this._trackSource = new HP(), wN("DISABLE_WEBAUDIO") && (this._bypassWebAudio = true), wN("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), $A2() && !pP ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();
        }
        setVolume(e2) {
          Pw2(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && xP.setVolume(this.getTrackId(), e2);
          try {
            if (this._bypassWebAudio) return void sD.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
            const e3 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, sO(this, VD.NEED_REPLACE_TRACK, this).then(() => {
              sD.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
            }).catch((e4) => {
              sD.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
            }));
          } catch (e3) {
          }
        }
        getVolumeLevel() {
          return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !SD()) throw new Ow2(ww2.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await xP.setSinkID(this.getTrackId(), e2);
        }
        async setEnabled(e2, t3, i2) {
          return this._setEnabled(e2, t3, i2);
        }
        async _setEnabled(e2, t3, i2) {
          if (!i2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (sD.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
            this._originMediaStreamTrack.enabled = true;
            try {
              i2 || (this._enabled = true), await sO(this, VD.NEED_ENABLE_TRACK, this), sD.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
            } catch (e3) {
              throw i2 || (this._enabled = false), sD.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, i2 || (this._enabled = false);
            try {
              await sO(this, VD.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw i2 || (this._enabled = true), sD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
            }
          }
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, sD.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await sO(this, VD.NEED_MUTE_TRACK, this) : await sO(this, VD.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          mO(() => {
            sD.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }, "localAudioTrackGetStatsWarning");
          return aO(this, VD.GET_STATS) || dP({}, zD);
        }
        setAudioFrameCallback(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2) return this._source.removeAllListeners(YD.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t3), this._source.removeAllListeners(YD.ON_AUDIO_BUFFER), this._source.on(YD.ON_AUDIO_BUFFER, (t4) => e2(t4));
        }
        play() {
          sD.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (sD.debug("[".concat(this.getTrackId(), "] start audio playback in element")), xP.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
        }
        stop() {
          sD.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? xP.stop(this.getTrackId()) : this._source.stop();
        }
        close() {
          super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          sD.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xP.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e2, t3) {
          this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t3 && this._originMediaStreamTrack.stop()), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this._processorContext && this.processor.updateInput({ track: e2, context: this._processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await sO(this, VD.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
        }
        renewMediaStreamTrack(e2) {
          return ip2.resolve(void 0);
        }
        pipe(e2) {
          if (this._bypassWebAudio) throw new Ow2(ww2.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e2) return e2;
          if (e2._source) throw new Ow2(ww2.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (!this.processor) return;
          const t3 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t3.reset();
        }
        bindProcessorDestinationEvents(e2) {
          e2.on(QD.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e3), await sO(this, VD.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await sO(this, VD.NEED_REPLACE_TRACK, this));
          }), e2.on(QD.ON_NODE, (e3) => {
            this._source.processedNode = e3;
          });
        }
        unbindProcessorDestinationEvents(e2) {
          e2.removeAllListeners(QD.ON_TRACK), e2.removeAllListeners(QD.ON_NODE);
        }
        bindProcessorContextEvents(e2) {
          e2.on($D.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
        unbindProcessorContextEvents(e2) {
          e2.removeAllListeners($D.REQUEST_CONSTRAINTS);
        }
        initWebAudio() {
          return this._trackSource instanceof HP && (this._trackSource = new RP(this._mediaStreamTrack, false, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;
        }
        initProcessor() {
          const e2 = new WP(this._source.context, this.getTrackId(), "local"), t3 = new GP(e2);
          return this._processorContext = e2, this._processorDestination = t3, this.bindProcessorContextEvents(e2), this.bindProcessorDestinationEvents(t3), this._source.on(YD.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: e2 });
          }), this._useAudioElement && (this._useAudioElement = false, this.isPlaying && (xP.stop(this.getTrackId()), this._source.play()), sO(this, VD.NEED_REPLACE_MIXING_TRACK, this).then(() => {
            sD.debug("[".concat(this.getTrackId(), "] replace from origin track to web audio track success"));
          }).catch((e3) => {
            sD.warning("[".concat(this.getTrackId(), "] replace from origin track to web audio track failed"), e3);
          })), { processorContext: e2, processorDestination: t3 };
        }
      }).prototype, "setVolume", [eL], Object.getOwnPropertyDescriptor(SL.prototype, "setVolume"), SL.prototype), sP(SL.prototype, "setPlaybackDevice", [tL, iL], Object.getOwnPropertyDescriptor(SL.prototype, "setPlaybackDevice"), SL.prototype), sP(SL.prototype, "setEnabled", [nL, rL, oL], Object.getOwnPropertyDescriptor(SL.prototype, "setEnabled"), SL.prototype), sP(SL.prototype, "setMuted", [sL, aL, cL], Object.getOwnPropertyDescriptor(SL.prototype, "setMuted"), SL.prototype), sP(SL.prototype, "getStats", [dL], Object.getOwnPropertyDescriptor(SL.prototype, "getStats"), SL.prototype), sP(SL.prototype, "setAudioFrameCallback", [lL], Object.getOwnPropertyDescriptor(SL.prototype, "setAudioFrameCallback"), SL.prototype), sP(SL.prototype, "play", [uL, hL], Object.getOwnPropertyDescriptor(SL.prototype, "play"), SL.prototype), sP(SL.prototype, "stop", [pL, _L], Object.getOwnPropertyDescriptor(SL.prototype, "stop"), SL.prototype), sP(SL.prototype, "close", [EL], Object.getOwnPropertyDescriptor(SL.prototype, "close"), SL.prototype), sP(SL.prototype, "pipe", [mL], Object.getOwnPropertyDescriptor(SL.prototype, "pipe"), SL.prototype), sP(SL.prototype, "unpipe", [fL], Object.getOwnPropertyDescriptor(SL.prototype, "unpipe"), SL.prototype), SL), jL = (gL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), TL = FP(), RL = FO("MicrophoneAudioTrack", "_enabledMutex"), vL = pD2({ argsMap: (e2, t3, i2) => [e2.getTrackId(), t3, i2] }), CL = FP(), yL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), sP((IL = class extends BL {
        get __className__() {
          return "MicrophoneAudioTrack";
        }
        constructor(e2, t3, i2, n3) {
          super(e2, t3.encoderConfig ? kD2(t3.encoderConfig) : {}, n3, wN("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), aP(this, "_config", void 0), aP(this, "_deviceName", "default"), aP(this, "_constraints", void 0), aP(this, "_originalConstraints", void 0), aP(this, "_enabled", true), this._config = t3, this._constraints = i2, this._originalConstraints = i2, this._deviceName = e2.label, "boolean" == typeof t3.bypassWebAudio && (this._bypassWebAudio = t3.bypassWebAudio), (Ew2() || mw2()) && _P.bindInterruptDetectorTrack(this);
        }
        async setDevice(e2) {
          if (sD.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled) try {
            const t3 = await PP.getDeviceById(e2), i2 = {};
            i2.audio = dP({}, this._constraints), i2.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
            let n3 = null;
            try {
              n3 = await wP(i2, this.getTrackId());
            } catch (e3) {
              throw sD.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n3 = await wP({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n3.getAudioTracks()[0], false), e3;
            }
            await this._updateOriginMediaStreamTrack(n3.getAudioTracks()[0], false), this._deviceName = t3.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw sD.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          else try {
            const t3 = await PP.getDeviceById(e2);
            this._deviceName = t3.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw sD.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
          sD.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
        }
        async setEnabled(e2, t3, i2) {
          if (t3) return sD.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
          if (!i2) {
            if (e2 === this._enabled) return;
            this.stateCheck("enabled", e2);
          }
          if (sD.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), wN("AUTO_RESET_AUDIO_ROUTE") && (nw2() || Sw2())) {
            const t4 = navigator.audioSession;
            t4 && (e2 || (t4.type = "playback"), t4.type = "auto");
          }
          if (!e2) {
            var n3;
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n3 = this._source.clonedTrack) || void 0 === n3 || n3.stop(), i2 || (this._enabled = false);
            try {
              await sO(this, VD.NEED_DISABLE_TRACK, this);
            } catch (e3) {
              throw sD.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
            }
            return;
          }
          const r2 = dP({}, this._constraints), o2 = PP.searchDeviceIdByName(this._deviceName);
          o2 && !r2.deviceId && (r2.deviceId = o2);
          try {
            i2 || (this._enabled = true);
            const e3 = await wP({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await sO(this, VD.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw i2 || (this._enabled = false), sD.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
          }
          sD.info("[".concat(this.getTrackId(), "] setEnabled success"));
        }
        close() {
          super.close(), (Ew2() || mw2()) && _P.unbindInterruptDetectorTrack(this);
        }
        onTrackEnded() {
          if ((nw2() || Sw2()) && this._enabled && !this._isClosed && _P.duringInterruption) {
            const e2 = async () => {
              _P.off(vD.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (sD.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            _P.on(vD.IOS_INTERRUPTION_END, e2);
          } else sD.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(WD.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t3 = e2 || this._constraints, i2 = PP.searchDeviceIdByName(this._deviceName);
          if (i2 && !t3.deviceId && (t3.deviceId = i2), this._constraints = t3, this._enabled) {
            this._originMediaStreamTrack.stop();
            const e3 = await wP({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
          }
        }
        bindProcessorContextEvents(e2) {
          super.bindProcessorContextEvents(e2), e2.on($D.REQUEST_UPDATE_CONSTRAINTS, async (e3, t3, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i3), t3();
            } catch (e4) {
              i2(e4);
            }
          });
        }
        unbindProcessorContextEvents(e2) {
          super.unbindProcessorContextEvents(e2), e2.removeAllListeners($D.REQUEST_UPDATE_CONSTRAINTS);
        }
      }).prototype, "setDevice", [gL, TL], Object.getOwnPropertyDescriptor(IL.prototype, "setDevice"), IL.prototype), sP(IL.prototype, "setEnabled", [RL, vL, CL], Object.getOwnPropertyDescriptor(IL.prototype, "setEnabled"), IL.prototype), sP(IL.prototype, "close", [yL], Object.getOwnPropertyDescriptor(IL.prototype, "close"), IL.prototype), IL), GL = (bL = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3, e2.duration] }), AL = FP(), wL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), OL = FP(), NL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), DL = FP(), PL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), LL = FP(), kL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), ML = FP(), UL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), VL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), xL = FP(), sP((FL = class extends BL {
        get __className__() {
          return "BufferSourceAudioTrack";
        }
        constructor(e2, t3, i2, n3) {
          super(t3.createOutputTrack(), i2, n3), aP(this, "source", void 0), aP(this, "_bufferSource", void 0), this._useAudioElement = false, this.source = e2, this._bufferSource = t3, this._bufferSource.on(YD.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
            this.safeEmit(WD.SOURCE_STATE_CHANGE, e3);
          });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        get playbackSpeed() {
          return this._bufferSource.playbackSpeed;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e2) {
          e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
        }
        pauseProcessAudioBuffer() {
          this._bufferSource.pauseProcessAudioBuffer();
        }
        seekAudioBuffer(e2) {
          this._bufferSource.seekAudioBuffer(e2);
        }
        resumeProcessAudioBuffer() {
          this._bufferSource.resumeProcessAudioBuffer();
        }
        stopProcessAudioBuffer() {
          this._bufferSource.stopProcessAudioBuffer();
        }
        close() {
          this.source = null, this._bufferSource.destroy(), super.close();
        }
        setAudioBufferPlaybackSpeed(e2) {
          Pw2(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
        }
      }).prototype, "startProcessAudioBuffer", [bL, AL], Object.getOwnPropertyDescriptor(FL.prototype, "startProcessAudioBuffer"), FL.prototype), sP(FL.prototype, "pauseProcessAudioBuffer", [wL, OL], Object.getOwnPropertyDescriptor(FL.prototype, "pauseProcessAudioBuffer"), FL.prototype), sP(FL.prototype, "seekAudioBuffer", [NL, DL], Object.getOwnPropertyDescriptor(FL.prototype, "seekAudioBuffer"), FL.prototype), sP(FL.prototype, "resumeProcessAudioBuffer", [PL, LL], Object.getOwnPropertyDescriptor(FL.prototype, "resumeProcessAudioBuffer"), FL.prototype), sP(FL.prototype, "stopProcessAudioBuffer", [kL, ML], Object.getOwnPropertyDescriptor(FL.prototype, "stopProcessAudioBuffer"), FL.prototype), sP(FL.prototype, "close", [UL], Object.getOwnPropertyDescriptor(FL.prototype, "close"), FL.prototype), sP(FL.prototype, "setAudioBufferPlaybackSpeed", [VL, xL], Object.getOwnPropertyDescriptor(FL.prototype, "setAudioBufferPlaybackSpeed"), FL.prototype), FL);
      class WL extends BL {
        get __className__() {
          return "MixingAudioTrack";
        }
        get isActive() {
          for (const e2 of this.trackList) if (e2._enabled && !e2._isClosed && !e2.muted) return true;
          return false;
        }
        constructor() {
          const e2 = EP().createMediaStreamDestination();
          super(e2.stream.getAudioTracks()[0], void 0, IO(8, "track-mix-")), aP(this, "trackList", void 0), aP(this, "destNode", void 0), this._useAudioElement = false;
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
          this.destNode = e2, this.trackList = [];
        }
        hasAudioTrack(e2) {
          return -1 !== this.trackList.indexOf(e2);
        }
        addAudioTrack(e2) {
          -1 === this.trackList.indexOf(e2) ? (sD.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : sD.debug("track ".concat(e2.getTrackId(), " is already added"));
        }
        removeAudioTrack(e2) {
          if (-1 !== this.trackList.indexOf(e2)) {
            sD.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
            try {
              e2._source.outputNode.disconnect(this.destNode);
            } catch (e3) {
            }
            lO(this.trackList, e2), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e2 = {};
          this.trackList.forEach((t3) => {
            t3._encoderConfig && ((t3._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t3._encoderConfig.bitrate), (t3._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t3._encoderConfig.sampleRate), (t3._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t3._encoderConfig.sampleSize), t3._encoderConfig.stereo && (e2.stereo = true));
          }), this._encoderConfig = e2;
        }
        _updateRtpTransceiver(e2) {
          this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach((t3) => {
            t3 instanceof WL ? t3.emit(GD.TRANSCEIVER_UPDATED, e2) : t3._updateRtpTransceiver(e2);
          }));
        }
      }
      class HL extends TP {
        set currentState(e2) {
          e2 !== this._currentState && (this._currentState = e2, this.safeEmit(YD.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(), aP(this, "audioBuffer", void 0), aP(this, "sourceNode", void 0), aP(this, "startPlayTime", 0), aP(this, "startPlayOffset", 0), aP(this, "pausePlayTime", 0), aP(this, "options", void 0), aP(this, "currentLoopCount", 0), aP(this, "currentPlaybackSpeed", 100), aP(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t3, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer ? this.audioBuffer.duration : 0;
        }
        get playbackSpeed() {
          return this.currentPlaybackSpeed;
        }
        get currentTime() {
          return this.audioBuffer ? "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
        }
        updateOptions(e2) {
          "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : sD.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e2) {
          this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
        }
        resumeProcessAudioBuffer() {
          "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e2) {
            }
            this.reset();
          }
        }
        destroy() {
          this.audioBuffer = null, super.destroy();
        }
        setAudioBufferPlaybackSpeed(e2) {
          this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const KL = /* @__PURE__ */ new Map();
      function YL(e2, t3) {
        if (0 === e2.length || 0 === t3.length) return 1 / 0;
        const i2 = kO(e2), n3 = kO(t3);
        return Math.floor(n3 / i2);
      }
      class zL {
        get rendFrameRate() {
          const e2 = Math.max(1, YL(this._render_interframe_delays_sizes, this._render_interframe_delays));
          return Math.floor(1e3 / e2);
        }
        get videoElementStatus() {
          return this._isInPage ? this._videoElementStatus : iP.DESTROYED;
        }
        set videoElementStatus(e2) {
          e2 !== this._videoElementStatus && (sD.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
        }
        get videoState() {
          return this._videoState;
        }
        set videoState(e2) {
          var t3;
          e2 !== this._videoState && (this._videoState = e2, null === (t3 = this.onVideoStateChanged) || void 0 === t3 || t3.call(this, this.videoState));
        }
        constructor(e2) {
          aP(this, "trackId", void 0), aP(this, "config", void 0), aP(this, "onFirstVideoFrameDecoded", void 0), aP(this, "onFirstVideoFrameRender", void 0), aP(this, "onVideoStateChanged", void 0), aP(this, "freezeTimeCounterList", []), aP(this, "renderFreezeAccTime", 0), aP(this, "renderFreezeAccTime2", 0), aP(this, "isKeepLastFrame", false), aP(this, "isDestroyed", false), aP(this, "timeUpdatedCount", 0), aP(this, "freezeTime", 0), aP(this, "playbackTime", 0), aP(this, "lastTimeUpdatedTime", 0), aP(this, "autoplayFailed", false), aP(this, "videoTrack", void 0), aP(this, "videoElement", void 0), aP(this, "cacheVideoElement", void 0), aP(this, "internal", false), aP(this, "_render_interframe_delays", []), aP(this, "_render_interframe_delays_sizes", []), aP(this, "_videoState", nP.VideoStateStopped), aP(this, "videoElementCheckInterval", void 0), aP(this, "videoElementFreezeTimeout", void 0), aP(this, "_videoElementStatus", iP.NONE), aP(this, "_isInPage", true), aP(this, "isGettingVideoDimensions", false), aP(this, "startGetVideoDimensions", () => {
            const e3 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return sD.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
              setTimeout(e3, 500);
            };
            !this.isGettingVideoDimensions && e3();
          }), aP(this, "autoResumeAfterInterruption", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && "running" === _P.curState && (sD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(JA2())), fw2() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), aP(this, "handleVideoEvents", (e3) => {
            switch (e3.type) {
              case "play":
              case "playing":
                "play" === e3.type && sD.debug("[".concat(this.trackId, "] video element status: play")), this.startGetVideoDimensions(), this.videoElementStatus = iP.PLAYING;
                break;
              case "loadeddata":
                if (this.videoState = nP.VideoStateStarting, this.onFirstVideoFrameRender && this.onFirstVideoFrameRender(), this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                  try {
                    this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                  } catch (e4) {
                  }
                  this.cacheVideoElement = void 0;
                }
                break;
              case "canplay":
                this.videoElementStatus = iP.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = iP.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = iP.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = iP.PAUSED, nw2() || Sw2() || $A2() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (sD.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = iP.WAITING;
                break;
              case "abort":
                this.videoElementStatus = iP.ABORT;
                break;
              case "ended":
                this.videoElementStatus = iP.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = iP.EMPTIED;
                break;
              case "error": {
                const e4 = this.videoElement.error;
                e4 && (this.videoElementStatus = iP.ERROR, sD.error("[".concat(this.trackId, "] media error: ").concat(e4.message, " (").concat(e4.code, ")")));
                break;
              }
              case "timeupdate": {
                const e4 = performance.now();
                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e4);
                const t3 = e4 - this.lastTimeUpdatedTime, i2 = this.lastTimeUpdatedTime;
                if (this.lastTimeUpdatedTime = e4, Qk2.lastVisibleTime < Qk2.lastHiddenTime || i2 < Qk2.lastHiddenTime || i2 < Qk2.lastVisibleTime) return;
                if (this.isSkipCalcRenderFreezeTime()) return;
                for (t3 > wN("VIDEO_FREEZE_DURATION") && (this.freezeTime += t3), this.playbackTime += t3; this.playbackTime >= 6e3; ) {
                  this.playbackTime -= 6e3;
                  const e5 = Math.min(6e3, this.freezeTime);
                  this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                }
                break;
              }
            }
          }), aP(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
            this.videoTrack && "live" === this.videoTrack.readyState && (sD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(JA2())), fw2() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
          }), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), _P.on(vD.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _P.on(vD.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          var e2;
          return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
        }
        play(e2) {
          const t3 = this.videoElement.play();
          t3 && t3.catch && t3.catch((t4) => {
            e2 && UP(e2, "video", t4.message, this.trackId), "NotAllowedError" === t4.name ? (sD.warning("detected video element autoplay failed", t4), this.autoplayFailed = true, this.handleAutoPlayFailed()) : sD.warning("[".concat(this.trackId, "] play warning: "), t4);
          });
          const i2 = zA2();
          if (("Safari" === i2.name && 15 === Number(i2.version) || Ew2()) && t3 && t3.then) {
            const e3 = () => {
              this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
            };
            t3.then(e3).catch(e3);
          }
        }
        getCurrentFrame() {
          const e2 = document.createElement("canvas");
          e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
          const t3 = e2.getContext("2d");
          if (!t3) return sD.error("create canvas context failed!"), new ImageData(2, 2);
          t3.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
          const i2 = t3.getImageData(0, 0, e2.width, e2.height);
          return e2.remove(), i2;
        }
        async getCurrentFrameToUint8Array(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          const i2 = document.createElement("canvas");
          i2.width = this.videoElement.videoWidth, i2.height = this.videoElement.videoHeight;
          const n3 = i2.getContext("2d");
          return n3 ? (n3.drawImage(this.videoElement, 0, 0, i2.width, i2.height), new ip2((n4, r2) => {
            i2.toBlob(async (e3) => {
              if (i2.remove(), e3) {
                const t4 = await $P(e3);
                n4({ buffer: t4, width: i2.width, height: i2.height });
              } else r2(new Ow2(ww2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
            }, e2, t3 < 0 ? 0.1 : t3 > 1 ? 1 : t3);
          })) : await QP(e2);
        }
        destroy() {
          this.isDestroyed = true, _P.off(vD.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), _P.off(vD.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = nP.VideoStateStopped;
        }
        initVideoElement() {
          if (this.videoElementStatus = iP.INIT, !this.videoElementCheckInterval && (qL.forEach((e3) => {
            this.videoElement.addEventListener(e3, this.handleVideoEvents);
          }), this.videoElementCheckInterval = window.setInterval(() => {
            this._isInPage = function(e3) {
              return e3 !== document.body && document.body.contains(e3);
            }(this.videoElement);
          }, 1e3), wN("ENABLE_VIDEO_FRAME_CALLBACK"))) {
            var e2, t3;
            let i3;
            const n4 = () => {
              "visible" === document.visibilityState && (document.removeEventListener("visibilitychange", n4), this.videoElementFreezeTimeout = window.setTimeout(r2, wN("VIDEO_FREEZE_DURATION")));
            }, r2 = () => {
              this.videoElementFreezeTimeout = void 0, this.videoState === nP.VideoStateDecoding && ("visible" === document.visibilityState ? this.videoState = nP.VideoStateFrozen : document.addEventListener("visibilitychange", n4));
            }, o2 = (e3, t4) => {
              if (this.videoElementStatus === iP.PLAYING) {
                if (i3) {
                  const e4 = t4.presentationTime - i3.presentationTime, n6 = t4.presentedFrames - i3.presentedFrames;
                  this._render_interframe_delays_sizes.push(n6), this._render_interframe_delays.push(e4);
                  const o3 = kO(this._render_interframe_delays_sizes), s3 = o3 - this._render_interframe_delays_sizes[0];
                  if (o3 > 30 && s3 > 5 && (this._render_interframe_delays_sizes.shift(), this._render_interframe_delays.shift()), this.videoState === nP.VideoStateStarting && (this.videoState = nP.VideoStateDecoding), this.videoState === nP.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(r2, wN("VIDEO_FREEZE_DURATION"))), e4 < wN("VIDEO_FREEZE_DURATION") && this.videoState === nP.VideoStateFrozen && (this.videoState = nP.VideoStateDecoding), e4 > wN("VIDEO_FREEZE_DURATION") && Qk2.lastVisibleTime >= Qk2.lastHiddenTime && i3.timestamp > Qk2.lastVisibleTime && i3.timestamp > Qk2.lastHiddenTime) {
                    const t5 = Math.min(66, YL(this._render_interframe_delays_sizes, this._render_interframe_delays)), i4 = Math.max(0, e4 - (n6 - 1) * t5);
                    this.renderFreezeAccTime2 += i4 > t5 ? i4 : 0, this.renderFreezeAccTime += e4;
                  }
                }
                i3 = dP(dP({}, t4), {}, { timestamp: e3 });
              } else this.isSkipCalcRenderFreezeTime() && (i3 = dP(dP({}, t4), {}, { timestamp: e3 }));
              var n5, s2;
              wN("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (n5 = (s2 = this.videoElement).requestVideoFrameCallback) || void 0 === n5 || n5.call(s2, o2));
            };
            null === (e2 = (t3 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 || e2.call(t3, o2);
          }
          this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), Cw2() && !wN("HIDE_NO_POSTER") && (this.videoElement.poster = "noposter");
          const i2 = zA2();
          "Safari" === i2.name && 15 === Number(i2.version) || Ew2() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, iw2() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, iw2() && this.videoElement.load());
          const n3 = this.videoElement.play();
          void 0 !== n3 && n3.catch((e3) => {
            sD.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
          });
        }
        resetVideoElement() {
          qL.forEach((e2) => {
            this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
          }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = iP.NONE;
        }
        isSkipCalcRenderFreezeTime() {
          return this.videoElementStatus === iP.DESTROYED || this.internal;
        }
        handleAutoPlayFailed() {
          const e2 = (t3) => {
            t3.preventDefault(), this.videoElement.play().then(() => {
              sD.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
            }).catch((e3) => {
              sD.error(e3);
            }), this.autoplayFailed = false, yw2() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
          };
          yw2() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), MP();
        }
      }
      const qL = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
      class XL extends zL {
        constructor(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          super(e2), aP(this, "container", void 0), aP(this, "slot", void 0), this.slot = e2.element, this.internal = t3, this.updateConfig(e2);
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId;
          const t3 = e2.element;
          var i2;
          !this.internal || this.slot ? (t3 !== this.slot && (this.destroy(), this.slot = t3), this.createElements()) : (this.slot = t3, t3 && this.container ? (this.internal = false, this.container.id = "agora-video-player-".concat(this.trackId), this.videoElement.id = "video_".concat(this.trackId), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", null === (i2 = this.slot) || void 0 === i2 || i2.appendChild(this.container)) : this.createElements());
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
        }
        play(e2) {
          var t3;
          null !== (t3 = this.container) && void 0 !== t3 && t3.contains(this.videoElement) && super.play(e2);
        }
        getCurrentFrame() {
          var e2;
          return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameToUint8Array(e2) {
          var t3;
          let i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return null !== (t3 = this.container) && void 0 !== t3 && t3.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i2) : await QP(e2);
        }
        destroy() {
          if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
            try {
              var e2;
              this.container.remove(), null === (e2 = this.slot) || void 0 === e2 || e2.removeChild(this.container);
            } catch (e3) {
            }
            this.container = void 0;
          }
        }
        createElements() {
          var e2;
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", wN("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), null === (e2 = this.slot) || void 0 === e2 || e2.appendChild(this.container);
        }
        mountedVideoElement() {
          var e2;
          !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
        }
        unmountedVideoElement() {
          var e2;
          if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
            super.resetVideoElement();
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e3) {
            }
            this.videoElement = document.createElement("video");
          }
        }
        resetVideoElement() {
          var e2;
          null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
        }
        getContainerElement() {
          return this.container;
        }
      }
      var JL, ZL, QL, $L, ek2, tk2, ik2, nk2, rk2, ok2, sk2, ak2, ck2, dk2, lk2, uk2, hk2, pk2, _k, Ek2, mk2, fk2, Sk2, gk2, Tk2, Rk2, vk2, Ck2, yk2, Ik2, bk2, Ak2, wk2, Ok2, Nk2, Dk2, Pk2, Lk2;
      let kk2 = (JL = pD2({ argsMap: (e2, t3, i2) => [e2.getTrackId(), "string" == typeof t3 ? t3 : t3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), ZL = FP(), QL = pD2({ argsMap: (e2) => [e2.getTrackId()] }), $L = FO("LocalVideoTrack", "_enabledMutex"), ek2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), tk2 = FP(), ik2 = FO("LocalVideoTrack", "_enabledMutex"), nk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), rk2 = FP(), ok2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3, e2._saveEncodeBitrateRatio] }), sk2 = FP(), ak2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), ck2 = FP(), dk2 = FP(), lk2 = pD2({ argsMap: (e2, t3, i2) => [e2.getTrackId(), t3, i2] }), uk2 = FP(), hk2 = FP(), pk2 = FP(), _k = pD2({ argsMap: (e2) => [e2.getTrackId()] }), Ek2 = FP(), mk2 = FP(), fk2 = FP(), Sk2 = FP(), gk2 = FP(), Tk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3.name] }), Rk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), vk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), Ck2 = pD2({ argsMap: (e2, t3, i2) => [e2.getTrackId(), t3.label, i2] }), yk2 = class e2 extends uP {
        get videoHeight() {
          if ($A2()) {
            const { height: e3 } = this._mediaStreamTrack.getSettings();
            return this._videoHeight = e3, this._videoHeight;
          }
          return this._videoHeight;
        }
        get videoWidth() {
          if ($A2()) {
            const { width: e3 } = this._mediaStreamTrack.getSettings();
            return this._videoWidth = e3, this._videoWidth;
          }
          return this._videoWidth;
        }
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== iP.PLAYING);
        }
        get processorDestination() {
          return this._processorDestination;
        }
        get processorContext() {
          return this._processorContext;
        }
        set processorContext(e3) {
          this._processorContext = e3;
        }
        get __className__() {
          return "LocalVideoTrack";
        }
        constructor(e3, t3, i2, n3, r2, o2) {
          if (super(e3, r2), aP(this, "trackMediaType", KD.VIDEO), aP(this, "_player", void 0), aP(this, "isUseScaleResolutionDownBy", false), aP(this, "_videoVisibleTimer", null), aP(this, "_previousVideoVisibleStatus", void 0), aP(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), aP(this, "_encoderConfig", void 0), aP(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), aP(this, "_optimizationMode", void 0), aP(this, "_saveEncodeBitrateRatio", 1), aP(this, "_videoHeight", void 0), aP(this, "_videoWidth", void 0), aP(this, "_forceBitrateLimit", void 0), aP(this, "_enabled", true), aP(this, "_processorDestination", void 0), aP(this, "_processorContext", void 0), $A2()) {
            const { width: t4, height: i3 } = e3.getSettings();
            this._videoWidth = t4, this._videoHeight = i3;
          } else this.updateMediaStreamTrackResolution();
          if (this._scalabilityMode = i2, this._optimizationMode = n3, this._hints = o2 || [], t3 && -1 !== this._hints.indexOf(xD.CUSTOM_TRACK) ? this._encoderConfig = pO(t3) : this._encoderConfig = t3, -1 === this._hints.indexOf(xD.SCREEN_TRACK)) this.updateBitrateFromProfile();
          else if (sw2(WA2.CHROME, 115) && -1 !== XA2().indexOf("Windows")) {
            const t4 = function(e4, t5) {
              if ("VideoFrame" in window && "TransformStream" in window && fD2().supportWebRTCInsertableStream) {
                const i3 = new MediaStreamTrackProcessor(e4), n4 = new MediaStreamTrackGenerator({ kind: "video" });
                let r3, o3, s2 = Date.now();
                const a3 = () => {
                  c3 && (clearInterval(c3), c3 = void 0), r3 && (r3.close(), r3 = void 0), e4.stop(), o3 = void 0, n4.removeEventListener("ended", a3);
                };
                let c3 = window.setInterval(() => {
                  if (o3 && r3 && Date.now() - s2 > (null != t5 ? t5 : 1e3)) try {
                    "live" === n4.readyState ? o3.enqueue(r3.clone()) : a3();
                  } catch (e5) {
                    a3();
                  }
                }, null != t5 ? t5 : 1e3);
                const d2 = new TransformStream({ transform: (e5, t6) => {
                  "live" === n4.readyState ? (o3 = t6, s2 = Date.now(), void 0 === r3 ? (r3 = e5, t6.enqueue(e5.clone())) : (t6.enqueue(r3), r3 = e5)) : e5.close();
                } });
                return n4.addEventListener("ended", a3), i3.readable.pipeThrough(d2).pipeTo(n4.writable), n4;
              }
            }(e3);
            t4 && (sD.info("local screen video track begin to inject frame"), this._mediaStreamTrack = t4);
          }
          t3 && -1 !== this._hints.indexOf(xD.CUSTOM_TRACK) && this.setEncoderConfiguration(t3), this._processorContext = new jP(this.getTrackId(), "local"), this._processorDestination = new BP(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if ("string" == typeof e3) {
            const t4 = document.getElementById(e3);
            t4 ? e3 = t4 : (sD.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), e3 = document.body);
          }
          sD.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t3));
          const i2 = dP(dP(dP({}, this._getDefaultPlayerConfig()), t3), {}, { trackId: this.getTrackId(), element: e3 });
          this._player ? this._player.updateConfig(i2) : (e3 instanceof HTMLVideoElement ? this._player = new zL(i2) : this._player = new XL(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e4 = this.getVideoElementVisibleStatus();
              this.safeEmit(WD.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
            } catch (e4) {
            }
          }, wN("CHECK_VIDEO_VISIBLE_INTERVAL"));
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, sD.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        async setEnabled(e3, t3) {
          if (!t3) {
            if (e3 === this._enabled) return;
            this.stateCheck("enabled", e3);
          }
          if (sD.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), !e3) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await sO(this, VD.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw sD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            return t3 || (this._enabled = false), void sD.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await sO(this, VD.NEED_ENABLE_TRACK, this);
          } catch (e4) {
            throw sD.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e4.toString()), e4;
          }
          sD.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t3 || (this._enabled = true);
        }
        async setMuted(e3) {
          e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._originMediaStreamTrack.enabled = !e3, sD.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), e3 ? await sO(this, VD.NEED_MUTE_TRACK, this) : await sO(this, VD.NEED_UNMUTE_TRACK, this));
        }
        async setSaveEncodeBitrateRatio() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._saveEncodeBitrateRatio;
          if (1 !== this._saveEncodeBitrateRatio && this._encoderConfig && this._encoderConfig.bitrateMax && this._encoderConfig.bitrateMin) {
            this._encoderConfig.bitrateMin = Math.floor(this._encoderConfig.bitrateMin * e3), this._encoderConfig.bitrateMax = Math.floor(this._encoderConfig.bitrateMax * e3), sD.debug("[".concat(this.getTrackId(), "] set save encode bitrate ratio, ").concat(e3)), this._saveEncodeBitrateRatio = 1;
            try {
              await sO(this, VD.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e4) {
              return e4.throw(sD);
            }
          }
        }
        async setEncoderConfiguration(e3, t3) {
          if (!this._enabled) throw new Ow2(ww2.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          if (e3 = ND(e3), wN("USE_STANDARD_BITRATE_DEFAULT") && (delete e3.bitrateMax, delete e3.bitrateMin), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), e3.width || e3.height || e3.frameRate) {
            const t4 = zP({ encoderConfig: e3 });
            ($A2() || nw2() || Sw2()) && (t4.deviceId = void 0), sD.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(t4));
            try {
              await this._originMediaStreamTrack.applyConstraints(t4), this.updateMediaStreamTrackResolution();
            } catch (e4) {
              const t5 = new Ow2(ww2.UNEXPECTED_ERROR, e4.toString());
              throw sD.error("[".concat(this.getTrackId(), "] applyConstraints error"), t5.toString()), t5;
            }
          }
          this._encoderConfig = e3, -1 === this._hints.indexOf(xD.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await sO(this, VD.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(sD);
          }
        }
        getStats() {
          mO(() => {
            sD.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }, "localVideoTrackGetStatsWarning");
          return aO(this, VD.GET_STATS) || dP({}, qD2);
        }
        async setBeautyEffect(e3) {
          sD.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        async getCurrentFrameImage(e3) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
          return this._player ? this._player.getCurrentFrameToUint8Array(e3, t3) : await QP(e3);
        }
        async findClosestProfile() {
          const { width: e3, height: t3, frameRate: i2 } = this.getMediaStreamTrackSettings(), { width: n3, height: r2, frameRate: o2 } = this._encoderConfig || {}, s2 = LO(this._videoWidth || e3 || n3 || 0), a3 = LO(this._videoHeight || t3 || r2 || 0), c3 = function(e4, t4, i3) {
            if (!Array.isArray(wN("VIDEO_ENCODER_CONFIG_LIST"))) return false;
            if (0 === wN("VIDEO_ENCODER_CONFIG_LIST").length) return false;
            const n4 = Math.min(e4, t4);
            return !(n4 >= 480) && dP(dP({}, wN("VIDEO_ENCODER_CONFIG_LIST").find((e5) => e5.height > n4)), {}, { frameRate: i3 });
          }(s2, a3, LO(i2 || o2 || 15));
          if (c3) return sD.debug("[".concat(this.getTrackId(), "] find closest profile, ").concat(s2, "x").concat(a3, " => ").concat(JSON.stringify(c3))), this.setEncoderConfiguration(c3);
        }
        async setBitrateLimit(e3) {
          sD.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e3))), e3 && (this._forceBitrateLimit = e3, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e3.max_bitrate ? this._encoderConfig.bitrateMax : e3.max_bitrate : this._encoderConfig.bitrateMax = e3.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e3.min_bitrate));
        }
        async setOptimizationMode(e3) {
          if ("motion" !== e3 && "detail" !== e3 && "balanced" !== e3) return void sD.error(ww2.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
          const t3 = this._optimizationMode;
          try {
            this._optimizationMode = e3, await sO(this, VD.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);
          } catch (e4) {
            throw this._optimizationMode = t3, sD.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e4.toString()), e4;
          }
          sD.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e3, ")"));
        }
        setScalabiltyMode(e3) {
          if (1 === e3.numSpatialLayers && 1 !== e3.numTemporalLayers) return sD.error(ww2.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabilityMode = e3, sD.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e3, ")"));
        }
        updateMediaStreamTrackResolution() {
          YP(this._originMediaStreamTrack).then((e3) => {
            let [t3, i2] = e3;
            this._videoHeight = i2, this._videoWidth = t3;
          }).catch(AO);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        async setSenderConfiguration(e3) {
          if (!this._enabled) throw new Ow2(ww2.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          sD.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e3)), e3 = ND(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), this._encoderConfig = e3, -1 === this._hints.indexOf(xD.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await sO(this, VD.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(sD);
          }
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig) return;
          const { width: e3, height: t3, frameRate: i2 } = this.getMediaStreamTrackSettings();
          if (!e3 || !t3 || !i2) return;
          const { bitrateMax: n3, bitrateMin: r2 } = this._encoderConfig;
          if (null == r2 || null == n3) {
            const { max: o2, min: s2 } = function(e4, t4, i3, n4, r3) {
              const o3 = wN("BITRATE_ADAPTER_TYPE");
              if ("DEFAULT_BITRATE" === o3) return { min: n4, max: r3 };
              if (void 0 === r3) {
                const s3 = Math.floor(200 * Math.pow(i3 / 15, 0.6) * Math.pow(e4 * t4 / 640 / 360, 0.75));
                r3 = "STANDARD_BITRATE" === o3 ? 4 * s3 : 2 * s3, n4 = null != n4 ? n4 : s3;
              } else n4 = null != n4 ? n4 : Math.floor(r3 / 10);
              return { min: n4, max: r3 };
            }(e3, t3, i2, r2, n3);
            if (this._encoderConfig.bitrateMin = s2, this._encoderConfig.bitrateMax = o2, wN("VIDEO_STANDARD_BITRATE_VERSION") && null == r2 && null == n3) {
              const [n4, r3] = function(e4, t4, i3) {
                const n5 = 4 * Math.floor(2e5 * Math.pow(i3 / 15, 0.6) * Math.pow(e4 * t4 / 230400, 0.75)), r4 = e4 * t4, o3 = /* @__PURE__ */ new Map([[19200, 0.9], [230400, 0.85], [518400, 0.75], [921600, 0.7], [2073600, 0.6], [3686400, 0.5]]), s3 = /* @__PURE__ */ new Map([[230400, 0.95], [518400, 0.9], [921600, 0.85], [2073600, 0.8]]);
                let a3 = up2(o3).call(o3).next().value, c3 = 1;
                if (o3.has(r4)) a3 = o3.get(r4);
                else {
                  var d2;
                  const e5 = Xp2(d2 = Array.from(o3.entries())).call(d2, (e6, t6) => {
                    let [i4] = e6, [n6] = t6;
                    return i4 - n6;
                  }), t5 = e5.find((e6) => {
                    let [t6] = e6;
                    return t6 > r4;
                  });
                  if (t5) {
                    const i4 = e5.indexOf(t5);
                    if (i4 > 0) {
                      const n6 = e5[i4 - 1], o4 = (r4 - n6[0]) / (t5[0] - n6[0]);
                      a3 = n6[1] + o4 * (t5[1] - n6[1]);
                    } else a3 = t5[1];
                  } else a3 = e5[e5.length - 1][1];
                }
                if (s3.has(r4)) c3 = s3.get(r4);
                else {
                  var l2;
                  const e5 = Xp2(l2 = Array.from(s3.entries())).call(l2, (e6, t6) => {
                    let [i4] = e6, [n6] = t6;
                    return i4 - n6;
                  }), t5 = e5.find((e6) => {
                    let [t6] = e6;
                    return t6 > r4;
                  });
                  if (t5) {
                    const i4 = e5.indexOf(t5);
                    if (i4 > 0) {
                      const n6 = e5[i4 - 1], o4 = (r4 - n6[0]) / (t5[0] - n6[0]);
                      c3 = n6[1] + o4 * (t5[1] - n6[1]);
                    } else c3 = t5[1];
                  } else c3 = e5[e5.length - 1][1];
                }
                const u3 = wN("VIDEO_NEW_BITRATE_RATIO");
                u3 && u3 > 0 && (a3 = u3 / 100);
                const h2 = Math.floor(n5 * a3), p2 = Math.floor(65e4 * Math.pow(e4 * t4 / 230400, 0.5) * Math.pow(i3 / 15, 0.69));
                let _2 = h2;
                const E3 = wN("VIDEO_STANDARD_BITRATE_VERSION");
                return E3 && E3 > 0 && (1 === E3 ? _2 = n5 : 2 === E3 ? _2 = h2 : 3 === E3 && (_2 = p2)), [Math.floor(_2 / 1e3), c3];
              }(e3, t3, i2);
              this._encoderConfig.bitrateMax = n4, this._encoderConfig.bitrateMin = s2 ? Math.min(s2, n4) : n4, this._saveEncodeBitrateRatio = r3, sD.debug("[".concat(this.getTrackId(), "] update new bitrate from profile, [w: ").concat(e3, ", h: ").concat(t3, ", fps: ").concat(i2, "] => [brMax: ").concat(this._encoderConfig.bitrateMax, ", brMin: ").concat(this._encoderConfig.bitrateMin, ", save_bitrate_ratio: ").concat(this._saveEncodeBitrateRatio, "]"));
            } else sD.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e3, ", h: ").concat(t3, ", fps: ").concat(i2, "] => [brMax: ").concat(o2, ", brMin: ").concat(s2, "]")), this._saveEncodeBitrateRatio = 1;
          }
        }
        getVideoElementVisibleStatus() {
          try {
            var e3, t3;
            const i2 = null == this || null === (e3 = this._player) || void 0 === e3 ? void 0 : e3.getContainerElement(), n3 = { track: this, element: null == this || null === (t3 = this._player) || void 0 === t3 ? void 0 : t3.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n3;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e4 = Bw2.checkOneElementVisible(r2), t4 = Object.assign({}, e4);
              if (t4.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t4.visible;
                const e5 = _D.reportApiInvoke(null, { tag: qw2.TRACER, name: zw2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t4.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t4.reason));
              }
              return t4;
            }
            return;
          } catch (e4) {
            throw new Ow2(ww2.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
          }
        }
        async renewMediaStreamTrack(e3) {
        }
        pipe(e3) {
          if (this.processor === e3) return e3;
          if (e3._source) throw new Ow2(ww2.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
        }
        unpipe() {
          if (!this.processor) return;
          const e3 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e3.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        clone(t3) {
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n3 = this._encoderConfig;
          t3 && (n3 = dP(dP({}, n3), ND(t3))), n3 = _O(n3);
          const r2 = IO(8, "track-video-cloned-"), o2 = new e2(i2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, n3, _O(this._scalabilityMode), this._optimizationMode, r2, _O(this._hints));
          return t3 && n3 && o2.setEncoderConfiguration(n3), sD.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i2)), o2;
        }
        async replaceTrack(e3, t3) {
          if (!(e3 instanceof MediaStreamTrack)) throw new Ow2(ww2.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
          if ("video" !== e3.kind) throw new Ow2(ww2.INVALID_PARAMS, "track should be a video MediaStreamTrack");
          await this._updateOriginMediaStreamTrack(e3, t3, true), this.updateMediaStreamTrackResolution();
        }
        sendSeiData(e3) {
          if (mO(() => {
            _D.reportApiInvoke(null, { name: zw2.LOCAL_VIDEO_SEND_SEI_DATA, options: [], tag: qw2.TRACER }).onSuccess("");
          }, this._mediaStreamTrack.id || this.getTrackId()), !wN("ENABLE_VIDEO_SEI") || !wN("ENABLE_ENCODED_TRANSFORM")) return void sD.warning('To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient');
          if (e3 instanceof Uint8Array == 0) return new Ow2(ww2.INVALID_PARAMS, "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.").throw();
          const t3 = this.getRTCRtpTransceiver();
          if (!t3) return void sD.warning("Video track is not published, SEI can not be send");
          const i2 = t3.sender.getParameters();
          if (0 === i2.codecs.length) return;
          const n3 = i2.codecs[0].mimeType.toLocaleLowerCase();
          "video/h264" === n3 || "video/h265" === n3 ? this.safeEmit("sei-to-send", e3) : sD.warning("SEI is not supported by ".concat(n3));
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(QD.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(), await sO(this, VD.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await sO(this, VD.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(QD.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners($D.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners($D.REQUEST_CONSTRAINTS);
        }
      }, sP(yk2.prototype, "play", [JL, ZL], Object.getOwnPropertyDescriptor(yk2.prototype, "play"), yk2.prototype), sP(yk2.prototype, "stop", [QL], Object.getOwnPropertyDescriptor(yk2.prototype, "stop"), yk2.prototype), sP(yk2.prototype, "setEnabled", [$L, ek2, tk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setEnabled"), yk2.prototype), sP(yk2.prototype, "setMuted", [ik2, nk2, rk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setMuted"), yk2.prototype), sP(yk2.prototype, "setSaveEncodeBitrateRatio", [ok2, sk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setSaveEncodeBitrateRatio"), yk2.prototype), sP(yk2.prototype, "setEncoderConfiguration", [ak2, ck2], Object.getOwnPropertyDescriptor(yk2.prototype, "setEncoderConfiguration"), yk2.prototype), sP(yk2.prototype, "getStats", [dk2], Object.getOwnPropertyDescriptor(yk2.prototype, "getStats"), yk2.prototype), sP(yk2.prototype, "setBeautyEffect", [lk2, uk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setBeautyEffect"), yk2.prototype), sP(yk2.prototype, "getCurrentFrameData", [hk2], Object.getOwnPropertyDescriptor(yk2.prototype, "getCurrentFrameData"), yk2.prototype), sP(yk2.prototype, "getCurrentFrameImage", [pk2], Object.getOwnPropertyDescriptor(yk2.prototype, "getCurrentFrameImage"), yk2.prototype), sP(yk2.prototype, "findClosestProfile", [_k, Ek2], Object.getOwnPropertyDescriptor(yk2.prototype, "findClosestProfile"), yk2.prototype), sP(yk2.prototype, "setBitrateLimit", [mk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setBitrateLimit"), yk2.prototype), sP(yk2.prototype, "setOptimizationMode", [fk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setOptimizationMode"), yk2.prototype), sP(yk2.prototype, "setScalabiltyMode", [Sk2], Object.getOwnPropertyDescriptor(yk2.prototype, "setScalabiltyMode"), yk2.prototype), sP(yk2.prototype, "updateMediaStreamTrackResolution", [gk2], Object.getOwnPropertyDescriptor(yk2.prototype, "updateMediaStreamTrackResolution"), yk2.prototype), sP(yk2.prototype, "pipe", [Tk2], Object.getOwnPropertyDescriptor(yk2.prototype, "pipe"), yk2.prototype), sP(yk2.prototype, "unpipe", [Rk2], Object.getOwnPropertyDescriptor(yk2.prototype, "unpipe"), yk2.prototype), sP(yk2.prototype, "close", [vk2], Object.getOwnPropertyDescriptor(yk2.prototype, "close"), yk2.prototype), sP(yk2.prototype, "replaceTrack", [Ck2], Object.getOwnPropertyDescriptor(yk2.prototype, "replaceTrack"), yk2.prototype), yk2), Mk2 = (Ik2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), bk2 = FP(), Ak2 = FO("CameraVideoTrack", "_enabledMutex"), wk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), Ok2 = FP(), Nk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), Dk2 = FP(), Pk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), Lk2 = class e2 extends kk2 {
        get __className__() {
          return "CameraVideoTrack";
        }
        constructor(e3, t3, i2, n3, r2, o2) {
          super(e3, ND(t3.encoderConfig), n3, r2, o2), aP(this, "_config", void 0), aP(this, "_originalConstraints", void 0), aP(this, "_constraints", void 0), aP(this, "_enabled", true), aP(this, "_deviceName", "default"), aP(this, "tryResumeVideoForIOS15_16WeChat", async () => {
            (Ew2() || mw2()) && !function() {
              const e4 = zA2();
              if (e4.os !== GA2.IOS || !e4.osVersion) return false;
              const t4 = e4.osVersion.split(".");
              return 15 === Number(t4[0]) && Number(t4[1]) >= 2;
            }() && gw2() && this._enabled && !this._isClosed && (sD.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          }), this._config = t3, this._originalConstraints = i2, this._constraints = i2, this._deviceName = e3.label, this._encoderConfig = ND(this._config.encoderConfig), _P.on(vD.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _P.on(vD.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e3) {
          return "string" == typeof e3 ? this._setDeviceById(e3) : e3.deviceId ? this._setDeviceById(e3.deviceId) : e3.facingMode ? this._setDeviceByFacingModel(e3.facingMode) : void 0;
        }
        async _setDeviceById(e3) {
          if (sD.info("[".concat(this.getTrackId(), "] set device to ").concat(e3)), this._enabled) try {
            const t3 = await PP.getDeviceById(e3), i2 = {};
            i2.video = dP({}, this._constraints), i2.video.deviceId = { exact: e3 }, i2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
            let n3 = null;
            try {
              n3 = await wP(i2, this.getTrackId());
            } catch (e4) {
              throw sD.error("[".concat(this.getTrackId(), "] setDevice failed"), e4.toString()), n3 = await wP({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n3.getVideoTracks()[0], false), e4;
            }
            await this._updateOriginMediaStreamTrack(n3.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t3.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
          } catch (e4) {
            throw sD.error("[".concat(this.getTrackId(), "] setDevice error"), e4.toString()), e4;
          }
          else try {
            const t3 = await PP.getDeviceById(e3);
            this._deviceName = t3.label, this._config.cameraId = e3, this._constraints.deviceId = { exact: e3 };
          } catch (e4) {
            throw sD.error("[".concat(this.getTrackId(), "] setDevice error"), e4.toString()), e4;
          }
          sD.info("[".concat(this.getTrackId(), "] setDevice success"));
        }
        async _setDeviceByFacingModel(e3) {
          sD.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e3));
          const t3 = { video: dP(dP({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e3 } }) };
          if (this._enabled) {
            this._originMediaStreamTrack.stop();
            let e4 = null;
            try {
              e4 = await wP(t3, this.getTrackId());
            } catch (t4) {
              throw sD.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), t4.toString()), e4 = await wP({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), t4;
            }
            await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
          }
          this._deviceName = "", this._config.facingMode = e3, this._config.cameraId = void 0, this._constraints = dP({}, t3.video), sD.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
        }
        async setEnabled(e3, t3) {
          if (!t3) {
            if (e3 === this._enabled) return;
            this.stateCheck("enabled", e3);
          }
          if (sD.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), e3) {
            try {
              if (this.isExternalTrack) this._originMediaStreamTrack.enabled = true;
              else {
                const e4 = await wP({ video: this._constraints }, this.getTrackId());
                await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], false);
              }
              await sO(this, VD.NEED_ENABLE_TRACK, this);
            } catch (e4) {
              throw sD.error("[".concat(this.getTrackId(), "] setEnabled true error"), e4.toString()), e4;
            }
            this.updateMediaStreamTrackResolution(), sD.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t3 || (this._enabled = true);
          } else {
            this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t3 || (this._enabled = false);
            try {
              await sO(this, VD.NEED_DISABLE_TRACK, this);
            } catch (e4) {
              throw sD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
            }
            sD.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
          }
        }
        async setEncoderConfiguration(e3, t3) {
          if (!this._enabled) throw new Ow2(ww2.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
          e3 = ND(e3), wN("USE_STANDARD_BITRATE_DEFAULT") && (delete e3.bitrateMax, delete e3.bitrateMin), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate || e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate || e3.bitrateMin);
          const i2 = pO(this._config);
          i2.encoderConfig = e3;
          const n3 = zP(i2);
          ($A2() || nw2() || Sw2()) && (n3.deviceId = void 0), sD.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(n3));
          try {
            await this._originMediaStreamTrack.applyConstraints(n3), this.updateMediaStreamTrackResolution();
          } catch (e4) {
            const t4 = new Ow2(ww2.UNEXPECTED_ERROR, e4.toString());
            throw sD.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
          }
          this._config = i2, this._constraints = n3, this._originalConstraints = n3, this._encoderConfig = e3, -1 === this._hints.indexOf(xD.SCREEN_TRACK) && this.updateBitrateFromProfile();
          try {
            await sO(this, VD.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw(sD);
          }
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((nw2() || Sw2()) && this._enabled && !this._isClosed && _P.duringInterruption) {
            const e3 = async () => {
              _P.off(vD.IOS_INTERRUPTION_END, e3), this._enabled && !this._isClosed && (sD.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
            };
            _P.on(vD.IOS_INTERRUPTION_END, e3);
          } else sD.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(WD.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e3) {
          const t3 = e3 || this._constraints, i2 = PP.searchDeviceIdByName(this._deviceName);
          if (i2 && !t3.deviceId && (t3.deviceId = { exact: i2 }), this._enabled) {
            const e4 = await wP({ video: t3 }, this.getTrackId());
            this._constraints = t3, await this._updateOriginMediaStreamTrack(e4.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
          }
        }
        close() {
          super.close(), _P.off(vD.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), _P.off(vD.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
        }
        clone(t3) {
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n3 = this._encoderConfig;
          t3 && (n3 = dP(dP({}, n3), ND(t3))), n3 = _O(n3);
          const r2 = IO(8, "track-cam-cloned-"), o2 = new e2(i2 ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, _O(dP(dP({}, this._config), {}, { encoderConfig: n3 })), _O(this._constraints), _O(this._scalabilityMode), this._optimizationMode, r2);
          return t3 && n3 && o2.setEncoderConfiguration(n3), sD.debug("clone track from ".concat(this.getTrackId(), " to ").concat(r2, ", clone ").concat(i2)), o2;
        }
        bindProcessorContextEvents() {
          this.processorContext.on($D.REQUEST_UPDATE_CONSTRAINTS, async (e3, t3, i2) => {
            try {
              const i3 = Object.assign({}, this._originalConstraints, ...e3);
              await this.renewMediaStreamTrack(i3), t3();
            } catch (e4) {
              i2(e4);
            }
          }), this.processorContext.on($D.REQUEST_CONSTRAINTS, async (e3) => {
            e3(this._originMediaStreamTrack.getSettings());
          });
        }
      }, sP(Lk2.prototype, "setDevice", [Ik2, bk2], Object.getOwnPropertyDescriptor(Lk2.prototype, "setDevice"), Lk2.prototype), sP(Lk2.prototype, "setEnabled", [Ak2, wk2, Ok2], Object.getOwnPropertyDescriptor(Lk2.prototype, "setEnabled"), Lk2.prototype), sP(Lk2.prototype, "setEncoderConfiguration", [Nk2, Dk2], Object.getOwnPropertyDescriptor(Lk2.prototype, "setEncoderConfiguration"), Lk2.prototype), sP(Lk2.prototype, "close", [Pk2], Object.getOwnPropertyDescriptor(Lk2.prototype, "close"), Lk2.prototype), Lk2);
      function Uk2(e2, t3, i2, n3) {
        i2.optimizationMode && (n3 && n3.width && n3.height ? (i2.encoderConfig = dP(dP({}, n3), {}, { bitrateMin: n3.bitrateMin, bitrateMax: n3.bitrateMax }), "motion" !== i2.optimizationMode && "detail" !== i2.optimizationMode || (t3.contentHint = i2.optimizationMode, t3.contentHint === i2.optimizationMode ? sD.debug("[".concat(e2, "] set content hint to"), i2.optimizationMode) : sD.debug("[".concat(e2, "] set content hint failed")))) : sD.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
      }
      var Vk2, xk2, Fk2, Bk2, jk2, Gk2, Wk2, Hk2, Kk2, Yk2, zk2, qk2;
      class Xk2 extends lP {
        getUserId() {
          return this._userId;
        }
        constructor(e2, t3, i2, n3) {
          super(e2, "track-".concat(e2.kind, "-").concat(t3, "-").concat(n3.clientId, "_").concat(IO(5, ""))), aP(this, "_userId", void 0), aP(this, "_uintId", void 0), aP(this, "_isDestroyed", false), aP(this, "store", void 0), aP(this, "processor", void 0), aP(this, "processorContext", void 0), this._userId = t3, this._uintId = i2, this.store = n3;
        }
        _updateOriginMediaStreamTrack(e2) {
          this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
        }
        _destroy() {
          this._isDestroyed = true, sD.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
        getProcessorUsage() {
          return this.processorContext.gatherUsage();
        }
      }
      let Jk2 = (Vk2 = pD2({ argsMap: (e2, t3, i2) => [e2.getTrackId(), "string" == typeof t3 ? t3 : t3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i2] }), xk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), Fk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3.name] }), Bk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), sP((jk2 = class extends Xk2 {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== iP.PLAYING);
        }
        get __className__() {
          return "RemoteVideoTrack";
        }
        constructor(e2, t3, i2, n3, r2) {
          super(e2, t3, i2, n3), aP(this, "_videoVisibleTimer", null), aP(this, "_previousVideoVisibleStatus", void 0), aP(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), aP(this, "trackMediaType", KD.VIDEO), aP(this, "_videoWidth", void 0), aP(this, "_videoHeight", void 0), aP(this, "_player", void 0), aP(this, "_prePlayer", void 0), aP(this, "processorDestination", void 0), aP(this, "processorContext", void 0), this._prePlayer = r2, this.updateMediaStreamTrackResolution(), this.processorContext = new jP(this.getTrackId(), "remote"), this.processorDestination = new BP(this.processorContext), this.bindProcessorDestinationEvents();
        }
        getStats() {
          return mO(() => {
            sD.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }, "remoteVideoTrackGetStatsWarning"), aO(this, VD.GET_STATS) || dP({}, ZD);
        }
        play(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (this.safeEmit(HD.PLAY_START), "string" == typeof e2) {
            const t4 = document.getElementById(e2);
            t4 ? e2 = t4 : (sD.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
          }
          sD.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t3));
          const i2 = dP(dP({ fit: "cover" }, t3), {}, { trackId: this.getTrackId(), element: e2 });
          if (this._player) this._player.updateConfig(i2);
          else {
            let t4 = false, n3 = false;
            e2 instanceof HTMLVideoElement ? (this._player = new zL(i2), this._prePlayer && (this._prePlayer.destroy(), this._prePlayer = void 0, n3 = true)) : this._prePlayer && !this._prePlayer.isDestroyed ? (this._player = this._prePlayer, this._prePlayer = void 0, t4 = this._player.videoState > 0, this._player.updateConfig(i2)) : this._player = new XL(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
              this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(HD.FIRST_FRAME_DECODED), n3 && this.safeEmit(HD.FIRST_FRAME_RENDER);
            }, this._player.onVideoStateChanged = (e3) => {
              this.safeEmit(HD.VIDEO_STATE_CHANGED, e3);
            }, t4 && (this._player.onFirstVideoFrameDecoded(), this._player.onVideoStateChanged(this._player.videoState));
          }
          this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.safeEmit(HD.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }, wN("CHECK_VIDEO_VISIBLE_INTERVAL")), this.safeEmit(HD.PLAY_END);
        }
        stop() {
          this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, sD.debug("[".concat(this.getTrackId(), "] stop video playback")));
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          YP(this._originMediaStreamTrack).then((e2) => {
            let [t3, i2] = e2;
            this._videoHeight = i2, this._videoWidth = t3;
          }).catch(AO);
        }
        _updatePlayerSource() {
          sD.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t3;
            const i2 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n3 = { track: this, element: null == this || null === (t3 = this._player) || void 0 === t3 ? void 0 : t3.getVideoElement(), slot: null == i2 ? void 0 : i2.parentElement }, { element: r2, slot: o2 } = n3;
            if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e3 = Bw2.checkOneElementVisible(r2), t4 = Object.assign({}, e3);
              if (t4.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t4.visible;
                const e4 = _D.reportApiInvoke(null, { tag: qw2.TRACER, name: zw2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t4.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t4.reason));
              }
              return t4;
            }
            return;
          } catch (e3) {
            throw new Ow2(ww2.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
        pipe(e2) {
          if (this.processor === e2) return e2;
          if (e2._source) throw new Ow2(ww2.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
        }
        unpipe() {
          if (!this.processor) return;
          const e2 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(QD.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(QD.ON_TRACK);
        }
        _destroy() {
          this._prePlayer && (this._prePlayer.destroy(), this._prePlayer = void 0), super._destroy(), this.unbindProcessorDestinationEvents();
        }
        _onSei(e2) {
          this.emit(GD.SEI_RECEIVED, e2);
        }
      }).prototype, "play", [Vk2], Object.getOwnPropertyDescriptor(jk2.prototype, "play"), jk2.prototype), sP(jk2.prototype, "stop", [xk2], Object.getOwnPropertyDescriptor(jk2.prototype, "stop"), jk2.prototype), sP(jk2.prototype, "pipe", [Fk2], Object.getOwnPropertyDescriptor(jk2.prototype, "pipe"), jk2.prototype), sP(jk2.prototype, "unpipe", [Bk2], Object.getOwnPropertyDescriptor(jk2.prototype, "unpipe"), jk2.prototype), jk2), Zk2 = (Gk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3], throttleTime: 300 }), Wk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3] }), Hk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), Kk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), Yk2 = pD2({ argsMap: (e2, t3) => [e2.getTrackId(), t3.name] }), zk2 = pD2({ argsMap: (e2) => [e2.getTrackId()] }), sP((qk2 = class extends Xk2 {
        get isPlaying() {
          return this._useAudioElement ? xP.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        get __className__() {
          return "RemoteAudioTrack";
        }
        constructor(e2, t3, i2, n3) {
          super(e2, t3, i2, n3), aP(this, "trackMediaType", KD.AUDIO), aP(this, "_source", void 0), aP(this, "_useAudioElement", true), aP(this, "_volume", 100), aP(this, "processorContext", void 0), aP(this, "processorDestination", void 0), aP(this, "_played", false), aP(this, "_bypassWebAudio", false), wN("DISABLE_WEBAUDIO") ? (this._source = new HP(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new RP(e2, true), wN("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(YD.RECEIVE_TRACK_BUFFER, () => {
            this.safeEmit(HD.FIRST_FRAME_DECODED);
          }), this.processorContext = new WP(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new GP(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(YD.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setAudioFrameCallback(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
          if (!e2) return this._source.removeAllListeners(YD.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t3), this._source.removeAllListeners(YD.ON_AUDIO_BUFFER), this._source.on(YD.ON_AUDIO_BUFFER, (t4) => e2(t4));
        }
        setVolume(e2) {
          this._volume = e2, this._useAudioElement ? xP.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
        }
        async setPlaybackDevice(e2) {
          if (!this._useAudioElement || !SD()) throw new Ow2(ww2.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          await xP.setSinkID(this.getTrackId(), e2);
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getStats() {
          return mO(() => {
            sD.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }, "remoteAudioTrackGetStatsWarning"), aO(this, VD.GET_STATS) || dP({}, XD);
        }
        play() {
          sD.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (sD.debug("[".concat(this.getTrackId(), "] use audio element to play")), xP.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
        }
        stop() {
          sD.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? xP.stop(this.getTrackId()) : this._source.stop();
        }
        _destroy() {
          super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          sD.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && xP.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        pipe(e2) {
          if (this._bypassWebAudio) throw new Ow2(ww2.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
          if (this.processor === e2) return e2;
          if (e2._source) throw new Ow2(ww2.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (this._bypassWebAudio) throw new Ow2(ww2.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
          if (!this.processor) return;
          const t3 = this.processor;
          null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t3.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(QD.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
          }), this.processorDestination.on(QD.ON_NODE, (e2) => {
            this._source.processedNode = e2;
            const t3 = !e2;
            this._useAudioElement !== t3 && (this._played ? (this.stop(), this._useAudioElement = t3, this.play()) : this._useAudioElement = t3);
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(QD.ON_TRACK), this.processorDestination.removeAllListeners(QD.ON_NODE);
        }
      }).prototype, "setVolume", [Gk2], Object.getOwnPropertyDescriptor(qk2.prototype, "setVolume"), qk2.prototype), sP(qk2.prototype, "setPlaybackDevice", [Wk2], Object.getOwnPropertyDescriptor(qk2.prototype, "setPlaybackDevice"), qk2.prototype), sP(qk2.prototype, "play", [Hk2], Object.getOwnPropertyDescriptor(qk2.prototype, "play"), qk2.prototype), sP(qk2.prototype, "stop", [Kk2], Object.getOwnPropertyDescriptor(qk2.prototype, "stop"), qk2.prototype), sP(qk2.prototype, "pipe", [Yk2], Object.getOwnPropertyDescriptor(qk2.prototype, "pipe"), qk2.prototype), sP(qk2.prototype, "unpipe", [zk2], Object.getOwnPropertyDescriptor(qk2.prototype, "unpipe"), qk2.prototype), qk2);
      const Qk2 = new class extends Hw2 {
        get visibility() {
          return document.visibilityState;
        }
        get lastHiddenTime() {
          return this._lastHiddenTime;
        }
        get lastVisibleTime() {
          return this._lastVisibleTime;
        }
        constructor() {
          super(), aP(this, "_lastHiddenTime", 0), aP(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
            "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), sD.debug("current web page is ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
          });
        }
      }();
      class $k2 extends Hw2 {
        constructor(e2, t3) {
          super(), aP(this, "trackMediaType", KD.DATA), aP(this, "_version", 1), aP(this, "_type", 3), aP(this, "_config", void 0), aP(this, "_originDataChannel", void 0), aP(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), aP(this, "_dataStreamPacketHandler", { serialize: (e3) => e3, deserialize: (e3) => e3 }), aP(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e2, t3 && (this._originDataChannel = t3, this._bandDataChannelEvents(t3)), this._initPacketHeader();
        }
        useDataStream(e2) {
          this._dataStreamPacketHandler = e2;
        }
        get id() {
          return this._config.id;
        }
        get ordered() {
          return this._config.ordered;
        }
        get maxRetransmits() {
          return wN("DATASTREAM_MAX_RETRANSMITS");
        }
        get metadata() {
          return this._config.metadata;
        }
        get readyState() {
          var e2, t3;
          return null !== (e2 = null === (t3 = this._originDataChannel) || void 0 === t3 ? void 0 : t3.readyState) && void 0 !== e2 ? e2 : "connecting";
        }
        get _originDataChannelId() {
          var e2, t3;
          return null !== (e2 = null === (t3 = this._originDataChannel) || void 0 === t3 ? void 0 : t3.id) && void 0 !== e2 ? e2 : null;
        }
        getChannelId() {
          return this.id;
        }
        getConfig() {
          return this._config;
        }
        _close() {
          this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
        }
        async _waitTillOpen() {
          return new ip2((e2, t3) => {
            if (this._originDataChannel) {
              "open" === this._originDataChannel.readyState && e2();
              const i2 = setTimeout(() => {
                var e3;
                t3(new Ow2(ww2.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat(null === (e3 = this._originDataChannel) || void 0 === e3 ? void 0 : e3.id)));
              }, 1e4);
              this._originDataChannel.onopen = () => {
                clearTimeout(i2), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e2();
              }, this._originDataChannel.onerror = () => {
                throw clearTimeout(i2), new Ow2(ww2.DATACHANNEL_CONNECTION_TIMEOUT);
              };
            } else t3(new Ow2(ww2.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
          });
        }
        _updateOriginDataChannel(e2) {
          this._originDataChannel = e2, this._bandDataChannelEvents(e2);
        }
        _initPacketHeader() {
          const e2 = new DataView(this._dataStreamPacketHeader);
          e2.setUint16(0, this._version), e2.setUint8(2, this._type), e2.setUint8(3, this._config.id);
        }
        _bandDataChannelEvents(e2) {
          this._unbindDataChannelEvents(e2), [oP.OPEN, oP.CLOSE, oP.ERROR].forEach((t3) => {
            const i2 = () => {
              this.emit(t3);
            };
            this._datachannelEventMap.set(t3, i2), e2.addEventListener(t3, i2);
          });
        }
        _unbindDataChannelEvents(e2) {
          Array.from(this._datachannelEventMap.entries()).forEach((t3) => {
            let [i2, n3] = t3;
            e2.removeEventListener(i2, n3);
          }), this._datachannelEventMap.clear();
        }
      }
      class eM extends $k2 {
        constructor(e2) {
          super(e2), aP(this, "_messageListener", void 0), this._messageListener = (e3) => {
            if (e3.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
            const t3 = e3.data.slice(0, this._dataStreamPacketHeader.byteLength), i2 = new DataView(t3).getUint8(3);
            if (i2 !== this.id) return void (wN("SHOW_DATASTREAM2_LOG") && sD.debug("invalid datachannel id: ".concat(i2, " !== ").concat(this.id)));
            let n3 = e3.data.slice(this._dataStreamPacketHeader.byteLength);
            n3 = this._dataStreamPacketHandler.deserialize(n3), this.emit(oP.MESSAGE, n3);
          };
        }
        _updateOriginDataChannel(e2) {
          super._updateOriginDataChannel(e2), this._bandRemoteDataChannelEvents();
        }
        _close() {
          this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
        }
        _bandRemoteDataChannelEvents() {
          this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
        }
      }
      class tM extends $k2 {
        send(e2) {
          if (this._originDataChannel) {
            let t3 = e2;
            t3 = this._dataStreamPacketHandler.serialize(e2);
            const i2 = new Uint8Array(this._dataStreamPacketHeader.byteLength + t3.byteLength);
            i2.set(new Uint8Array(this._dataStreamPacketHeader), 0), i2.set(new Uint8Array(t3), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i2.buffer);
          }
        }
      }
      function iM() {
        const e2 = new Blob([atob("Y29uc3QgdD0idmlkZW8vaDI2NCIsZT0idmlkZW8vaDI2NSI7ZnVuY3Rpb24gbih0LGUsbil7bGV0IGE9bmV3IFVpbnQ4QXJyYXkodCxlLG4pLHI9W10sbz0wO2Zvcig7ci5sZW5ndGg8bjspbyszPG4mJjA9PT1hW29dJiYwPT09YVtvKzFdJiYzPT09YVtvKzJdJiYoMD09PWFbbyszXXx8MT09PWFbbyszXXx8Mj09PWFbbyszXXx8Mz09PWFbbyszXSk/KHIucHVzaChhW29dLGFbbysxXSxhW28rM10pLG8rPTQpOihyLnB1c2goYVtvXSksbysrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocil9ZnVuY3Rpb24gYShhLHIpe3N3aXRjaChyKXtjYXNlIHQ6cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IERhdGFWaWV3KHQuZGF0YSk7bGV0IGE9MDtmb3IoO2ErNDx0LmRhdGEuYnl0ZUxlbmd0aDspe2lmKDA9PT1lLmdldFVpbnQ4KGErMCkmJjA9PT1lLmdldFVpbnQ4KGErMSkmJjA9PT1lLmdldFVpbnQ4KGErMikmJjE9PT1lLmdldFVpbnQ4KGErMykmJjY9PT1lLmdldFVpbnQ4KGErNCkpe2xldCByPWErNixvPTAsaT0wO2Zvcig7MjU1PT09KGk9ZS5nZXRVaW50OChyKyspKTspbys9MjU1O28rPWk7Y29uc3Qgcz1uKHQuZGF0YSxyLG8pO3JldHVybiBuZXcgVWludDhBcnJheShzKX1hKyt9cmV0dXJuIG51bGx9KGEpO2Nhc2UgZTpyZXR1cm4gZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgRGF0YVZpZXcodC5kYXRhKTtsZXQgYT0wO2Zvcig7YSs1PHQuZGF0YS5ieXRlTGVuZ3RoOyl7aWYoMD09PWUuZ2V0VWludDgoYSswKSYmMD09PWUuZ2V0VWludDgoYSsxKSYmMD09PWUuZ2V0VWludDgoYSsyKSYmMT09PWUuZ2V0VWludDgoYSszKSYmNzg9PT1lLmdldFVpbnQ4KGErNCkmJjE9PT1lLmdldFVpbnQ4KGErNSkmJjEwMT09PWUuZ2V0VWludDgoYSs2KSl7bGV0IHI9YSs3LG89MCxpPTA7Zm9yKDsyNTU9PT0oaT1lLmdldFVpbnQ4KHIrKykpOylvKz0yNTU7bys9aTtjb25zdCBzPW4odC5kYXRhLHIsbyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHMpfWErK31yZXR1cm4gbnVsbH0oYSk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gcih0KXtjb25zdCBlPXQubGVuZ3RoO2xldCBuPVtdLGE9MDtmb3IoO2E8ZTspYSsyPGUmJjA9PT10W2FdJiYwPT09dFthKzFdJiYoMD09PXRbYSsyXXx8MT09PXRbYSsyXXx8Mj09PXRbYSsyXXx8Mz09PXRbYSsyXSk/KG4ucHVzaCh0W2FdLHRbYSsxXSwzLHRbYSsyXSksYSs9Myk6KG4ucHVzaCh0W2FdKSxhKyspO3JldHVybiBuZXcgVWludDhBcnJheShuKX1mdW5jdGlvbiBvKG4sYSxvKXtzd2l0Y2gobyl7Y2FzZSB0OnJldHVybiBmdW5jdGlvbih0LGUpe2NvbnN0IG49cihlKSxhPW4ubGVuZ3RoLG89TWF0aC5mbG9vcihhLzI1NSksaT1hJTI1NSxzPW5ldyBVaW50OEFycmF5KDYrbysxK2ErdC5ieXRlTGVuZ3RoKTtzWzBdPTAsc1sxXT0wLHNbMl09MCxzWzNdPTEsc1s0XT02LHNbNV09MTAxO2xldCBmPTA7Zm9yKDtmPG87KXNbNitmXT0yNTUsZisrO3JldHVybiBzWzYrZl09aSxmKysscy5zZXQobiw2K2YpLHMuc2V0KG5ldyBVaW50OEFycmF5KHQpLDYrZithKSxzLmJ1ZmZlcn0obixhKTtjYXNlIGU6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1yKGUpLGE9bi5sZW5ndGgsbz1NYXRoLmZsb29yKGEvMjU1KSxpPWElMjU1LHM9bmV3IFVpbnQ4QXJyYXkoNytvKzErYSsxK3QuYnl0ZUxlbmd0aCk7c1swXT0wLHNbMV09MCxzWzJdPTAsc1szXT0xLHNbNF09Nzgsc1s1XT0xLHNbNl09MTAxO2xldCBmPTA7Zm9yKDtmPG87KXNbNytmXT0yNTUsZisrO3JldHVybiBzWzcrZl09aSxmKysscy5zZXQobiw3K2YpLGYrPWEsc1s3K2ZdPTEyOCxmKysscy5zZXQobmV3IFVpbnQ4QXJyYXkodCksNytmKSxzLmJ1ZmZlcn0obixhKTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBpKG4pe2lmKG4ubGVuZ3RoPDUpcmV0dXJuIiI7bGV0IGE9LTE7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aC0zO3QrKyl7aWYoMD09PW5bdF0mJjA9PT1uW3QrMV0mJjE9PT1uW3QrMl0pe2E9dDticmVha31pZih0PG4ubGVuZ3RoLTQmJjA9PT1uW3RdJiYwPT09blt0KzFdJiYwPT09blt0KzJdJiYxPT09blt0KzNdKXthPXQ7YnJlYWt9fWlmKC0xPT09YSlyZXR1cm4iIjtjb25zdCByPWErKDA9PT1uW2ErMl0/NDozKTtpZihyPj1uLmxlbmd0aClyZXR1cm4iIjtjb25zdCBvPW5bcl07aWYoMTI4Jm8pcmV0dXJuIiI7aWYoKG8+PjEmNjMpPj0zMilyZXR1cm4gZTtpZihyKzE8bi5sZW5ndGgpe2lmKDA9PSgyNDgmbltyKzFdKSlyZXR1cm4gZX1yZXR1cm4oMzEmbyk8PTMxP3Q6IiJ9Y29uc3Qgcz03MSxmPTEsbD0yLHU9MSxnPTI7dmFyIGM7ZnVuY3Rpb24gZCh0LGU9ITEpe2NvbnN0IG49dC5nZXRVaW50OCgwKTtpZihuIT09cylyZXR1cm47Y29uc3QgYT10LmdldFVpbnQxNigxKSxyPWYrbCthLG89bmV3IFVpbnQ4QXJyYXkodC5ieXRlTGVuZ3RoLXIpO28uc2V0KG5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHIsdC5ieXRlTGVuZ3RoLXIpKTtjb25zdCBpPXttOm4sdGx2TGVuOmEsdGx2OltdLGZyYW1lOm99O2xldCBkPWYrbDtmb3IoO2Q8cjspe2NvbnN0IG49dC5nZXRVaW50OChkKSxhPXQuZ2V0VWludDE2KGQrdSkscj11K2c7aWYobj09PWMuQVVESU9fTEVWRUwpe2xldCBvPXQuZ2V0VWludDgoZCtyKTtmb3IobGV0IGU9MTtlPGE7ZSsrKW89bzw8OHx0LmdldFVpbnQ4KGQrcitlKTtpLnRsdi5wdXNoKHt0YWc6bixsZW5ndGg6YSx2YWx1ZTplPzEyN15vPj4xOjEyNyZvfSl9ZWxzZSBpZihuPT09Yy5NRVRBREFUQXx8bj09PWMuQVVESU9fNjRfQklUX1BUUyl7Y29uc3QgZT1uZXcgVWludDhBcnJheShhKTtmb3IobGV0IG49MDtuPGE7bisrKWVbbl09dC5nZXRVaW50OChkK3Irbik7aS50bHYucHVzaCh7dGFnOm4sbGVuZ3RoOmEsdmFsdWU6ZX0pfWQrPXIrYX1yZXR1cm4gaX0hZnVuY3Rpb24odCl7dFt0LkFVRElPX0xFVkVMPTFdPSJBVURJT19MRVZFTCIsdFt0Lk1FVEFEQVRBPTJdPSJNRVRBREFUQSIsdFt0LkFVRElPXzY0X0JJVF9QVFM9M109IkFVRElPXzY0X0JJVF9QVFMifShjfHwoYz17fSkpLHNlbGYub25ydGN0cmFuc2Zvcm09dD0+e2NvbnN0IGU9dC50cmFuc2Zvcm1lcjtsZXQgbj1bXSxyPVtdO2Uub3B0aW9ucy5wb3J0Lm9ubWVzc2FnZT10PT57dC5kYXRhLnNlaSYmbi5wdXNoKHQuZGF0YS5zZWkpLHQuZGF0YS5tZXRhZGF0YSYmci5wdXNoKHQuZGF0YS5tZXRhZGF0YSl9LHNlbGYucG9zdE1lc3NhZ2UoInN0YXJ0ZWQiKTtjb25zdCBoPWUucmVhZGFibGUuZ2V0UmVhZGVyKCksVT1lLndyaXRhYmxlLmdldFdyaXRlcigpOyJzZWktcngiPT09ZS5vcHRpb25zLm5hbWU/ZnVuY3Rpb24gdChlKXtoLnJlYWQoKS50aGVuKChuPT57aWYoIW4uZG9uZSl7aWYobi52YWx1ZSBpbnN0YW5jZW9mIFJUQ0VuY29kZWRWaWRlb0ZyYW1lKXtjb25zdCB0PWkobmV3IFVpbnQ4QXJyYXkobi52YWx1ZS5kYXRhKSkscj1hKG4udmFsdWUsdCk7ciYmZS5vcHRpb25zLnBvcnQucG9zdE1lc3NhZ2Uoe3NlaTpyfSl9VS53cml0ZShuLnZhbHVlKSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSx0KGUpfX0pKX0oZSk6InNlaS10eCI9PT1lLm9wdGlvbnMubmFtZT9mdW5jdGlvbiB0KGUpe2gucmVhZCgpLnRoZW4oKGE9PntpZighYS5kb25lKXtpZihhLnZhbHVlIGluc3RhbmNlb2YgUlRDRW5jb2RlZFZpZGVvRnJhbWUpe2NvbnN0IHQ9aShuZXcgVWludDhBcnJheShhLnZhbHVlLmRhdGEpKSxlPW4uc2hpZnQoKTtpZihlKXtjb25zdCBuPW8oYS52YWx1ZS5kYXRhLGUsdCk7biYmKGEudmFsdWUuZGF0YT1uKX19VS53cml0ZShhLnZhbHVlKSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSx0KGUpfX0pKX0oZSk6ImF1ZGlvLW1ldGFkYXRhLXJ4Ij09PWUub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQoZSl7aC5yZWFkKCkudGhlbigobj0+e2lmKCFuLmRvbmUpe2lmKG4udmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkQXVkaW9GcmFtZSl7Y29uc3QgdD1uZXcgRGF0YVZpZXcobi52YWx1ZS5kYXRhKSxhPXQuZ2V0VWludDgoMCk7bGV0IHI7aWYoMCE9KDEyOCZhKSYmNzEhPT1hKXtsZXQgZT1mdW5jdGlvbih0KXtpZih0LmJ5dGVMZW5ndGg8PTApcmV0dXJuW107Y29uc3QgZT1bXTtsZXQgbj0wO2Zvcig7bjx0LmJ5dGVMZW5ndGg7KXtjb25zdCBhPSgxMjgmdC5nZXRVaW50OChuKSk+Pjcscj0xMjcmdC5nZXRVaW50OChuKTtpZighKGEmJm4rNDw9dC5ieXRlTGVuZ3RoKSl7bisrO2JyZWFrfXtjb25zdCBhPXQuZ2V0VWludDMyKG4sITEpLG89KDE2Nzc2MTkyJmEpPj4xMCxpPTEwMjMmYTtlLnB1c2goe3B0OnIsdHNfb2Zmc2V0Om8sbGVuZ3RoOmksZGF0YTpuZXcgVWludDhBcnJheX0pLG4rPTR9fWxldCBhPXQuYnl0ZUxlbmd0aC1uO2Zvcihjb25zdCByIG9mIGUpe2lmKHIubGVuZ3RoPmEpcmV0dXJuIGNvbnNvbGUud2FybigiQnJva2VuIHJlZCBwYXlsb2FkIiksW107ci5sZW5ndGg+MCYmKHIuZGF0YT1uZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrbixyLmxlbmd0aCksbis9ci5sZW5ndGgsYS09ci5sZW5ndGgpfWlmKGE+MCl7Y29uc3Qgcj17cHQ6ZS5sZW5ndGg+MD9lW2UubGVuZ3RoLTFdLnB0OjAsdHNfb2Zmc2V0OjAsbGVuZ3RoOmEsZGF0YTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrbixhKX07ZS5wdXNoKHIpfXJldHVybiBlfSh0KTtpZihlLmxlbmd0aD4wKXtjb25zdCB0PWZ1bmN0aW9uKHQpe2xldCBlPTA7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZSs9bjx0Lmxlbmd0aC0xPzQ6MSxlKz10W25dLmxlbmd0aDtjb25zdCBuPW5ldyBVaW50OEFycmF5KGUpO2xldCBhPTA7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoZTx0Lmxlbmd0aC0xKXtjb25zdCByPSgyMTQ3NDgzNjQ4fCgxMjcmdFtlXS5wdCk8PDI0fCgyNjIxNDMmdFtlXS50c19vZmZzZXQpPDwxMHwxMDIzJnRbZV0ubGVuZ3RoKT4+PjA7blthKytdPXI+PjI0JjI1NSxuW2ErK109cj4+MTYmMjU1LG5bYSsrXT1yPj44JjI1NSxuW2ErK109MjU1JnJ9ZWxzZSBuW2ErK109MTI3JnRbZV0ucHQ7Zm9yKGNvbnN0IGUgb2YgdCluLnNldChlLmRhdGEsYSksYSs9ZS5sZW5ndGg7cmV0dXJuIG59KGUubWFwKCh0PT57bGV0IGU9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO2Uuc2V0KHQuZGF0YSk7Y29uc3Qgbj1kKG5ldyBEYXRhVmlldyhlLmJ1ZmZlcikpO3JldHVybiBuPy5mcmFtZSYmKHQuZGF0YT1uPy5mcmFtZSkscj1uLHR9KSkpO24udmFsdWUuZGF0YT10LmJ1ZmZlcn19ZWxzZSByPWQodCksciYmKG4udmFsdWUuZGF0YT1yLmZyYW1lLmJ1ZmZlcik7aWYocil7bGV0IHQ9ci50bHYuZmluZCgodD0+dC50YWc9PT1jLk1FVEFEQVRBKSk7aWYodCYmdC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJmUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHttZXRhZGF0YTp0LnZhbHVlfSksdD1yLnRsdi5maW5kKCh0PT50LnRhZz09PWMuQVVESU9fNjRfQklUX1BUUykpLHQmJnQudmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5JiY4PT10LnZhbHVlLmxlbmd0aCl7Y29uc3Qgbj1uZXcgRGF0YVZpZXcodC52YWx1ZS5idWZmZXIpLmdldEJpZ1VpbnQ2NCgwLCEwKTt0JiZ0LnZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSYmZS5vcHRpb25zLnBvcnQucG9zdE1lc3NhZ2Uoe3B0czpufSl9fX1VLndyaXRlKG4udmFsdWUpLGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQoZSl9fSkpfShlKToiYXVkaW8tbWV0YWRhdGEtdHgiPT09ZS5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIHQoZSl7aC5yZWFkKCkudGhlbigobj0+e2lmKCFuLmRvbmUpe2lmKGUub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHtnZXRNZXRhZGF0YTohMH0pLG4udmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkQXVkaW9GcmFtZSl7Y29uc3QgdD1yLnNoaWZ0KCk7dCYmKG4udmFsdWUuZGF0YT1mdW5jdGlvbih0LGUsbil7Y29uc3QgYT1uLmJ5dGVMZW5ndGgscj1hK3UrZyxvPWYrbCtyLGk9bmV3IEFycmF5QnVmZmVyKHQuYnl0ZUxlbmd0aCtvKSxjPW5ldyBEYXRhVmlldyhpKTtjLnNldFVpbnQ4KDAscyksYy5zZXRVaW50MTYoMSxyKSxjLnNldFVpbnQ4KDMsZSksYy5zZXRVaW50MTYoNCxhKTtmb3IobGV0IHQ9MDt0PGE7dCsrKWMuc2V0VWludDgoNit0LG5bdF0pO2NvbnN0IGQ9bmV3IFVpbnQ4QXJyYXkoYy5idWZmZXIpO3JldHVybiBkLnNldChuZXcgVWludDhBcnJheSh0KSxvKSxkLmJ1ZmZlcn0obi52YWx1ZS5kYXRhLGMuQVVESU9fNjRfQklUX1BUUyx0KSl9VS53cml0ZShuLnZhbHVlKSxlLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSx0KGUpfX0pKX0oZSl9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKTsK")], { type: "text/javascript" });
        return setTimeout(() => RS.revokeObjectURL(e2), 0), new Worker(RS.createObjectURL(e2));
      }
      const nM = 71, rM = 1, oM = 2, sM = 1, aM = 2;
      var cM = function(e2) {
        return e2[e2.AUDIO_LEVEL = 1] = "AUDIO_LEVEL", e2[e2.METADATA = 2] = "METADATA", e2[e2.AUDIO_64_BIT_PTS = 3] = "AUDIO_64_BIT_PTS", e2;
      }(cM || {});
      function dM(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = e2.getUint8(0);
        if (i2 !== nM) return;
        const n3 = e2.getUint16(1), r2 = rM + oM + n3, o2 = new Uint8Array(e2.byteLength - r2);
        o2.set(new Uint8Array(e2.buffer, r2, e2.byteLength - r2));
        const s2 = { m: i2, tlvLen: n3, tlv: [], frame: o2 };
        let a3 = rM + oM;
        for (; a3 < r2; ) {
          const i3 = e2.getUint8(a3), n4 = e2.getUint16(a3 + sM), r3 = sM + aM;
          if (i3 === cM.AUDIO_LEVEL) {
            let o3 = e2.getUint8(a3 + r3);
            for (let t4 = 1; t4 < n4; t4++) o3 = o3 << 8 | e2.getUint8(a3 + r3 + t4);
            s2.tlv.push({ tag: i3, length: n4, value: t3 ? 127 ^ o3 >> 1 : 127 & o3 });
          } else if (i3 === cM.METADATA || i3 === cM.AUDIO_64_BIT_PTS) {
            const t4 = new Uint8Array(n4);
            for (let i4 = 0; i4 < n4; i4++) t4[i4] = e2.getUint8(a3 + r3 + i4);
            s2.tlv.push({ tag: i3, length: n4, value: t4 });
          }
          a3 += r3 + n4;
        }
        return s2;
      }
      const lM = /* @__PURE__ */ new Map();
      const uM = 127, hM = 1e-10, pM = 139 / 13, _M = /* @__PURE__ */ new Map();
      function EM(e2, t3, i2) {
        const n3 = "".concat(e2, "-").concat(t3, "-").concat(i2);
        let r2 = 0;
        if (_M.has(n3)) r2 = _M.get(n3);
        else {
          const o2 = 0.5;
          r2 = Math.log(function(e3, t4) {
            const i3 = e3 - t4;
            t4 < i3 && (t4 = i3);
            let n4 = 1;
            for (let i4 = e3, r3 = 1; i4 > t4; i4--, r3++) n4 = n4 * i4 / r3;
            return n4;
          }(t3, e2)) + e2 * Math.log(o2) + (t3 - e2) * Math.log(1 - o2) - Math.log(i2) + i2 * e2, _M.set(n3, r2);
        }
        return r2 < hM && (r2 = hM), r2;
      }
      function mM(e2, t3, i2) {
        const n3 = t3.length, r2 = e2.length / n3;
        let o2 = false;
        for (let s2 = 0, a3 = 0; s2 < n3; s2++) {
          let n4 = 0;
          for (let t4 = a3 + r2; a3 < t4; a3++) e2[a3] > i2 && n4++;
          t3[s2] !== n4 && (t3[s2] = n4, o2 = true);
        }
        return o2;
      }
      window.cache = _M;
      let fM = 0;
      class SM {
        constructor(e2) {
          aP(this, "id", void 0), aP(this, "immediates", []), aP(this, "lastNonSilence", -1), aP(this, "immediateSpeechActivityScore", hM), aP(this, "lastLevelChangedTime", Date.now()), aP(this, "levels", []), aP(this, "longs", []), aP(this, "longSpeechActivityScore", hM), aP(this, "mediums", []), aP(this, "mediumSpeechActivityScore", hM), aP(this, "minLevel", 0), aP(this, "nextMinLevel", 0), aP(this, "nextMinLevelWindowLength", 0), aP(this, "energyScore", 0), this.id = e2 || "".concat(fM++), this.immediates.length = 50, this.mediums.length = 10, this.longs.length = 1, this.levels.length = this.immediates.length;
        }
        computeImmediates() {
          const e2 = this.immediates, t3 = this.levels, i2 = this.minLevel + pM;
          let n3 = false;
          for (let r2 = 0; r2 < e2.length; ++r2) {
            let o2 = t3[r2];
            o2 < i2 && (o2 = 0);
            const s2 = Math.floor(o2 / pM);
            e2[r2] !== s2 && (e2[r2] = s2, n3 = true);
          }
          return n3;
        }
        computeLongs() {
          return mM(this.mediums, this.longs, 4);
        }
        computeMediums() {
          return mM(this.immediates, this.mediums, 7);
        }
        evaluateImmediateSpeechActivityScore() {
          this.immediateSpeechActivityScore = EM(this.immediates[0], 13, 0.78);
        }
        evaluateLongSpeechActivityScore(e2) {
          this.longSpeechActivityScore = EM(this.longs[0], 10, 47), this.longSpeechActivityScore > hM && (this.lastNonSilence = e2);
        }
        evaluateMediumSpeechActivityScore() {
          this.mediumSpeechActivityScore = EM(this.mediums[0], 5, 24);
        }
        evaluateSpeechActivityScores(e2) {
          this.computeImmediates() && (this.evaluateImmediateSpeechActivityScore(), this.computeMediums() && (this.evaluateMediumSpeechActivityScore(), this.computeLongs() && this.evaluateLongSpeechActivityScore(e2)));
        }
        getLastLevelChangedTime() {
          return this.lastLevelChangedTime;
        }
        getLevels() {
          var e2;
          return "[".concat(mr2(e2 = [...this.levels]).call(e2).join(), "]");
        }
        getSpeechActivityScore(e2) {
          switch (e2) {
            case 0:
              return this.immediateSpeechActivityScore;
            case 1:
              return this.mediumSpeechActivityScore;
            case 2:
              return this.longSpeechActivityScore;
            default:
              throw new Error("interval " + e2);
          }
        }
        levelChanged(e2, t3) {
          if (this.lastLevelChangedTime <= t3) {
            this.lastLevelChangedTime = t3;
            let i2 = e2;
            return e2 < 0 && (i2 = 0), e2 > uM && (i2 = uM), this.levels.unshift(i2), this.levels.length > this.immediates.length && this.levels.pop(), this.updateMinLevel(i2), i2 >= this.minLevel + pM ? i2 : i2 / 2;
          }
          return -1;
        }
        levelTimedOut() {
          this.levelChanged(0, this.lastLevelChangedTime);
        }
        updateMinLevel(e2) {
          if (0 !== e2) {
            if (0 === this.minLevel || this.minLevel > e2) return this.minLevel = e2, this.nextMinLevel = 0, void (this.nextMinLevelWindowLength = 0);
            if (0 === this.nextMinLevel) return this.nextMinLevel = e2, void (this.nextMinLevelWindowLength = 1);
            if (this.nextMinLevel > e2 && (this.nextMinLevel = e2), this.nextMinLevelWindowLength++, this.nextMinLevelWindowLength >= 750) {
              let e3 = Math.sqrt(this.minLevel * this.nextMinLevel);
              e3 < 0 ? e3 = 0 : e3 > uM && (e3 = uM), this.minLevel = e3, this.nextMinLevel = 0, this.nextMinLevelWindowLength = 0;
            }
          }
        }
      }
      class gM {
        constructor(e2) {
          aP(this, "algorithm", void 0), this.algorithm = e2;
        }
        execute() {
          let e2 = !this.algorithm;
          if (!e2) try {
            const t3 = this.algorithm.runInDecisionMaker(this);
            t3 <= 0 ? e2 = true : setTimeout(this.execute.bind(this), t3);
          } catch (t3) {
            e2 = true;
          }
          e2 && this.algorithm && this.algorithm.decisionMakerExited(this);
        }
      }
      class TM {
        constructor(e2, t3, i2) {
          aP(this, "isDominant", void 0), aP(this, "energyRanking", void 0), aP(this, "energyScore", void 0), this.isDominant = e2, this.energyRanking = t3, this.energyScore = i2;
        }
      }
      class RM extends Hw2 {
        constructor(e2) {
          super(), aP(this, "dominantId", null), aP(this, "lastDecisionTime", 0), aP(this, "lastLevelChangedTime", 0), aP(this, "lastLevelIdleTime", 0), aP(this, "relativeSpeechActivities", []), aP(this, "speakers", /* @__PURE__ */ new Map()), aP(this, "enableSilence", false), aP(this, "timeoutToSilenceInterval", 0), aP(this, "decisionMaker", null), aP(this, "loudest", []), aP(this, "numLoudestToTrack", 3), aP(this, "energyExpireTimeMs", 250), aP(this, "energyAlphaPct", 50), this.timeoutToSilenceInterval = e2, this.enableSilence = e2 > 0, this.relativeSpeechActivities.length = 3;
        }
        setLoudestConfig() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3, t3 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
          this.numLoudestToTrack = e2, null != t3 && (this.energyExpireTimeMs = t3), null != i2 && (this.energyAlphaPct = i2), this.loudest.length > e2 && this.loudest.splice(e2);
        }
        getDominantSpeaker() {
          return this.dominantId;
        }
        isAmongLoudest(e2) {
          return this.loudest.some((t3) => t3.id === e2);
        }
        levelChanged(e2, t3) {
          const i2 = Date.now(), n3 = this.getOrCreateSpeaker(e2);
          this.lastLevelChangedTime < i2 && (this.lastLevelChangedTime = i2, this.maybeStartDecisionMaker());
          const r2 = n3.levelChanged(t3, i2);
          return this.updateLoudestList(n3, r2, i2);
        }
        runInDecisionMaker(e2) {
          return this.decisionMaker !== e2 || this.lastDecisionTime > 0 && this.lastDecisionTime - this.lastLevelChangedTime >= 15e3 ? -1 : this._runInDecisionMaker();
        }
        decisionMakerExited(e2) {
          this.decisionMaker === e2 && (this.decisionMaker = null);
        }
        destroy() {
          this.decisionMaker = null, this.loudest.length = 0, this.speakers.clear(), this.removeAllListeners();
        }
        addSpeakers(e2) {
          e2.forEach((e3) => {
            this.speakers.has(e3.id) || this.speakers.set(e3.id, e3);
          });
        }
        removeSpeakers(e2) {
          e2.forEach((e3) => {
            this.speakers.delete(e3.id);
          });
        }
        getOrCreateSpeaker(e2) {
          let t3 = this.speakers.get(e2);
          return t3 || (t3 = new SM(e2), this.speakers.set(e2, t3), this.maybeStartDecisionMaker()), t3;
        }
        updateLoudestList(e2, t3, i2) {
          const n3 = e2.id === this.dominantId;
          if (t3 < 0) {
            let t4 = 0;
            for (; t4 < this.loudest.length && this.loudest[t4] !== e2; ) ++t4;
            return new TM(n3, t4, e2.energyScore);
          }
          if (e2.energyScore = Math.floor((this.energyAlphaPct * t3 + (100 - this.energyAlphaPct) * e2.energyScore + 50) / 100), 0 === this.numLoudestToTrack) return new TM(n3, 0, e2.energyScore);
          const r2 = i2 - this.energyExpireTimeMs;
          let o2 = 0;
          for (; o2 < this.loudest.length; ) {
            const t4 = this.loudest[o2];
            if (t4.getLastLevelChangedTime() < r2 && this.loudest.length >= this.numLoudestToTrack) this.loudest.splice(o2, 1);
            else if (t4.id !== e2.id) ++o2;
            else if (this.loudest.splice(o2, 1), this.loudest.length < this.numLoudestToTrack) break;
          }
          let s2 = 0;
          for (; s2 < this.loudest.length && !(this.loudest[s2].energyScore < e2.energyScore); ) ++s2;
          return s2 < this.numLoudestToTrack && (this.loudest.splice(s2, 0, e2), this.loudest.length > this.numLoudestToTrack && this.loudest.splice(this.numLoudestToTrack, 1)), new TM(n3, s2, e2.energyScore);
        }
        maybeStartDecisionMaker() {
          !this.decisionMaker && this.speakers.size > 0 && (this.decisionMaker = new gM(this), this.decisionMaker.execute());
        }
        makeDecision(e2) {
          let t3 = null, i2 = null;
          const n3 = this.speakers.size;
          let r2 = null;
          if (0 === n3) r2 = null;
          else if (1 === n3) {
            var o2;
            const t4 = up2(o2 = this.speakers).call(o2).next().value;
            this.enableSilence && t4 && (r2 = t4.id, t4.evaluateSpeechActivityScores(e2), e2 - t4.lastNonSilence > this.timeoutToSilenceInterval && (r2 = null));
          } else {
            let t4 = null == this.dominantId ? null : this.speakers.get(this.dominantId);
            if (null == t4) {
              const e3 = this.speakers.entries().next();
              e3.value && (r2 = e3.value[0], t4 = e3.value[1]);
            } else r2 = t4.id;
            null != t4 && t4.evaluateSpeechActivityScores(e2);
            const i3 = this.relativeSpeechActivities;
            let n4 = 2;
            for (const o3 of this.speakers.entries()) {
              const [s2, a3] = o3;
              if (a3 === t4) continue;
              a3.evaluateSpeechActivityScores(e2);
              for (let e3 = 0; e3 < i3.length; ++e3) {
                const n5 = null == t4 ? hM : t4.getSpeechActivityScore(e3);
                i3[e3] = Math.log(a3.getSpeechActivityScore(e3) / n5);
              }
              const c3 = i3[0], d2 = i3[1], l2 = i3[2];
              c3 > 3 && d2 > 2 && l2 > 0 && d2 > n4 && (n4 = d2, r2 = s2);
            }
            this.enableSilence && null != t4 && r2 === t4.id && e2 - t4.lastNonSilence > this.timeoutToSilenceInterval && (r2 = null);
          }
          null == r2 && !this.enableSilence || r2 === this.dominantId || (t3 = this.dominantId, this.dominantId = r2, i2 = this.dominantId), null == i2 && !this.enableSilence || i2 === t3 || this.emit("ActiveSpeakerChanged", i2);
        }
        _runInDecisionMaker() {
          const e2 = Date.now(), t3 = 300 - (e2 - this.lastLevelIdleTime);
          let i2 = 0;
          t3 <= 0 ? (0 !== this.lastLevelIdleTime && this.timeoutIdleLevels(e2), this.lastLevelIdleTime = e2) : i2 = t3;
          let n3 = 300 - (e2 - this.lastDecisionTime);
          return n3 <= 0 && (this.lastDecisionTime = e2, this.makeDecision(e2), n3 = 300 - (Date.now() - e2)), n3 > 0 && i2 > n3 && (i2 = n3), i2;
        }
        timeoutIdleLevels(e2) {
          const t3 = [];
          for (const n3 of up2(i2 = this.speakers).call(i2)) {
            var i2;
            const r2 = e2 - n3.getLastLevelChangedTime();
            36e5 < r2 && (null == this.dominantId || n3.id !== this.dominantId) ? t3.push(n3.id) : 300 < r2 && n3.levelTimedOut();
          }
          t3.forEach((e3) => this.speakers.delete(e3));
        }
      }
      const vM = /* @__PURE__ */ new Map();
      let CM = null, yM = null;
      const IM = 3;
      let bM = [];
      const AM = /* @__PURE__ */ new Map(), wM = /* @__PURE__ */ new Map();
      class OM {
        get samples() {
          return this.actives + this.inactives;
        }
        get activeRate() {
          return this.actives / this.samples;
        }
        constructor(e2, t3) {
          aP(this, "id", void 0), aP(this, "track", void 0), aP(this, "score", 0), aP(this, "active", true), aP(this, "muted", false), aP(this, "timer", 0), aP(this, "actives", 0), aP(this, "inactives", 0), this.id = e2, this.track = t3, this.setActive(AM.size < 3);
        }
        autoCheckActive() {
          this.autoSetActive(), this.autoAdjustActive(), this.resetTimer(), this.actives = 0, this.inactives = 0;
        }
        autoSetActive() {
          const e2 = this.active;
          this.active = this.activeRate >= 0.8;
          const { actives: t3, inactives: i2 } = function() {
            const e3 = [], t4 = [];
            return Array.from(up2(AM).call(AM)).forEach((i3) => {
              i3.active ? e3.push(i3) : t4.push(i3);
            }), { actives: e3, inactives: t4 };
          }();
          if (t3.length > 3) {
            let e3;
            t3.forEach((t4) => {
              (!e3 || e3.score > t4.score) && (e3 = t4);
            }), e3 && e3.setActive(false);
          }
          if (t3.length < 3 && i2.length > 0) {
            let t4;
            i2.forEach((e3) => {
              (!t4 || t4.score < e3.score) && e3.id !== this.id && (t4 = e3);
            }), t4 && e2 && !this.active && (t4.samples > 40 && t4.activeRate - this.activeRate > 0.4 ? t4.setActive(true) : this.active = true);
          }
          this.setMuted(!this.active);
        }
        setActive(e2) {
          this.active = e2, this.resetTimer(), this.setMuted(!e2);
        }
        autoAdjustActive() {
          this.active ? this.autoSwitchToInactive() : this.autoSwitchToActive();
        }
        autoSwitchToActive() {
          const e2 = function(e3) {
            let t3;
            return Array.from(up2(AM).call(AM)).forEach((i2) => {
              !i2.active || i2.id === e3 || i2.samples < 40 || (!t3 || i2.score < t3.score) && (t3 = i2);
            }), t3;
          }(this.id);
          e2 && this.activeRate - e2.activeRate > 0.4 && (e2.setActive(false), this.setActive(true));
        }
        autoSwitchToInactive() {
          const e2 = function(e3) {
            let t3;
            return Array.from(up2(AM).call(AM)).forEach((i2) => {
              i2.active || i2.id === e3 || i2.samples < 40 || (!t3 || i2.score > t3.score) && (t3 = i2);
            }), t3;
          }(this.id);
          e2 && e2.activeRate - this.activeRate > 0.4 && (e2.setActive(true), this.setActive(false));
        }
        addSample(e2) {
          e2 ? this.actives += 1 : this.inactives += 1, this.samples > 66.66666666666667 && this.autoCheckActive();
        }
        setMuted(e2) {
          this.track && (this.track.enabled = !e2, this.muted = e2);
        }
        resetTimer() {
          this.clearTimer(), this.timer = window.setTimeout(() => {
            if (0 !== this.samples) return this.samples < 50 ? this.resetTimer() : void this.autoCheckActive();
          }, 1e3);
        }
        clearTimer() {
          this.timer && (clearTimeout(this.timer), this.timer = 0);
        }
      }
      let NM;
      function DM(e2) {
        const t3 = AM.get(e2);
        t3 && (AM.delete(e2), t3.clearTimer());
      }
      const PM = /* @__PURE__ */ new Map(), LM = /* @__PURE__ */ new Map();
      const kM = "video/h264", MM = "video/h265";
      function UM(e2, t3, i2) {
        let n3 = new Uint8Array(e2, t3, i2), r2 = [], o2 = 0;
        for (; r2.length < i2; ) o2 + 3 < i2 && 0 === n3[o2] && 0 === n3[o2 + 1] && 3 === n3[o2 + 2] && (0 === n3[o2 + 3] || 1 === n3[o2 + 3] || 2 === n3[o2 + 3] || 3 === n3[o2 + 3]) ? (r2.push(n3[o2], n3[o2 + 1], n3[o2 + 3]), o2 += 4) : (r2.push(n3[o2]), o2++);
        return new Uint8Array(r2);
      }
      function VM(e2) {
        const t3 = e2.length;
        let i2 = [], n3 = 0;
        for (; n3 < t3; ) n3 + 2 < t3 && 0 === e2[n3] && 0 === e2[n3 + 1] && (0 === e2[n3 + 2] || 1 === e2[n3 + 2] || 2 === e2[n3 + 2] || 3 === e2[n3 + 2]) ? (i2.push(e2[n3], e2[n3 + 1], 3, e2[n3 + 2]), n3 += 3) : (i2.push(e2[n3]), n3++);
        return new Uint8Array(i2);
      }
      function xM(e2) {
        if (e2.length < 5) return "";
        let t3 = -1;
        for (let i3 = 0; i3 < e2.length - 3; i3++) {
          if (0 === e2[i3] && 0 === e2[i3 + 1] && 1 === e2[i3 + 2]) {
            t3 = i3;
            break;
          }
          if (i3 < e2.length - 4 && 0 === e2[i3] && 0 === e2[i3 + 1] && 0 === e2[i3 + 2] && 1 === e2[i3 + 3]) {
            t3 = i3;
            break;
          }
        }
        if (-1 === t3) return "";
        const i2 = t3 + (0 === e2[t3 + 2] ? 4 : 3);
        if (i2 >= e2.length) return "";
        const n3 = e2[i2];
        return 128 & n3 ? "" : (n3 >> 1 & 63) >= 32 || i2 + 1 < e2.length && 0 == (248 & e2[i2 + 1]) ? MM : (31 & n3) <= 31 ? kM : "";
      }
      const FM = /* @__PURE__ */ new Map();
      const BM = /* @__PURE__ */ new Map();
      !function() {
        const e2 = zA2();
        mD2.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), mD2.getStreamFromExtension = e2.name === WA2.CHROME && Number(e2.version) > 34, mD2.supportUnifiedPlan = function() {
          if (!window.RTCRtpTransceiver) return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype)) return false;
          const e3 = new RTCPeerConnection();
          let t3 = false;
          try {
            e3.addTransceiver("audio"), t3 = true;
          } catch (e4) {
          }
          return e3.close(), t3;
        }(), mD2.supportMinBitrate = e2.name === WA2.CHROME || e2.name === WA2.EDGE, mD2.supportSetRtpSenderParameters = function() {
          const e3 = zA2();
          return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!vw2() || !(!$A2() && !ZA2()) || e3.name === WA2.FIREFOX && Number(e3.version) >= 64);
        }(), e2.name === WA2.SAFARI && (Number(e2.version) >= 14 ? mD2.supportDualStream = true : mD2.supportDualStream = false), mD2.webAudioMediaStreamDest = function() {
          const e3 = zA2();
          return !(e3.name === WA2.SAFARI && Number(e3.version) < 12);
        }(), mD2.supportReplaceTrack = !!window.RTCRtpSender && "function" == typeof RTCRtpSender.prototype.replaceTrack, mD2.supportWebGL = "undefined" != typeof WebGLRenderingContext, mD2.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, vw2() || (mD2.webAudioWithAEC = true), mD2.supportShareAudio = function() {
          const e3 = zA2();
          return (e3.os === GA2.WIN_10 || e3.os === GA2.WIN_81 || e3.os === GA2.WIN_7 || e3.os === GA2.LINUX || e3.os === GA2.MAC_OS || e3.os === GA2.CHROMIUM_OS) && e3.name === WA2.CHROME && Number(e3.version) >= 74;
        }(), mD2.supportDataChannel = !!(rw2(76) || cw2(68) || dw2(14)), mD2.supportPCSetConfiguration = function() {
          const e3 = window.RTCPeerConnection;
          return !iw2() && !!e3 && e3.prototype.setConfiguration instanceof Function;
        }(), mD2.supportWebRTCEncodedTransform = rw2(87) || ew2() || cw2(117), mD2.supportWebRTCInsertableStream = function() {
          const e3 = zA2();
          return (e3.name === WA2.CHROME || e3.name === WA2.EDGE) && Number(e3.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
        }(), mD2.supportRequestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, mD2.supportWebCrypto = "undefined" != typeof window && void 0 !== window.crypto && void 0 !== window.crypto.subtle, hO(() => {
          mD2.supportDualStreamEncoding = function() {
            const e3 = zA2();
            return !!wN("DISABLE_WEBAUDIO") || ("Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && wN("CHROME_DUAL_STREAM_USE_ENCODING")));
          }(), sD.debug("browser ua: ", navigator.userAgent), sD.info("browser info: ", e2), sD.info("browser compatibility: ", mD2);
        });
      }();
      const jM = ["CHINA", "GLOBAL"];
      const GM = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], WM = [], HM = [];
      function KM(e2, t3) {
        return !!t3 && WM.some((i2) => i2.uid === e2 && i2.channelName === t3);
      }
      function YM() {
        return HM.length > 0;
      }
      var zM = Av2.forEach, qM = Wn2("forEach") ? [].forEach : function(e2) {
        return zM(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      };
      Oi2({ target: "Array", proto: true, forced: [].forEach !== qM }, { forEach: qM });
      var XM = Qi2("Array", "forEach"), JM = En2, ZM = $e2, QM = l, $M = XM, eU = Array.prototype, tU = { DOMTokenList: true, NodeList: true }, iU = function(e2) {
        var t3 = e2.forEach;
        return e2 === eU || QM(eU, e2) && t3 === eU.forEach || ZM(tU, JM(e2)) ? $M : t3;
      }, nU = i(iU), rU = Je2, oU = ho2;
      Oi2({ target: "Object", stat: true, forced: n2(function() {
        oU(1);
      }) }, { keys: function(e2) {
        return oU(rU(e2));
      } });
      var sU = i($.Object.keys), aU = i(ir2), cU = i(Er2), dU = Oi2, lU = or2, uU = Zc2, hU = Q2, pU = xi2, _U = Wi2, EU = J2, mU = YE, fU = pt2, SU = sd2, gU = jR("slice"), TU = fU("species"), RU = Array, vU = Math.max;
      dU({ target: "Array", proto: true, forced: !gU }, { slice: function(e2, t3) {
        var i2, n3, r2, o2 = EU(this), s2 = _U(o2), a3 = pU(e2, s2), c3 = pU(void 0 === t3 ? s2 : t3, s2);
        if (lU(o2) && (i2 = o2.constructor, (uU(i2) && (i2 === RU || lU(i2.prototype)) || hU(i2) && null === (i2 = i2[TU])) && (i2 = void 0), i2 === RU || void 0 === i2)) return SU(o2, a3, c3);
        for (n3 = new (void 0 === i2 ? RU : i2)(vU(c3 - a3, 0)), r2 = 0; a3 < c3; a3++, r2++) a3 in o2 && mU(n3, r2, o2[a3]);
        return n3.length = r2, n3;
      } });
      var CU = Qi2("Array", "slice"), yU = l, IU = CU, bU = Array.prototype, AU = function(e2) {
        var t3 = e2.slice;
        return e2 === bU || yU(bU, e2) && t3 === bU.slice ? IU : t3;
      }, wU = i(AU);
      function OU(e2, t3, i2, n3, r2) {
        var o2, s2, a3, c3 = {};
        return nU(o2 = sU(n3)).call(o2, function(e3) {
          c3[e3] = n3[e3];
        }), c3.enumerable = !!c3.enumerable, c3.configurable = !!c3.configurable, ("value" in c3 || c3.initializer) && (c3.writable = true), c3 = aU(s2 = cU(a3 = wU(i2).call(i2)).call(a3)).call(s2, function(i3, n4) {
          return n4(e2, t3, i3) || i3;
        }, c3), r2 && void 0 !== c3.initializer && (c3.value = c3.initializer ? c3.initializer.call(r2) : void 0, c3.initializer = void 0), void 0 === c3.initializer ? (OR(e2, t3, c3), null) : c3;
      }
      let NU = function(e2) {
        return e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR", e2;
      }({}), DU = function(e2) {
        return e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR", e2;
      }({}), PU = function(e2) {
        return e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND", e2;
      }({}), LU = function(e2) {
        return e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV", e2;
      }({}), kU = function(e2) {
        return e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.DATASTREAM2_NOT_AVAILABLE = 27] = "DATASTREAM2_NOT_AVAILABLE", e2[e2.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY", e2;
      }({}), MU = function(e2) {
        return e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed", e2;
      }({}), UU = function(e2) {
        return e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.PRE_CONNECT_PC = "pre_connect_pc", e2.P2P_CONNECTION = "p2p_connection", e2.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", e2.P2P_SUBSCRIBE = "p2p_subscribe", e2.P2P_UNSUBSCRIBE = "p2p_unsubscribe", e2.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", e2.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", e2.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream", e2.RECOVER_NOTIFICATION = "recover_notification", e2;
      }({}), VU = function(e2) {
        return e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.PUBLISH_DATASTREAM = "publish_datastream", e2.UNPUBLISH = "unpublish", e2.UNPUBLISH_DATASTREAM = "unpublish_datastream", e2.SUBSCRIBE = "subscribe", e2.PRE_SUBSCRIBE = "pre_subscribe", e2.SUBSCRIBE_DATASTREAM = "subscribe_datastream", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter", e2.SET_RTM2_FLAG = "set_rtm2_flag", e2.DOWNGRADE_CODEC = "downgrade_codec", e2;
      }({}), xU = function(e2) {
        return e2.WRTC_STATS = "wrtc_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats", e2;
      }({}), FU = function(e2) {
        return e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", e2.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", e2.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list", e2;
      }({}), BU = function(e2) {
        return e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY", e2;
      }({}), jU = function(e2) {
        return e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire", e2;
      }({});
      function GU(e2) {
        if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2)) throw sD.error("Invalid Channel Name ".concat(e2)), new ED(ww2.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function WU(e2) {
        if (!(t3 = e2, "number" == typeof t3 && Math.floor(t3) === t3 && 0 <= t3 && t3 <= 4294967295 || Vw2(e2, 1, 255))) throw new ED(ww2.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t3;
        "string" == typeof e2 && sD.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      let HU = function(e2) {
        return e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2;
      }({});
      const KU = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, YU = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function zU(e2, t3) {
        kw2(e2.url, "".concat(t3, ".url"), 1, 1e3, false), Uw2(e2.x) || Pw2(e2.x, "".concat(t3, ".x"), 0, 1e4), Uw2(e2.y) || Pw2(e2.y, "".concat(t3, ".y"), 0, 1e4), Uw2(e2.width) || Pw2(e2.width, "".concat(t3, ".width"), 0, 1e4), Uw2(e2.height) || Pw2(e2.height, "".concat(t3, ".height"), 0, 1e4), Uw2(e2.zOrder) || Pw2(e2.zOrder, "".concat(t3, ".zOrder"), 0, 255), Uw2(e2.alpha) || Pw2(e2.alpha, "".concat(t3, ".alpha"), 0, 1, false);
      }
      const qU = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" };
      let XU = function(e2) {
        return e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address", e2;
      }({}), JU = function(e2) {
        return e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager", e2;
      }({}), ZU = function(e2) {
        return e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN", e2;
      }({});
      function QU(e2) {
        if (!e2.channelName) throw new ED(ww2.INVALID_PARAMS, "invalid channelName in info");
        if ("number" != typeof e2.uid) throw new ED(ww2.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e2.token && kw2(e2.token, "info.token", 1, 2047), WU(e2.uid), GU(e2.channelName), true;
      }
      let $U = function(e2) {
        return e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile", e2;
      }({}), eV = function(e2) {
        return e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE", e2;
      }({}), tV = function(e2) {
        return e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE", e2;
      }({}), iV = function(e2) {
        return e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED", e2;
      }({}), nV = function(e2) {
        return e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low", e2;
      }({}), rV = function(e2) {
        return e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.PRE_CONNECT_PC = "pre-connect_pc", e2.UPDATE_GATEWAY_CONFIG = "update-gateway-config", e2;
      }({}), oV = function(e2) {
        return e2.P2P_DISCONNECTED = "P2P_DISCONNECTED", e2.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", e2.TIMEOUT = "TIMEOUT", e2.UNKNOWN_REASON = "UNKNOWN_REASON", e2;
      }({}), sV = function(e2) {
        return e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data", e2[e2.DataStream0 = 256] = "DataStream0", e2[e2.DataStream1 = 512] = "DataStream1", e2[e2.DataStream2 = 1024] = "DataStream2", e2[e2.DataStream3 = 2048] = "DataStream3", e2[e2.DataStream4 = 4096] = "DataStream4", e2[e2.DataStream5 = 8192] = "DataStream5", e2[e2.DataStream6 = 16384] = "DataStream6", e2[e2.DataStream7 = 32768] = "DataStream7", e2;
      }({}), aV = function(e2) {
        return e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS", e2;
      }({});
      const cV = [aV.AFRICA, aV.ASIA, aV.CHINA, aV.EUROPE, aV.GLOBAL, aV.INDIA, aV.JAPAN, aV.NORTH_AMERICA, aV.OCEANIA, aV.OVERSEA, aV.SOUTH_AMERICA];
      let dV = function(e2) {
        return e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL", e2;
      }({});
      const lV = { CHINA: {}, ASIA: { CODE: dV.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: dV.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: dV.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: dV.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: dV.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: dV.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: dV.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: dV.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: dV.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: dV.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: dV.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: dV.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: dV.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
      gN && (lV.CHINA = { CODE: dV.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] });
      let uV = function(e2) {
        return e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit", e2.UPDATE_CLIENT_ROLE_OPTIONS = "update_client_role_options", e2;
      }({});
      function hV(e2) {
        return !!e2 && (!(!e2.uplink || !e2.id) && (void 0 !== e2.uplink.max_bitrate && void 0 !== e2.uplink.min_bitrate));
      }
      class pV extends Hw2 {
        constructor(e2, t3) {
          super(), uI(this, "onICEConnectionStateChange", void 0), uI(this, "onConnectionStateChange", void 0), uI(this, "onDTLSTransportStateChange", void 0), uI(this, "onDTLSTransportError", void 0), uI(this, "onICETransportStateChange", void 0), uI(this, "onFirstAudioReceived", void 0), uI(this, "onFirstVideoReceived", void 0), uI(this, "onFirstAudioDecoded", void 0), uI(this, "onFirstVideoDecoded", void 0), uI(this, "onFirstVideoRender", void 0), uI(this, "onFirstVideoDecodedTimeout", void 0), uI(this, "onSelectedLocalCandidateChanged", void 0), uI(this, "onSelectedRemoteCandidateChanged", void 0), uI(this, "onICECandidateError", void 0), uI(this, "getLocalVideoStats", void 0);
        }
      }
      class _V extends pV {
        constructor(e2, t3) {
          super(e2, t3), uI(this, "establishPromise", void 0);
        }
      }
      let EV = function(e2) {
        return e2.VIDEO = "video", e2.AUDIO = "audio", e2;
      }({}), mV = function(e2) {
        return e2.UDP_RELAY = "udp_relay", e2.UDP_TCP_RELAY = "udp_tcp_relay", e2.TCP_RELAY = "tcp_relay", e2.RELAY = "relay", e2;
      }({}), fV = function(e2) {
        return e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.UDP_TCP_RESTART = 1] = "UDP_TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.TCP_RESTART = 3] = "TCP_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED", e2;
      }({});
      const SV = ["disconnected", "failed"];
      let gV = function(e2) {
        return e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack", e2;
      }({}), TV = function(e2) {
        return e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected", e2;
      }({}), RV = function(e2) {
        return e2.AudioMetadata = "audioMetadata", e2.AudioPts = "audioPts", e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestRePublishDataChannel = "requestRePublishDataChannel", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.RequestUpload = "requestUpload", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState", e2.LocalCandidate = "LocalCandidate", e2.RequestP2PMuteLocal = "requestP2PMuteLocal", e2.RequestP2PUnPublish = "RequestP2PUnPublish", e2.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", e2.RequestP2PMuteRemote = "RequestP2PMuteRemote", e2.RequestP2PRestartICE = "RequestP2PRestartICE", e2;
      }({}), vV = function(e2) {
        return e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED", e2;
      }({}), CV = function(e2) {
        return e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED", e2;
      }({}), yV = function(e2) {
        return e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e2;
      }({}), IV = function(e2) {
        return e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback", e2.PRE_CONNECT_PC = "transmitter:pre_connect_pc", e2;
      }({}), bV = function(e2) {
        return e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation", e2;
      }({}), AV = function(e2) {
        return e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED", e2;
      }({}), wV = function(e2) {
        return e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url", e2;
      }({}), OV = function(e2) {
        return e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED", e2;
      }({}), NV = function(e2) {
        return e2.CALL = "call", e2.CANDIDATE = "candidate", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.CONTROL = "control", e2.RESTART_ICE = "restart_ice", e2.ACK = "ack", e2.RESPONSE = "response", e2.JOIN = "join", e2.CHECK = "check", e2;
      }({}), DV = function(e2) {
        return e2.ABORT = "abort", e2;
      }({}), PV = function(e2) {
        return e2.MUTE_LOCAL_AUDIO = "mute_local_audio", e2.MUTE_LOCAL_VIDEO = "mute_local_video", e2.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", e2.UNMUTE_LOCAL_VIDEO = "unmute_local_video", e2;
      }({}), LV = function(e2) {
        return e2.P2P_TOKEN_TIMEOUT = "p2p_token_timeout", e2.P2P_TOKEN_CHANGED = "p2p_token_changed", e2;
      }({});
      const kV = { [NU.ACCESS_POINT]: { [LU.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [LU.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [LU.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [LU.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [LU.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [LU.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [LU.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [NU.UNILBS]: { [PU.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [PU.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [PU.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [PU.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [PU.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [PU.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [PU.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [PU.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [PU.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [PU.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [PU.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [PU.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [NU.STRING_UID_ALLOCATOR]: { [DU.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [DU.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [DU.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function MV(e2) {
        const t3 = kV[Math.floor(e2 / 1e4)];
        if (!t3) return { desc: "unknown error", retry: false };
        const i2 = t3[e2 % 1e4];
        if (!i2) {
          if (Math.floor(e2 / 1e4) === NU.ACCESS_POINT) {
            const t4 = e2 % 1e4;
            if ("1" === t4.toString()[0]) return { desc: e2.toString(), retry: false };
            if ("2" === t4.toString()[0]) return { desc: e2.toString(), retry: true };
          }
          return { desc: "unknown error", retry: false };
        }
        return i2;
      }
      const UV = { [kU.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [kU.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [kU.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [kU.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [kU.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [kU.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [kU.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [kU.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [kU.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [kU.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [kU.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [kU.DATASTREAM2_NOT_AVAILABLE]: { desc: "DATASTREAM2_NOT_AVAILABLE", action: "quit" }, [kU.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [kU.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [kU.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [kU.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [kU.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [kU.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [kU.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [kU.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [kU.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [kU.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [kU.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [kU.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [kU.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [kU.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [kU.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [kU.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [kU.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [kU.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [kU.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [kU.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [kU.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [kU.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [kU.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [kU.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [kU.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [kU.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [kU.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [kU.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [kU.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [kU.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [kU.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [kU.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [kU.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [kU.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [kU.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [kU.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [kU.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [kU.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [kU.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [kU.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [kU.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [kU.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [kU.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [kU.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [kU.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [kU.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [kU.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [kU.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [kU.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [kU.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [kU.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [kU.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
      function VV(e2) {
        const t3 = UV[e2];
        return t3 || { desc: "UNKNOWN_ERROR_".concat(e2), action: "failed" };
      }
      function xV(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function FV(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? xV(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : xV(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      function BV(e2, t3) {
        if ("string" == typeof e2) return e2;
        const { proxy: i2, host: n3, port: r2 } = e2;
        if (t3) {
          const e3 = wN("JOIN_GATEWAY_FALLBACK_PORT") || 443;
          return 443 === e3 ? "wss://".concat(n3, "/ws/?p=").concat(Number(r2) + 150) : "wss://".concat(n3, ":").concat(e3, "/ws/?p=").concat(Number(r2) + 150);
        }
        return i2 ? "wss://".concat(i2, "/ws/?h=").concat(n3, "&p=").concat(r2) : "wss://".concat(n3, ":").concat(r2);
      }
      const jV = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/, GV = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/, WV = /wss:\/\/(.+):([0-9]+)\/?/, HV = /wss:\/\/(.[^\/]+)\/?/;
      let KV = 0;
      class YV {
        constructor(e2, t3) {
          uI(this, "id", 0), uI(this, "store", void 0), uI(this, "recordIndex", void 0), uI(this, "websockets", []), uI(this, "try443PortDuration", 2e3), uI(this, "forceCloseWSDuration", 5e3), uI(this, "try443PortTimeout", null), uI(this, "forceCloseTimeout", null), uI(this, "isTry443PortFailed", false), uI(this, "isNormalPortFailed", false), uI(this, "useDoubleDomain", false), uI(this, "useProxy", false), uI(this, "startTime", Date.now()), this.id = ++KV, this.try443PortDuration = wN("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e2 || 5e3, this.store = t3;
        }
        closeAllWebsockets() {
          this.websockets.forEach((e2) => {
            e2.onopen = null, e2.onclose = null, e2.onmessage = null, e2.close();
          }), this.websockets.length = 0;
        }
        clearTimeout() {
          this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout), this.forceCloseTimeout = null, this.try443PortTimeout = null;
        }
        logger() {
          var e2;
          const t3 = Date.now() - this.startTime;
          for (var i2 = arguments.length, n3 = new Array(i2), r2 = 0; r2 < i2; r2++) n3[r2] = arguments[r2];
          sD.debug("[choose-best-ws ".concat(null === (e2 = this.store) || void 0 === e2 ? void 0 : e2.clientId, " ").concat(this.id, "] ").concat(t3, "ms:"), ...n3);
        }
        createWebSocket(e2, t3, i2) {
          this.logger("createWebSocket:", e2, { isTry443Port: t3, hasTimeoutDetection: i2 });
          const n3 = wN("GATEWAY_DOMAINS"), r2 = Date.now(), o2 = [], s2 = n3.find((t4) => {
            var i3;
            return Ln2(i3 = e2.host).call(i3, t4);
          });
          s2 || (this.useDoubleDomain = false);
          const a3 = [];
          if (this.useDoubleDomain) n3.forEach((i3) => {
            a3.push(BV(FV(FV({}, e2), {}, { host: e2.host.replace(s2, i3) }), t3));
          });
          else {
            const i3 = FV({}, e2);
            if (t3 && s2) {
              const e3 = n3.find((e4) => e4 !== s2);
              e3 && (i3.host = i3.host.replace(s2, e3));
            }
            a3.push(BV(i3, t3));
          }
          try {
            a3.forEach((e3) => {
              const t4 = new WebSocket(e3);
              t4.binaryType = "arraybuffer", o2.push(t4), this.logger("ws is connecting:", t4.url);
            });
          } catch (n4) {
            if (this.logger("ws create failed"), o2.forEach((e3) => e3.close()), o2.length = 0, this.useDoubleDomain) return this.useDoubleDomain = false, this.createWebSocket(e2, t3, i2);
            if (!t3 && 443 !== Number(e2.port)) return this.createWebSocket(e2, true, i2);
            throw new ED(ww2.WS_ERR, "init websocket failed! Error: ".concat(n4.toString()));
          }
          const c3 = xA2();
          this.store && this.store.recordJoinChannelService({ urls: o2.map((e3) => e3.url), service: "gateway" }, this.recordIndex), o2.forEach((e3) => {
            e3.onopen = () => {
              this.logger("onopen: ws ".concat(e3.url, " open cost ").concat(Date.now() - r2, "ms")), this.websockets.forEach((t4) => {
                t4 !== e3 && (t4.onopen = null, t4.onclose = null, t4.onmessage = null, t4.close(), this.logger("close backup websocket: ".concat(t4.url)));
              }), this.websockets.length = 0, c3.resolve(e3);
            }, e3.onclose = (i3) => {
              this.logger("onclose: ws ".concat(e3.url, " closed cost ").concat(Date.now() - r2, "ms state: ").concat(e3.readyState));
              const n4 = o2.every((e4) => e4.readyState === WebSocket.CLOSED || e4.readyState === WebSocket.CLOSING);
              this.logger("".concat(t3 ? "443" : "47xx", " websocket closed, all failed: ").concat(n4)), n4 && (t3 || this.isTry443PortFailed || this.useProxy) ? (this.logger("onclose: all websocket is closed, ".concat(i3.reason)), c3.reject({ code: i3.code, reason: oV.A_ROUND_WS_FAILED })) : !t3 && n4 && !this.isNormalPortFailed && this.try443PortTimeout && (this.logger("all 47xx websocket is closed, try 443 port"), this.clearTimeout(), l2()), t3 ? this.isTry443PortFailed = n4 : this.isNormalPortFailed = n4;
            }, e3.onmessage = (t4) => this.logger("".concat(e3.url, " onmessage: ").concat(t4.data));
          }), this.websockets.push(...o2);
          const d2 = () => {
            this.websockets.forEach((e3) => e3.readyState !== WebSocket.OPEN && e3.close());
          }, l2 = () => {
            if (c3.isResolved) return d2();
            zA2().os === GA2.MAC_OS && iw2() && d2(), this.createWebSocket(e2, true, true).then((e3) => {
              c3.resolve(e3);
            }).catch((e3) => {
              this.isNormalPortFailed && c3.reject(e3), this.logger("try 443 port to create ws failed");
            }), this.forceCloseTimeout = window.setTimeout(() => {
              this.logger("5s timeout close un-opens, isWebsocket created: ", c3.isResolved), this.forceCloseTimeout = null, d2();
            }, this.forceCloseWSDuration);
          };
          return i2 || (() => {
            if (t3 || this.useProxy) return this.logger("add 5s timeout at ".concat(t3 ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout(() => {
              this.forceCloseTimeout = null, d2();
            }, this.forceCloseWSDuration);
            this.try443PortTimeout = window.setTimeout(() => {
              this.logger("2s timeout, isWebsocket created: ", c3.isResolved), this.try443PortTimeout = null, l2();
            }, this.try443PortDuration);
          })(), c3.promise;
        }
        chooseBestWebsocket(e2, t3, i2, n3) {
          return this.useDoubleDomain = !!t3, "string" == typeof e2 && (e2 = function(e3) {
            let t4, i3, n4;
            return [, t4, i3, n4] = e3.match(jV) || [], t4 || ([, i3, n4] = e3.match(GV) || []), i3 && n4 || ([, i3, n4] = e3.match(WV) || []), i3 && n4 || ([, i3] = e3.match(HV) || []), i3 || sD.warning("un-destructible url: ", e3), { proxy: t4, host: i3, port: n4 || "443" };
          }(e2)), this.recordIndex = n3, this.useProxy = !!e2.proxy, i2 && this.useProxy && (sD.warn("cannot use 443 only when use proxy"), i2 = false), this.createWebSocket(e2, !!i2, false).finally(() => this.clearTimeout());
        }
      }
      function zV(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      class qV extends Hw2 {
        get url() {
          return this.websocket && this.websocket.url || this._websocketUrl;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          var t3;
          Ln2(t3 = ["tryNext", "recover"]).call(t3, e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(jU.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(jU.CONNECTED) : "closed" === this._state ? this.emit(jU.CLOSED) : "failed" === this._state && this.emit(jU.FAILED));
        }
        resetReconnectCount(e2) {
          sD.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
        }
        constructor(e2, t3) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o2 = arguments.length > 5 ? arguments[5] : void 0;
          super(), uI(this, "_websocketUrl", null), uI(this, "connectionID", 0), uI(this, "currentURLIndex", 0), uI(this, "urls", []), uI(this, "_reconnectMode", "tryNext"), uI(this, "reconnectReason", void 0), uI(this, "_initMutex", void 0), uI(this, "name", void 0), uI(this, "_state", "closed"), uI(this, "reconnectInterrupter", void 0), uI(this, "websocket", void 0), uI(this, "retryConfig", void 0), uI(this, "reconnectCount", 0), uI(this, "forceCloseTimeout", 5e3), uI(this, "onlineReconnectListener", void 0), uI(this, "useCompress", void 0), uI(this, "tryDoubleDomain", false), uI(this, "use443PortOnly", false), uI(this, "wsInflateLength", 0), uI(this, "wsDeflateLength", 0), uI(this, "closeEstablishingWs", () => {
          }), uI(this, "store", void 0), uI(this, "joinGatewayRecordIndex", void 0), this.store = o2, this.name = e2, this.retryConfig = function(e3) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i3 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? zV(Object(i3), true).forEach(function(t5) {
                uI(e3, t5, i3[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : zV(Object(i3)).forEach(function(t5) {
                Object.defineProperty(e3, t5, Object.getOwnPropertyDescriptor(i3, t5));
              });
            }
            return e3;
          }({}, t3), this.useCompress = i2, this.tryDoubleDomain = n3, this.use443PortOnly = r2, this._initMutex = new xO("websocket", o2 ? o2.clientId : void 0);
          const { timeout: s2, timeoutFactor: a3 } = t3, c3 = Math.max(300, Math.floor(3 * s2 / 5)), d2 = Math.max(1.2, Math.floor(8 * a3) / 10);
          nO.ONLINE && (this.retryConfig.timeout = c3, this.retryConfig.timeoutFactor = d2), dO.on(rO.NETWORK_STATE_CHANGE, (e3, t4) => {
            e3 !== t4 && (this.resetReconnectCount("network state change: ".concat(t4, " -> ").concat(e3)), e3 === nO.ONLINE ? (this.retryConfig.timeout = c3, this.retryConfig.timeoutFactor = d2) : (this.retryConfig.timeout = s2, this.retryConfig.timeoutFactor = a3));
          });
        }
        getConnection() {
          return this.websocket || void 0;
        }
        async init(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
          const i2 = await this._initMutex.lock();
          this._reconnectMode = "tryNext", this.forceCloseTimeout = t3, this.urls = e2, this.state = "connecting";
          try {
            var n3;
            const e3 = xA2(), t4 = this.urls[this.currentURLIndex];
            null === (n3 = this.store) || void 0 === n3 || n3.beforeConnect(), function(e4) {
              return !(gD2() || wN("USE_NEW_TOKEN") || !wN("ENABLE_PREALLOC_PC") && (null == e4 || !e4.autoSubscribe || wN("FORCE_DISABLE_AUTO_SUB")));
            }(this.store) && this.emit(IV.PRE_CONNECT_PC), this.createWebSocketConnection(t4).then(e3.resolve).catch(e3.reject), this.once(jU.CLOSED, () => {
              e3.reject(new Ow2(ww2.WS_DISCONNECT));
            }), this.once(jU.CONNECTED, e3.resolve), await e3.promise;
          } catch (e3) {
          } finally {
            i2();
          }
        }
        close(e2, t3) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e3 = this.websocket;
            t3 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0, this._websocketUrl = null;
          }
          this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e2, t3) {
          if (!this.websocket) return void sD.warning("[".concat(this.name, "] can not reconnect, no websocket"));
          void 0 !== e2 && (this.reconnectMode = e2), sD.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinGatewayRecordIndex && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(t3)] }, this.joinGatewayRecordIndex);
          const i2 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), i2 && i2.bind(this.websocket)({ code: 9999, reason: t3 });
        }
        sendMessage(e2) {
          let t3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Ow2(ww2.WS_ABORT, "websocket is not ready");
          try {
            t3 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
          } catch (e3) {
            throw new Ow2(ww2.WS_ERR, "send websocket message error" + e3.toString());
          }
        }
        setWsInflateData(e2) {
          this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
        }
        getWsInflateData() {
          const e2 = this.wsInflateLength, t3 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t3 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e2) {
          var t3;
          const i2 = xA2();
          this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
          const n3 = (e3) => {
            var t4;
            null === (t4 = this.store) || void 0 === t4 || t4.signalChannelOpen(), sD.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i2.resolve();
          }, r2 = async (e3) => {
            var t4;
            if (sD.debug("[".concat(this.name, "] websocket close ").concat(null === (t4 = this.websocket) || void 0 === t4 ? void 0 : t4.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i2.reject(new Ow2(ww2.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
            else {
              "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
              const t5 = aO(this, jU.WILL_RECONNECT, this.reconnectMode, e3.reason) || this.reconnectMode, n4 = await this.reconnectWithAction(t5);
              if ("closed" === this.state) return void sD.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
              if (!n4) return i2.reject(new Ow2(ww2.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), this.close(true);
              i2.resolve();
            }
          }, o2 = (e3) => {
            this.emit(jU.ON_MESSAGE, e3);
          }, s2 = (e3) => {
            sD.warn("[".concat(this.connectionID, "] ws open error ").concat(e3));
          };
          this.websocket && (this.websocket.onclose = null, this.websocket.close()), wN("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = wN("GATEWAY_WSS_ADDRESS")), sD.debug("[".concat(this.name, "] start connect, url:"), e2);
          const a3 = null === (t3 = this.store) || void 0 === t3 ? void 0 : t3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
          try {
            var c3;
            this._websocketUrl = BV(e2);
            const t4 = await this.chooseBestWebsocketConnection(e2);
            this.websocket = t4, n3 && n3(this.websocket.url), this.websocket.onclose = r2, this.websocket.onmessage = o2, this.websocket.onerror = s2, null === (c3 = this.store) || void 0 === c3 || c3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), this.joinGatewayRecordIndex = a3;
          } catch (e3) {
            const t4 = "closed" === this.state, n4 = e3 instanceof Ow2, o3 = n4 && e3.code === ww2.WS_ABORT, s3 = n4 && e3.code === ww2.WS_ERR, c4 = n4 ? e3.message : e3 && (e3.reason || e3.toString());
            sD.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c4)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: o3 ? "aborted" : "error", errors: [e3] }, a3), t4 || s3 ? (i2.reject(t4 ? new Ow2(ww2.WS_DISCONNECT, "websocket is closed: ".concat(c4)) : new Ow2(ww2.WS_ERR, "init websocket failed: ".concat(c4))), s3 && sD.error("[".concat(this.name, "] init websocket failed: ").concat(c4))) : r2 && r2(e3);
          }
          return i2.promise;
        }
        async reconnectWithAction(e2) {
          let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount) return false;
          if (0 === this.urls.length) return false;
          if ("closed" === this.state) return false;
          sD.warning("[choose-best-ws] action: =>", e2), this.onlineReconnectListener || dO.isOnline || !dO.onlineWaiter || (this.onlineReconnectListener = dO.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
          let i2 = true;
          if (this.reconnectInterrupter = () => i2 = false, t3) {
            const t4 = jO(this.reconnectCount, this.retryConfig);
            sD.debug("[".concat(this.name, "] wait ").concat(t4, "ms to reconnect websocket, mode: ").concat(e2)), await ip2.race([yO(t4), this.onlineReconnectListener || new ip2(() => {
            })]);
          }
          if ("closed" === this._state || !i2) return false;
          this.reconnectCount += 1;
          const n3 = async (e3, t4) => {
            this.emit(jU.RECONNECT_CREATE_CONNECTION, t4), await this.createWebSocketConnection(e3);
          };
          try {
            if ("retry" === e2) await n3(this.urls[this.currentURLIndex], e2);
            else if ("tryNext" === e2) {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction("recover", false);
              sD.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), await n3(this.urls[this.currentURLIndex], e2);
            } else "recover" === e2 && (sD.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.urls = await oO(this, jU.REQUEST_NEW_URLS), this.currentURLIndex = 0, await n3(this.urls[this.currentURLIndex], e2));
          } catch (i3) {
            var r2;
            sD.error("[".concat(this.name, "] reconnect failed ").concat(i3 && i3.toString()));
            const n4 = null == i3 || null === (r2 = i3.data) || void 0 === r2 ? void 0 : r2.desc;
            return Array.isArray(n4) && Ln2(n4).call(n4, "dynamic key expired") ? (this.emit(jU.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : this.reconnectWithAction(e2, t3);
          }
          return true;
        }
      }
      class XV extends qV {
        constructor(e2, t3) {
          super(e2, t3, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t3) {
          const i2 = xA2(), n3 = function(e3, t4) {
            return new YV(e3, t4);
          }(this.forceCloseTimeout, this.store);
          this.closeEstablishingWs = () => {
            sD.debug("[choose-best-ws] close establishing websockets"), n3.closeAllWebsockets(), i2.reject(new Ow2(ww2.WS_ABORT, "choose best websocket aborted"));
          };
          const r2 = wN("GATEWAY_DOMAINS");
          return sD.debug("[choose-best-ws] currentDomain: ", e2, ", domains: ", r2, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), n3.chooseBestWebsocket(e2, this.tryDoubleDomain, this.use443PortOnly, t3).then(i2.resolve).catch(i2.reject), i2.promise.finally(() => {
            this.closeEstablishingWs = void 0;
          });
        }
      }
      class JV extends qV {
        constructor(e2, t3) {
          super(e2, t3, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3], arguments.length > 4 && void 0 !== arguments[4] && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
        }
        async chooseBestWebsocketConnection(e2, t3) {
          return new ip2((i2, n3) => {
            let r2 = false;
            const o2 = [];
            this.closeEstablishingWs = () => {
              sD.debug("[choose-best-ws] close establishing websockets"), o2.forEach((e3) => {
                e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
              }), n3(new Ow2(ww2.WS_ABORT, "choose best websocket aborted"));
            };
            const s2 = wN("GATEWAY_DOMAINS");
            let a3;
            const c3 = e2.indexOf("?h="), d2 = s2.find((t4) => -1 !== c3 ? Ln2(e2).call(e2, t4, c3) : Ln2(e2).call(e2, t4));
            sD.debug("[choose-best-ws] currentDomain: ", d2, ", domains: ", s2);
            let l2 = !this.tryDoubleDomain || !d2;
            if (!l2 && d2) {
              var u3;
              const h3 = Date.now();
              try {
                s2.forEach((t4) => {
                  const i3 = -1 === c3 ? e2.replace(d2, t4) : e2.substr(0, c3) + e2.substr(c3).replace(d2, t4), n4 = new WebSocket(i3);
                  n4.binaryType = "arraybuffer", o2.push(n4), sD.debug("[choose-best-ws] ws is connecting:", n4.url);
                });
              } catch (e3) {
                for (sD.debug("[choose-best-ws] ws create failed, fallback to single url"), o2.forEach((e4) => e4.close()); o2.length; ) o2.pop();
                l2 = true;
              }
              null === (u3 = this.store) || void 0 === u3 || u3.recordJoinChannelService({ urls: o2.map((e3) => e3.url), service: "gateway" }, t3), o2.forEach((e3) => {
                e3.onopen = () => {
                  if (r2) return;
                  const t4 = Date.now() - h3;
                  sD.debug("[choose-best-ws] ws open cost ".concat(t4, "ms")), o2.filter((t5) => t5 !== e3).forEach((e4) => {
                    sD.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                  }), r2 = true, i2(e3);
                }, e3.onclose = (e4) => {
                  if (a3 = e4, r2) return;
                  o2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (sD.debug("[choose-best-ws] all websocket is closed"), r2 = true, n3(a3));
                }, e3.onmessage = (t4) => {
                  sD.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t4.data));
                };
              }), yO(this.forceCloseTimeout).then(() => {
                o2.forEach((e3) => {
                  e3.readyState !== WebSocket.OPEN && e3.close();
                });
              });
            }
            if (l2) {
              var h2;
              let r3;
              sD.debug("[choose-best-ws] use single url: ", e2), null === (h2 = this.store) || void 0 === h2 || h2.recordJoinChannelService({ urls: [e2], service: "gateway" }, t3);
              try {
                r3 = new WebSocket(e2), o2.push(r3), r3.binaryType = "arraybuffer";
              } catch (e3) {
                const t4 = new Ow2(ww2.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return sD.error("[".concat(this.name, "]").concat(t4)), void n3(t4);
              }
              r3.onopen = () => {
                i2(r3);
              }, r3.onclose = (e3) => {
                n3(e3);
              }, r3.onmessage = (e3) => {
                sD.debug("[choose-best-ws]".concat(r3.url, " onmessage: ").concat(e3.data));
              }, yO(this.forceCloseTimeout).then(() => {
                r3 && r3.readyState !== WebSocket.OPEN && r3.close();
              });
            }
          }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
            throw this.closeEstablishingWs = void 0, e3;
          });
        }
      }
      class ZV extends Hw2 {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === MU.CONNECTED ? this.emit(UU.WS_CONNECTED) : e2 === MU.RECONNECTING ? this.emit(UU.WS_RECONNECTING, this._websocketReconnectReason) : e2 === MU.CLOSED && this.emit(UU.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t3) {
          super(), uI(this, "_disconnectedReason", void 0), uI(this, "_websocketReconnectReason", void 0), uI(this, "_connectionState", MU.CLOSED), uI(this, "reconnectToken", void 0), uI(this, "websocket", void 0), uI(this, "openConnectionTime", void 0), uI(this, "clientId", void 0), uI(this, "lastMsgTime", Date.now()), uI(this, "uploadCache", []), uI(this, "uploadCacheInterval", void 0), uI(this, "rttRolling", new HO(5)), uI(this, "pingpongTimer", void 0), uI(this, "wsInflateDataTimer", void 0), uI(this, "pingpongTimeoutCount", 0), uI(this, "ortc", void 0), uI(this, "joinResponse", void 0), uI(this, "multiIpOption", void 0), uI(this, "initError", void 0), uI(this, "spec", void 0), uI(this, "store", void 0), uI(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer) return void this.emit(UU.ON_BINARY_DATA, e3.data);
            const t4 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t4, "_id")) {
              const e4 = "res-@".concat(t4._id);
              this.emit(e4, t4._result, t4._message);
            } else if (Object.prototype.hasOwnProperty.call(t4, "_type")) {
              if (this.emit(t4._type, t4._message), t4._type === FU.ON_NOTIFICATION && this.handleNotification(t4._message), t4._type === FU.ON_USER_BANNED) switch (t4._message.error_code) {
                case 14:
                  this.close(Zw2.UID_BANNED);
                  break;
                case 15:
                  this.close(Zw2.IP_BANNED);
                  break;
                case 16:
                  this.close(Zw2.CHANNEL_BANNED);
              }
              if (t4._type === FU.ON_USER_LICENSE_BANNED) switch (t4._message.error_code) {
                case kU.ERR_LICENSE_MISSING:
                  this.close(Zw2.LICENSE_MISSING);
                  break;
                case kU.ERR_LICENSE_EXPIRED:
                  this.close(Zw2.LICENSE_EXPIRED);
                  break;
                case kU.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(Zw2.LICENSE_MINUTES_EXCEEDED);
                  break;
                case kU.ERR_LICENSE_PERIOD_INVALID:
                  this.close(Zw2.LICENSE_PERIOD_INVALID);
                  break;
                case kU.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(Zw2.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case kU.ERR_LICENSE_ILLEGAL:
                  this.close(Zw2.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t3, this.websocket = new XV("gateway-".concat(this.clientId), this.spec.retryConfig, true, wN("JOIN_GATEWAY_USE_DUAL_DOMAIN"), wN("JOIN_GATEWAY_USE_443PORT_ONLY"), t3), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === MU.CONNECTED && this.reconnect("retry", iO.OFFLINE);
          });
        }
        async request(e2, t3, i2, n3) {
          const r2 = IO(6, ""), o2 = { _id: r2, _type: e2, _message: t3 }, s2 = this.websocket.connectionID, a3 = () => new ip2((t4, i3) => {
            if (this.connectionState === MU.CONNECTED) return t4();
            const n4 = () => {
              this.off(UU.WS_CLOSED, r3), t4();
            }, r3 = () => {
              this.off(UU.WS_CONNECTED, n4), i3(new ED(ww2.WS_ABORT));
            };
            this.once(UU.WS_CONNECTED, n4), this.once(UU.WS_CLOSED, r3), e2 !== VU.PUBLISH && e2 !== VU.PUBLISH_DATASTREAM && e2 !== VU.SUBSCRIBE && e2 !== VU.SUBSCRIBE_DATASTREAM && e2 !== VU.UNSUBSCRIBE && e2 !== VU.UNSUBSCRIBE_DATASTREAM && e2 !== VU.UNPUBLISH && e2 !== VU.UNPUBLISH_DATASTREAM && e2 !== VU.CONTROL && e2 !== VU.RESTART_ICE || this.once(UU.DISCONNECT_P2P, () => {
              i3(new ED(ww2.DISCONNECT_P2P));
            }), e2 !== VU.PUBLISH && e2 !== VU.RESTART_ICE || this.once(UU.ABORT_P2P_EXECUTION, () => {
              i3(new ED(ww2.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== MU.CONNECTING && this.connectionState !== MU.RECONNECTING || e2 === VU.JOIN || e2 === VU.REJOIN || await a3(), this.websocket.sendMessage(o2, true), n3) return;
          const c3 = new ip2((i3, n4) => {
            let o3 = false;
            const a4 = (n5, r3) => {
              o3 = true, i3({ isSuccess: "success" === n5, message: r3 || {} }), this.off(UU.WS_CLOSED, c4), this.off(UU.WS_RECONNECTING, c4), this.emit(UU.REQUEST_SUCCESS, e2, t3);
            };
            this.once("res-@".concat(r2), a4);
            const c4 = () => {
              n4(new ED(ww2.WS_ABORT, "type: ".concat(e2))), this.off(UU.WS_CLOSED, c4), this.off(UU.WS_RECONNECTING, c4), this.off("res-@".concat(r2), a4);
            };
            this.once(UU.WS_CLOSED, c4), this.once(UU.WS_RECONNECTING, c4), yO(wN("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (sD.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(UU.REQUEST_TIMEOUT, e2, t3));
            });
          });
          let d2 = null;
          try {
            d2 = await c3;
          } catch (n4) {
            if (this.connectionState === MU.CLOSED || e2 === VU.LEAVE) throw new ED(ww2.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n4.throw() : e2 === VU.JOIN || e2 === VU.REJOIN ? null : (await a3(), await this.request(e2, t3));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u3 = VV(l2), h2 = new ED(ww2.UNEXPECTED_RESPONSE, "".concat(u3.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u3.desc });
          return "success" === u3.action ? d2.message : (sD.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u3.desc, ", action: ").concat(u3.action)), l2 === kU.ERR_TOO_MANY_BROADCASTERS ? e2 === VU.JOIN || e2 === VU.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u3.action ? h2.throw() : "quit" === u3.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === kU.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, sD.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", iO.MULTI_IP)) : this.reconnect(u3.action, iO.SERVER_ERROR), e2 === VU.JOIN || e2 === VU.REJOIN ? null : await this.request(e2, t3)));
        }
        waitMessage(e2, t3) {
          return new ip2((i2) => {
            const n3 = (r2) => {
              (!t3 || t3(r2)) && (this.off(e2, n3), i2(r2));
            };
            this.on(e2, n3);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void sD.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t3 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(xU.WRTC_STATS, t3);
        }
        upload(e2, t3) {
          const i2 = { _type: e2, _message: t3 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t4 = wN("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t4 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== MU.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, wN("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t3) {
          const i2 = { _type: e2, _message: t3 };
          this.websocket.sendMessage(i2);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new ip2((t3, i2) => {
            this.once(UU.WS_CONNECTED, () => t3(this.joinResponse)), this.once(UU.WS_CLOSED, (e3) => i2(this.initError || new ED(ww2.WS_ABORT, e3))), this.connectionState = MU.CONNECTING, this.websocket.init(e2).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4);
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || Zw2.LEAVE, this.connectionState = MU.CLOSED, sD.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close();
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(UU.ABORT_P2P_EXECUTION), this.store.signalConnected();
            const e2 = await oO(this, UU.REQUEST_JOIN_INFO);
            this.store.joinReq();
            const t3 = await this.request(VU.JOIN, e2);
            if (this.ortc = null == e2 ? void 0 : e2.ortc, this.store.joinRep(), !t3) return this.emit(UU.REPORT_JOIN_GATEWAY, oV.TIMEOUT, this.url || ""), false;
            this.joinResponse = t3, this.emit(UU.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = MU.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken) throw new ED(ww2.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = cO(this, UU.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t3 = await this.request(VU.REJOIN, e2);
          return !!t3 && (this.connectionState = MU.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t3.peers && t3.peers.forEach((e3) => {
            this.emit(FU.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(FU.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(FU.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(FU.MUTE_AUDIO, { uid: e3.uid }) : this.emit(FU.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(FU.MUTE_VIDEO, { uid: e3.uid }) : this.emit(FU.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(FU.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(FU.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(FU.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(FU.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(FU.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
          }), true);
        }
        reconnect(e2, t3) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t3);
        }
        async downgradeCodec(e2) {
          if (!this.ortc) return false;
          const t3 = { downgrade_codec: e2, ortc: this.ortc };
          return !!await this.request(VU.DOWNGRADE_CODEC, t3);
        }
        handleNotification(e2) {
          sD.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t3 = VV(e2.code);
          if (28 === e2.code && "detail" in e2 && (sD.info("[".concat(this.clientId, "] receive recover notification: "), e2.detail), this.emit(UU.RECOVER_NOTIFICATION, e2.detail)), "success" !== t3.action) {
            if ("failed" !== t3.action) return "quit" === t3.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t3.desc && this.close(Zw2.UID_BANNED), void this.close()) : void this.reconnect(t3.action, iO.SERVER_ERROR);
            sD.error("[".concat(this.clientId, "] ignore error: "), t3.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = wN("PING_PONG_TIME_OUT"), t3 = Date.now();
          this.pingpongTimeoutCount >= e2 && (sD.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(t3 - this.lastMsgTime, "ms")), t3 - this.lastMsgTime > wN("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", iO.TIMEOUT) : this.request(VU.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t3;
            this.rttRolling.add(e3), wN("REPORT_STATS") && this.send(VU.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWsInflateData() {
          const { wsInflateLength: e2, wsDeflateLength: t3 } = this.websocket.getWsInflateData();
          0 !== e2 && 0 !== t3 && this.upload(xU.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t3, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(jU.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(UU.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(jU.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(jU.CLOSED, () => {
            this.connectionState = MU.CLOSED;
          }), this.websocket.on(jU.FAILED, () => {
            this._disconnectedReason = Zw2.NETWORK_ERROR, this.connectionState = MU.CLOSED;
          }), this.websocket.on(jU.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === MU.CONNECTED ? this.connectionState = MU.RECONNECTING : this.connectionState = MU.CONNECTING;
          }), this.websocket.on(jU.WILL_RECONNECT, (e2, t3, i2) => {
            const n3 = cO(this, UU.IS_P2P_DISCONNECTED), r2 = n3 || "retry" !== e2;
            n3 && "retry" === e2 && (sD.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e2 = "tryNext", t3 = oV.P2P_DISCONNECTED), r2 && (sD.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e2)), this.emit(UU.REPORT_JOIN_GATEWAY, t3 || oV.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(UU.DISCONNECT_P2P)), i2(e2);
          }), this.websocket.on(jU.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              sD.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", iO.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(UU.REPORT_JOIN_GATEWAY, e2, this.url || ""), e2 instanceof ED) {
                if (e2.code === ww2.UNEXPECTED_RESPONSE && e2.data.code === kU.ERR_NO_AUTHORIZED) return this.initError = new ED(ww2.TOKEN_EXPIRE, "dynamic key expired"), void this.close(Zw2.TOKEN_EXPIRE);
                sD.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", iO.SERVER_ERROR) : (this.initError = e2, this.close());
              }
            });
          }), this.websocket.on(jU.REQUEST_NEW_URLS, (e2, t3) => {
            oO(this, UU.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t3);
          }), this.websocket.on(jU.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(FU.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          }), this.websocket.on(IV.PRE_CONNECT_PC, () => {
            this.emit(UU.PRE_CONNECT_PC);
          });
        }
      }
      let QV = function(e2) {
        return e2.NATIVE_RTC = "native_rtc", e2.NATIVE_RTM = "native_rtm", e2.WEB_RTC = "web_rtc", e2.WEB_RTM = "web_rtm", e2;
      }({}), $V = function(e2) {
        return e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK", e2;
      }({});
      function ex2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function tx2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? ex2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ex2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      function ix2(e2) {
        return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(wN("TURN_DOMAIN")) : (sD.debug("Cannot recognized as ip address: ".concat(e2, ", use as host2")), e2);
      }
      function nx2(e2) {
        try {
          const t3 = wN("GATEWAY_DOMAINS").concat(wN("TURN_DOMAIN")).find((t4) => Ln2(e2).call(e2, t4));
          if (t3) {
            return e2.split(".".concat(t3))[0].replace(/-/g, ".");
          }
          return e2;
        } catch (t3) {
          return sD.debug("serverUrlToIp error, fallback to url", e2), e2;
        }
      }
      function rx2(e2, t3) {
        e2.addresses || (e2.addresses = []);
        const i2 = function(e3, t4) {
          if (wN("CONNECT_GATEWAY_WITHOUT_DOMAIN")) return e3.map((e4) => {
            let { ip: t5, port: i4 } = e4;
            return { address: "".concat(t5, ":").concat(i4) };
          });
          const i3 = wN("GATEWAY_DOMAINS");
          let n4 = i3[1] && Ln2(t4).call(t4, i3[1]) ? 1 : 0;
          return e3.map((e4) => {
            let { domain_prefix: t5, port: r3, ip: o3 } = e4;
            if (t5) return { address: "".concat(t5, ".").concat(i3[n4++ % i3.length], ":").concat(r3) };
            const s3 = /^[\.\:\d]+$/.test(o3), a3 = s3 ? "".concat(o3.replace(/[^\d]/g, "-"), ".").concat(i3[n4++ % i3.length], ":").concat(r3) : "".concat(o3, ":").concat(r3);
            return s3 || sD.debug("Cannot recognized as ip address: ".concat(o3, ", use as host3")), { ip: o3, port: r3, address: a3 };
          });
        }(e2.addresses, t3), n3 = Array.isArray(e2.detail) && e2.detail[18];
        if (n3 && "string" == typeof n3) {
          const e3 = n3.split(";");
          for (let t4 = 0; t4 < e3.length; t4++) {
            var r2;
            const n4 = Pg2(r2 = e3[t4]).call(r2);
            i2[t4] && n4 && (i2[t4].ip6 = n4);
          }
        }
        const o2 = e2.detail && e2.detail.candidate;
        let s2;
        if (o2) {
          const [e3, t4] = o2.split(":");
          e3 && t4 && (s2 = { port: Number(t4), ip: e3, address: "".concat(e3, ":").concat(t4) });
        }
        return { gatewayAddrs: i2, apGatewayAddress: s2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
      }
      function ox2(e2) {
        return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function sx2(e2) {
        const t3 = e2._encoderConfig;
        if (!t3) return {};
        const i2 = { resolution: t3.width && t3.height ? "".concat(ox2(t3.width), "x").concat(ox2(t3.height)) : void 0, maxVideoBW: t3.bitrateMax, minVideoBW: t3.bitrateMin };
        return "number" == typeof t3.frameRate ? (i2.maxFrameRate = t3.frameRate, i2.minFrameRate = t3.frameRate) : t3.frameRate && (i2.maxFrameRate = t3.frameRate.max || t3.frameRate.ideal || t3.frameRate.exact || t3.frameRate.min, i2.minFrameRate = t3.frameRate.min || t3.frameRate.ideal || t3.frameRate.exact || t3.frameRate.max), i2;
      }
      function ax2(e2) {
        return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
      }
      function cx2(e2, t3) {
        let i2, n3, r2;
        switch (t3) {
          case $V.CHOOSE_SERVER:
            n3 = 4096, r2 = "choose server";
            break;
          case $V.CLOUD_PROXY:
            n3 = 1048576, r2 = "proxy";
            break;
          case $V.CLOUD_PROXY_5:
            n3 = 4194304, r2 = "proxy5";
            break;
          case $V.CLOUD_PROXY_FALLBACK:
            n3 = 4194310, r2 = "proxy fallback";
            break;
          default:
            throw new ED(ww2.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
        }
        if (e2.response_body.forEach((t4) => {
          t4.buffer && t4.buffer.flag === n3 && (i2 = { code: t4.buffer.code, addresses: (t4.buffer.edges_services || []).map((e3) => tx2(tx2({}, e3), {}, { ticket: t4.buffer.cert })), server_ts: e2.enter_ts, uid: t4.buffer.uid, cid: t4.buffer.cid, cname: t4.buffer.cname, detail: tx2(tx2({}, t4.buffer.detail), e2.detail), flag: t4.buffer.flag, opid: e2.opid, cert: t4.buffer.cert });
        }), !i2) throw new ED(ww2.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
        return i2;
      }
      async function dx2(e2, t3) {
        return await ip2.all(e2.addresses.map(async (e3) => ({ address: ix2(e3.ip), tcpport: e3.port, udpport: e3.port, username: t3 && wN("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t3.toString() : RN.username, password: t3 && wN("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await Ww2(t3.toString()) : RN.password })));
      }
      function lx2(e2, t3) {
        const i2 = t3.getMediaStreamTrack(true).getSettings(), n3 = t3.videoHeight || i2.height, r2 = t3.videoWidth || i2.width;
        return n3 && r2 ? Math.max(Math.min(n3, r2) / Math.min(ox2(e2.height), ox2(e2.width)), 1) : (sD.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
      }
      function ux2(e2) {
        let { candidateType: t3, relayProtocol: i2, type: n3, address: r2, port: o2, protocol: s2 } = e2;
        const a3 = { candidateType: t3, relayProtocol: i2, protocol: s2 };
        if ("local-candidate" !== n3) {
          const e3 = r2.split(".");
          e3.length >= 4 && (e3[1] = "*", e3[2] = "*"), a3.address = e3.join("."), a3.port = o2;
        }
        return a3;
      }
      function hx2(e2) {
        const t3 = e2.split(":"), i2 = e2.split(/[-.]/), n3 = Ln2(e2).call(e2, "-") ? "-" : ".";
        let r2 = e2;
        return t3.length > 1 ? i2.length > 1 ? (i2[1] = "**", r2 = i2[0] + n3 + "**:" + t3[t3.length - 1]) : r2 = t3.length > 2 ? t3[0] + n3 + "**:" + t3[t3.length - 1] : "**:" + t3[t3.length - 1] : i2.length > 1 && (r2 = i2[0] + n3 + "**"), r2;
      }
      function px2() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : wN("SVC_MODE");
        if (wN("ENABLE_SVC")) return function(e3) {
          return e3 in cN;
        }(e2) ? e2 : cN.L1T3;
      }
      const _x = { [EV.VIDEO]: [{ key: "abs-send-time", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }, { key: "video-orientation", extensionName: "urn:3gpp:video-orientation" }, { key: "draft-holmer-rmcat-transport-wide-cc-extensions-01", extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }, { key: "playout-delay", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay" }, { key: "video-content-type", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type" }, { key: "color-space", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/color-space" }, { key: "video-timing", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/video-timing" }], [EV.AUDIO]: [{ key: "ssrc-audio-level", extensionName: "urn:ietf:params:rtp-hdrext:ssrc-audio-level" }, { key: "draft-holmer-rmcat-transport-wide-cc-extensions-01", extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }, { key: "abs-send-time", extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }] };
      function Ex2(e2, t3, i2) {
        t3.forEach((t4) => {
          var n3;
          const r2 = _x[e2].find((e3) => {
            var i3;
            let { key: n4 } = e3;
            return Ln2(i3 = t4.extensionName).call(i3, n4);
          });
          if (!r2) return;
          const o2 = i2.find((e3) => {
            let { extensionName: t5 } = e3;
            return Ln2(t5).call(t5, r2.key);
          });
          o2 && Ln2(n3 = o2.extensionName).call(n3, "gdpr_forbidden") && (t4.extensionName = o2.extensionName);
        });
      }
      function mx2(e2, t3) {
        t3.forEach((t4) => {
          var i2;
          const n3 = _x[e2].find((e3) => {
            var i3;
            let { key: n4 } = e3;
            return Ln2(i3 = t4.extensionName).call(i3, n4);
          });
          Ln2(i2 = t4.extensionName).call(i2, "gdpr_forbidden") && n3 && (t4.extensionName = n3.extensionName);
        });
      }
      function fx2(e2) {
        return "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e2 || Ln2(e2).call(e2, "abs-send-time");
      }
      function Sx2(e2) {
        return "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e2 || Ln2(e2).call(e2, "draft-holmer-rmcat-transport-wide-cc-extensions-01");
      }
      function gx2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function Tx2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? gx2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : gx2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      function Rx2(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n3 = arguments.length > 3 ? arguments[3] : void 0;
        const { filterRTX: r2, filterVideoFec: o2, filterAudioFec: s2, filterAudioCodec: a3, filterVideoCodec: c3, unsupportedVideoUplinkCodec: d2, unsupportedVideoDownlinkCodec: l2 } = t3, { useXR: u3 } = i2;
        let h2 = [], p2 = [], _2 = [], E3 = [], m3 = false, f2 = false;
        if (FN(e2).mediaDescriptions.forEach((e3) => {
          n3 && n3 !== e3.attributes.direction || ("video" !== e3.media.mediaType || m3 || (p2 = e3.attributes.payloads, E3 = e3.attributes.extmaps, m3 = true), "audio" !== e3.media.mediaType || f2 || (h2 = e3.attributes.payloads, _2 = e3.attributes.extmaps, f2 = true));
        }), !E3 || 0 === p2.length) throw new Error("Cannot get video capabilities from SDP.");
        if (!_2 || 0 === h2.length) throw new Error("Cannot get audio capabilities from SDP.");
        if (p2.forEach((e3) => {
          var t4;
          null !== (t4 = e3.rtpMap) && void 0 !== t4 && t4.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), u3 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        }), h2.forEach((e3) => {
          var t4;
          null !== (t4 = e3.rtpMap) && void 0 !== t4 && t4.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate)), u3 && e3.rtcpFeedbacks.push({ type: "rrtr" });
        }), r2 && (h2 = h2.filter((e3) => {
          var t4;
          return "rtx" !== (null === (t4 = e3.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase());
        }), p2 = p2.filter((e3) => {
          var t4;
          return "rtx" !== (null === (t4 = e3.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase());
        })), o2) {
          const e3 = p2.filter((e4) => {
            var t5;
            return /(red)|(ulpfec)|(flexfec)/i.test((null === (t5 = e4.rtpMap) || void 0 === t5 ? void 0 : t5.encodingName) || "");
          }), t4 = Fx2(e3, p2).map((e4) => e4.payloadType), i3 = [...e3.map((e4) => e4.payloadType), ...t4];
          p2 = p2.filter((e4) => !Ln2(i3).call(i3, e4.payloadType));
        }
        if (s2 && (h2 = h2.filter((e3) => {
          var t4;
          return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t4 = e3.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName) || "");
        })), a3 && (null == a3 ? void 0 : a3.length) > 0 && (h2 = h2.filter((e3) => {
          var t4;
          return Ln2(a3).call(a3, (null === (t4 = e3.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "");
        })), c3 && (null == c3 ? void 0 : c3.length) > 0) {
          const e3 = p2.filter((e4) => {
            var t4;
            return Ln2(c3).call(c3, (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLowerCase()) || "");
          });
          p2 = e3.concat(r2 ? [] : Fx2(e3, p2));
        }
        const S3 = wN("UNSUPPORTED_VIDEO_CODEC");
        if (S3 && S3.length > 0) {
          const e3 = p2.filter((e4) => e4.rtpMap && Ln2(S3).call(S3, e4.rtpMap.encodingName.toLowerCase())), t4 = Fx2(e3, p2), i3 = e3.concat(t4).map((e4) => e4.payloadType);
          p2 = p2.filter((e4) => !Ln2(i3).call(i3, e4.payloadType)), sD.debug("unsupportedVideoCodec: ".concat(S3, ", toBeRemoved: ").concat(i3));
        }
        if (d2 && d2.length > 0 && "sendonly" === n3) {
          const e3 = p2.filter((e4) => e4.rtpMap && Ln2(d2).call(d2, e4.rtpMap.encodingName.toLowerCase())), t4 = Fx2(e3, p2), i3 = e3.concat(t4).map((e4) => e4.payloadType);
          p2 = p2.filter((e4) => !Ln2(i3).call(i3, e4.payloadType)), sD.debug("unsupportedVideoUplinkCodec: ".concat(d2, ", toBeRemoved: ").concat(i3));
        }
        if (l2 && l2.length > 0 && "recvonly" === n3) {
          const e3 = p2.filter((e4) => e4.rtpMap && Ln2(l2).call(l2, e4.rtpMap.encodingName.toLowerCase())), t4 = Fx2(e3, p2), i3 = e3.concat(t4).map((e4) => e4.payloadType);
          p2 = p2.filter((e4) => !Ln2(i3).call(i3, e4.payloadType)), sD.debug("unsupportedVideoDownlinkCodec: ".concat(l2, ", toBeRemoved: ").concat(i3));
        }
        return { audioCodecs: h2, videoCodecs: p2, audioExtensions: _2, videoExtensions: E3 };
      }
      function vx2(e2) {
        const t3 = FN(e2);
        let i2, n3;
        for (const e3 of t3.mediaDescriptions) {
          if (!i2) {
            const t4 = e3.attributes.iceUfrag, n4 = e3.attributes.icePwd;
            if (!t4 || !n4) throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            i2 = { iceUfrag: t4, icePwd: n4 };
          }
          if (!n3) {
            const t4 = e3.attributes.fingerprints;
            t4.length > 0 && (n3 = { fingerprints: t4 });
          }
        }
        if (!n3 && t3.attributes.fingerprints.length > 0 && (n3 = { fingerprints: t3.attributes.fingerprints }), !n3 || !i2) throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: i2, dtlsParameters: n3 };
      }
      function Cx2(e2, t3) {
        const i2 = [], n3 = e2.attributes.ssrcGroups.filter((e3) => "FID" === e3.semantic), r2 = e2.attributes.ssrcGroups.find((e3) => "SIM" === e3.semantic), o2 = e2.attributes.ssrcs;
        if (r2) r2.ssrcIds.forEach((e3) => {
          var r3;
          const o3 = null === (r3 = n3.find((t4) => t4.ssrcIds[0] === e3)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t3 ? o3 : void 0 });
        });
        else if (n3.length > 0) {
          const e3 = n3[0].ssrcIds[0], r3 = n3[0].ssrcIds[1];
          i2.push({ ssrcId: e3, rtx: t3 ? r3 : void 0 });
        } else {
          if (0 === o2.length) throw new Error("No ssrcs found on local media description.");
          i2.push({ ssrcId: o2[0].ssrcId });
        }
        return i2;
      }
      function yx2(e2, t3, i2) {
        const { cname: n3 } = e2;
        let r2 = [];
        t3 && (r2 = Ix2(t3)), 0 === r2.length && (r2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} })), sD.debug("Using candidates from gateway."));
        const o2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, s2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
        let a3;
        switch (e2.dtlsParameters.role) {
          case "server":
            a3 = "passive";
            break;
          case "client":
            a3 = "active";
            break;
          case "auto":
            a3 = "actpass";
        }
        const c3 = Ux2(e2.rtpCapabilities), d2 = [];
        return Array.isArray(i2) && i2.length > 0 && i2.forEach((e3) => {
          d2.push({ kind: EV.VIDEO, ssrcMsg: [{ ssrcId: e3.v, rtx: e3.v_rtx }], mslabel: "".concat(e3.v, "_").concat(e3.a) }, { kind: EV.AUDIO, ssrcMsg: [{ ssrcId: e3.a }], mslabel: "".concat(e3.v, "_").concat(e3.a) });
        }), { dtlsParameters: o2, iceParameters: s2, candidates: r2, rtpCapabilities: c3, setup: a3, cname: n3, preSSRCs: d2 };
      }
      function Ix2(e2) {
        let t3 = [];
        return e2.ip && "number" == typeof e2.port && (t3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e2.ip, port: e2.port.toString(), type: "host", extension: {} }], sD.debug("Using remote candidate from AP ".concat(hx2(e2.ip), ":").concat(e2.port)), e2.ip6 && (t3.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e2.ip6, port: e2.port.toString(), type: "host", extension: {} }), sD.debug("Using IPV6 remote candidate from AP ".concat(hx2(e2.ip6), ":").concat(e2.port)))), t3;
      }
      function bx2(e2, t3, i2) {
        const n3 = [], r2 = [];
        return e2.forEach((e3) => {
          let { ssrcId: o2, rtx: s2 } = e3;
          const a3 = IO(8, "track-"), c3 = { ssrcId: o2, attributes: Tx2({ label: a3, mslabel: i2 = i2 || IO(10, ""), msid: "".concat(i2, " ").concat(a3) }, t3 && { cname: t3 }) };
          if (n3.push(c3), void 0 !== s2) {
            const e4 = { ssrcId: s2, attributes: Tx2({ label: a3, mslabel: i2, msid: "".concat(i2, " ").concat(a3) }, t3 && { cname: t3 }) };
            n3.push(e4), r2.push({ semantic: "FID", ssrcIds: [o2, s2] });
          }
        }), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
          let { ssrcId: t4 } = e3;
          return t4;
        }) }), { ssrcs: n3, ssrcGroups: r2 };
      }
      function Ax2(e2, t3) {
        t3 instanceof BL && e2.attributes.payloads.forEach((e3) => {
          var i2;
          const n3 = null === (i2 = e3.rtpMap) || void 0 === i2 ? void 0 : i2.encodingName.toLowerCase();
          if (!n3 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n3)) return;
          e3.fmtp || (e3.fmtp = { parameters: {} }), "opus" === n3 && "number" == typeof wN("OPUS_PTIME") ? e3.fmtp.parameters.ptime = wN("OPUS_PTIME") : e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
          const r2 = t3._encoderConfig;
          r2 && ("pcmu" !== n3 && "pcma" !== n3 && "g722" !== n3 && (r2.bitrate && !iw2() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1")), t3 instanceof jL && "opus" === n3 && t3._config.DTX && (e3.fmtp.parameters.usedtx = "1"));
        });
      }
      function wx2(e2) {
        const t3 = e2.attributes.unrecognized.findIndex((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue);
        -1 !== t3 && e2.attributes.unrecognized.splice(t3, 1);
      }
      function Ox2(e2, t3) {
        var i2;
        if (!(t3 instanceof kk2 && t3._encoderConfig && -1 === t3._hints.indexOf(xD.SCREEN_TRACK))) return;
        const n3 = t3._encoderConfig;
        fD2().supportMinBitrate && n3.bitrateMin && e2.attributes.payloads.forEach((e3) => {
          var t4, i3;
          Ln2(t4 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t4, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(n3.bitrateMin));
        }), fD2().supportMinBitrate && !Ln2(i2 = t3._hints).call(i2, xD.LOW_STREAM) && n3.bitrateMax && e2.attributes.payloads.forEach((e3) => {
          var t4, i3;
          Ln2(t4 = ["h264", "h265", "vp8", "vp9", "av1"]).call(t4, (null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(wN("X_GOOGLE_START_BITRATE") || Math.floor(n3.bitrateMax)));
        });
      }
      function Nx2(e2) {
        if ("video" !== e2.media.mediaType) return;
        const t3 = zA2();
        if (t3.name !== WA2.SAFARI && t3.os !== GA2.IOS) return;
        const i2 = e2.attributes.extmaps.findIndex((e3) => /video-orientation/g.test(e3.extensionName));
        -1 !== i2 && e2.attributes.extmaps.splice(i2, 1);
      }
      function Dx2(e2, t3, i2) {
        if (!t3) return;
        let n3, r2;
        if ("video" === e2.media.mediaType ? (n3 = i2.videoExtensions, r2 = i2.videoCodecs) : (n3 = i2.audioExtensions, r2 = i2.audioCodecs), true === t3.twcc) {
          const t4 = n3.find((e3) => Sx2(e3.extensionName));
          if (t4) {
            const i3 = t4.extensionName;
            e2.attributes.extmaps.find((e3) => Sx2(e3.extensionName)) || e2.attributes.extmaps.push({ entry: t4.entry, extensionName: i3 });
            const n4 = function(e3, t5) {
              return t5.filter((t6) => !!e3.find((e4) => e4.payloadType === t6.payloadType && !!e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type)));
            }(r2, e2.attributes.payloads);
            n4.forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "transport-cc" === e4.type) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
            });
          }
        } else if (false === t3.twcc) {
          const t4 = e2.attributes.extmaps.findIndex((e3) => Sx2(e3.extensionName));
          -1 !== t4 && e2.attributes.extmaps.splice(t4, 1), e2.attributes.payloads.forEach((e3) => {
            const t5 = e3.rtcpFeedbacks.findIndex((e4) => "transport-cc" === e4.type);
            -1 !== t5 && e3.rtcpFeedbacks.splice(t5, 1);
          });
        }
        if (true === t3.remb) {
          const t4 = n3.find((e3) => fx2(e3.extensionName));
          if (t4) {
            const i3 = t4.extensionName;
            e2.attributes.extmaps.find((e3) => e3.extensionName === i3) || e2.attributes.extmaps.push({ entry: t4.entry, extensionName: i3 });
            const n4 = function(e3, t5) {
              return t5.filter((t6) => !!e3.find((e4) => e4.payloadType === t6.payloadType && !!e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type)));
            }(r2, e2.attributes.payloads);
            n4.forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => "goog-remb" === e4.type) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
            });
          }
        } else if (false === t3.remb) {
          const t4 = e2.attributes.extmaps.findIndex((e3) => fx2(e3.extensionName));
          -1 !== t4 && e2.attributes.extmaps.splice(t4, 1), e2.attributes.payloads.forEach((e3) => {
            const t5 = e3.rtcpFeedbacks.findIndex((e4) => "goog-remb" === e4.type);
            -1 !== t5 && e3.rtcpFeedbacks.splice(t5, 1);
          });
        }
      }
      function Px2(e2, t3, i2) {
        if (iw2()) return;
        if ("video" !== e2.media.mediaType) return;
        if (!(t3 instanceof kk2)) return;
        if ("vp9" !== i2 && "vp8" !== i2) return;
        if ("vp8" === i2 && !wN("SIMULCAST")) return;
        if ("vp9" === i2 && wN("ENABLE_SVC")) return;
        if (void 0 === t3._scalabilityMode || t3._scalabilityMode.numSpatialLayers <= 1) return;
        const n3 = "vp8" === i2 ? 2 : t3._scalabilityMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], o2 = e2.attributes.ssrcGroups.find((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId), s2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
        for (let t4 = 1; t4 < n3; t4++) e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t4, attributes: pO(r2.attributes) }), s2.ssrcIds.push(r2.ssrcId + t4), o2 && (e2.attributes.ssrcs.push({ ssrcId: o2.ssrcIds[1] + t4, attributes: pO(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t4, o2.ssrcIds[1] + t4] }));
        e2.attributes.ssrcGroups.unshift(s2);
      }
      async function Lx2() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = new RTCPeerConnection();
        i2.addTransceiver("video", { direction: "sendonly" }), i2.addTransceiver("audio", { direction: "sendonly" }), i2.addTransceiver("video", { direction: "recvonly" }), i2.addTransceiver("audio", { direction: "recvonly" });
        const n3 = (await i2.createOffer()).sdp, { send: r2, recv: o2, sendrecv: s2 } = function() {
          let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i3 = arguments.length > 2 ? arguments[2] : void 0;
          const n4 = Rx2(i3, e3, t4, "sendonly"), r3 = Rx2(i3, e3, t4, "recvonly"), o3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, s3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, a3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (Mx2(n4, r3, "videoExtensions", o3, s3, a3), Mx2(n4, r3, "videoCodecs", o3, s3, a3), Mx2(n4, r3, "audioExtensions", o3, s3, a3), Mx2(n4, r3, "audioCodecs", o3, s3, a3), wN("RAISE_H264_BASELINE_PRIORITY")) {
            const e4 = [], t5 = [];
            if (a3.videoCodecs.forEach((i4, n5) => {
              var r4;
              if ("h264" === (null === (r4 = i4.rtpMap) || void 0 === r4 ? void 0 : r4.encodingName.toLocaleLowerCase())) {
                var o4, s4;
                const r5 = a3.videoCodecs[n5 + 1], c3 = r5 && Hx2(i4, r5), d2 = null === (o4 = i4.fmtp) || void 0 === o4 ? void 0 : o4.parameters["profile-level-id"], l2 = null === (s4 = i4.fmtp) || void 0 === s4 ? void 0 : s4.parameters["packetization-mode"];
                !d2 || d2 !== wN("FIRST_H264_PROFILE_LEVEL_ID") || wN("FIRST_PACKETIZATION_MODE") && l2 !== wN("FIRST_PACKETIZATION_MODE") ? c3 ? t5.push([i4, r5]) : t5.push([i4]) : c3 ? e4.push([i4, r5]) : e4.push([i4]);
              }
            }), e4.length > 0 && t5.length > 0) {
              sD.debug("raising H264 baseline profile priority"), a3.videoCodecs.forEach((i5, n5) => {
                var r4;
                if ("h264" === (null === (r4 = i5.rtpMap) || void 0 === r4 ? void 0 : r4.encodingName.toLocaleLowerCase())) {
                  const r5 = Hx2(i5, a3.videoCodecs[n5 + 1]), o4 = e4.shift() || t5.shift() || [];
                  o4.length > 0 && (r5 ? a3.videoCodecs.splice(n5, 2, ...o4) : a3.videoCodecs.splice(n5, 1, ...o4));
                }
              });
              const i4 = s3.videoCodecs.filter((e5) => {
                var t6, i5;
                return "h264" === (null === (t6 = e5.rtpMap) || void 0 === t6 ? void 0 : t6.encodingName.toLocaleLowerCase()) && (null === (i5 = e5.fmtp) || void 0 === i5 ? void 0 : i5.parameters["profile-level-id"]) !== wN("FIRST_H264_PROFILE_LEVEL_ID");
              });
              if (i4.length > 0) {
                const e5 = Fx2(i4, s3.videoCodecs).map((e6) => e6.payloadType), t6 = [...i4.map((e6) => e6.payloadType), ...e5];
                s3.videoCodecs = s3.videoCodecs.filter((e6) => !Ln2(t6).call(t6, e6.payloadType));
              }
              wN("FILTER_SEND_H264_BASELINE") && (o3.videoCodecs = o3.videoCodecs.filter((e5) => {
                var t6, i5;
                return !("h264" === (null === (t6 = e5.rtpMap) || void 0 === t6 ? void 0 : t6.encodingName.toLocaleLowerCase()) && (null === (i5 = e5.fmtp) || void 0 === i5 ? void 0 : i5.parameters["profile-level-id"]) !== wN("FIRST_H264_PROFILE_LEVEL_ID"));
              }));
            }
            return { send: o3, recv: s3, sendrecv: a3 };
          }
          return { send: o3, recv: s3, sendrecv: a3 };
        }(e2, t3, n3);
        try {
          i2.close();
        } catch (e3) {
        }
        return { send: r2, recv: o2, sendrecv: s2 };
      }
      function kx2() {
        const e2 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t3 = Rx2(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "recvonly"), i2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
        if (Mx2(e2, t3, "videoExtensions", i2, n3, r2), Mx2(e2, t3, "videoCodecs", i2, n3, r2), Mx2(e2, t3, "audioExtensions", i2, n3, r2), Mx2(e2, t3, "audioCodecs", i2, n3, r2), wN("RAISE_H264_BASELINE_PRIORITY")) {
          const e3 = r2.videoCodecs.findIndex((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" === e4.fmtp.parameters["profile-level-id"]);
          if (-1 !== e3) {
            const t4 = r2.videoCodecs.findIndex((e4) => e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase());
            if (t4 < e3) {
              sD.debug("raising H264 baseline profile priority");
              const i3 = r2.videoCodecs[e3];
              r2.videoCodecs.splice(e3, 1), r2.videoCodecs.splice(t4, 0, i3);
            }
            -1 !== t4 && (n3.videoCodecs = n3.videoCodecs.filter((e4) => !(e4.rtpMap && "h264" === e4.rtpMap.encodingName.toLocaleLowerCase() && e4.fmtp && "42001f" !== e4.fmtp.parameters["profile-level-id"])));
          }
        }
        return { send: i2, recv: n3, sendrecv: r2 };
      }
      function Mx2(e2, t3, i2, n3, r2, o2) {
        if ("videoExtensions" === i2 || "audioExtensions" === i2) {
          const s2 = [];
          return e2[i2].forEach((e3) => {
            t3[i2].some((t4, i3) => {
              if (e3.entry === t4.entry && e3.extensionName === t4.extensionName) return s2.push(i3), true;
            }) ? o2[i2].push(e3) : n3[i2].push(e3);
          }), void t3[i2].forEach((e3, t4) => {
            -1 === s2.indexOf(t4) && r2[i2].push(e3);
          });
        }
        if ("videoCodecs" === i2 || "audioCodecs" === i2) {
          const s2 = [];
          return e2[i2].forEach((e3) => {
            t3[i2].some((t4, i3) => {
              if (e3.payloadType === t4.payloadType && JSON.stringify(e3) === JSON.stringify(t4)) return s2.push(i3), true;
            }) ? o2[i2].push(e3) : n3[i2].push(e3);
          }), void t3[i2].forEach((e3, t4) => {
            -1 === s2.indexOf(t4) && r2[i2].push(e3);
          });
        }
      }
      function Ux2(e2) {
        const { send: t3, recv: i2, sendrecv: n3 } = e2;
        if (!n3) {
          if (!t3 || !i2) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t3, recv: i2 };
        }
        let r2, o2;
        return t3 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t3.audioCodecs, ...n3.audioCodecs], r2.videoCodecs = [...t3.videoCodecs, ...n3.videoCodecs], r2.audioExtensions = [...t3.audioExtensions, ...n3.audioExtensions], r2.videoExtensions = [...t3.videoExtensions, ...n3.videoExtensions]) : r2 = n3, i2 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...i2.audioCodecs, ...n3.audioCodecs], o2.videoCodecs = [...i2.videoCodecs, ...n3.videoCodecs], o2.audioExtensions = [...i2.audioExtensions, ...n3.audioExtensions], o2.videoExtensions = [...i2.videoExtensions, ...n3.videoExtensions]) : o2 = n3, { send: r2, recv: o2 };
      }
      function Vx2(e2) {
        if ("audio" !== e2.media.mediaType) return;
        e2.attributes.payloads.filter((e3) => {
          var t3;
          return "opus" === (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
        }).forEach((e3) => {
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
        });
      }
      function xx2(e2, t3, i2, n3) {
        let r2 = [];
        if (e2 === EV.VIDEO) {
          if (wN("H264_PROFILE_LEVEL_ID") && "h264" === n3 && (r2 = t3.videoCodecs.filter((e3) => {
            var t4;
            return Ln2(t4 = e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").call(t4, n3) && e3 && e3.fmtp && e3.fmtp.parameters["profile-level-id"] === wN("H264_PROFILE_LEVEL_ID");
          })), !Array.isArray(r2) || 0 === r2.length) {
            let e3 = [];
            const o2 = [], s2 = [], a3 = [];
            if (i2.videoCodecs.forEach((t4) => {
              const i3 = t4.rtpMap && t4.rtpMap.encodingName.toLowerCase() || "";
              Ln2(i3).call(i3, n3) ? e3.push(t4) : Ln2(i3).call(i3, "vp9") ? o2.push(t4) : Ln2(i3).call(i3, "vp8") ? s2.push(t4) : Ln2(i3).call(i3, "h264") && a3.push(t4);
            }), 0 === e3.length) {
              let t4 = "";
              0 !== o2.length ? (e3 = o2, t4 = "vp9") : 0 !== s2.length ? (e3 = s2, t4 = "vp8") : 0 !== a3.length && (e3 = a3, t4 = "h264"), sD.warning("codec ".concat(n3, " not included in rtpCapabilities, fallback to default payloads: ").concat(t4));
            }
            0 !== e3.length && (r2 = t3.videoCodecs.filter((t4) => e3.some((e4) => e4.payloadType === t4.payloadType)));
          }
          if (0 === r2.length && (sD.warning("codec ".concat(n3, " not included in rtpCapabilities, fallback to default payloads: ").concat(t3.videoCodecs[0].rtpMap && t3.videoCodecs[0].rtpMap.encodingName)), r2 = t3.videoCodecs), wN("USE_PUB_RTX") || wN("USE_SUB_RTX")) {
            const e3 = Fx2(r2, t3.videoCodecs);
            r2 = [...r2, ...e3];
          }
        } else {
          r2 = t3.audioCodecs.filter((e4) => {
            var t4;
            return Ln2(t4 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t4, n3);
          });
          const e3 = t3.audioCodecs.filter((e4) => {
            var t4;
            return Ln2(t4 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t4, "red");
          });
          0 === r2.length && (sD.warning("codec ".concat(n3, " not included in rtpCapabilities, fallback to opus")), r2 = t3.audioCodecs.filter((e4) => {
            var t4;
            return Ln2(t4 = e4.rtpMap && e4.rtpMap.encodingName.toLowerCase() || "").call(t4, "opus");
          })), wN("ENABLE_AUDIO_RED") && 0 !== e3.length && (r2 = [...e3, ...r2]);
        }
        return r2;
      }
      function Fx2(e2, t3) {
        const i2 = e2.map((e3) => e3.payloadType.toString());
        return t3.filter((e3) => e3.rtpMap && "rtx" === e3.rtpMap.encodingName && e3.fmtp && e3.fmtp.parameters.apt && Ln2(i2).call(i2, e3.fmtp && e3.fmtp.parameters.apt));
      }
      async function Bx2(e2, t3, i2) {
        const n3 = t3.toString(), r2 = Gx2(n3, "offer", "remote", "exchangeSDP");
        await e2.setRemoteDescription({ type: "offer", sdp: n3 });
        const o2 = await e2.createAnswer();
        if (!o2.sdp) throw new Error("cannot get answer sdp");
        let s2 = o2.sdp;
        s2 = jx2(s2, i2 || {}), null == r2 || r2(s2 || ""), await e2.setLocalDescription({ type: "answer", sdp: s2 });
      }
      function jx2(e2, t3, i2) {
        const n3 = FN(e2), { useXR: r2 } = t3;
        return n3.mediaDescriptions.forEach((e3) => {
          var t4;
          e3.attributes.mid && (Array.isArray(i2) && !Ln2(i2).call(i2, e3.attributes.mid) || ("audio" === e3.media.mediaType && Vx2(e3), r2 && Ln2(t4 = ["audio", "video"]).call(t4, e3.media.mediaType) && e3.attributes.payloads.forEach((e4) => {
            -1 === e4.rtcpFeedbacks.findIndex((e5) => "rrtr" === e5.type) && e4.rtcpFeedbacks.push({ type: "rrtr" });
          })));
        }), BN(n3);
      }
      function Gx2(e2, t3, i2, n3) {
        if (wN("SDP_LOGGING")) return sD.upload("exchanging ".concat(i2, " ").concat(t3, " SDP during P2PConnection.").concat(n3, "\n"), e2), "offer" === t3 ? (e3) => {
          Gx2(e3, "answer", "local" === i2 ? "remote" : "local", n3);
        } : void 0;
      }
      function Wx2(e2) {
        const t3 = wN("COMPATIBLE_SDP_EXTENSION");
        return !!(Array.isArray(t3) && t3.length > 0) && t3.some((t4) => Ln2(e2).call(e2, t4));
      }
      function Hx2(e2, t3) {
        try {
          var i2;
          return (null === (i2 = e2.fmtp) || void 0 === i2 ? void 0 : i2.parameters.apt) === t3.payloadType.toString();
        } catch (e3) {
          return false;
        }
      }
      function Kx2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function Yx2(e2, t3) {
        return typeof wN(e2) === t3 ? wN(e2) : void 0;
      }
      function zx2() {
        try {
          const e2 = wN("EXPERIMENTS") || {};
          return "string" == typeof e2 || Array.isArray(e2) ? {} : function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i2 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? Kx2(Object(i2), true).forEach(function(t4) {
                uI(e3, t4, i2[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i2)) : Kx2(Object(i2)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i2, t4));
              });
            }
            return e3;
          }({}, e2);
        } catch (e2) {
          return sD.debug("handle gateway attributes failed: ", e2), {};
        }
      }
      const qx2 = {};
      function Xx2(e2) {
        (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) && sD.debug("install service ".concat(e2.name)), qx2[e2.name] = e2;
      }
      function Jx2(e2) {
        const t3 = qx2[e2];
        if (!t3) throw new Ow2(ww2.INVALID_OPERATION, "".concat(e2, " not found, please use AgoraRTC.use(").concat(e2, "Service) to load it first"));
        return t3;
      }
      function Zx2(e2, t3) {
        return Jx2("DataStream").create(e2, t3);
      }
      function Qx2() {
        return Jx2("InterceptFrame").create();
      }
      function $x2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function eF(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? $x2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : $x2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const tF = /* @__PURE__ */ new Map();
      class iF extends Hw2 {
        get state() {
          return this._state;
        }
        set state(e2) {
          if (e2 === this._state) return;
          const t3 = this._state;
          this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit(rV.CONNECTION_STATE_CHANGE, e2, t3, this._disconnectedReason) : this.emit(rV.CONNECTION_STATE_CHANGE, e2, t3);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e2) {
          sD.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
        }
        constructor(e2, t3) {
          var i2, n3, r2;
          super(), uI(this, "store", void 0), uI(this, "joinInfo", void 0), uI(this, "key", void 0), uI(this, "ntpOffset", 0), uI(this, "signal", void 0), uI(this, "role", void 0), uI(this, "isPreallocation", void 0), uI(this, "isPreSub", void 0), uI(this, "inChannelInfo", { joinAt: null, duration: 0 }), uI(this, "spec", void 0), uI(this, "_state", "DISCONNECTED"), uI(this, "_statsCollector", void 0), uI(this, "_disconnectedReason", void 0), uI(this, "isSignalRecover", false), uI(this, "hasChangeBGPAddress", false), uI(this, "trafficStatsInterval", void 0), uI(this, "networkQualityInterval", void 0), uI(this, "_joinGatewayStartTime", 0), uI(this, "_signalTimeout", false), uI(this, "_clientRoleOptions", void 0), uI(this, "_isProactiveJoin", false), this.store = e2, this.spec = t3, this.signal = this.store.useP2P ? (i2 = { spec: eF(eF({}, t3), {}, { retryConfig: t3.websocketRetryConfig }), store: e2 }, null === (n3 = (r2 = Jx2("P2PChannel")).createSubmodule) || void 0 === n3 ? void 0 : n3.call(r2, i2)) : new ZV(eF(eF({}, t3), {}, { retryConfig: t3.websocketRetryConfig }), e2), this._statsCollector = t3.statsCollector, this.role = t3.role || "audience", this._clientRoleOptions = t3.clientRoleOptions, this.handleSignalEvents();
        }
        async join(e2, t3, i2) {
          this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
          const n3 = Date.now();
          let r2 = tF.get(e2.cname);
          if (r2 || (r2 = /* @__PURE__ */ new Map(), tF.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
            const t4 = new ED(ww2.UID_CONFLICT);
            throw _D.joinGateway(e2.sid, { lts: n3, succ: false, ec: t4.code, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, isProxy: !!e2.proxyServer, signalChannel: "0", preload: e2.preload }), t4;
          }
          r2.set(e2.uid, true), this.joinInfo = e2, this.key = t3;
          let o2 = 0;
          this.joinGatewayStartTime = n3;
          const s2 = e2.proxyServer;
          try {
            sD.debug("[".concat(this.store.clientId, "] use websocket join uid ").concat(o2));
            const t4 = e2.gatewayAddrs.map((t5) => {
              let { address: i3 } = t5;
              const [n4, r3] = i3.split(":"), o3 = { host: n4, port: r3 };
              return e2.proxyServer && (o3.proxy = e2.proxyServer), o3;
            });
            o2 = (await this.signal.init(t4)).uid, sD.debug("[".concat(this.store.clientId, "] websocket join uid ").concat(o2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
          } catch (t4) {
            var a3;
            throw sD.error("[".concat(this.store.clientId, "] User join failed"), t4.toString()), _D.joinGateway(e2.sid, { lts: n3, succ: false, ec: (null === (a3 = t4.data) || void 0 === a3 ? void 0 : a3.desc) || t4.code, errorMsg: t4.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, isProxy: !!s2, signalChannel: "0", preload: e2.preload }), r2.delete(e2.uid), this.signal.close(), t4;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), sD.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
            this.updateTrafficStats().catch((e3) => {
              sD.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
            });
          }, 3e3), this.networkQualityInterval = window.setInterval(() => {
            navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(rV.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(rV.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(rV.NETWORK_QUALITY, { uplinkNetworkQuality: ax2(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: ax2(this._statsCollector.trafficStats.B_dnq) }) : this.emit(rV.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }, 2e3), this.store.joinGatewayEnd(), o2;
        }
        async leave() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t3 = arguments.length > 1 ? arguments[1] : void 0;
          if ("DISCONNECTED" !== this.state) {
            t3 !== Zw2.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e2 || this.signal.connectionState !== MU.CONNECTED || await function(e3, t4) {
                return t4 === 1 / 0 ? e3 : ip2.race([e3, CO(t4)]);
              }(this.signal.request(VU.LEAVE, void 0, true), 3e3);
            } catch (e3) {
              sD.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
            }
            this.signal.close(t3), t3 !== Zw2.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e2, t3, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const n3 = { state: "offer", p2p_id: this.store.p2pId, ortc: t3, mode: this.spec.mode, extend: wN("PUB_EXTEND"), twcc: !!wN("PUBLISH_TWCC"), rtx: !!wN("USE_PUB_RTX") };
          try {
            return (await this.signal.request(VU.PUBLISH, n3, true))._message;
          } catch (n4) {
            if (i2 && n4.data && n4.data.code === kU.ERR_PUBLISH_REQUEST_INVALID) return sD.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n4.toString()), await this.tryUnpubBeforeRepub(e2, t3), this.publish(e2, t3, false);
            throw n4;
          }
        }
        async publishDataChannel(e2, t3, i2) {
          var n3;
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const r2 = { stream_id: t3.streamId, ordered: t3.ordered ? 1 : 0, max_retrans_times: null !== (n3 = t3.maxRetransmits) && void 0 !== n3 ? n3 : 10, channel_id: t3.channelId, metadata: t3.metadata };
          try {
            await this.signal.request(VU.PUBLISH_DATASTREAM, r2, true);
          } catch (n4) {
            if (i2 && n4.data && n4.data.code === kU.ERR_PUBLISH_REQUEST_INVALID) return sD.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), n4.toString()), await this.tryUnpubDataChannelBeforeRepub(e2, t3), this.publishDataChannel(e2, t3, false);
            throw n4;
          }
        }
        async unpublish(e2, t3) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(VU.UNPUBLISH, { stream_id: t3, ortc: e2 }, true);
          } catch (e3) {
            sD.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
          }
        }
        async unpublishDataChannel(e2) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await ip2.all(e2.map((e3) => this.signal.request(VU.UNPUBLISH_DATASTREAM, { channel_id: e3 }, true)));
          } catch (e3) {
            sD.warning("unpublish datachannels warning: ", e3);
          }
        }
        async presubscribe(e2, t3, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not presubscribe when connection state is ".concat(this.state));
          const n3 = { stream_id: e2, stream_type: t3, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!wN("SUBSCRIBE_TWCC"), rtx: !!wN("USE_SUB_RTX") || void 0, extend: wN("SUB_EXTEND"), svc: Array.isArray(wN("SVC")) && 0 !== wN("SVC").length ? wN("SVC") : void 0 };
          try {
            return await this.signal.request(VU.PRE_SUBSCRIBE, n3, true);
          } catch (n4) {
            if (i2 && n4.data && n4.data.code === kU.ERR_SUBSCRIBE_REQUEST_INVALID) return sD.warning("[".concat(this.store.clientId, "] pre-subscribe error, retry"), n4.toString()), this.presubscribe(e2, t3, false);
            throw n4;
          }
        }
        async subscribe(e2, t3, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const n3 = { stream_id: e2, stream_type: t3.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!wN("SUBSCRIBE_TWCC"), rtx: !!wN("USE_SUB_RTX"), extend: wN("SUB_EXTEND"), ssrcId: t3.ssrcId, svc: Array.isArray(wN("SVC")) && 0 !== wN("SVC").length ? wN("SVC") : void 0 };
          try {
            return (await this.signal.request(VU.SUBSCRIBE, n3, true))._message;
          } catch (n4) {
            if (i2 && n4.data && n4.data.code === kU.ERR_SUBSCRIBE_REQUEST_INVALID) return sD.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n4.toString()), await this.tryUnsubBeforeResub(e2, t3), await this.subscribe(e2, t3, false);
            throw n4;
          }
        }
        async subscribeDataChannel(e2, t3, i2) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
          const n3 = { uid: e2, stream_id: t3.id, channel_id: t3.datachannelId };
          try {
            return void await this.signal.request(VU.SUBSCRIBE_DATASTREAM, n3, true);
          } catch (n4) {
            if (i2 && n4.data && n4.data.code === kU.ERR_SUBSCRIBE_REQUEST_INVALID) return sD.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), n4.toString()), await this.tryUnsubDataChannelBeforeResub(e2, t3), await this.subscribeDataChannel(e2, t3, false);
            throw n4;
          }
        }
        async subscribeAll(e2, t3) {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const i2 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!wN("USE_SUB_RTX"), twcc: !!wN("SUBSCRIBE_TWCC"), svc: Array.isArray(wN("SVC")) && 0 !== wN("SVC").length ? wN("SVC") : void 0 };
          try {
            return await this.signal.request(VU.SUBSCRIBE_STREAMS, i2, true);
          } catch (i3) {
            if (t3 && i3.data && i3.data.code === kU.ERR_SUBSCRIBE_REQUEST_INVALID) return sD.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i3.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
            throw i3;
          }
        }
        async setVideoProfile(e2) {
          const t3 = function(e3) {
            if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width)) return;
            let t4 = e3.frameRate, i2 = e3.width, n3 = e3.height, r2 = true;
            return "number" != typeof t4 && (t4 = t4.exact || t4.ideal || t4.max || t4.min || 0, t4 || (r2 = false)), "number" != typeof i2 && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, i2 || (r2 = false)), "number" != typeof n3 && (n3 = n3.exact || n3.ideal || n3.max || n3.min || 0, t4 || (r2 = false)), r2 ? { stream_type: 0, width: i2, height: n3, fps: t4, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
          }(e2);
          if (t3) return this.signal.request(VU.SET_VIDEO_PROFILE, t3);
          sD.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e2, t3) {
          try {
            await this.signal.request(VU.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t3 }, true);
          } catch (e3) {
            sD.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
          }
        }
        async unsubscribeDataChannel(e2, t3) {
          try {
            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new ED(ww2.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await ip2.all(e2.map((e3) => this.signal.request(VU.UNSUBSCRIBE_DATASTREAM, { stream_id: e3, uid: t3 }, true)));
          } catch (e3) {
            sD.warning("unsubscribeDataChannel warning: ", e3);
          }
        }
        async massUnsubscribe(e2) {
          try {
            await this.signal.request(VU.UNSUBSCRIBE_STREAMS, e2, true);
          } catch (e3) {
            sD.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
          }
        }
        async reconnectPC(e2) {
          const { iceParameters: t3, dtlsParameters: i2, rtpCapabilities: n3 } = e2;
          return { gatewayEstablishParams: await this.signal.request(VU.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t3, dtlsParameters: i2, rtpCapabilities: n3 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
        }
        getGatewayInfo() {
          return this.signal.request(VU.GATEWAY_INFO);
        }
        async renewToken(e2) {
          await this.signal.request(VU.RENEW_TOKEN, e2), this.key = e2.token;
        }
        updateClientRole(e2, t3) {
          t3 && (this._clientRoleOptions = Object.assign({}, t3)), wN("CLIENT_ROLE_OPTIONS") && (sD.debug("[".concat(this.store.clientId, "] Set roleOptions for ").concat(JSON.stringify(wN("CLIENT_ROLE_OPTIONS")), " instead of ").concat(JSON.stringify(this._clientRoleOptions), " ")), this._clientRoleOptions = Object.assign({}, wN("CLIENT_ROLE_OPTIONS"))), this.role = e2;
        }
        async setClientRole(e2, t3) {
          if (t3 && (this._clientRoleOptions = Object.assign({}, t3)), wN("CLIENT_ROLE_OPTIONS") && (this._clientRoleOptions = Object.assign({}, wN("CLIENT_ROLE_OPTIONS")), sD.debug("[".concat(this.store.clientId, "] Set roleOptions for ").concat(JSON.stringify(wN("CLIENT_ROLE_OPTIONS")), " instead of ").concat(JSON.stringify(this._clientRoleOptions), " "))), "CONNECTED" !== this.state) return void (this.role = e2);
          let i2, n3 = 0;
          "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i2 = this._clientRoleOptions.delay, n3 = 1) : n3 = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : n3 = 0;
          const r2 = Object.assign({}, t3);
          delete r2.delay, delete r2.level, await this.signal.request(VU.SET_CLIENT_ROLE, eF(eF({ role: e2, level: n3, delay: i2 }, r2), {}, { client_ts: Date.now() })), this.role = e2;
        }
        async setRemoteVideoStreamType(e2, t3) {
          await this.signal.request(VU.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t3 });
        }
        async setDefaultRemoteVideoStreamType(e2) {
          await this.signal.request(VU.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
        }
        async setStreamFallbackOption(e2, t3) {
          await this.signal.request(VU.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t3 });
        }
        async pickSVCLayer(e2, t3) {
          await this.signal.request(VU.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t3.spatialLayer, temporal_layer: t3.temporalLayer });
        }
        async setRTM2Flag(e2) {
          await this.signal.request(VU.SET_RTM2_FLAG, { rtm2_flag: e2 });
        }
        async sendExtensionMessage(e2, t3, i2) {
          if (this.store.useP2P) return this.signal.sendExtensionMessage(e2, t3, i2);
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), eF({}, this.inChannelInfo);
        }
        async getGatewayVersion() {
          return (await this.signal.request(VU.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e2 = tF.get(this.joinInfo.cname);
            e2 && e2.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo) return;
          const e2 = function(e3) {
            let t3;
            return t3 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t3 ? { username: RN.username, password: RN.password, turnServerURL: t3[2], tcpport: parseInt(t3[3]) + 30, udpport: parseInt(t3[3]) + 30, forceturn: false } : null;
          }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(eF(eF({}, RN), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if ("CONNECTED" !== this.state) return;
          const e2 = await this.signal.request(VU.TRAFFIC_STATS, void 0, true);
          e2.timestamp = Date.now(), null != e2.ntp_offset && (this.ntpOffset = e2.ntp_offset), e2.peer_delay.forEach((e3) => {
            const t3 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3.peer_uid);
            t3 && t3.B_st !== e3.B_st && hO(() => {
              this.emit(rV.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
            });
          }), this._statsCollector.updateTrafficStats(e2);
        }
        getJoinMessage(e2) {
          var t3, i2;
          if (!this.joinInfo || !this.key) throw new ED(ww2.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const n3 = Object.assign({}, this.joinInfo.apResponse);
          let r2 = wN("REPORT_APP_SCENARIO");
          if ("string" != typeof r2) try {
            r2 = JSON.stringify(r2);
          } catch (e3) {
            r2 = void 0;
          }
          var o2;
          r2 && r2.length > 128 && (r2 = void 0), this.store.hasStartJoinChannel = true, this.store.isABTestSuccess || this.emit(rV.UPDATE_GATEWAY_CONFIG), o2 = this.store.clientId, Ln2(HM).call(HM, o2) || HM.push(o2);
          const s2 = TD(this.store), a3 = !(null === (t3 = this.isPreallocation) || void 0 === t3 || !t3.call(this)), c3 = RD(this.store), d2 = zx2(), l2 = rw2(87) || ew2() || cw2(117), u3 = (function() {
            const e3 = zA2();
            if (e3.name !== WA2.SAFARI || !e3.browserVersion) return false;
            const t4 = e3.browserVersion.split(".");
            return Number(t4[0]) > 18 || 18 === Number(t4[0]) && Number(t4[1]) >= 4;
          }() || lw2(18, 4, false)) && hw2(18, 6, true) && "h264" === this.spec.codec && wN("ENABLE_ABSSENDTIME_AS_SENTTS"), h2 = eF({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: SN, browser: navigator.userAgent, process_id: wN("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: n3, extend: wN("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: r2, attributes: { userAttributes: eF(eF({ enableEncodedTransform: (!!wN("ENABLE_AUDIO_METADATA") || !!wN("ENABLE_AUDIO_PTS")) && l2 || !!wN("ENABLE_AUDIO_TOPN") && sw2(WA2.CHROME, 87, 116) || void 0, enableAudioMetadata: !!wN("ENABLE_AUDIO_METADATA") && l2, enableAudioPts: !!wN("ENABLE_AUDIO_PTS") && l2, topnSmoothLevel: wN("TOPN_SMOOTH_LEVEL"), topnNewSpeakerDelay: wN("TOPN_NEW_SPEAKER_DELAY"), topnSwitchHoldMs: wN("TOPN_SWITCH_HOLD_MS"), topnAudioGain: wN("TOPN_AUDIO_GAIN"), enablePublishedUserList: wN("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: wN("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: Yx2("SUBSCRIBE_AUDIO_FILTER_TOPN", "number"), enablePublishAudioFilter: Yx2("ENABLE_PUBLISH_AUDIO_FILTER", "boolean"), enableUserLicenseCheck: Yx2("ENABLE_USER_LICENSE_CHECK", "boolean"), enableRTX: true === wN("USE_PUB_RTX") || true === wN("USE_SUB_RTX") || void 0, disableFEC: wN("DISABLE_FEC"), enableNTPReport: !!wN("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: c3, enableFulllinkAvSync: !!wN("ENABLE_FULL_LINK_AV_SYNC") || void 0, enableDataStream2: Yx2("ENABLE_DATASTREAM_2", "boolean"), enableAutFeedback: !!wN("FORCE_ENABLE_AUT_CC") || !gD2() && (!!wN("ENABLE_AUT_FEEDBACK") || void 0), rtm2Flag: "number" == typeof this.joinInfo.rtmFlag ? this.joinInfo.rtmFlag : void 0, enableUserAutoRebalanceCheck: !!wN("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: Yx2("USE_XR", "boolean"), enableLossbasedBwe: Yx2("ENABLE_LOSSBASED_BWE", "boolean"), enableAutCC: !!wN("FORCE_ENABLE_AUT_CC") || !gD2() && (!!wN("ENABLE_AUT_CC") || void 0), enableCCFallback: Yx2("ENABLE_CC_FALLBACK", "boolean"), enablePreallocPC: a3, preSubNum: s2 ? Yx2("PRE_SUB_NUM", "number") : void 0, enablePubTWCC: Yx2("PUBLISH_TWCC", "boolean"), enableSubTWCC: Yx2("SUBSCRIBE_TWCC", "boolean"), enablePubRTX: Yx2("USE_PUB_RTX", "boolean"), enableSubRTX: Yx2("USE_SUB_RTX", "boolean"), enableSubSVC: wN("ENABLE_SVC") ? wN("ENABLE_SVC_DEFAULT_CODECS") : Array.isArray(wN("SVC")) && 0 !== wN("SVC").length ? wN("SVC") : void 0, enableSvcExtended: wN("ENABLE_SVC") && Array.isArray(wN("SVC_EXTENDED")) && 0 !== wN("SVC_EXTENDED").length ? wN("SVC_EXTENDED") : void 0 }, d2), {}, { audioDuplicate: Yx2("ENABLE_AUDIO_RED", "boolean") ? null !== (i2 = Yx2("AUDIO_DUPLICATE_NUM", "number")) && void 0 !== i2 ? i2 : 2 : void 0, senttsUsesAbsSendTime: !!u3 || void 0 }) }, join_ts: this.joinGatewayStartTime }, e2);
          return this.joinInfo.stringUid && (h2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (h2.aes_mode = this.joinInfo.aesmode, wN("ENCRYPT_AES") ? (h2.aes_secret = this.joinInfo.aespassword, h2.aes_encrypt = true) : h2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (h2.aes_salt = this.joinInfo.aessalt)), n3.addresses[this.signal.websocket.currentURLIndex] && (h2.ap_response.ticket = n3.addresses[this.signal.websocket.currentURLIndex].ticket, delete n3.addresses), void 0 !== this.joinInfo.defaultVideoStream && (h2.default_video_stream = this.joinInfo.defaultVideoStream), h2;
        }
        getRejoinMessage() {
          if (!this.joinInfo) throw new ED(ww2.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(UU.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
            this.joinGatewayStartTime = Date.now();
          }), this.signal.on(UU.WS_RECONNECTING, (e2) => {
            this.joinInfo && _D.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || iO.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", _D.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode, stringUid: this.joinInfo.stringUid, channelProfile: "live" === this.spec.mode ? 1 : 0, channelMode: 0, lsid: this.joinInfo.sid, clientRole: "audience" === this.role ? 2 : 1, buildFormat: 1 }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          }), this.signal.on(UU.WS_CLOSED, (e2) => {
            let t3;
            switch (e2) {
              case Zw2.LEAVE:
                t3 = iO.LEAVE;
                break;
              case Zw2.UID_BANNED:
              case Zw2.IP_BANNED:
              case Zw2.CHANNEL_BANNED:
              case Zw2.SERVER_ERROR:
                t3 = iO.SERVER_ERROR;
                break;
              case Zw2.FALLBACK:
                t3 = iO.FALLBACK;
                break;
              case Zw2.LICENSE_MISSING:
              case Zw2.LICENSE_EXPIRED:
              case Zw2.LICENSE_MINUTES_EXCEEDED:
              case Zw2.LICENSE_PERIOD_INVALID:
              case Zw2.LICENSE_MULTIPLE_SDK_SERVICE:
              case Zw2.LICENSE_ILLEGAL:
              case Zw2.TOKEN_EXPIRE:
                t3 = e2;
                break;
              default:
                t3 = iO.NETWORK_ERROR;
            }
            sD.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t3 || "undefined -> " + iO.NETWORK_ERROR)), this.joinInfo && _D.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === Zw2.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t3 }), this._disconnectedReason = e2, e2 !== Zw2.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }), this.signal.on(UU.WS_CONNECTED, () => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo) {
              if ("audience" === this.role) {
                const e2 = wN("CLIENT_ROLE_OPTIONS") || this._clientRoleOptions;
                e2 && (e2.level || e2.delay) && (sD.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(e2.level, ", delay: ").concat(e2.delay)), this.setClientRole(this.role, e2));
              }
              if (_D.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload, isABTestSuccess: this.store.isABTestSuccess }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion) {
                const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
                if (!e2) return void sD.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
                AN("EVENT_REPORT_DOMAIN", e2[1]), AN("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), AN("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
              }
            }
          }), this.signal.on(FU.ON_UPLINK_STATS, (e2) => {
            this._statsCollector.updateUplinkStats(e2);
          }), this.signal.on(UU.REQUEST_RECOVER, (e2, t3, i2) => {
            if (!this.joinInfo) return i2(new ED(ww2.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, oO(this, rV.REQUEST_NEW_GATEWAY_LIST).then(t3).catch(i2);
          }), this.signal.on(UU.REQUEST_JOIN_INFO, async (e2, t3, i2) => {
            var n3, r2, o2;
            if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e2(this.getJoinMessage({ ortc: {} }));
            const s2 = pO(null === (n3 = this.joinInfo) || void 0 === n3 ? void 0 : n3.turnServer);
            if (wN("NEW_TURN_MODE") && s2 && "disabled" === (null === (r2 = this.joinInfo) || void 0 === r2 ? void 0 : r2.cloudProxyServer)) {
              var a3;
              let e3 = s2.servers.map((e4) => "turnServerURL" in e4 && wN("USE_TURN_IP") ? eF(eF({}, e4), {}, { turnServerURL: nx2(e4.turnServerURL) }) : e4), t4 = null === (a3 = s2.serversFromGateway) || void 0 === a3 ? void 0 : a3.map((e4) => wN("USE_TURN_IP") ? eF(eF({}, e4), {}, { turnServerURL: nx2(e4.turnServerURL) }) : e4);
              const i3 = this.signal.currentURLIndex;
              if (e3.length > 0) {
                e3 = [e3[i3 % e3.length]], s2.servers = e3;
              }
              Array.isArray(t4) && t4.length > 0 && (t4 = [t4[0]], s2.serversFromGateway = t4), sD.debug("[".concat(this.store.clientId, "] use single turn, use turn server index: ").concat(i3));
            }
            const { iceParameters: c3, dtlsParameters: d2, rtpCapabilities: l2 } = await oO(this, rV.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: s2, cloudProxyServer: null === (o2 = this.joinInfo) || void 0 === o2 ? void 0 : o2.cloudProxyServer });
            try {
              e2(this.getJoinMessage({ ortc: { iceParameters: c3, dtlsParameters: d2, rtpCapabilities: l2, version: "2" } }));
            } catch (e3) {
              t3(e3);
            }
          }), this.signal.on(UU.REQUEST_REJOIN_INFO, (e2) => {
            e2(this.getRejoinMessage());
          }), this.signal.on(UU.REPORT_JOIN_GATEWAY, (e2, t3) => {
            if (!this.joinInfo) return;
            let i2, n3 = "";
            var r2;
            e2 instanceof ED ? (i2 = (null === (r2 = e2.data) || void 0 === r2 ? void 0 : r2.desc) || e2.code, n3 = e2.message) : i2 = e2;
            _D.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: i2, errorMsg: n3, addr: t3, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload });
          }), this.signal.on(UU.IS_P2P_DISCONNECTED, (e2) => {
            e2(cO(this, rV.IS_P2P_DISCONNECTED));
          }), this.signal.on(UU.DISCONNECT_P2P, () => {
            this.emit(rV.DISCONNECT_P2P);
          }), this.signal.on(UU.REQUEST_SUCCESS, () => {
            this._signalTimeout = false;
          }), this.signal.on(UU.REQUEST_TIMEOUT, () => {
            this._signalTimeout = true;
          }), this.signal.on(UU.JOIN_RESPONSE, (e2) => {
            const t3 = this.getCurrentGatewayAddress();
            this.emit(rV.JOIN_RESPONSE, e2, t3);
          }), this.signal.on(UU.PRE_CONNECT_PC, async () => {
            if (this.joinInfo) {
              var e2, t3;
              this.updateTurnConfigFromSignal();
              const n3 = this.getCurrentGatewayAddress(), r2 = pO(null === (e2 = this.joinInfo) || void 0 === e2 ? void 0 : e2.turnServer);
              if (wN("NEW_TURN_MODE") && r2 && "disabled" === (null === (t3 = this.joinInfo) || void 0 === t3 ? void 0 : t3.cloudProxyServer)) {
                var i2;
                let e3 = r2.servers.map((e4) => "turnServerURL" in e4 && wN("USE_TURN_IP") ? eF(eF({}, e4), {}, { turnServerURL: nx2(e4.turnServerURL) }) : e4), t4 = null === (i2 = r2.serversFromGateway) || void 0 === i2 ? void 0 : i2.map((e4) => wN("USE_TURN_IP") ? eF(eF({}, e4), {}, { turnServerURL: nx2(e4.turnServerURL) }) : e4);
                const n4 = this.signal.currentURLIndex;
                if (e3.length > 0) {
                  e3 = [e3[n4 % e3.length]], r2.servers = e3;
                }
                Array.isArray(t4) && t4.length > 0 && (t4 = [t4[0]], r2.serversFromGateway = t4), sD.debug("[".concat(this.store.clientId, "] use single turn, use turn server index: ").concat(n4, ",in pre pc"));
              }
              const o2 = wN("FINGERPRINT") || this.joinInfo.apResponse.addresses[this.signal.currentURLIndex].fingerprint;
              if (n3 && o2) {
                const e3 = Ix2(n3);
                this.emit(rV.PRE_CONNECT_PC, { candidates: e3, fingerprint: o2, turnServer: r2 });
              }
            }
          }), this.signal.on(UU.RECOVER_NOTIFICATION, (e2) => {
            this.joinInfo && "string" == typeof wN("AP_REQUEST_DETAIL") && (this.joinInfo.apRequestDetail = "".concat(wN("AP_REQUEST_DETAIL"), ";").concat(e2));
          });
        }
        async tryUnsubBeforeResub(e2, t3) {
          try {
            await this.signal.request(VU.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t3] }, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
          }
        }
        async tryUnsubDataChannelBeforeResub(e2, t3) {
          try {
            await this.signal.request(VU.UNSUBSCRIBE, { stream_id: t3.id }, true);
          } catch (e3) {
            throw sD.warning("unsubscribe datachannel warning", e3), e3;
          }
        }
        async tryUnpubBeforeRepub(e2, t3) {
          try {
            await this.signal.request(VU.UNPUBLISH, { stream_id: e2, ortc: t3 }, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
          }
        }
        async tryUnpubDataChannelBeforeRepub(e2, t3) {
          try {
            await this.signal.request(VU.UNPUBLISH_DATASTREAM, { channnel_id: t3.channelId }, true);
          } catch (e3) {
            throw sD.warning("unpublish datastream warning: ", e3), e3;
          }
        }
        async tryMassUnsubBeforeResub(e2) {
          const t3 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
          try {
            await this.signal.request(VU.UNSUBSCRIBE_STREAMS, t3, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
          }
        }
        async muteLocal(e2, t3) {
          const i2 = { action: e2.find((e3) => e3.stream_type === nV.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t3 };
          try {
            await this.signal.request(VU.CONTROL, i2, true, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
          }
        }
        async unmuteLocal(e2, t3) {
          const i2 = { action: e2.find((e3) => e3.stream_type === nV.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t3 };
          try {
            await this.signal.request(VU.CONTROL, i2, true, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
          }
        }
        async muteRemote(e2, t3) {
          const i2 = { action: e2 === EV.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: t3 };
          try {
            await this.signal.request(VU.CONTROL, i2, true, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), e3), e3;
          }
        }
        async unmuteRemote(e2, t3) {
          const i2 = { action: e2 === EV.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: t3 };
          try {
            await this.signal.request(VU.CONTROL, i2, true, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), e3), e3;
          }
        }
        uploadWRTCStats(e2) {
          this.signal.uploadWRTCStats(e2);
        }
        upload(e2, t3) {
          this.signal.upload(e2, t3);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e2) {
          const t3 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
          try {
            return await this.signal.request(VU.RESTART_ICE, t3, true);
          } catch (e3) {
            throw sD.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
          }
        }
        reconnect(e2, t3) {
          "CONNECTED" === this.state && this.signal.reconnect(e2 || void 0, t3 || iO.P2P_FAILED);
        }
        getCurrentGatewayAddress() {
          var e2, t3;
          if (!wN("GATEWAY_WSS_ADDRESS")) return wN("USE_CANDIDATE_FROM_AP_DETAIL") && null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.apGatewayAddress ? (sD.debug("[".concat(this.store.clientId, "] use candidate from ap detail, ").concat(JSON.stringify(this.joinInfo.apGatewayAddress))), this.joinInfo.apGatewayAddress) : null !== (t3 = this.joinInfo) && void 0 !== t3 && t3.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
        }
        async setPublishAudioFilterEnabled(e2) {
          await this.signal.request(VU.SET_PARAMETER, { enablePublishAudioFilter: e2 });
        }
        downgradeCodec(e2) {
          this.signal.downgradeCodec(e2);
        }
      }
      let nF = 0, rF = 0;
      function oF(e2, t3, i2, n3) {
        return new ip2((r2, o2) => {
          t3.timeout = t3.timeout || wN("HTTP_CONNECT_TIMEOUT"), t3.responseType = t3.responseType || "json", t3.data && !i2 ? (t3.data = JSON.stringify(t3.data), nF += RO(t3.data)) : i2 && (t3.data.size ? nF += t3.data.size : t3.data instanceof FormData ? nF += vO(t3.data) : nF += RO(JSON.stringify(t3.data))), t3.headers = t3.headers || {}, t3.headers["Content-Type"] = t3.headers["Content-Type"] || "application/json", t3.method = "POST", t3.url = e2, UA2.request(t3).then((e3) => {
            "string" == typeof e3.data ? rF += RO(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? rF += e3.data.byteLength : rF += RO(JSON.stringify(e3.data)), n3 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
          }).catch((e3) => {
            UA2.isCancel(e3) ? o2(new ED(ww2.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new ED(ww2.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new ED(ww2.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new ED(ww2.NETWORK_ERROR, e3.message));
          });
        });
      }
      !function() {
        var e2;
        function i2(e3) {
          var t3 = 0;
          return function() {
            return t3 < e3.length ? { done: false, value: e3[t3++] } : { done: true };
          };
        }
        var n3 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t3, i3) {
          return e3 == Array.prototype || e3 == Object.prototype || (e3[t3] = i3.value), e3;
        };
        var r2, o2 = function(e3) {
          e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t2 && t2];
          for (var i3 = 0; i3 < e3.length; ++i3) {
            var n4 = e3[i3];
            if (n4 && n4.Math == Math) return n4;
          }
          throw Error("Cannot find global object");
        }(this);
        function s2(e3, t3) {
          if (t3) e: {
            var i3 = o2;
            e3 = e3.split(".");
            for (var r3 = 0; r3 < e3.length - 1; r3++) {
              var s3 = e3[r3];
              if (!(s3 in i3)) break e;
              i3 = i3[s3];
            }
            (t3 = t3(r3 = i3[e3 = e3[e3.length - 1]])) != r3 && null != t3 && n3(i3, e3, { configurable: true, writable: true, value: t3 });
          }
        }
        function a3(e3) {
          return (e3 = { next: e3 })[Symbol.iterator] = function() {
            return this;
          }, e3;
        }
        function c3(e3) {
          var t3 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
          return t3 ? t3.call(e3) : { next: i2(e3) };
        }
        if (s2("Symbol", function(e3) {
          function t3(e4, t4) {
            this.A = e4, n3(this, "description", { configurable: true, writable: true, value: t4 });
          }
          if (e3) return e3;
          t3.prototype.toString = function() {
            return this.A;
          };
          var i3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
          return function e4(n4) {
            if (this instanceof e4) throw new TypeError("Symbol is not a constructor");
            return new t3(i3 + (n4 || "") + "_" + r3++, n4);
          };
        }), s2("Symbol.iterator", function(e3) {
          if (e3) return e3;
          e3 = Symbol("Symbol.iterator");
          for (var t3 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t3.length; r3++) {
            var s3 = o2[t3[r3]];
            "function" == typeof s3 && "function" != typeof s3.prototype[e3] && n3(s3.prototype, e3, { configurable: true, writable: true, value: function() {
              return a3(i2(this));
            } });
          }
          return e3;
        }), "function" == typeof Object.setPrototypeOf) r2 = Object.setPrototypeOf;
        else {
          var d2;
          e: {
            var l2 = {};
            try {
              l2.__proto__ = { a: true }, d2 = l2.a;
              break e;
            } catch (e3) {
            }
            d2 = false;
          }
          r2 = d2 ? function(e3, t3) {
            if (e3.__proto__ = t3, e3.__proto__ !== t3) throw new TypeError(e3 + " is not extensible");
            return e3;
          } : null;
        }
        var u3 = r2;
        function h2() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function p2(e3) {
          if (e3.m) throw new TypeError("Generator is already running");
          e3.m = true;
        }
        function _2(e3, t3) {
          return e3.h = 3, { value: t3 };
        }
        function E3(e3) {
          this.g = new h2(), this.G = e3;
        }
        function m3(e3, t3, i3, n4) {
          try {
            var r3 = t3.call(e3.g.j, i3);
            if (!(r3 instanceof Object)) throw new TypeError("Iterator result " + r3 + " is not an object");
            if (!r3.done) return e3.g.m = false, r3;
            var o3 = r3.value;
          } catch (t4) {
            return e3.g.j = null, e3.g.s(t4), f2(e3);
          }
          return e3.g.j = null, n4.call(e3.g, o3), f2(e3);
        }
        function f2(e3) {
          for (; e3.g.h; ) try {
            var t3 = e3.G(e3.g);
            if (t3) return e3.g.m = false, { value: t3.value, done: false };
          } catch (t4) {
            e3.g.v = void 0, e3.g.s(t4);
          }
          if (e3.g.m = false, e3.g.l) {
            if (t3 = e3.g.l, e3.g.l = null, t3.F) throw t3.D;
            return { value: t3.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function S3(e3) {
          this.next = function(t3) {
            return e3.o(t3);
          }, this.throw = function(t3) {
            return e3.s(t3);
          }, this.return = function(t3) {
            return function(e4, t4) {
              p2(e4.g);
              var i3 = e4.g.j;
              return i3 ? m3(e4, "return" in i3 ? i3.return : function(e5) {
                return { value: e5, done: true };
              }, t4, e4.g.return) : (e4.g.return(t4), f2(e4));
            }(e3, t3);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function g2(e3, t3) {
          return t3 = new S3(new E3(t3)), u3 && e3.prototype && u3(t3, e3.prototype), t3;
        }
        if (h2.prototype.o = function(e3) {
          this.v = e3;
        }, h2.prototype.s = function(e3) {
          this.l = { D: e3, F: true }, this.h = this.C || this.u;
        }, h2.prototype.return = function(e3) {
          this.l = { return: e3 }, this.h = this.u;
        }, E3.prototype.o = function(e3) {
          return p2(this.g), this.g.j ? m3(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), f2(this));
        }, E3.prototype.s = function(e3) {
          return p2(this.g), this.g.j ? m3(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), f2(this));
        }, s2("Array.prototype.entries", function(e3) {
          return e3 || function() {
            return function(e4, t3) {
              e4 instanceof String && (e4 += "");
              var i3 = 0, n4 = false, r3 = { next: function() {
                if (!n4 && i3 < e4.length) {
                  var r4 = i3++;
                  return { value: t3(r4, e4[r4]), done: false };
                }
                return n4 = true, { done: true, value: void 0 };
              } };
              return r3[Symbol.iterator] = function() {
                return r3;
              }, r3;
            }(this, function(e4, t3) {
              return [e4, t3];
            });
          };
        }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
          var T3 = function(e3, t3) {
            for (var i3 = 0; i3 < e3.length; i3++) t3(e3[i3]);
          }, R3 = function(e3) {
            return e3.replace(/\r?\n|\r/g, "\r\n");
          }, v3 = function(e3, t3, i3) {
            return t3 instanceof Blob ? (i3 = void 0 !== i3 ? String(i3 + "") : "string" == typeof t3.name ? t3.name : "blob", t3.name === i3 && "[object Blob]" !== Object.prototype.toString.call(t3) || (t3 = new File([t3], i3)), [String(e3), t3]) : [String(e3), String(t3)];
          }, C2 = function(e3, t3) {
            if (e3.length < t3) throw new TypeError(t3 + " argument required, but only " + e3.length + " present.");
          }, y3 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, I3 = y3.FormData, b2 = y3.XMLHttpRequest && y3.XMLHttpRequest.prototype.send, A2 = y3.Request && y3.fetch, w3 = y3.navigator && y3.navigator.sendBeacon, O3 = y3.Element && y3.Element.prototype, N3 = y3.Symbol && Symbol.toStringTag;
          N3 && (Blob.prototype[N3] || (Blob.prototype[N3] = "Blob"), "File" in y3 && !File.prototype[N3] && (File.prototype[N3] = "File"));
          try {
            new File([], "");
          } catch (e3) {
            y3.File = function(e4, t3, i3) {
              return e4 = new Blob(e4, i3 || {}), Object.defineProperties(e4, { name: { value: t3 }, lastModified: { value: +(i3 && void 0 !== i3.lastModified ? new Date(i3.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), N3 && Object.defineProperty(e4, N3, { value: "File" }), e4;
            };
          }
          var D3 = function(e3) {
            return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, P2 = function(e3) {
            this.i = [];
            var t3 = this;
            e3 && T3(e3.elements, function(e4) {
              if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *")) if ("file" === e4.type) {
                var i3 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                T3(i3, function(i4) {
                  t3.append(e4.name, i4);
                });
              } else "select-multiple" === e4.type || "select-one" === e4.type ? T3(e4.options, function(i4) {
                !i4.disabled && i4.selected && t3.append(e4.name, i4.value);
              }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t3.append(e4.name, e4.value) : (i3 = "textarea" === e4.type ? R3(e4.value) : e4.value, t3.append(e4.name, i3));
            });
          };
          if ((e2 = P2.prototype).append = function(e3, t3, i3) {
            C2(arguments, 2), this.i.push(v3(e3, t3, i3));
          }, e2.delete = function(e3) {
            C2(arguments, 1);
            var t3 = [];
            e3 = String(e3), T3(this.i, function(i3) {
              i3[0] !== e3 && t3.push(i3);
            }), this.i = t3;
          }, e2.entries = function e3() {
            var t3, i3 = this;
            return g2(e3, function(e4) {
              if (1 == e4.h && (t3 = 0), 3 != e4.h) return t3 < i3.i.length ? e4 = _2(e4, i3.i[t3]) : (e4.h = 0, e4 = void 0), e4;
              t3++, e4.h = 2;
            });
          }, e2.forEach = function(e3, t3) {
            C2(arguments, 1);
            for (var i3 = c3(this), n4 = i3.next(); !n4.done; n4 = i3.next()) {
              var r3 = c3(n4.value);
              n4 = r3.next().value, r3 = r3.next().value, e3.call(t3, r3, n4, this);
            }
          }, e2.get = function(e3) {
            C2(arguments, 1);
            var t3 = this.i;
            e3 = String(e3);
            for (var i3 = 0; i3 < t3.length; i3++) if (t3[i3][0] === e3) return t3[i3][1];
            return null;
          }, e2.getAll = function(e3) {
            C2(arguments, 1);
            var t3 = [];
            return e3 = String(e3), T3(this.i, function(i3) {
              i3[0] === e3 && t3.push(i3[1]);
            }), t3;
          }, e2.has = function(e3) {
            C2(arguments, 1), e3 = String(e3);
            for (var t3 = 0; t3 < this.i.length; t3++) if (this.i[t3][0] === e3) return true;
            return false;
          }, e2.keys = function e3() {
            var t3, i3, n4, r3, o3 = this;
            return g2(e3, function(e4) {
              if (1 == e4.h && (t3 = c3(o3), i3 = t3.next()), 3 != e4.h) return i3.done ? void (e4.h = 0) : (n4 = i3.value, r3 = c3(n4), _2(e4, r3.next().value));
              i3 = t3.next(), e4.h = 2;
            });
          }, e2.set = function(e3, t3, i3) {
            C2(arguments, 2), e3 = String(e3);
            var n4 = [], r3 = v3(e3, t3, i3), o3 = true;
            T3(this.i, function(t4) {
              t4[0] === e3 ? o3 && (o3 = !n4.push(r3)) : n4.push(t4);
            }), o3 && n4.push(r3), this.i = n4;
          }, e2.values = function e3() {
            var t3, i3, n4, r3, o3 = this;
            return g2(e3, function(e4) {
              if (1 == e4.h && (t3 = c3(o3), i3 = t3.next()), 3 != e4.h) return i3.done ? void (e4.h = 0) : (n4 = i3.value, (r3 = c3(n4)).next(), _2(e4, r3.next().value));
              i3 = t3.next(), e4.h = 2;
            });
          }, P2.prototype._asNative = function() {
            for (var e3 = new I3(), t3 = c3(this), i3 = t3.next(); !i3.done; i3 = t3.next()) {
              var n4 = c3(i3.value);
              i3 = n4.next().value, n4 = n4.next().value, e3.append(i3, n4);
            }
            return e3;
          }, P2.prototype._blob = function() {
            var e3 = "----formdata-polyfill-" + Math.random(), t3 = [], i3 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach(function(e4, n4) {
              return "string" == typeof e4 ? t3.push(i3 + D3(R3(n4)) + '"\r\n\r\n' + R3(e4) + "\r\n") : t3.push(i3 + D3(R3(n4)) + '"; filename="' + D3(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
            }), t3.push("--" + e3 + "--"), new Blob(t3, { type: "multipart/form-data; boundary=" + e3 });
          }, P2.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, P2.prototype.toString = function() {
            return "[object FormData]";
          }, O3 && !O3.matches && (O3.matches = O3.matchesSelector || O3.mozMatchesSelector || O3.msMatchesSelector || O3.oMatchesSelector || O3.webkitMatchesSelector || function(e3) {
            for (var t3 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t3 && e3.item(t3) !== this; ) ;
            return -1 < t3;
          }), N3 && (P2.prototype[N3] = "FormData"), b2) {
            var L3 = y3.XMLHttpRequest.prototype.setRequestHeader;
            y3.XMLHttpRequest.prototype.setRequestHeader = function(e3, t3) {
              L3.call(this, e3, t3), "content-type" === e3.toLowerCase() && (this.B = true);
            }, y3.XMLHttpRequest.prototype.send = function(e3) {
              e3 instanceof P2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), b2.call(this, e3)) : b2.call(this, e3);
            };
          }
          A2 && (y3.fetch = function(e3, t3) {
            return t3 && t3.body && t3.body instanceof P2 && (t3.body = t3.body._blob()), A2.call(this, e3, t3);
          }), w3 && (y3.navigator.sendBeacon = function(e3, t3) {
            return t3 instanceof P2 && (t3 = t3._asNative()), w3.call(this, e3, t3);
          }), y3.FormData = P2;
        }
      }();
      const sF = () => {
        const e2 = wN("AREAS");
        0 === e2.length && e2.push(aV.GLOBAL);
        return nr2(e2).call(e2, (e3, t3, i2) => {
          const n3 = aF(t3);
          return n3 ? 0 === i2 ? n3 : "".concat(e3, ",").concat(n3) : e3;
        }, "");
      }, aF = (e2) => e2 === aV.OVERSEA ? "".concat(dV.ASIA, ",").concat(dV.EUROPE, ",").concat(dV.AFRICA, ",").concat(dV.NORTH_AMERICA, ",").concat(dV.SOUTH_AMERICA, ",").concat(dV.OCEANIA) : dV[e2], cF = (e2) => {
        const t3 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
        return e2.map((e3) => {
          const i2 = lV[e3], n3 = Object.keys(i2);
          n3 && n3.map((e4) => {
            "CODE" !== e4 && (t3[e4] = t3[e4].concat(i2[e4]));
          });
        }), t3;
      }, dF = { GLOBAL: { ASIA: [aV.CHINA, aV.JAPAN, aV.INDIA, aV.KOREA, aV.HKMC], EUROPE: [], NORTH_AMERICA: [aV.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, lF = Object.keys(dF[aV.GLOBAL]), uF = [aV.CHINA, aV.NORTH_AMERICA, aV.EUROPE, aV.ASIA, aV.JAPAN, aV.INDIA, aV.OCEANIA, aV.SOUTH_AMERICA, aV.AFRICA, aV.KOREA, aV.HKMC, aV.US], hF = function(e2, t3) {
        let i2 = [];
        if (Ln2(e2).call(e2, aV.GLOBAL)) {
          const o2 = [aV.GLOBAL, aV.OVERSEA], s2 = Object.keys(lV);
          if (t3 === aV.GLOBAL) throw new ED(ww2.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t3 === aV.CHINA) i2 = [aV.OVERSEA];
          else if (r2 = t3, Ln2(lF).call(lF, r2)) {
            const e3 = (n3 = t3, dF[aV.GLOBAL][n3] || []), r3 = [...o2, t3, ...e3];
            i2 = s2.filter((e4) => !Ln2(r3).call(r3, e4));
          } else if (function(e3) {
            let t4 = false;
            return lF.forEach((i3) => {
              var n4;
              Ln2(n4 = dF[aV.GLOBAL][i3]).call(n4, e3) && (t4 = true);
            }), t4;
          }(t3)) {
            const e3 = function(e4) {
              let t4;
              return lF.forEach((i3) => {
                var n5;
                Ln2(n5 = dF[aV.GLOBAL][i3]).call(n5, e4) && (t4 = i3);
              }), t4;
            }(t3), n4 = [...o2, e3, t3];
            i2 = s2.filter((e4) => !Ln2(n4).call(n4, e4));
          } else i2 = e2;
          i2 = function(e3) {
            const t4 = [];
            return uF.forEach((i3) => {
              Ln2(e3).call(e3, i3) && t4.push(i3);
            }), t4.concat(e3.filter((e4) => !Ln2(uF).call(uF, e4)));
          }(i2);
        } else i2 = e2;
        var n3, r2;
        return i2;
      };
      function pF(e2) {
        var t3, i2;
        if (!e2 && Ln2(t3 = wN("AREAS")).call(t3, aV.EXTENSIONS)) return sD.debug("update area from ap : reset"), void _F(jM, true);
        if (!Ln2(i2 = wN("AREAS")).call(i2, aV.GLOBAL) || !e2) return;
        let n3 = lV.EXTENSIONS;
        n3 && (n3 = { CODE: aF(aV.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, sD.debug("update area from ap success: ".concat(e2, ",config is "), n3), AN("AREAS", [aV.EXTENSIONS], true), Object.keys(n3).map((e3) => {
          if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
            AN(e3, n3[e3][0]);
          } else AN(e3, n3[e3]);
        }));
      }
      function _F(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = _D.reportApiInvoke(null, { name: zw2.SET_AREA, options: e2, tag: qw2.TRACER });
        try {
          let n3 = [];
          if ("string" == typeof e2 && (n3 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
            if (!Ln2(cV).call(cV, e3)) throw new ED(ww2.INVALID_PARAMS, "invalid area code");
          }), n3 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
            const { areaCode: t4, excludedArea: i3 } = e2;
            if (!t4) throw new ED(ww2.INVALID_PARAMS, "area code is needed");
            let r3 = t4;
            "string" == typeof t4 && (r3 = [t4]), n3 = i3 ? hF(r3, i3) : r3;
          }
          if (!t3) {
            if (NN.AREAS) {
              const e3 = new ED(ww2.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
              return i2.onError(e3), void sD.warning("setArea is prohibited because of config-distribute");
            }
            if (Ln2(n3).call(n3, aV.GLOBAL) && wN("AREAS") === aV.EXTENSIONS) {
              const e3 = new ED(ww2.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
              return i2.onError(e3), void sD.warning("setArea is prohibited because of ap extensions");
            }
          }
          AN("AREAS", n3, t3);
          const r2 = cF(n3);
          Object.keys(r2).map((e3) => {
            if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
              AN(e3, r2[e3][0]);
            } else AN(e3, r2[e3]);
          }), sD.debug("set area success:", n3.join(","));
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        i2.onSuccess();
      }
      function EF(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function mF(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? EF(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : EF(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      let fF = 1;
      function SF(e2, t3, i2, n3, r2) {
        fF += 1;
        const o2 = { sid: i2.sid, command: "convergeAllocateEdge", uid: "666", appId: i2.appId, ts: Math.floor(Date.now() / 1e3), seq: fF, requestId: fF, version: SN, cname: i2.cname }, s2 = { service_name: t3, json_body: JSON.stringify(o2) };
        let a3, c3, d2 = e2[0];
        return GO(async () => {
          a3 = Date.now();
          const e3 = await oF(d2, { data: s2, cancelToken: n3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c3 = Date.now() - a3, 0 !== e3.code) {
            const t4 = new ED(ww2.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c3 });
            throw sD.error(t4.toString()), t4;
          }
          const i3 = JSON.parse(e3.json_body);
          if (200 !== i3.code) {
            const e4 = new ED(ww2.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i3.code, ", reason: ").concat(i3.reason), { code: i3.code, responseTime: c3 });
            throw sD.error(e4.toString()), e4;
          }
          if (!i3.servers || 0 === i3.servers.length) {
            const e4 = new ED(ww2.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i3.code, responseTime: c3 });
            throw sD.error(e4.toString()), e4;
          }
          const r3 = function(e4, t4) {
            return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(wN("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t4))), workerToken: e4.workerToken, vid: e4.vid };
          }(i3, t3);
          return wN("LIVE_STREAMING_ADDRESS") && (r3.addressList = wN("LIVE_STREAMING_ADDRESS") instanceof Array ? wN("LIVE_STREAMING_ADDRESS") : [wN("LIVE_STREAMING_ADDRESS")]), mF(mF({}, r3), {}, { responseTime: c3 });
        }, (n4, r3) => (_D.apworkerEvent(i2.sid, { success: true, sc: 200, serviceName: t3, responseDetail: JSON.stringify(n4.addressList), firstSuccess: 0 === r3, responseTime: c3, serverIp: e2[r3 % e2.length] }), false), (n4, r3) => (_D.apworkerEvent(i2.sid, { success: false, sc: n4.data && n4.data.code || 200, serviceName: t3, responseTime: c3, serverIp: e2[r3 % e2.length] }), !!(n4.code !== ww2.OPERATION_ABORTED && n4.code !== ww2.UNEXPECTED_RESPONSE || n4.data && n4.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true)), r2);
      }
      let gF = 1;
      function TF(e2, t3, i2, n3) {
        let { url: r2, areaCode: o2 } = e2;
        const { clientId: s2, sid: a3 } = t3, c3 = Date.now();
        let d2;
        const l2 = t3.role, [u3, h2] = IF(t3, o2, [$V.CHOOSE_SERVER]);
        let p2 = dO.networkState;
        return GO(async () => {
          p2 && dO.networkState === nO.OFFLINE && dO.onlineWaiter && await ip2.race([dO.onlineWaiter, yO(n3 && n3.maxRetryTimeout || BO.maxRetryTimeout)]), p2 = dO.networkState;
          const { data: e3, headers: o3 } = await oF(r2, { data: u3, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          d2 = "1" === o3.http3 ? 1 : -1, _D.reportResourceTiming(r2, a3), vF(e3, r2, t3, c3, [$V.CHOOSE_SERVER], d2);
          const s3 = cx2(e3, $V.CHOOSE_SERVER);
          return CF(s3), rx2(s3, r2);
        }, (e3) => (e3 && _D.joinChooseServer(a3, { role: l2, lts: c3, succ: true, csAddr: r2, opid: h2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [$V.CHOOSE_SERVER].toString(), isHttp3: d2, corssRegionTagReq: t3.apRequestDetail, corssRegionTagRes: e3.res.detail && e3.res.detail[38] }), false), (e3) => e3.code !== ww2.OPERATION_ABORTED && (e3.code === ww2.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (_D.joinChooseServer(a3, { role: l2, lts: c3, succ: false, csAddr: r2, serverList: null, opid: h2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [$V.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: p2 }), isHttp3: d2, corssRegionTagReq: t3.apRequestDetail }), sD.warning("[".concat(s2 || "sid-".concat(a3.slice(0, 6)), "] Choose server network error, retry"), e3), true)), n3);
      }
      function RF(e2, t3, i2, n3) {
        let r2, { url: o2, areaCode: s2, serviceIds: a3 } = e2;
        const c3 = Date.now(), d2 = t3.role, [l2, u3] = IF(t3, s2, a3);
        let h2;
        return GO(async () => {
          h2 && dO.networkState === nO.OFFLINE && dO.onlineWaiter && await ip2.race([dO.onlineWaiter, yO(n3 && n3.maxRetryTimeout || BO.maxRetryTimeout)]), h2 = dO.networkState;
          const { data: e3, headers: s3 } = await oF(o2, { data: l2, cancelToken: i2, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
          r2 = "1" === s3.http3 ? 1 : -1, _D.reportResourceTiming(o2, t3.sid), vF(e3, o2, t3, c3, a3, r2);
          const d3 = cx2(e3, $V.CHOOSE_SERVER), u4 = cx2(e3, "proxy5" === t3.cloudProxyServer ? $V.CLOUD_PROXY_5 : "proxy3" === t3.cloudProxyServer || "proxy4" === t3.cloudProxyServer ? $V.CLOUD_PROXY : $V.CLOUD_PROXY_FALLBACK), p2 = performance.getEntriesByName(o2), _2 = p2[p2.length - 1];
          let E3;
          return _2 && (E3 = { name: _2.name, protocol: "nextHopProtocol" in _2 ? _2.nextHopProtocol : "", dnscost: "domainLookupEnd" in _2 && "domainLookupStart" in _2 && "number" == typeof _2.domainLookupEnd && "number" == typeof _2.domainLookupStart ? _2.domainLookupEnd - _2.domainLookupStart : -1, tcpTlsCost: "connectEnd" in _2 && "connectStart" in _2 && "number" == typeof _2.connectEnd && "number" == typeof _2.connectStart ? _2.connectEnd - _2.connectStart : -1, reqCost: "requestStart" in _2 && "number" == typeof _2.requestStart && "responseEnd" in _2 && "number" == typeof _2.responseEnd ? _2.responseEnd - _2.requestStart : -1, handleCost: "leave_ts" in e3 && "enter_ts" in e3 && "number" == typeof e3.leave_ts && "number" == typeof e3.enter_ts ? e3.leave_ts - e3.enter_ts : -1 }), CF(d3), { gatewayInfo: rx2(d3, o2), proxyInfo: u4, url: o2, resourceTimingInfo: E3 };
        }, (e3) => (e3.gatewayInfo && _D.joinChooseServer(t3.sid, { role: d2, lts: c3, succ: true, csAddr: o2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: u3, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a3.toString(), isHttp3: r2, corssRegionTagReq: t3.apRequestDetail, corssRegionTagRes: e3.gatewayInfo.res.detail && e3.gatewayInfo.res.detail[38], resourceTimingInfo: e3.resourceTimingInfo ? JSON.stringify(e3.resourceTimingInfo) : void 0 }), e3.proxyInfo && _D.joinWebProxyAP(t3.sid, { lts: c3, sucess: 1, apServerAddr: o2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t3.cloudProxyServer, unilbsServerIds: a3.toString() }), false), (e3) => e3.code !== ww2.OPERATION_ABORTED && (e3.code === ww2.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (_D.joinWebProxyAP(t3.sid, { lts: c3, sucess: 0, apServerAddr: o2, turnServerAddrList: null, errorCode: e3.code, eventType: t3.cloudProxyServer, unilbsServerIds: a3.toString(), extend: JSON.stringify({ networkState: h2 }) }), sD.warning("[".concat(t3.clientId, "] multi unilbs network error, retry"), e3), true)), n3);
      }
      const vF = (e2, t3, i2, n3, r2, o2) => {
        const { sid: s2, clientId: a3, cloudProxyServer: c3 } = i2, d2 = [], l2 = (a4) => {
          4096 === a4.flag ? _D.joinChooseServer(s2, { role: i2.role, lts: n3, succ: false, csAddr: t3, opid: e2.opid, serverList: null, ec: a4.error.message, csIp: a4.error.data && a4.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: o2, corssRegionTagReq: i2.apRequestDetail }) : 1048576 !== a4.flag && 4194304 !== a4.flag && 4194310 !== a4.flag || _D.joinWebProxyAP(s2, { lts: n3, sucess: 0, apServerAddr: t3, turnServerAddrList: null, errorCode: a4.error.code, eventType: c3, unilbsServerIds: r2.toString() });
        };
        if (e2.response_body.forEach((t4) => {
          const i3 = t4.buffer.code;
          if (23 === t4.uri && 0 === i3 && !t4.buffer.edges_services) if (4194310 === t4.buffer.flag) sD.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t4.buffer.edges_services = [];
          else {
            const i4 = { error: new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t4.buffer.flag };
            d2.push(i4), l2(i4);
          }
          if (0 !== i3) {
            const n4 = MV(i3), r3 = { error: new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, n4.desc, { desc: n4.desc, retry: n4.retry, csIp: e2.detail[502] }), flag: t4.buffer.flag };
            4194310 === t4.buffer.flag ? sD.warning(r3.error.toString()) : d2.push(r3), l2(r3);
          }
        }), d2.length) throw sD.warning("[".concat(a3 || "sid-".concat(s2.slice(0, 6)), "] multi unilbs ").concat(t3, " failed, ").concat(d2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, d2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!d2.find((e3) => e3.error.data.retry), csIp: e2.detail[502], desc: [...new Set(d2.map((e3) => {
          var t4;
          return null == e3 || null === (t4 = e3.error) || void 0 === t4 || null === (t4 = t4.data) || void 0 === t4 ? void 0 : t4.desc;
        }).filter((e3) => !!e3))] });
      }, CF = (e2) => {
        var t3, i2, n3, r2;
        if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code) throw new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
        wN("AP_AREA") && (null !== (n3 = e2.detail) && void 0 !== n3 && n3[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? pF(e2.detail[23].toLowerCase()) : pF());
        if (null !== (t3 = e2.detail) && void 0 !== t3 && t3[19] && "string" == typeof (null === (i2 = e2.detail) || void 0 === i2 ? void 0 : i2[19])) {
          const t4 = e2.detail[19], i3 = null == t4 ? void 0 : t4.split(";");
          for (let t5 = 0; t5 < i3.length; t5++) {
            var o2;
            const n4 = Pg2(o2 = i3[t5]).call(o2);
            e2.addresses[t5] && i3 && (e2.addresses[t5].fingerprint = n4);
          }
        }
        if (wN("GATEWAY_ADDRESS") && wN("GATEWAY_ADDRESS").length > 0) {
          sD.debug("assign gateway address to", wN("GATEWAY_ADDRESS"));
          const t4 = wN("GATEWAY_ADDRESS").map((t5) => {
            var i3, n4;
            const r3 = null !== (i3 = null === (n4 = e2.addresses.find((e3) => e3.ip === t5.ip && e3.port === t5.port)) || void 0 === n4 ? void 0 : n4.fingerprint) && void 0 !== i3 ? i3 : "";
            return { ip: t5.ip, port: t5.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: r3 };
          });
          e2.addresses = t4;
        }
      }, yF = (e2, t3) => {
        if (e2.response_body && e2.response_body.length) {
          const t4 = e2.response_body[0];
          if (0 !== t4.buffer.code) {
            const e3 = MV(t4.buffer.code);
            throw new ED(ww2.UPDATE_TICKET_FAILED, "[".concat(t4.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
          }
          return t4.buffer.ticket;
        }
        throw sD.debug("update ticket request received ap response without response body:", t3), new ED(ww2.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, IF = (e2, t3, i2) => {
        const n3 = Math.floor(Math.random() * 10 ** 12), r2 = "host" === e2.role ? "1" : "audience" === e2.role ? "2" : void 0, o2 = { appid: e2.appId, client_ts: Date.now(), opid: n3, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: mF(mF(mF({ 6: e2.stringUid, 11: t3, 12: wN("USE_NEW_TOKEN") ? "1" : void 0 }, r2 ? { 17: r2 } : {}), {}, { 22: t3 }, e2.apRequestDetail ? { 33: e2.apRequestDetail } : {}), e2.apRTM ? { 26: "RTM2" } : {}), key: e2.token, service_ids: i2, uid: e2.uid || 0 } }] };
        o2.request_bodies.forEach((t4) => {
          e2.multiIP && e2.multiIP.gateway_ip && (t4.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
        });
        const s2 = new FormData();
        return s2.append("request", JSON.stringify(o2)), [s2, n3];
      }, bF = (e2, t3) => {
        const i2 = Math.floor(Math.random() * 10 ** 12), n3 = { appid: e2.appId, client_ts: Date.now(), opid: i2, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t3, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, r2 = new FormData();
        return r2.append("request", JSON.stringify(n3)), [r2, i2];
      };
      let AF = 0;
      function wF(e2) {
        return ip2.all(e2.map((e3) => e3.then((e4) => {
          throw e4;
        }, (e4) => e4))).then((e3) => {
          throw e3;
        }, (e3) => e3);
      }
      const OF = async (e2) => {
        let { fragementLength: t3, referenceList: i2, asyncMapHandler: n3, allFailedhandler: r2, promisesCollector: o2 } = e2, s2 = 0;
        const a3 = t3;
        let c3, d2 = 0;
        const l2 = async () => {
          const e3 = (() => {
            const e4 = s2 * a3, t4 = e4 + a3;
            return i2.slice(e4, t4).map(n3);
          })();
          o2 && o2.push(...e3);
          try {
            c3 = await wF(e3);
          } catch (e4) {
            if (d2 += a3, s2++, !(d2 >= i2.length)) return void await l2();
            r2(e4);
          }
          e3.forEach((e4) => e4.cancel());
        };
        return await l2(), c3;
      }, NF = async (e2) => {
        let { referenceList: t3, asyncMapHandler: i2, closeFn: n3 } = e2;
        const r2 = t3.length;
        let o2 = 0;
        const s2 = async () => {
          const e3 = i2(t3.shift());
          try {
            return await e3;
          } catch (e4) {
            if (o2++, o2 >= r2 || null != n3 && n3(e4)) throw e4;
            return s2();
          }
        };
        return s2();
      };
      async function DF() {
        if ("undefined" == typeof VideoDecoder) return true;
        let e2;
        const t3 = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 85, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 149, 160, 133, 4, 144, 43, 122, 168, 159, 120, 159, 205, 39, 82, 131, 57, 52, 87, 187, 68, 23, 248, 134, 204, 226, 97, 17, 49, 183, 55, 236, 219, 249, 221, 98, 208, 215, 190, 59, 179, 167, 213, 47, 1, 246, 150, 14, 194, 245, 159, 83, 35, 64, 103, 218, 38, 21, 82, 3, 135, 21, 185, 84, 248, 134], i2 = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 87, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 148, 62, 134, 140, 92, 172, 141, 77, 35, 94, 181, 164, 65, 169, 65, 156, 154, 43, 221, 162, 11, 252, 67, 102, 113, 48, 136, 137, 219, 62, 43, 113, 239, 23, 126, 250, 186, 252, 10, 138, 218, 25, 193, 244, 74, 68, 194, 209, 107, 23, 52, 206, 199, 78, 72, 98, 103, 151, 71, 96, 62, 51, 210, 158, 72, 231, 158], n3 = [18, 0, 10, 13, 0, 0, 0, 3, 180, 253, 144, 6, 136, 8, 8, 8, 32, 50, 87, 16, 66, 128, 2, 8, 32, 132, 0, 8, 0, 180, 90, 204, 169, 166, 242, 109, 241, 190, 143, 143, 233, 163, 51, 196, 98, 95, 151, 224, 22, 134, 33, 240, 150, 248, 67, 18, 34, 196, 142, 81, 238, 173, 140, 80, 205, 232, 132, 144, 67, 12, 131, 157, 4, 171, 243, 86, 122, 35, 6, 166, 184, 243, 85, 126, 13, 206, 103, 152, 62, 168, 160, 187, 2, 241, 138, 52, 211, 72, 121, 128, 151, 63, 147, 128, 19, 42], r2 = [18, 0, 50, 138, 1, 48, 192, 64, 253, 248, 65, 17, 67, 192, 32, 0, 16, 0, 0, 0, 0, 0, 0, 0, 195, 12, 48, 144, 64, 32, 0, 209, 75, 61, 9, 204, 25, 115, 79, 226, 115, 63, 63, 208, 70, 210, 220, 153, 126, 241, 237, 37, 107, 195, 153, 1, 99, 112, 230, 189, 209, 169, 130, 10, 11, 22, 167, 215, 159, 205, 197, 7, 183, 162, 26, 48, 254, 141, 134, 103, 32, 16, 235, 45, 1, 15, 18, 119, 169, 110, 206, 251, 51, 115, 202, 60, 148, 1, 46, 39, 109, 25, 28, 86, 168, 15, 77, 211, 239, 2, 58, 43, 146, 26, 230, 184, 81, 48, 140, 226, 226, 250, 222, 146, 171, 133, 164, 13, 188, 180, 64, 122, 142, 146, 32, 208, 238, 170, 193, 35, 53, 44, 225], o2 = [18, 0, 50, 107, 48, 0, 133, 125, 248, 65, 26, 195, 64, 62, 32, 31, 16, 0, 0, 0, 0, 0, 1, 4, 16, 64, 144, 64, 32, 0, 204, 24, 122, 65, 56, 165, 18, 52, 206, 218, 4, 187, 51, 97, 9, 29, 191, 90, 253, 106, 185, 31, 197, 155, 52, 205, 245, 185, 203, 131, 20, 226, 25, 124, 95, 113, 220, 113, 141, 15, 15, 104, 211, 144, 152, 237, 150, 157, 127, 51, 143, 24, 231, 218, 171, 255, 176, 241, 128, 229, 149, 150, 148, 66, 245, 228, 91, 27, 182, 228, 136, 61, 182, 237, 133, 45, 220, 24, 103, 214, 152], s2 = [18, 0, 50, 122, 48, 1, 9, 253, 248, 65, 26, 67, 64, 62, 32, 31, 16, 0, 0, 0, 0, 0, 1, 4, 16, 64, 144, 64, 32, 0, 198, 182, 231, 242, 220, 235, 163, 140, 12, 36, 36, 166, 46, 132, 210, 4, 71, 23, 218, 132, 27, 30, 17, 45, 244, 79, 31, 243, 195, 136, 100, 169, 76, 88, 142, 85, 204, 217, 121, 168, 29, 163, 198, 17, 251, 223, 73, 12, 212, 244, 139, 123, 151, 179, 75, 216, 96, 208, 136, 40, 229, 42, 59, 149, 10, 116, 228, 85, 99, 93, 221, 108, 255, 140, 248, 20, 30, 167, 122, 109, 206, 164, 108, 197, 110, 251, 23, 243, 133, 160, 63, 13, 207, 177, 12, 128], a3 = await new ip2((a4, c3) => {
          let d2;
          !async function() {
            e2 && "closed" !== e2.state || await async function() {
              e2 = new VideoDecoder({ output: (e3) => {
                e3.close(), clearTimeout(d2), a4(true);
              }, error: (e3) => {
                clearTimeout(d2), a4(false);
              } }), await e2.configure({ codec: "av01.0.05M.08", width: 160, height: 90 });
            }();
            const c4 = [t3, i2, n3, r2, o2, s2];
            for (let t4 = 0; t4 < c4.length; t4++) {
              const i3 = new EncodedVideoChunk({ type: 0 == t4 ? "key" : "delta", timestamp: 33333 * t4, duration: 33333, data: new Uint8Array(c4[t4]) });
              try {
                await e2.decode(i3);
              } catch (e3) {
                return void a4(false);
              }
            }
          }(), d2 = setTimeout(() => {
            a4(false);
          }, 5e3);
        });
        return a3;
      }
      async function PF(e2, t3, i2, n3) {
        const r2 = async function(e3, t4, i3, n4) {
          let r3 = null;
          const o2 = [], s2 = async () => {
            const r4 = wN("WEBCS_DOMAIN").slice(0, wN("AJAX_REQUEST_CONCURRENT")).map((t5) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t5 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t5, "/api/v2/transpond/webrtc?v=2"), areaCode: sF() })), s3 = n4.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e4) => e4.url) }), a4 = await OF({ fragementLength: wN("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n5) => (sD.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n5.url), TF(n5, e3, t4, i3)), allFailedhandler: (e4) => {
              throw n4.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s3), e4[0];
            }, promisesCollector: o2 });
            return n4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a4;
          }, a3 = async () => {
            if (await yO(1e3), null !== r3) return r3;
            const s3 = wN("WEBCS_DOMAIN_BACKUP_LIST").map((t5) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t5 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t5, "/api/v2/transpond/webrtc?v=2"), areaCode: sF() })), a4 = n4.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map((e4) => e4.url) }), c3 = await OF({ fragementLength: wN("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (n5) => (sD.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n5.url), TF(n5, e3, t4, i3)), allFailedhandler: (e4) => {
              throw n4.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a4), e4[0];
            }, promisesCollector: o2 });
            return n4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a4), c3;
          };
          try {
            return r3 = await wF([s2(), a3()]), o2.length && o2.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
          } catch (e4) {
            throw e4[0];
          }
        }(e2, t3, i2, n3);
        return { gatewayInfo: await r2 };
      }
      async function LF(e2, t3, i2, n3, r2) {
        const o2 = e2.cloudProxyServer;
        if ("disabled" === o2) {
          if (!n3) return;
          if (e2.useLocalAccessPoint) return await PF(e2, t3, i2, r2);
          if (wN("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: n4, proxyInfo: o3 } = await xF(e2, t3, i2, r2);
            if (e2.turnServer && "auto" !== e2.turnServer.mode) return { gatewayInfo: n4 };
            const a4 = o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || RN.tcpport, udpport: e3.udpport || RN.udpport, username: e3.username || RN.username, password: e3.password || RN.password, forceturn: false, security: true }));
            if (r2.useP2P) {
              var s2;
              const t4 = null !== (s2 = e2.uid) && void 0 !== s2 ? s2 : n4.uid, i3 = "glb:".concat(t4.toString()), r3 = await Ww2(i3), c4 = o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || RN.tcpport, udpport: e3.udpport || RN.udpport, username: i3, password: r3, forceturn: false, security: true }));
              a4.push(...c4);
            }
            return e2.turnServer = { mode: "manual", servers: a4 }, { gatewayInfo: n4 };
          }
          return await PF(e2, t3, i2, r2);
        }
        const { proxyInfo: a3, gatewayInfo: c3 } = await xF(e2, t3, i2, r2), d2 = { gatewayInfo: c3 }, l2 = a3.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport ? e3.tcpport : RN.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport ? e3.udpport : RN.udpport, username: e3.username || RN.username, password: e3.password || RN.password, forceturn: "proxy4" !== o2, security: "proxy5" === o2 }));
        if (r2.useP2P) {
          var u3;
          const t4 = null !== (u3 = e2.uid) && void 0 !== u3 ? u3 : c3.uid, i3 = "glb:".concat(t4.toString()), n4 = await Ww2(i3), r3 = a3.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport || RN.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport || RN.udpport, username: i3, password: n4, forceturn: "proxy4" !== o2, security: "proxy5" === o2 }));
          l2.push(...r3);
        }
        return e2.turnServer = { mode: "manual", servers: l2 }, sD.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(o2)), d2;
      }
      async function kF(e2, t3, i2, n3, r2) {
        const o2 = wN("ACCOUNT_REGISTER").slice(0, wN("AJAX_REQUEST_CONCURRENT"));
        let s2 = [];
        s2 = t3.proxyServer ? o2.map((e3) => "https://".concat(t3.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : o2.map((e3) => "https://".concat(e3, "/api/v1"));
        const a3 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
        try {
          const o3 = await async function(e3, t4, i3, n4, r3) {
            const o4 = Date.now(), s3 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t4 };
            let a4 = e3[0];
            const c3 = await GO(() => oF(a4 + "".concat(-1 === a4.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: n4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i4, n5) => {
              if (0 === i4.code) {
                if (i4.uid <= 0 || i4.uid >= Math.pow(2, 32)) throw sD.error("Invalid Uint Uid ".concat(t4, " => ").concat(i4.uid), i4), _D.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a4, stringUid: s3.string_uid, uid: i4.uid, errorCode: ww2.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new ED(ww2.INVALID_UINT_UID_FROM_STRING_UID);
                return _D.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a4, stringUid: s3.string_uid, uid: i4.uid, errorCode: null, extend: s3 }), false;
              }
              const r4 = MV(i4.code);
              return r4.retry && (a4 = e3[(n5 + 1) % e3.length]), _D.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a4, stringUid: s3.string_uid, uid: i4.uid, errorCode: r4.desc, extend: s3 }), r4.retry;
            }, (t5, i4) => t5.code !== ww2.OPERATION_ABORTED && (_D.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a4, stringUid: s3.string_uid, uid: null, errorCode: t5.code, extend: s3 }), a4 = e3[(i4 + 1) % e3.length], true), r3);
            if (0 !== c3.code) {
              const e4 = MV(c3.code);
              throw new ED(ww2.UNEXPECTED_RESPONSE, e4.desc);
            }
            return c3;
          }(s2, e2, t3, i2, n3);
          return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a3), o3.uid;
        } catch (e3) {
          throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a3), e3;
        }
      }
      async function MF(e2, t3, i2) {
        const n3 = wN("ACCOUNT_REGISTER");
        let r2 = [];
        r2 = t3.proxyServer ? n3.map((e3) => "https://".concat(t3.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : n3.map((e3) => "https://".concat(e3, "/api/v1"));
        try {
          const n4 = await NF({ referenceList: r2, asyncMapHandler: (n5) => async function(e3, t4, i3, n6) {
            const r3 = Date.now(), o2 = { sid: i3.sid, opid: 10, appid: i3.appId, string_uid: t4 };
            try {
              const t5 = await oF(e3 + "".concat(-1 === e3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: o2, cancelToken: n6, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } });
              if (0 !== t5.code) {
                const e4 = MV(t5.code);
                throw new ED(ww2.UNEXPECTED_RESPONSE, "preload sua error:".concat(e4.desc), e4);
              }
              if (t5.uid <= 0 || t5.uid >= Math.pow(2, 32)) throw new ED(ww2.INVALID_UINT_UID_FROM_STRING_UID);
              return { requestTime: r3, url: e3, req: o2, uid: t5.uid, elapse: Date.now() - r3 };
            } catch (e4) {
              throw e4;
            }
          }(n5, e2, t3, i2), closeFn: (e3) => e3.code === ww2.OPERATION_ABORTED || e3.code === ww2.UNEXPECTED_RESPONSE && !e3.data.retry });
          return n4;
        } catch (e3) {
          throw e3;
        }
      }
      async function UF(e2, t3, i2) {
        const n3 = wN("CDS_AP").slice(0, wN("AJAX_REQUEST_CONCURRENT")).map((t4) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t4 + "/api/v1") : "https://".concat(t4, "/api/v1?action=config")), r2 = n3.map((n4) => function(e3, t4, i3, n5) {
          const r3 = zA2(), o3 = { flag: 64, cipher_method: 0, features: mF(mF(mF(mF(mF({ install_id: fN(), device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t4.appId, version: SN, cname: t4.cname, session_id: t4.sid, proxyServer: t4.proxyServer, sdk_type: QV.WEB_RTC, browser_name: r3.name, browser_version: r3.version, user_agent: navigator.userAgent, channel_name: t4.cname }, t4.stringUid && { string_uid: t4.stringUid }), t4.uid && { uid: t4.uid + "" }), r3.os && { os_name: r3.os }), r3.osVersion && { os_version: r3.osVersion }), {}, { detail: "" }) };
          return GO(() => oF(e3, { data: o3, timeout: 1e3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== ww2.OPERATION_ABORTED, n5);
        }(n4, e2, t3, i2));
        let o2 = null, s2 = null, a3 = {};
        try {
          o2 = await wF(r2);
        } catch (e3) {
          if (e3.code === ww2.OPERATION_ABORTED) throw e3;
          s2 = e3;
        }
        r2.forEach((e3) => e3.cancel());
        if (_D.reportApiInvoke(e2.sid, { name: zw2.REQUEST_CONFIG_DISTRIBUTE, options: { error: s2, res: o2 } }).onSuccess(), o2 && o2.test_tags) try {
          a3 = function(e3) {
            if (!e3.test_tags) return {};
            const t4 = e3.test_tags, i3 = Object.keys(t4), n4 = {};
            return i3.forEach((e4) => {
              var i4;
              const r3 = Pg2(i4 = e4.slice(4)).call(i4), o3 = JSON.parse(t4[e4]), s3 = o3[1];
              n4[r3] = { tag: o3[0] || "", value: s3 };
            }), n4;
          }(o2);
        } catch (e3) {
        }
        return a3;
      }
      async function VF(e2, t3) {
        const i2 = wN("WEBCS_DOMAIN").concat(wN("WEBCS_DOMAIN_BACKUP_LIST")).map((e3) => ({ url: "https://".concat(e3, "/api/v2/transpond/webrtc?v=2"), areaCode: sF(), serviceIds: [$V.CHOOSE_SERVER, $V.CLOUD_PROXY_FALLBACK] }));
        try {
          const n3 = await NF({ referenceList: i2, asyncMapHandler: (i3) => async function(e3, t4, i4) {
            let n4, { url: r2, areaCode: o2, serviceIds: s2 } = e3;
            const a3 = Date.now(), [c3, d2] = IF(t4, o2, s2);
            let l2 = dO.networkState;
            try {
              l2 && dO.networkState === nO.OFFLINE && dO.onlineWaiter && await ip2.race([dO.onlineWaiter, yO(BO.maxRetryTimeout)]), l2 = dO.networkState;
              const { data: e4, headers: t5 } = await oF(r2, { data: c3, cancelToken: i4, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
              n4 = "1" === t5.http3 ? 1 : -1;
              const o3 = (e5) => {
                const t6 = [];
                if (e5.response_body.forEach((i5) => {
                  const n5 = i5.buffer.code;
                  if (23 === i5.uri && 0 === n5 && !i5.buffer.edges_services) if (4194310 === i5.buffer.flag) i5.buffer.edges_services = [];
                  else {
                    const n6 = { error: new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e5.detail[502] }), flag: i5.buffer.flag };
                    t6.push(n6);
                  }
                  if (0 !== n5) {
                    const r3 = MV(n5), o4 = { error: new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, r3.desc, { desc: r3.desc, retry: r3.retry, csIp: e5.detail[502] }), flag: i5.buffer.flag };
                    4194310 === i5.buffer.flag ? sD.warning(o4.error.toString()) : t6.push(o4);
                  }
                }), t6.length) throw new ED(ww2.CAN_NOT_GET_GATEWAY_SERVER, t6.map((e6) => "flag: ".concat(e6.flag, ", message: ").concat(e6.error.message)).join(" | "), { retry: !!t6.find((e6) => e6.error.data.retry), csIp: e5.detail[502], desc: [...new Set(t6.map((e6) => {
                  var t7;
                  return null == e6 || null === (t7 = e6.error) || void 0 === t7 || null === (t7 = t7.data) || void 0 === t7 ? void 0 : t7.desc;
                }).filter((e6) => !!e6))] });
              };
              o3(e4);
              const s3 = cx2(e4, $V.CHOOSE_SERVER), u3 = cx2(e4, $V.CLOUD_PROXY_FALLBACK);
              return CF(s3), { gatewayInfo: rx2(s3, r2), proxyInfo: u3, opid: d2, requestTime: a3, url: r2, isHttp3: n4, elapse: Date.now() - a3 };
            } catch (e4) {
              throw e4;
            }
          }(i3, e2, t3), closeFn: (e3) => e3.code === ww2.OPERATION_ABORTED || e3.code === ww2.CAN_NOT_GET_GATEWAY_SERVER && !e3.data.retry });
          return n3;
        } catch (e3) {
          throw e3;
        }
      }
      async function xF(e2, t3, i2, n3) {
        const r2 = wN("PROXY_SERVER_TYPE3"), o2 = (e3, t4, i3) => {
          let n4 = i3 || r2;
          return Array.isArray(n4) && (n4 = t4 % 2 == 0 && r2[1] || r2[0]), "https://".concat(n4, "/ap/?url=").concat(e3);
        };
        let s2 = null;
        const a3 = [], c3 = async () => {
          const r3 = wN("WEBCS_DOMAIN").slice(0, wN("AJAX_REQUEST_CONCURRENT")).map((t4, i3) => {
            let n4;
            return n4 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t4, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i3), { url: n4, areaCode: sF(), serviceIds: [$V.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? $V.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? $V.CLOUD_PROXY : $V.CLOUD_PROXY_FALLBACK] };
          }), s3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), c4 = await OF({ fragementLength: wN("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n4) => (sD.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n4.url), RF(n4, e2, t3, i2)), allFailedhandler: (e3) => {
            throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, s3), e3[0];
          }, promisesCollector: a3 });
          return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c4;
        }, d2 = async () => {
          if (await yO(1e3), null !== s2) return s2;
          const r3 = wN("WEBCS_DOMAIN_BACKUP_LIST").map((t4, i3) => {
            let n4;
            return n4 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i3, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t4, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t4, "/api/v2/transpond/webrtc?v=2"), i3), { url: n4, areaCode: sF(), serviceIds: [$V.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? $V.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? $V.CLOUD_PROXY : $V.CLOUD_PROXY_FALLBACK] };
          }), c4 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), d3 = await OF({ fragementLength: wN("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n4) => (sD.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n4.url), RF(n4, e2, t3, i2)), allFailedhandler: (e3) => {
            throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c4), e3[0];
          }, promisesCollector: a3 });
          return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c4), d3;
        };
        let l2, u3, h2;
        try {
          ({ gatewayInfo: l2, proxyInfo: u3, url: h2 } = await wF([c3(), d2()]));
        } catch (e3) {
          throw e3[0];
        }
        if (a3.length && a3.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), !l2 || !u3) throw new ED(ww2.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e2.apUrl = h2, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && h2) {
          const t4 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h2)[1];
          Ln2(r2).call(r2, t4) && (e2.proxyServer = t4, sD.setProxyServer(t4), _D.setProxyServer(t4));
        }
        return s2 = { gatewayInfo: l2, proxyInfo: await dx2(u3, l2.uid) }, s2;
      }
      async function FF(e2, t3, i2) {
        const n3 = wN("UAP_AP").slice(0, wN("AJAX_REQUEST_CONCURRENT")).map((t4) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t4 + "/api/v1?action=uap") : "https://".concat(t4, "/api/v1?action=uap")), r2 = n3.map((n4) => function(e3, t4, i3, n5) {
          const r3 = { command: "convergeAllocateEdge", sid: t4.sid, appId: t4.appId, token: t4.token, ts: Date.now(), version: SN, cname: t4.cname, uid: t4.uid.toString(), requestId: gF, seq: gF };
          gF += 1;
          const o2 = { service_name: "tele_channel", json_body: JSON.stringify(r3) };
          return GO(async () => {
            const t5 = await oF(e3, { data: o2, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (0 !== t5.code) {
              const e4 = new ED(ww2.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t5.code, { retry: true });
              throw sD.error(e4.toString()), e4;
            }
            const n6 = JSON.parse(t5.json_body);
            if (200 !== n6.code) {
              const e4 = new ED(ww2.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n6.code, ", reason: ").concat(n6.reason));
              throw sD.error(e4.toString()), e4;
            }
            if (!n6.servers || 0 === n6.servers.length) {
              const e4 = new ED(ww2.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw sD.error(e4.toString()), e4;
            }
            return { vid: n6.vid, workerToken: n6.workerToken, addressList: (wN("CHANNEL_MEDIA_RELAY_SERVERS") || n6.servers).map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(wN("WORKER_DOMAIN"), ":").concat(e4.wss)) };
          }, void 0, (e4) => !!(e4.code !== ww2.OPERATION_ABORTED && e4.code !== ww2.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), n5);
        }(n4, e2, t3, i2));
        try {
          const e3 = await wF(r2);
          return r2.forEach((e4) => e4.cancel()), e3;
        } catch (e3) {
          throw e3[0];
        }
      }
      async function BF(e2, t3, i2) {
        let n3 = null;
        const r2 = [], o2 = async (o3) => {
          const s2 = wN(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t4) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"));
          return o3 && (await yO(1e3), null !== n3) ? n3 : await OF({ fragementLength: wN("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (n4) => (sD.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), n4), function(e3, t4, i3, n5) {
            const [r3] = bF(t4, [$V.CHOOSE_SERVER]);
            let o4 = dO.networkState;
            return GO(async () => {
              o4 && dO.networkState === nO.OFFLINE && dO.onlineWaiter && await ip2.race([dO.onlineWaiter, yO(n5 && n5.maxRetryTimeout || BO.maxRetryTimeout)]), o4 = dO.networkState;
              const t5 = await oF(e3, { data: r3, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return yF(t5, e3);
            }, () => false, (e4) => e4.code !== ww2.OPERATION_ABORTED && (e4.code === ww2.UPDATE_TICKET_FAILED ? e4.data.retry : (sD.warning("[".concat(t4.clientId, "] update ticket network error, retry"), e4), true)), n5);
          }(n4, e2, t3, i2)), allFailedhandler: (e3) => {
            throw e3[0];
          }, promisesCollector: r2 });
        };
        try {
          return n3 = await wF([o2(false), o2(true)]), r2.length && r2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), n3;
        } catch (e3) {
          throw e3[0];
        }
      }
      function jF(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function GF(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? jF(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : jF(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      class WF extends Hw2 {
        get isSuccess() {
          return !!this.configs;
        }
        constructor(e2, t3) {
          super(), uI(this, "configs", void 0), uI(this, "store", void 0), uI(this, "joinInfo", void 0), uI(this, "cancelToken", void 0), uI(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), uI(this, "interval", void 0), uI(this, "mutex", void 0), uI(this, "mutableParamsRead", false), uI(this, "configCache", {}), uI(this, "limit_bitrate", void 0), this.mutex = new xO("config-distribute", e2), this.store = t3;
        }
        startGetConfigDistribute(e2, t3) {
          this.joinInfo = e2, this.cancelToken = t3, this.interval && this.stopGetConfigDistribute(), wN("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, wN("CONFIG_DISTRIBUTE_INTERVAL")));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0, this.configs = void 0, this.limit_bitrate = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked) return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            _D.reportApiInvoke(null, { options: void 0, name: zw2.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: qw2.TRACER }).onSuccess(JSON.stringify(NN));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void sD.debug("[config-distribute] get config distribute interrupted have no joininfo");
          let e2;
          const t3 = await this.mutex.lock();
          try {
            e2 = await UF(this.joinInfo, this.cancelToken, this.retryConfig), sD.debug("[config-distribute] get config distribute", JSON.stringify(e2));
            const i2 = function(e3) {
              var t4;
              const i3 = Xp2(t4 = Object.keys(e3).filter((e4) => /^webrtc_ng_global_parameter/.test(e4))).call(t4);
              for (let t5 = 0; t5 < i3.length; t5++) for (let n4 = i3.length - 1; n4 > t5; n4--) {
                const t6 = i3[n4], r3 = e3[t6].value;
                if ("number" == typeof r3.__priority) {
                  const o2 = r3.__priority, s2 = i3[n4 - 1], a3 = e3[s2].value;
                  if ("number" == typeof a3.__priority) {
                    if (!(o2 > a3.__priority)) continue;
                    {
                      const e4 = t6;
                      i3[n4] = i3[n4 - 1], i3[n4 - 1] = e4;
                    }
                  } else {
                    const e4 = t6;
                    i3[n4] = i3[n4 - 1], i3[n4 - 1] = e4;
                  }
                }
              }
              const n3 = Date.now();
              let r2 = {};
              return i3.forEach((t5) => {
                const i4 = e3[t5].value.__expires;
                i4 && i4 <= n3 || (r2[t5] = e3[t5]);
              }), r2;
            }(e2);
            this.cacheGlobalParameterConfig(i2), this.store.hasStartJoinChannel || (this.store.isABTestSuccess = true), this.configs = i2;
          } catch (e3) {
            const t4 = new ED(ww2.NETWORK_RESPONSE_ERROR, e3);
            sD.warning("[config-distribute] ".concat(t4.toString()));
          } finally {
            t3();
          }
        }
        getBitrateLimit() {
          return this.limit_bitrate || void 0;
        }
        handleBitrateLimit(e2) {
          hV(e2) && (this.limit_bitrate ? this.limit_bitrate && this.limit_bitrate.id !== e2.id && this.emit(uV.UPDATE_BITRATE_LIMIT, e2) : this.emit(uV.UPDATE_BITRATE_LIMIT, e2));
        }
        getLowStreamConfigDistribute() {
          return this.limit_bitrate && GF({}, this.limit_bitrate.low_stream_uplink);
        }
        handleABTestConfigDistribute(e2) {
          try {
            const t3 = {}, i2 = Object.keys(e2), n3 = [];
            i2.forEach((i3) => {
              const r2 = e2[i3].value;
              t3[i3] = r2;
              const o2 = r2.__id;
              if (o2 && this.configCache[i3] && this.configCache[i3].__id === o2) return;
              const s2 = r2.__type, a3 = e2[i3].value, c3 = e2[i3].tag;
              let d2 = 0;
              s2 ? s2 === ON.REALTIME && (d2 = 1) : Object.keys(a3).some((e3) => Object.prototype.hasOwnProperty.call(IN, e3) || !YM() && Object.prototype.hasOwnProperty.call(vN, e3) ? (d2 = 1, true) : void 0), n3.push({ tag: c3, isApplied: d2, feature: i3, params: JSON.stringify(r2) });
            }), n3.forEach((e3) => {
              let { tag: t4, feature: i3, params: n4, isApplied: r2 } = e3;
              this.store.sessionId && _D.abTest(this.store.sessionId, { intSucc: 1, isApplied: r2, tag: t4, feature: i3, params: n4, cid: this.store.cid, uid: this.store.intUid });
            }), this.configCache = t3;
          } catch (e3) {
            sD.debug("handleABTestConfigDistribute error", e3);
          }
        }
        cacheGlobalParameterConfig(e2) {
          const t3 = function(e3) {
            const t4 = {};
            return Object.keys(e3).forEach((i3) => {
              const n3 = e3[i3].value, r2 = n3.__expires, o2 = n3.__type;
              Object.keys(n3).forEach((e4) => {
                "__id" === e4 || "__type" === e4 || "__priority" === e4 || "__expires" === e4 || Object.prototype.hasOwnProperty.call(t4, e4) || (t4[e4] = GF(GF({ value: n3[e4] }, r2 && { expires: r2 }), o2 && { type: o2 }));
              });
            }), t4;
          }(e2);
          try {
            var i2;
            const n3 = null === (i2 = t3.LIMIT_BITRATE) || void 0 === i2 ? void 0 : i2.value;
            delete t3.LIMIT_BITRATE, n3 && hV(n3) && this.handleBitrateLimit(n3), this.limit_bitrate = n3, this.handleGlobalParameterConfig(t3), this.handleABTestConfigDistribute(e2), function(e3) {
              try {
                const t4 = Date.now();
                Object.keys(e3).forEach((i3) => {
                  const { value: n4, type: r3, expires: o3 } = e3[i3];
                  o3 && o3 <= t4 || ((r3 === ON.REALTIME || Object.prototype.hasOwnProperty.call(IN, i3)) && (NN[i3] = n4, bN[i3] = n4, sD.debug("Update realtime parameters from config distribute", i3, n4)), r3 || YM() || !Object.prototype.hasOwnProperty.call(vN, i3) || (NN[i3] = n4, bN[i3] = n4, sD.debug("Update gateway parameters from config distribute", i3, n4)));
                });
              } catch (t4) {
                sD.error("Error update config immediately: ".concat(e3), t4.message);
              }
            }(t3);
            const r2 = JSON.stringify(t3), o2 = window.btoa(r2);
            window.localStorage.setItem("websdk_ng_global_parameter", o2), sD.debug("Caching global parameters ".concat(r2));
          } catch (e3) {
            sD.error("Error caching global parameters:", e3.message);
          }
        }
        handleGlobalParameterConfig(e2) {
          try {
            const t3 = Date.now();
            Object.keys(e2).forEach((i2) => {
              if ("CLIENT_ROLE_OPTIONS" === i2) {
                if (Object.prototype.hasOwnProperty.call(bN, i2)) {
                  const { value: n3, expires: r2 } = e2[i2];
                  if (r2 && r2 <= t3) return;
                  (function(e3, t4) {
                    try {
                      return "object" == typeof e3 && "object" == typeof t4 && JSON.stringify(e3) === JSON.stringify(t4);
                    } catch (e4) {
                      return false;
                    }
                  })(bN[i2], n3) || (NN[i2] = n3, bN[i2] = n3, this.emit(uV.UPDATE_CLIENT_ROLE_OPTIONS, n3), sD.debug("Updating client role options: ".concat(JSON.stringify(n3))));
                }
              }
            });
          } catch (e3) {
            sD.error("Error handling global parameter config:", e3.message);
          }
        }
      }
      class HF extends Hw2 {
        constructor() {
          super(...arguments), uI(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e2, t3, i2) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i2, t3)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i2, t3));
        }
        setLocalVideoStats(e2, t3, i2) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i2, t3)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i2, t3)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i2)), !t3.muted && this.record("VIDEO_ENCODE_FAILED", e2, this.checResolutionSent(i2));
        }
        setRemoteAudioStats(e2, t3) {
          const i2 = e2.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i2, this.checkAudioOutputLevel(t3));
        }
        setRemoteVideoStats(e2, t3) {
          const i2 = e2.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", i2, this.checkVideoDecode(t3));
        }
        record(e2, t3, i2) {
          if (wN("STATS_UPDATE_INTERVAL") > 500) return;
          this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
          const n3 = this.resultStorage.get(e2);
          if (!n3) return;
          n3.result.push(i2);
          const r2 = "VIDEO_ENCODE_FAILED" === e2 ? wN("ENCODE_EXCEPTION_TIMES") : 5;
          if (n3.result.length >= r2) {
            var o2;
            const i3 = Ln2(o2 = n3.result).call(o2, true);
            n3.isPrevNormal && !i3 && this.emit("exception", KF[e2], e2, t3), !n3.isPrevNormal && i3 && this.emit("exception", KF[e2] + 2e3, e2 + "_RECOVER", t3), n3.isPrevNormal = i3, n3.result = [];
          }
        }
        checkAudioOutputLevel(e2) {
          return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
        }
        checkAudioInputLevel(e2, t3) {
          return t3 instanceof WL && !t3.isActive || (!!t3.muted || 0 !== e2.sendVolumeLevel);
        }
        checkFramerateInput(e2, t3) {
          let i2 = null;
          t3._encoderConfig && t3._encoderConfig.frameRate && (i2 = ox2(t3._encoderConfig.frameRate));
          const n3 = e2.captureFrameRate;
          return !i2 || !n3 || !(i2 > 10 && n3 < 5 || i2 < 10 && i2 >= 5 && n3 <= 1);
        }
        checkFramerateSent(e2) {
          return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
        }
        checResolutionSent(e2) {
          var t3;
          return !(!e2.codecType || Ln2(t3 = wN("ENCODE_EXCEPTION_VALIDATE_CODEC")).call(t3, e2.codecType.toLocaleLowerCase())) || (!e2.captureFrameRate || 0 !== e2.sendFrameRate || 0 !== e2.sendResolutionWidth || 0 !== e2.sendResolutionHeight);
        }
        checkSendVideoBitrate(e2, t3) {
          return !!t3.muted || 0 !== e2.sendBitrate;
        }
        checkSendAudioBitrate(e2, t3) {
          return t3 instanceof WL && !t3.isActive || (!!t3.muted || 0 !== e2.sendBitrate);
        }
        checkVideoDecode(e2) {
          return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
        }
      }
      const KF = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003, VIDEO_ENCODE_FAILED: 2004 };
      const YF = new class {
        markSubscribeStart(e2, t3) {
          performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t3));
        }
        markPublishStart(e2, t3) {
          performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t3));
        }
        measureFromSubscribeStart(e2, t3) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t3));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e2, t3) {
          const i2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t3));
          if (i2.length > 0) {
            const e3 = i2[i2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
      }();
      function zF(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function qF(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? zF(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : zF(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      class XF {
        constructor(e2) {
          uI(this, "store", void 0), uI(this, "onStatsException", void 0), uI(this, "onUploadPublishDuration", void 0), uI(this, "onStatsChanged", void 0), uI(this, "onVideoCodecChanged", void 0), uI(this, "localStats", /* @__PURE__ */ new Map()), uI(this, "remoteStats", /* @__PURE__ */ new Map()), uI(this, "updateStatsInterval", void 0), uI(this, "trafficStats", void 0), uI(this, "trafficStatsPeerList", []), uI(this, "uplinkStats", void 0), uI(this, "exceptionMonitor", void 0), uI(this, "p2pChannel", void 0), uI(this, "scalabilityMode", cN.L1T1), uI(this, "updateStats", () => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          }), this.store = e2, this.exceptionMonitor = new HF(), this.exceptionMonitor.on("exception", (e3, t3, i2) => {
            this.onStatsException && this.onStatsException(e3, t3, i2);
          });
        }
        startUpdateStats() {
          this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));
        }
        stopUpdateStats() {
          this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(gV.LocalAudioTrack) || qF({}, zD);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(gV.LocalVideoTrack) || qF({}, qD2);
        }
        getRemoteAudioTrackStats(e2) {
          const t3 = (e3, t4) => {
            if (!this.trafficStats) return t4;
            const i3 = this.trafficStats.peer_delay.find((t5) => t5.peer_uid === e3);
            return i3 && (t4.publishDuration = i3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t4;
          }, i2 = {};
          if (e2) {
            var n3;
            const r2 = null === (n3 = this.remoteStats.get(e2)) || void 0 === n3 ? void 0 : n3.audioStats;
            r2 && (i2[e2] = t3(e2, r2));
          } else Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [n4, { audioStats: r2 }] = e3;
            r2 && (i2[n4] = t3(n4, r2));
          });
          return i2;
        }
        getRemoteNetworkQualityStats(e2) {
          const t3 = {};
          if (e2) {
            var i2;
            const n3 = null === (i2 = this.remoteStats.get(e2)) || void 0 === i2 ? void 0 : i2.networkStats;
            n3 && (t3[e2] = n3);
          } else Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [i3, { networkStats: n3 }] = e3;
            n3 && (t3[i3] = n3);
          });
          return t3;
        }
        getRemoteVideoTrackStats(e2) {
          const t3 = (e3, t4) => {
            if (!this.trafficStats) return t4;
            const i3 = this.trafficStats.peer_delay.find((t5) => t5.peer_uid === e3);
            return i3 && (t4.publishDuration = i3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t4;
          }, i2 = {};
          if (e2) {
            var n3;
            const r2 = null === (n3 = this.remoteStats.get(e2)) || void 0 === n3 ? void 0 : n3.videoStats;
            r2 && (i2[e2] = t3(e2, r2));
          } else Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [n4, { videoStats: r2 }] = e3;
            r2 && (i2[n4] = t3(n4, r2));
          });
          return i2;
        }
        getRTCStats() {
          let e2 = 0, t3 = 0, i2 = 0, n3 = 0;
          const r2 = this.localStats.get(gV.LocalAudioTrack);
          r2 && (e2 += r2.sendBytes, t3 += r2.sendBitrate);
          const o2 = this.localStats.get(gV.LocalVideoTrack);
          o2 && (e2 += o2.sendBytes, t3 += o2.sendBitrate);
          const s2 = this.localStats.get(gV.LocalVideoLowTrack);
          s2 && (e2 += s2.sendBytes, t3 += s2.sendBitrate), this.remoteStats.forEach((e3) => {
            let { audioStats: t4, videoStats: r3 } = e3;
            t4 && (i2 += t4.receiveBytes, n3 += t4.receiveBitrate), r3 && (i2 += r3.receiveBytes, n3 += r3.receiveBitrate);
          });
          let a3 = 1;
          return this.trafficStats && (a3 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a3, SendBitrate: t3, SendBytes: e2, RecvBytes: i2, RecvBitrate: n3, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e2) {
          this.localStats.set(e2, void 0);
        }
        removeLocalStats(e2) {
          e2 ? this.localStats.delete(e2) : this.localStats.clear();
        }
        addRemoteStats(e2) {
          this.remoteStats.set(e2, {});
        }
        removeRemoteStats(e2) {
          e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
        }
        addP2PChannel(e2) {
          this.p2pChannel = e2;
        }
        updateTrafficStats(e2) {
          e2.peer_delay = e2.peer_delay.filter((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd);
          e2.peer_delay.filter((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid)).forEach((e3) => {
            var t3;
            const i2 = null === (t3 = this.p2pChannel) || void 0 === t3 ? void 0 : t3.getRemoteMedia(e3.peer_uid), n3 = null != i2 && i2.videoSSRC ? YF.measureFromSubscribeStart(this.store.clientId, i2.videoSSRC) : 0, r2 = null != i2 && i2.audioSSRC ? YF.measureFromSubscribeStart(this.store.clientId, i2.audioSSRC) : 0;
            void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n3 > r2 ? n3 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
          }), this.trafficStats = e2;
        }
        updateUplinkStats(e2) {
          this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && sD.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
        }
        static isRemoteVideoFreeze(e2, t3, i2) {
          if (!e2) return false;
          const n3 = !!i2 && t3.framesDecodeFreezeTime > i2.framesDecodeFreezeTime, r2 = !i2 || t3.framesDecodeCount > i2.framesDecodeCount;
          return n3 || !r2;
        }
        static isRemoteAudioFreeze(e2) {
          return !!e2 && e2._isFreeze();
        }
        isLocalVideoFreeze(e2) {
          return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
        }
        updateLocalStats(e2) {
          Array.from(this.localStats.entries()).forEach((t3) => {
            let [i2, n3] = t3;
            switch (i2) {
              case gV.LocalVideoTrack:
              case gV.LocalVideoLowTrack: {
                const t4 = n3, s2 = qF({}, qD2), a3 = e2.getStats(), c3 = e2.getLocalMedia(i2);
                if (a3) {
                  const i3 = a3.videoSend.find((e3) => e3.ssrc === (null == c3 ? void 0 : c3.ssrcs[0].ssrcId));
                  if (i3) {
                    const n4 = e2.getLocalVideoSize(), o3 = e2.getEncoderConfig(gV.LocalVideoTrack);
                    var r2;
                    if ("H264" === i3.codec || "H265" === i3.codec || "VP8" === i3.codec || "VP9" === i3.codec || "AV1X" === i3.codec || "AV1" === i3.codec) {
                      if (s2.codecType = i3.codec, (null == t4 ? void 0 : t4.codecType) !== i3.codec) null === (r2 = this.onVideoCodecChanged) || void 0 === r2 || r2.call(this, i3.codec.toLocaleLowerCase());
                    }
                    s2.sendBytes = i3.bytes, s2.sendBitrate = t4 ? 8 * Math.max(0, s2.sendBytes - t4.sendBytes) : 0, i3.inputFrame ? (s2.captureFrameRate = i3.inputFrame.frameRate, s2.captureResolutionHeight = i3.inputFrame.height, s2.captureResolutionWidth = i3.inputFrame.width) : n4 && (s2.captureResolutionWidth = n4.width, s2.captureResolutionHeight = n4.height), i3.sentFrame ? (s2.sendFrameRate = i3.sentFrame.frameRate, s2.sendResolutionHeight = i3.sentFrame.height, s2.sendResolutionWidth = i3.sentFrame.width) : n4 && (s2.sendResolutionWidth = n4.width, s2.sendResolutionHeight = n4.height), i3.avgEncodeMs && (s2.encodeDelay = i3.avgEncodeMs), o3 && o3.bitrateMax ? s2.targetSendBitrate = 1e3 * o3.bitrateMax : i3.targetBitrate && (s2.targetSendBitrate = i3.targetBitrate), s2.sendPackets = i3.packets, s2.sendPacketsLost = i3.packetsLost, s2.sendJitterMs = i3.jitterMs, s2.sendRttMs = i3.rttMs, s2.totalDuration = t4 ? t4.totalDuration + 1 : 1, s2.totalFreezeTime = t4 ? t4.totalFreezeTime : 0, this.isLocalVideoFreeze(i3) && (s2.totalFreezeTime += 1), i3.scalabilityMode && this.scalabilityMode !== i3.scalabilityMode && (sD.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i3.scalabilityMode)), this.scalabilityMode = i3.scalabilityMode);
                  }
                  this.trafficStats && (s2.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
                }
                var o2;
                if (this.localStats.set(i2, s2), (null == t4 ? void 0 : t4.sendResolutionWidth) !== s2.sendResolutionWidth || (null == t4 ? void 0 : t4.sendResolutionHeight) !== s2.sendResolutionHeight) null === (o2 = this.onStatsChanged) || void 0 === o2 || o2.call(this, "resolution", { width: s2.sendResolutionWidth, height: s2.sendResolutionHeight });
                s2 && c3 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, c3.track, s2);
                break;
              }
              case gV.LocalAudioTrack: {
                const t4 = n3, r3 = qF({}, zD), o3 = e2.getStats(), s2 = e2.getLocalMedia(i2);
                if (o3) {
                  const i3 = o3.audioSend.find((e3) => e3.ssrc === (null == s2 ? void 0 : s2.ssrcs[0].ssrcId));
                  if (i3) {
                    if ("opus" !== i3.codec && "aac" !== i3.codec && "PCMU" !== i3.codec && "PCMA" !== i3.codec && "G722" !== i3.codec || (r3.codecType = i3.codec), i3.inputLevel) r3.sendVolumeLevel = Math.round(32767 * i3.inputLevel);
                    else {
                      const t5 = e2.getLocalAudioVolume();
                      t5 && (r3.sendVolumeLevel = Math.round(32767 * t5));
                    }
                    r3.sendBytes = i3.bytes, r3.sendPackets = i3.packets, r3.sendPacketsLost = i3.packetsLost, r3.sendJitterMs = i3.jitterMs, r3.sendRttMs = i3.rttMs, r3.sendBitrate = t4 ? 8 * Math.max(0, r3.sendBytes - t4.sendBytes) : 0;
                  }
                }
                this.trafficStats && (r3.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(gV.LocalAudioTrack, r3), r3 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, r3);
                break;
              }
            }
          });
        }
        updateRemoteStats(e2) {
          Array.from(this.remoteStats.entries()).forEach((t3) => {
            var i2, n3;
            let [r2, { videoStats: o2, audioStats: s2, videoPcStats: a3 }] = t3;
            const c3 = s2, d2 = o2, l2 = a3, u3 = qF({}, XD), h2 = qF({}, ZD), p2 = qF({}, JD), { audioTrack: _2, videoTrack: E3, audioSSRC: m3, videoSSRC: f2 } = e2.getRemoteMedia(r2);
            let S3;
            S3 = this.store.useP2P ? e2.getStats(true) : e2.getStats();
            const g2 = null === (i2 = S3) || void 0 === i2 ? void 0 : i2.audioRecv.find((e3) => e3.ssrc === m3), T3 = null === (n3 = S3) || void 0 === n3 ? void 0 : n3.videoRecv.find((e3) => e3.ssrc === f2), R3 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === r2);
            if (g2 && ("opus" !== g2.codec && "aac" !== g2.codec && "PCMU" !== g2.codec && "PCMA" !== g2.codec && "G722" !== g2.codec || (u3.codecType = g2.codec), g2.outputLevel ? u3.receiveLevel = Math.round(32767 * g2.outputLevel) : _2 && (u3.receiveLevel = Math.round(32767 * _2.getVolumeLevel())), u3.receiveBytes = g2.bytes, u3.receivePackets = g2.packets, u3.receivePacketsLost = g2.packetsLost, u3.receivePacketsDiscarded = g2.packetsDiscarded, u3.packetLossRate = u3.receivePacketsLost / (u3.receivePackets + u3.receivePacketsLost), u3.receiveBitrate = c3 ? 8 * Math.max(0, u3.receiveBytes - c3.receiveBytes) : 0, u3.totalDuration = c3 ? c3.totalDuration + 1 : 1, u3.totalFreezeTime = c3 ? c3.totalFreezeTime : 0, u3.freezeRate = u3.totalFreezeTime / u3.totalDuration, u3.receiveDelay = g2.jitterBufferMs, u3.totalDuration > 10 && XF.isRemoteAudioFreeze(_2) && (u3.totalFreezeTime += 1)), T3) {
              var v3;
              "H264" !== T3.codec && "H265" !== T3.codec && "VP8" !== T3.codec && "VP9" !== T3.codec && "AV1X" !== T3.codec && "AV1" !== T3.codec || (h2.codecType = T3.codec), h2.receiveBytes = T3.bytes, h2.receiveBitrate = d2 ? 8 * Math.max(0, h2.receiveBytes - d2.receiveBytes) : 0, h2.decodeFrameRate = T3.decodeFrameRate < 0 ? 0 : T3.decodeFrameRate, h2.renderFrameRate = T3.decodeFrameRate < 0 ? 0 : T3.decodeFrameRate, T3.outputFrame && (h2.renderFrameRate = T3.outputFrame.frameRate), T3.receivedFrame ? (h2.receiveFrameRate = T3.receivedFrame.frameRate, h2.receiveResolutionHeight = T3.receivedFrame.height, h2.receiveResolutionWidth = T3.receivedFrame.width) : E3 && (h2.receiveResolutionHeight = E3._videoHeight || 0, h2.receiveResolutionWidth = E3._videoWidth || 0), void 0 !== T3.framesRateFirefox && (h2.receiveFrameRate = Math.round(T3.framesRateFirefox)), h2.receivePackets = T3.packets, h2.receivePacketsLost = T3.packetsLost, h2.packetLossRate = h2.receivePacketsLost / (h2.receivePackets + h2.receivePacketsLost);
              const t4 = d2 ? d2.totalFreezeTime : 0, i3 = d2 ? d2.totalDuration : 0;
              h2.totalDuration = d2 ? d2.totalDuration + 1 : 1, h2.totalFreezeTime = null !== (v3 = T3.totalFreezesDuration) && void 0 !== v3 ? v3 : t4 || 0, h2.receiveDelay = T3.jitterBufferMs || 0;
              const n4 = !!f2 && e2.getRemoteVideoIsReady(f2);
              void 0 === T3.totalFreezesDuration && E3 && n4 && XF.isRemoteVideoFreeze(E3, T3, l2) && (h2.totalFreezeTime += 1), h2.freezeRate = Math.max(0, Math.min((h2.totalFreezeTime - t4) / (h2.totalDuration - i3), 1));
            }
            R3 && (u3.end2EndDelay = R3.B_ad, h2.end2EndDelay = R3.B_vd, u3.transportDelay = R3.B_ed, h2.transportDelay = R3.B_ed, u3.currentPacketLossRate = R3.B_ealr4 / 100, h2.currentPacketLossRate = R3.B_evlr4 / 100, p2.uplinkNetworkQuality = R3.B_punq ? R3.B_punq : 0, p2.downlinkNetworkQuality = R3.B_pdnq ? R3.B_pdnq : 0), this.remoteStats.set(r2, { audioStats: u3, videoStats: h2, videoPcStats: T3, networkStats: p2 }), _2 && this.exceptionMonitor.setRemoteAudioStats(_2, u3), E3 && this.exceptionMonitor.setRemoteVideoStats(E3, h2);
          });
        }
      }
      class JF {
        constructor() {
          uI(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), uI(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e2) {
          QU(e2), this.srcChannelMediaInfo = e2;
        }
        addDestChannelInfo(e2) {
          QU(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
        }
        removeDestChannelInfo(e2) {
          GU(e2), this.destChannelMediaInfos.delete(e2);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function ZF(e2) {
        if (!(e2 instanceof JF)) {
          return new ED(ww2.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t3 = e2.getSrcChannelMediaInfo(), i2 = e2.getDestChannelMediaInfo();
        if (!t3) {
          return new ED(ww2.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (0 === i2.size) {
          return new ED(ww2.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class QF {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;
        }
        get dataChannels() {
          return this._dataChannels;
        }
        constructor(e2, t3) {
          uI(this, "uid", void 0), uI(this, "_uintid", void 0), uI(this, "_trust_in_room_", true), uI(this, "_trust_audio_enabled_state_", true), uI(this, "_trust_video_enabled_state_", true), uI(this, "_trust_audio_mute_state_", true), uI(this, "_trust_video_mute_state_", true), uI(this, "_audio_muted_", false), uI(this, "_video_muted_", false), uI(this, "_audio_enabled_", true), uI(this, "_video_enabled_", true), uI(this, "_audio_added_", false), uI(this, "_video_added_", false), uI(this, "_is_pre_created", false), uI(this, "_video_pre_subscribed", false), uI(this, "_audio_pre_subscribed", false), uI(this, "_trust_video_stream_added_state_", true), uI(this, "_trust_audio_stream_added_state_", true), uI(this, "_audioTrack", void 0), uI(this, "_videoTrack", void 0), uI(this, "_dataChannels", []), uI(this, "_audioSSRC", void 0), uI(this, "_videoSSRC", void 0), uI(this, "_audioOrtc", void 0), uI(this, "_videoOrtc", void 0), uI(this, "_cname", void 0), uI(this, "_rtxSsrcId", void 0), uI(this, "_videoMid", void 0), uI(this, "_audioMid", void 0), this.uid = e2, this._uintid = t3;
        }
      }
      function $F(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function eB2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? $F(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : $F(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const tB2 = "9", iB2 = 2e4, nB2 = 4e4;
      function rB2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function oB2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? rB2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : rB2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      var sB2 = function(e2) {
        return e2[e2.DOWN = 0] = "DOWN", e2[e2.UP = 1] = "UP", e2;
      }(sB2 || {});
      const aB2 = /* @__PURE__ */ new Map();
      function cB2(e2, t3, i2, n3) {
        let { scale: r2 } = e2;
        if (0 === r2 && n3 === sB2.UP || r2 >= t3.length - 1 && n3 === sB2.DOWN) return e2;
        let o2 = oB2(oB2({}, e2), {}, { scale: n3 === sB2.DOWN ? ++r2 : --r2 });
        switch (i2) {
          case "maintain-framerate":
            o2 = oB2(oB2({}, o2), t3[r2].motion);
            break;
          case "maintain-resolution":
            o2 = oB2(oB2({}, o2), t3[r2].detail);
            break;
          case "balanced":
            o2 = oB2(oB2({}, o2), t3[r2].balanced);
        }
        return o2;
      }
      function dB2(e2, t3) {
        if (t3) {
          const i2 = { overUse: 0, underUse: 0, adaptationList: lB2(t3) };
          aB2.set(e2, i2);
        } else aB2.delete(e2);
      }
      function lB2(e2) {
        const t3 = oB2({}, e2), { bitrateMax: i2, frameRate: n3, scaleResolutionDownBy: r2, bitrateMin: o2 } = t3, { MIN_FRAME_RATE: s2, MAX_THRESHOLD_FRAMERATE: a3, MAX_SCALE: c3, BITRATE_MIN_THRESHOLD: d2, BITRATE_MAX_THRESHOLD: l2, BWE_SCALE_UP_THRESHOLD: u3, BWE_SCALE_DOWN_THRESHOLD: h2, PERF_SCALE_DOWN_THRESHOLD: p2, PERF_SCALE_UP_THRESHOLD: _2, BALANCE_BITRATE_FACTOR: E3, BALANCE_FRAMERATE_FACTOR: m3, BALANCE_RESOLUTION_FACTOR: f2, MOTION_RESOLUTION_FACTOR: S3, MOTION_BITRATE_FACTOR: g2, DETAIL_FRAMERATE_FACTOR: T3, DETAIL_BITRATE_FACTOR: R3 } = CN, v3 = Math.min(t3.frameRate, a3), C2 = [{ scale: 0, threshold: { bwe_down: Math.round(Math.pow(h2, 1) * i2), bwe_up: i2, fps_down: Math.round(Math.pow(p2, 1) * v3), fps_up: n3 }, balanced: { scaleResolutionDownBy: 1, frameRate: n3, bitrateMax: i2, bitrateMin: o2 }, motion: { scaleResolutionDownBy: 1, frameRate: n3, bitrateMax: i2, bitrateMin: o2 }, detail: { scaleResolutionDownBy: 1, frameRate: n3, bitrateMax: i2, bitrateMin: o2 } }];
        for (let e3 = 1; e3 <= c3; e3++) {
          const t4 = { bwe_up: Math.round(Math.pow(u3, e3) * i2), bwe_down: Math.round(Math.pow(h2, e3 + 1) * i2), fps_up: Math.round(Math.pow(_2, e3) * v3), fps_down: Math.round(Math.pow(p2, e3 + 1) * v3) }, a4 = { scaleResolutionDownBy: r2 / Math.pow(f2, e3), frameRate: Math.max(Math.round(Math.pow(m3, e3) * n3), s2), bitrateMax: Math.max(Math.round(Math.pow(E3, e3) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(E3, e3) * o2), d2) }, c4 = { scaleResolutionDownBy: r2 / Math.pow(S3, e3), frameRate: n3, bitrateMax: Math.max(Math.round(Math.pow(g2, e3) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(g2, e3) * o2), d2) }, y3 = { scaleResolutionDownBy: 1, frameRate: Math.max(Math.round(Math.pow(T3, e3) * n3), s2), bitrateMax: Math.max(Math.round(Math.pow(R3, e3) * i2), l2), bitrateMin: Math.max(Math.round(Math.pow(R3, e3) * o2), d2) };
          C2.push({ scale: e3, threshold: t4, balanced: a4, motion: c4, detail: y3 });
        }
        return C2;
      }
      function uB2(e2, t3, i2, n3, r2, o2) {
        const s2 = aB2.get(e2) || { overUse: 0, underUse: 0, adaptationList: lB2(r2) }, { adaptationList: a3 } = s2;
        aB2.set(e2, s2);
        const { OVERUSE_TIMES_THRESHOLD: c3, UNDERUSE_TIMES_THRESHOLD: d2 } = CN, { scale: l2 } = n3;
        let u3, h2;
        return "number" == typeof t3 && t3 > 0 && function(e3, t4, i3, n4) {
          if (t4 >= i3.length) return false;
          let { threshold: { fps_down: r3 } } = i3[t4];
          return wN("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n4 && (r3 = i3[0].threshold.fps_down), e3 < r3;
        }(t3, l2, a3, o2) && (s2.overUse++, h2 = aN.CPU, s2.overUse > c3) || "number" == typeof i2 && i2 > 0 && function(e3, t4, i3) {
          if (t4 >= i3.length) return false;
          const { threshold: { bwe_down: n4 } } = i3[t4];
          return e3 < n4;
        }(i2, l2, a3) && (s2.overUse++, h2 = aN.BANDWIDTH, s2.overUse > c3) ? (s2.overUse = 0, s2.underUse = 0, u3 = cB2(n3, a3, o2, sB2.DOWN), [u3, h2]) : ("number" == typeof t3 && t3 > 0 && "number" == typeof i2 && i2 > 0 && function(e3, t4, i3, n4) {
          if (0 === t4) return;
          let { threshold: { fps_up: r3 } } = i3[t4];
          return wN("FORCE_AG_HIGH_FRAMERATE") && "maintain-framerate" === n4 && (r3 = i3[1].threshold.fps_up), e3 > r3;
        }(t3, l2, a3, o2) && function(e3, t4, i3) {
          if (0 === t4) return;
          const { threshold: { bwe_up: n4 } } = i3[t4];
          return e3 > n4;
        }(i2, l2, a3) && (s2.underUse++, s2.underUse > d2 && (s2.overUse = 0, s2.underUse = 0, u3 = cB2(n3, a3, o2, sB2.UP), 0 === u3.scale && (h2 = aN.NONE))), [u3, h2]);
      }
      function hB2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function pB2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? hB2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : hB2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const _B = /* @__PURE__ */ new Map();
      function EB2(e2, t3) {
        const i2 = _B.get(e2);
        if (i2) {
          const { timer: t4 } = i2;
          window.clearTimeout(t4), _B.delete(e2);
        }
        t3.qualityLimitationReason = aN.NONE, dB2(e2);
      }
      function mB2(e2, t3) {
        var i2;
        let n3;
        switch (t3) {
          case gV.LocalAudioTrack:
            n3 = nV.Audio;
            break;
          case gV.LocalVideoTrack:
            n3 = Ln2(i2 = e2._hints).call(i2, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
            break;
          case gV.LocalVideoLowTrack:
            n3 = nV.Low;
        }
        return n3;
      }
      function fB2(e2) {
        const t3 = fD2();
        if (e2.some((e3) => e3._bypassWebAudio)) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
        if (!t3.webAudioMediaStreamDest) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks because your browser does not support audio mixing");
      }
      function SB2(e2, t3) {
        fB2(e2);
        const i2 = t3 || new WL();
        return e2.forEach((e3) => i2.addAudioTrack(e3)), i2;
      }
      const gB2 = !fD2().supportUnifiedPlan || wN("CHROME_FORCE_PLAN_B") && vw2();
      function TB2(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var i2;
        return gB2 ? (i2 = { spec: t3, store: e2 }, Jx2("PlanBConnection").create(i2)) : new bB2(t3, e2);
      }
      function RB2(e2) {
        return e2 && ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState);
      }
      function vB2(e2) {
        try {
          if (e2.iceServers) return false;
          if (e2.turnServer && "off" !== e2.turnServer.mode) {
            if (Qw2(e2.turnServer.servers)) return false;
            if (wN("FORCE_TURN_TCP") || e2.turnServer.servers.concat(e2.turnServer.serversFromGateway || []).some((e3) => e3.forceturn)) return true;
          }
          return false;
        } catch (e3) {
          return false;
        }
      }
      var CB2;
      function yB2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function IB2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? yB2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : yB2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      let bB2 = (CB2 = class e2 extends _V {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t3;
          return null !== (e3 = null === (t3 = this.peerConnection.getReceivers()[0]) || void 0 === t3 || null === (t3 = t3.transport) || void 0 === t3 ? void 0 : t3.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
            var t3;
            return Ln2(t3 = Object.keys(PN)).call(t3, e3);
          }))];
        }
        constructor(t3, i2) {
          super(t3, i2), uI(this, "id", IO(5, "connection-")), uI(this, "store", void 0), uI(this, "peerConnection", void 0), uI(this, "forceTurn", false), uI(this, "remoteSDP", void 0), uI(this, "initialOffer", void 0), uI(this, "transportEventReceiver", void 0), uI(this, "statsFilter", void 0), uI(this, "extension", { useXR: wN("USE_XR") }), uI(this, "localCapabilities", void 0), uI(this, "remoteCodecs", void 0), uI(this, "localCandidateCount", 0), uI(this, "allCandidatesReceived", false), uI(this, "isPreallocation", false), uI(this, "preMediaMap", /* @__PURE__ */ new Map()), uI(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), uI(this, "establishPromise", void 0), uI(this, "recoveredDataChannelIds", []), uI(this, "currentDataChannelId", 1), uI(this, "supportAV1RtpSpec", false), uI(this, "mutex", void 0), uI(this, "qualityLimitationReason", aN.NONE), uI(this, "isFirstConnected", false), this.store = i2, this.forceTurn = vB2(t3), this.mutex = new xO("P2PConnection-mutex", i2.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t3), { optional: [{ googDscp: true }] }), this.isFirstConnected = false, this.statsFilter = EN(this.peerConnection, wN("STATS_UPDATE_INTERVAL"), void 0, iw2() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, t3.isPreallocation && (this.isPreallocation = true), this.establishPromise = this.establish();
        }
        getPreMedia(e3) {
          return this.preMediaMap.get(e3);
        }
        isPreSub() {
          return this.preMediaMap.size > 0;
        }
        async updateRemoteRTPCapabilities(e3, t3) {
          if (this.remoteCodecs = t3, !this.remoteSDP) return void sD.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(t3));
          if (this.remoteSDP.updateRemoteCodec(e3, t3, this.store.codec)) {
            const e4 = await this.peerConnection.createOffer(), t4 = this.logSDPExchange(e4.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(e4);
            const i2 = this.remoteSDP.toString();
            null == t4 || t4(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } else sD.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const i2 = await this.peerConnection.createOffer();
            if (!i2.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const n3 = vx2(i2.sdp), r2 = await Lx2({ filterRTX: !wN("USE_PUB_RTX") && !wN("USE_SUB_RTX"), filterVideoFec: wN("FILTER_VIDEO_FEC"), filterAudioFec: wN("FILTER_AUDIO_FEC"), filterVideoCodec: wN("FILTER_VIDEO_CODEC"), unsupportedVideoUplinkCodec: wN("UNSUPPORTED_VIDEO_UPLINK_CODEC"), unsupportedVideoDownlinkCodec: wN("UNSUPPORTED_VIDEO_DOWNLINK_CODEC") }, this.extension);
            if (this.localCapabilities = Ux2(r2), this.initialOffer = i2, wN("ENABLE_SVC") && "av1" == this.store.codec) {
              const t4 = await async function() {
                try {
                  const e4 = new RTCPeerConnection();
                  e4.addTransceiver("video", { direction: "sendonly", sendEncodings: [{ scalabilityMode: cN.L1T3 }] });
                  const t5 = await e4.createOffer();
                  if (!t5.sdp) return void e4.close();
                  const i3 = FN(t5.sdp).mediaDescriptions[0];
                  if (!i3) return;
                  const n4 = i3.attributes.extmaps.find((e5) => "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension" === e5.extensionName);
                  return e4.close(), n4;
                } catch (e4) {
                  return;
                }
              }();
              var e3;
              if (t4) this.supportAV1RtpSpec = true, null === (e3 = r2.send) || void 0 === e3 || e3.videoExtensions.push(t4);
            }
            let o2;
            return i2.sdp && Wx2(i2.sdp) && (o2 = pO(r2), (t3 = o2).send && (mx2(EV.VIDEO, t3.send.videoExtensions), mx2(EV.AUDIO, t3.send.audioExtensions)), t3.recv && (mx2(EV.VIDEO, t3.recv.videoExtensions), mx2(EV.AUDIO, t3.recv.audioExtensions)), t3.sendrecv && (mx2(EV.VIDEO, t3.sendrecv.videoExtensions), mx2(EV.AUDIO, t3.sendrecv.audioExtensions))), IB2(IB2({}, n3), {}, { rtpCapabilities: o2 || r2, offerSDP: i2.sdp });
          } catch (e4) {
            throw new Ow2(ww2.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
          var t3;
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            this.initialOffer.sdp && Wx2(this.initialOffer.sdp) && (t3 = e3.rtpCapabilities, i2 = this.localCapabilities, t3.send && (Ex2(EV.VIDEO, t3.send.videoExtensions, i2.send.videoExtensions), Ex2(EV.AUDIO, t3.send.audioExtensions, i2.send.audioExtensions)), t3.recv && (Ex2(EV.VIDEO, t3.recv.videoExtensions, i2.recv.videoExtensions), Ex2(EV.AUDIO, t3.recv.audioExtensions, i2.recv.audioExtensions))), this.remoteSDP = new class {
              get localCapabilities() {
                return pO(this._localCapabilities);
              }
              get rtpCapabilities() {
                return pO(this._rtpCapabilities);
              }
              get candidates() {
                return pO(this._candidates);
              }
              get iceParameters() {
                return pO(this._iceParameters);
              }
              get dtlsParameters() {
                return pO(this._dtlsParameters);
              }
              constructor(e4) {
                let t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                uI(this, "sessionDesc", void 0), uI(this, "_localCapabilities", void 0), uI(this, "_rtpCapabilities", void 0), uI(this, "_candidates", void 0), uI(this, "_originCandidates", void 0), uI(this, "_iceParameters", void 0), uI(this, "_isUseExtmapAllowMixed", void 0), uI(this, "_isUseLocalCodecs", void 0), uI(this, "_dtlsParameters", void 0), uI(this, "setup", void 0), uI(this, "currentMidIndex", void 0), uI(this, "cname", void 0), uI(this, "useLocalCodecsMids", []), uI(this, "preloadSsrcs", []), uI(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), this._isUseExtmapAllowMixed = t4, this._isUseLocalCodecs = i3, e4 = pO(e4);
                const { iceParameters: n4, dtlsParameters: r3, candidates: o3, rtpCapabilities: s3, setup: a3, localCapabilities: c3, cname: d2 } = e4;
                this._rtpCapabilities = s3, this._candidates = o3, this._originCandidates = pO(o3), this._iceParameters = n4, this._dtlsParameters = r3, this._localCapabilities = c3, this.setup = a3, this.cname = d2, [this.sessionDesc] = this.updateRemoteRTPCapabilities(s3), this.currentMidIndex = this.sessionDesc.mediaDescriptions.length - 1;
              }
              checkPreloadSsrcs(e4) {
                return e4.length === this.preloadSsrcs.length && e4.every((e5) => {
                  var t4;
                  return Ln2(t4 = this.preloadSsrcs).call(t4, e5);
                });
              }
              preloadRemoteMedia(e4) {
                let t4 = 0;
                const i3 = [], n4 = [];
                for (; e4 > 0; ) {
                  const r3 = [eB2({ ssrcId: nB2 + t4 }, wN("USE_SUB_RTX") ? { rtx: nB2 + t4 + 1 } : {})], o3 = "".concat(nB2 + t4, "_").concat(iB2 + t4), { ssrcs: s3, ssrcGroups: a3 } = bx2(r3, this.cname, wN("SYNC_GROUP") ? o3 : void 0), c3 = this.preCreateOrRecycleSendMedia("video", s3, a3, void 0), d2 = [{ ssrcId: iB2 + t4 }], l2 = "".concat(nB2 + t4, "_").concat(iB2 + t4), { ssrcs: u3, ssrcGroups: h2 } = bx2(d2, this.cname, wN("SYNC_GROUP") ? l2 : void 0), p2 = this.preCreateOrRecycleSendMedia("audio", u3, h2, void 0);
                  e4--, t4 += 2, i3.push(c3, p2), n4.push(s3[0].ssrcId, u3[0].ssrcId);
                }
                return this.useLocalCodecsMids.push(...i3), this.preloadSsrcs = n4, { mids: i3, preSSRCs: n4, isAvailable: true };
              }
              preCreateOrRecycleSendMedia(e4, t4, i3, n4) {
                const r3 = this.rtpCapabilities.send.videoCodecs, o3 = this._isUseLocalCodecs || 0 === r3.length ? this.localCapabilities.recv : this.rtpCapabilities.send;
                sD.debug("create or recycle send media without remote rtp capabilities, ssrcs ", t4[0].ssrcId);
                const s3 = e4 === EV.VIDEO ? o3.videoCodecs : o3.audioCodecs, a3 = e4 === EV.VIDEO ? o3.videoExtensions : o3.audioExtensions;
                this.currentMidIndex += 1;
                const c3 = "".concat(this.currentMidIndex);
                let d2 = { media: { mediaType: e4, port: tB2, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s3.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t4, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: s3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(c3) } };
                return d2 = this.mungSendMediaDesc(d2, n4), this.sessionDesc.mediaDescriptions.push(d2), this.updateBundleMids(), c3;
              }
              toString() {
                return BN(this.sessionDesc);
              }
              send(e4, t4, i3, n4) {
                const { ssrcs: r3, ssrcGroups: o3 } = bx2(t4, this.cname, wN("SYNC_GROUP") ? i3 : void 0), s3 = this.findPreloadMediaDesc(r3);
                if (s3) {
                  if (iw2() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, s3.attributes.mid), n4 && (n4.twcc || n4.remb)) {
                    const e5 = this.sessionDesc.mediaDescriptions.indexOf(s3);
                    return this.sessionDesc.mediaDescriptions[e5] = this.mungSendMediaDesc(s3, n4), { mid: s3.attributes.mid, needExchangeSDP: true };
                  }
                  return { mid: s3.attributes.mid, needExchangeSDP: false };
                }
                {
                  const t5 = this.findAvailableMediaIndex(e4, r3);
                  let i4;
                  return -1 === t5 || 1 === t5 && ($A2() || function() {
                    const e5 = zA2();
                    return !(e5.name !== WA2.CHROME || !e5.osVersion) && Number(e5.version) <= 90;
                  }() || wN("ENABLE_ENCODED_TRANSFORM") && QA2()) || 0 === t5 && !function(e5) {
                    const t6 = zA2();
                    return !(t6.name !== WA2.FIREFOX || !t6.osVersion) && Number(t6.version) === e5;
                  }(138) && wN("USE_SUB_RTX") || _w() ? (i4 = this.createOrRecycleSendMedia(e4, r3, o3, "sendonly", n4), this.updateBundleMids()) : (i4 = pO(this.sessionDesc.mediaDescriptions[t5]), i4.attributes.direction = "sendonly", i4.attributes.ssrcs = r3, i4.attributes.ssrcGroups = o3, this.sessionDesc.mediaDescriptions[t5] = this.mungSendMediaDesc(i4, n4)), iw2() && this.firefoxSsrcMidMap.set(r3[0].ssrcId, i4.attributes.mid), { mid: i4.attributes.mid, needExchangeSDP: true };
                }
              }
              sendDataChannel() {
                const { mediaDesc: e4, needExchangeSDP: t4 } = this.createOrRecycleDataChannel();
                return this.updateBundleMids(), { mid: e4.attributes.mid, needExchangeSDP: t4 };
              }
              batchSend(e4) {
                const t4 = e4.map((e5) => {
                  let { kind: t5, ssrcMsg: i4, mslabel: n5 } = e5;
                  return this.send(t5, i4, n5);
                }), i3 = [];
                let n4 = false;
                return t4.forEach((e5) => {
                  let { mid: t5, needExchangeSDP: r3 } = e5;
                  r3 && (n4 = true), i3.push(t5);
                }), { mids: i3, needExchangeSDP: n4 };
              }
              stopSending(e4) {
                const t4 = this.sessionDesc.mediaDescriptions.filter((t5) => t5.attributes.mid && -1 !== e4.indexOf(t5.attributes.mid));
                if (t4.length !== e4.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
                t4.forEach((e5) => {
                  "0" === e5.attributes.mid || iw2() || _w() ? e5.attributes.ssrcs = [] : (e5.attributes.ssrcs = [], e5.attributes.direction = "inactive", e5.media.port = "0");
                }), this.updateBundleMids();
              }
              mute(e4) {
                const t4 = this.sessionDesc.mediaDescriptions.find((t5) => t5.attributes.mid === e4);
                if (!t4) throw new Error("mediaDescription not found with ".concat(e4, " in remote SDP when calling RemoteSDP.mute."));
                t4.attributes.direction = "inactive";
              }
              unmute(e4) {
                const t4 = this.sessionDesc.mediaDescriptions.find((t5) => t5.attributes.mid === e4);
                if (!t4) throw new Error("mediaDescription not found with ".concat(e4, " in remote SDP when calling RemoteSDP.unmute."));
                t4.attributes.direction = "sendonly";
              }
              muteRemote(e4) {
                const t4 = this.sessionDesc.mediaDescriptions.filter((t5) => Ln2(e4).call(e4, t5.attributes.mid || ""));
                if (t4.length !== e4.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                t4.forEach((e5) => {
                  e5.attributes.direction = "inactive";
                });
              }
              unmuteRemote(e4) {
                const t4 = this.sessionDesc.mediaDescriptions.filter((t5) => Ln2(e4).call(e4, t5.attributes.mid || ""));
                if (t4.length !== e4.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                t4.forEach((e5) => {
                  e5.attributes.direction = "recvonly";
                });
              }
              receive(e4, t4, i3, n4) {
                e4.forEach((e5, r3) => {
                  this.createOrRecycleRecvMedia(e5, [], "recvonly", t4, i3, n4[r3]);
                }), this.updateBundleMids();
              }
              stopReceiving(e4) {
                const t4 = this.sessionDesc.mediaDescriptions.filter((t5) => -1 !== e4.indexOf(t5.attributes.mid));
                if (t4.length !== e4.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
                t4.forEach((e5) => {
                  e5.media.port = "0", e5.attributes.direction = "inactive";
                }), this.updateBundleMids();
              }
              updateRemoteRTPCapabilities(e4) {
                const t4 = this.sessionDesc || FN((i3 = this._isUseExtmapAllowMixed, "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite".concat(i3 ? "\na=extmap-allow-mixed" : "", "\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n")));
                var i3;
                this._rtpCapabilities = e4;
                let n4 = false;
                const r3 = this.rtpCapabilities.send, o3 = this.localCapabilities.send, s3 = this.localCapabilities.recv, a3 = s3.videoCodecs, c3 = s3.audioCodecs, d2 = s3.videoExtensions, l2 = s3.audioExtensions;
                for (const e5 of t4.mediaDescriptions) {
                  var u3;
                  if ("sendonly" !== e5.attributes.direction || "string" != typeof e5.attributes.mid || !Ln2(u3 = this.useLocalCodecsMids).call(u3, e5.attributes.mid)) {
                    if (n4 = true, e5.attributes.iceUfrag = this._iceParameters.iceUfrag, e5.attributes.icePwd = this._iceParameters.icePwd, e5.attributes.fingerprints = this._dtlsParameters.fingerprints, e5.attributes.candidates = this._candidates, e5.attributes.setup = this.setup, "application" === e5.media.mediaType && (e5.attributes.sctpPort = "5000"), "video" === e5.media.mediaType) if (this._isUseLocalCodecs && "sendonly" === e5.attributes.direction) {
                      var h2;
                      e5.media.fmts = a3.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = a3, e5.attributes.extmaps = d2;
                      const t5 = e5.attributes.mid;
                      "string" != typeof t5 || Ln2(h2 = this.useLocalCodecsMids).call(h2, t5) || this.useLocalCodecsMids.push(t5);
                    } else if (0 === r3.videoCodecs.length) {
                      const t5 = o3.videoCodecs.filter((e6) => {
                        var t6, i4;
                        return null === (t6 = e6.rtpMap) || void 0 === t6 ? void 0 : Ln2(i4 = t6.encodingName.toLowerCase()).call(i4, "vp8");
                      }) || [o3.videoCodecs[0]];
                      e5.media.fmts = t5.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = t5, e5.attributes.extmaps = [];
                    } else e5.media.fmts = r3.videoCodecs.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = r3.videoCodecs, e5.attributes.extmaps = r3.videoExtensions;
                    if ("audio" === e5.media.mediaType) if (this._isUseLocalCodecs && "sendonly" === e5.attributes.direction) {
                      var p2;
                      e5.media.fmts = c3.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = c3, e5.attributes.extmaps = l2;
                      const t5 = e5.attributes.mid;
                      "string" != typeof t5 || Ln2(p2 = this.useLocalCodecsMids).call(p2, t5) || this.useLocalCodecsMids.push(t5);
                    } else if (0 === r3.audioCodecs.length) {
                      const t5 = o3.audioCodecs.filter((e6) => {
                        var t6, i4;
                        return null === (t6 = e6.rtpMap) || void 0 === t6 ? void 0 : Ln2(i4 = t6.encodingName.toLowerCase()).call(i4, "opus");
                      }) || [o3.audioCodecs[0]];
                      e5.media.fmts = t5.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = t5, e5.attributes.extmaps = [];
                    } else e5.media.fmts = r3.audioCodecs.map((e6) => e6.payloadType.toString(10)), e5.attributes.payloads = r3.audioCodecs, e5.attributes.extmaps = r3.audioExtensions, Vx2(e5);
                  }
                }
                return this.sessionDesc = t4, this.currentMidIndex = t4.mediaDescriptions.length - 1, [this.sessionDesc, n4];
              }
              updateCandidates(e4) {
                const t4 = this._originCandidates.filter((e5) => "udp" === e5.transport), i3 = [];
                if (t4.forEach((e5) => {
                  i3.push(eB2(eB2({}, e5), {}, { foundation: "tcpcandidate", priority: Number(e5.priority) - 1 + "", transport: "tcp", port: Number(e5.port) + 90 + "" }));
                }), 0 !== t4.length) {
                  switch (e4) {
                    case mV.TCP_RELAY:
                      this._candidates = i3;
                      break;
                    case mV.UDP_TCP_RELAY:
                    case mV.RELAY:
                      this._candidates = [...t4, ...i3];
                      break;
                    default:
                      this._candidates = t4;
                  }
                  for (const e5 of this.sessionDesc.mediaDescriptions) e5.attributes.candidates = this.candidates;
                }
              }
              restartICE(e4) {
                e4 = pO(e4), this._iceParameters = e4, this.sessionDesc.mediaDescriptions.forEach((t4) => {
                  t4.attributes.iceUfrag = e4.iceUfrag, t4.attributes.icePwd = e4.icePwd;
                });
              }
              predictReceivingMids(e4) {
                const t4 = [];
                for (let i3 = 0; i3 < e4; i3++) t4.push((this.currentMidIndex + i3 + 1).toString(10));
                return t4;
              }
              findAvailableMediaIndex(e4, t4) {
                return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
                  const n4 = i3.media.mediaType === e4 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
                  if (iw2()) {
                    if (n4) {
                      const e5 = this.firefoxSsrcMidMap.get(t4[0].ssrcId);
                      return !(e5 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e5 || e5 !== i3.attributes.mid);
                    }
                    return false;
                  }
                  return n4;
                });
              }
              createOrRecycleDataChannel() {
                for (const e5 of this.sessionDesc.mediaDescriptions) if ("application" === e5.media.mediaType) return { mediaDesc: e5, needExchangeSDP: false };
                this.currentMidIndex += 1;
                const e4 = "".concat(this.currentMidIndex), t4 = { media: { mediaType: "application", port: tB2, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e4), sctpPort: "5000" } };
                return this.sessionDesc.mediaDescriptions.push(t4), { mediaDesc: t4, needExchangeSDP: true };
              }
              createOrRecycleRecvMedia(e4, t4, i3, n4, r3, o3) {
                const s3 = e4._mediaStreamTrack.kind, a3 = this.rtpCapabilities.recv, c3 = xx2(s3, a3, this.localCapabilities.send, s3 === EV.VIDEO ? n4 : r3), d2 = s3 === EV.VIDEO ? a3.videoExtensions : a3.audioExtensions;
                this.currentMidIndex += 1;
                const l2 = "".concat(this.currentMidIndex);
                let u3 = { media: { mediaType: s3, port: tB2, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: c3.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: d2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t4, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: c3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
                u3 = this.mungRecvMediaDsec(u3, e4, o3);
                const h2 = this.findFirstClosedMedia(s3);
                if (h2) {
                  const e5 = this.sessionDesc.mediaDescriptions.indexOf(h2);
                  this.sessionDesc.mediaDescriptions[e5] = u3;
                } else this.sessionDesc.mediaDescriptions.push(u3);
                return u3;
              }
              updateRemoteDtlsParameters(e4) {
                const t4 = new Set(this._dtlsParameters.fingerprints.map((e5) => e5.fingerprint)), i3 = new Set(e4.map((e5) => e5.fingerprint));
                let n4 = false;
                t4.size !== i3.size && (n4 = true);
                for (const e5 of t4) i3.has(e5) || (n4 = true);
                return n4;
              }
              updateRemoteCodec(e4, t4, i3) {
                const n4 = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((e5) => e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || "").filter((e5) => {
                  var t5;
                  return Ln2(t5 = Object.keys(PN)).call(t5, e5);
                }))], r3 = new Set(t4);
                if (n4.every((e5) => r3.has(e5))) return sD.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t4)), false;
                const o3 = this._rtpCapabilities.recv.videoCodecs.filter((e5) => t4.some((t5) => {
                  var i4;
                  return Ln2(i4 = e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || "").call(i4, t5);
                }));
                if (0 === o3.length) return sD.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n4, " codecs: ").concat(t4)), false;
                const s3 = [...new Set(o3.map((e5) => e5.rtpMap && e5.rtpMap.encodingName.toLowerCase() || ""))];
                let a3;
                if (sD.debug("updateRemoteCodec, from ".concat(n4, " to ").concat(s3)), 0 === e4.length) a3 = this.sessionDesc.mediaDescriptions.filter((e5) => "video" === e5.media.mediaType && "recvonly" === e5.attributes.direction);
                else if (a3 = this.sessionDesc.mediaDescriptions.filter((t5) => t5.attributes.mid && "video" === t5.media.mediaType && Ln2(e4).call(e4, t5.attributes.mid) && "recvonly" === t5.attributes.direction), a3.length !== e4.length) return sD.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e4, ", codecs: ").concat(t4)), false;
                if (wN("USE_PUB_RTX") || wN("USE_SUB_RTX")) {
                  const e5 = Fx2(o3, this.rtpCapabilities.recv.videoCodecs);
                  o3.push(...e5);
                }
                this._rtpCapabilities.recv.videoCodecs = o3;
                const c3 = this.localCapabilities.send, d2 = this.rtpCapabilities.recv, l2 = xx2(EV.VIDEO, d2, c3, i3);
                return a3.forEach((e5) => {
                  const t5 = l2.map((e6) => e6.payloadType.toString(10));
                  sD.debug("updateRemoteCodec mid: ".concat(e5.attributes.mid, ", from"), e5.attributes.payloads, "to", l2), e5.attributes.payloads = l2, e5.media.fmts = t5;
                }), true;
              }
              createOrRecycleSendMedia(e4, t4, i3, n4, r3) {
                const o3 = this.rtpCapabilities.send.videoCodecs, s3 = this._isUseLocalCodecs || 0 === o3.length ? this.localCapabilities.recv : this.rtpCapabilities.send, a3 = e4 === EV.VIDEO ? s3.videoCodecs : s3.audioCodecs, c3 = e4 === EV.VIDEO ? s3.videoExtensions : s3.audioExtensions;
                this.currentMidIndex += 1;
                const d2 = "".concat(this.currentMidIndex);
                let l2 = { media: { mediaType: e4, port: tB2, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a3.map((e5) => e5.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: c3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t4, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: a3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n4, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
                l2 = this.mungSendMediaDesc(l2, r3);
                const u3 = this.findFirstClosedMedia(e4);
                if (u3) {
                  const e5 = this.sessionDesc.mediaDescriptions.indexOf(u3);
                  this.sessionDesc.mediaDescriptions[e5] = l2;
                } else this.sessionDesc.mediaDescriptions.push(l2);
                return l2;
              }
              updateBundleMids() {
                this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e4) => "0" !== e4.media.port).map((e4) => e4.attributes.mid);
              }
              mungRecvMediaDsec(e4, t4, i3) {
                const n4 = pO(e4);
                return wx2(n4), Ax2(n4, t4), Ox2(n4, t4), Nx2(n4), Dx2(n4, i3, this.localCapabilities.send), n4;
              }
              mungSendMediaDesc(e4, t4) {
                const i3 = pO(e4);
                return Dx2(i3, t4, this.localCapabilities.recv), Vx2(i3), i3;
              }
              updateRecvMedia(e4, t4) {
                const i3 = this.sessionDesc.mediaDescriptions.findIndex((t5) => t5.attributes.mid === e4);
                if (-1 !== i3) {
                  const e5 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t4);
                  this.sessionDesc.mediaDescriptions[i3] = e5;
                }
              }
              bumpMid(e4) {
                this.currentMidIndex += e4;
              }
              findFirstClosedMedia(e4) {
                return this.sessionDesc.mediaDescriptions.find((t4) => iw2() ? "0" === t4.media.port && t4.media.mediaType === e4 : "0" === t4.media.port);
              }
              findPreloadMediaDesc(e4) {
                return this.sessionDesc.mediaDescriptions.find((t4) => {
                  var i3;
                  return (null === (i3 = t4.attributes) || void 0 === i3 || null === (i3 = i3.ssrcs[0]) || void 0 === i3 ? void 0 : i3.ssrcId) === e4[0].ssrcId;
                });
              }
              getSSRC(e4) {
                var t4;
                return null === (t4 = this.sessionDesc.mediaDescriptions.find((t5) => t5.attributes.mid === e4)) || void 0 === t4 ? void 0 : t4.attributes.ssrcs;
              }
            }(IB2(IB2({}, e3), {}, { localCapabilities: this.localCapabilities }), this.supportAV1RtpSpec, !(!wN("ENABLE_PRE_SUB_WITH_PRE_PC") || !wN("PRE_USE_LOCAL_CODECS")) && TD(this.store)), e3.preallocation && (this.isPreallocation = true), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
            const n3 = this.remoteSDP.toString(), r2 = jx2(this.initialOffer.sdp, this.extension), o2 = this.logSDPExchange(r2 || "", "offer", "local", "connect");
            this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: r2 }), null == o2 || o2(n3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
            const s2 = this.peerConnection.getTransceivers()[0];
            if (null != s2 && s2.receiver && this.tryBindTransportEvents(s2.receiver), TD(this.store)) if (e3.preallocation && wN("ENABLE_PRE_SUB_WITH_PRE_PC")) {
              const e4 = wN("PRE_SUB_NUM"), { mids: t4, preSSRCs: i3 } = this.remoteSDP.preloadRemoteMedia(e4);
              await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.debug("[".concat(this.store.clientId, "] [P2PConnection] preload media, in pre pc,add preload ssrcs ").concat(i3)), this.presetMedia(t4, i3);
            } else {
              const { preSSRCs: t4 = [] } = e3, i3 = t4.map((e4) => e4.ssrcMsg[0].ssrcId);
              if (0 === t4.length) return;
              const { mids: n4 } = this.remoteSDP.batchSend(t4.map((e4) => Object.assign({}, e4)));
              await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.debug("[P2PConnection.connect] preload media, after join, add preload ssrcs ".concat(i3)), this.presetMedia(n4, i3);
            }
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
          var t3, i2;
        }
        presetMedia(e3, t3) {
          e3.forEach((e4, i2) => {
            this.peerConnection.getTransceivers().forEach((n3) => {
              if (null != n3.mid && e4 === n3.mid && n3.receiver.track) {
                const r2 = n3.receiver.track;
                let o2;
                "video" === r2.kind && wN("ENABLE_PRE_RENDER") && (o2 = new XL({ trackId: "track-".concat(r2.kind, "-unknown-").concat(this.store.clientId, "_").concat(IO(5, "")) }, true), o2.updateVideoTrack(r2), o2.onFirstVideoFrameRender = () => {
                  var e5;
                  const n4 = this.preMediaMap.get(t3[i2]);
                  n4 && (n4.firstVideoRender = Date.now()), null === (e5 = this.onFirstVideoRender) || void 0 === e5 || e5.call(this, t3[i2]);
                }, o2.play(this.store.sessionId || void 0)), this.preMediaMap.set(t3[i2], { mid: e4, track: r2, player: o2, transceiver: n3 });
              }
            }), this.store.peerReceiver();
          });
        }
        checkDtlsParameters(e3) {
          return !!this.remoteSDP && (e3.length > 0 && this.remoteSDP.updateRemoteDtlsParameters(e3));
        }
        async updateRemoteConnect(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateRemoteConnect before remote SDP created");
            let t3 = false;
            const { rtpCapabilities: i2 } = e3;
            if ([, t3] = this.remoteSDP.updateRemoteRTPCapabilities(i2), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0) {
              const e4 = this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
              t3 = t3 || e4;
            }
            const { preSSRCs: n3 = [] } = e3, r2 = n3.map((e4) => e4.ssrcMsg[0].ssrcId);
            if (!this.remoteSDP.checkPreloadSsrcs(r2)) {
              const e4 = [], t4 = [];
              if (Array.from(this.preMediaMap.entries()).every((i3) => {
                let [n4, { mid: r3, player: o2, track: s2 }] = i3;
                return e4.push(r3), t4.push(n4), this.preMediaMap.delete(n4), o2 && o2.destroy(), true;
              }), e4.length > 0 && (this.remoteSDP.stopSending(e4), await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.warn("[P2PConnection.updateRemoteConnect] preload media, failed, del preload ssrcs ".concat(t4)), _D.reportApiInvoke(this.store.sessionId, { name: zw2.PRELOAD_MEDIA_FAILED, options: [n3, t4], tag: qw2.TRACER }).onSuccess()), n3.length > 0) {
                const { mids: e5 } = this.remoteSDP.batchSend(n3.map((e6) => Object.assign({}, e6)));
                await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.debug("[P2PConnection.updateRemoteConnect] preload media, after join, add preload ssrcs ".concat(r2)), this.presetMedia(e5, r2);
              }
            }
            t3 ? (await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.debug("[P2PConnection] updateRemoteConnect by exchanging SDP.")) : sD.debug("[P2PConnection] updateRemoteConnect no need to exchange SDP, because no need to update remote codecs (use local codecs)");
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.updateRemoteConnect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t3, i2) {
          var n3 = this;
          return qb2(function* () {
            const r2 = yield Jb2(n3.mutex.lock("From P2PConnection.send"));
            try {
              if (!n3.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [], s2 = px2();
              e3.forEach((e4) => {
                const t4 = n3.peerConnection.addTransceiver(e4._mediaStreamTrack, IB2({ direction: "sendonly" }, "video" === e4.trackMediaType && n3.supportAV1RtpSpec && s2 ? { sendEncodings: [{ scalabilityMode: s2 }] } : {}));
                o2.push(t4), e4._updateRtpTransceiver(t4);
              }), iw2() && true === wN("SIMULCAST") && (yield Jb2(n3.applySimulcastForFirefox(o2, e3)));
              const a3 = yield Jb2(n3.peerConnection.createOffer()), c3 = n3.remoteSDP.predictReceivingMids(e3.length), d2 = n3.mungSendOfferSDP(a3.sdp, e3, c3), l2 = FN(d2), u3 = c3.map((e4) => {
                const t4 = l2.mediaDescriptions.find((t5) => t5.attributes.mid === e4);
                if (!t4) throw new Error("Cannot extract ssrc from mediaDescription.");
                return Cx2(t4, wN("USE_PUB_RTX"));
              });
              let h2;
              try {
                h2 = yield u3;
              } catch (r3) {
                h2 = [], n3.remoteSDP.receive(e3, t3, i2, h2);
                const o3 = n3.remoteSDP.toString();
                throw yield Jb2(n3.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Jb2(n3.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield Jb2(n3.stopSending(c3, true)), r3;
              }
              n3.remoteSDP.receive(e3, t3, i2, h2);
              const p2 = n3.remoteSDP.toString(), _2 = n3.logSDPExchange(d2, "offer", "local", "send");
              return yield Jb2(n3.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Jb2(n3.applySimulcastEncodings(o2, e3)), yield Jb2(n3.applySendEncodings(o2, e3)), null == _2 || _2(p2), yield Jb2(n3.peerConnection.setRemoteDescription({ type: "answer", sdp: p2 })), o2.map((e4, t4) => {
                const i3 = c3[t4];
                return { localSSRC: u3[t4], id: i3, transceiver: e4 };
              });
            } catch (e4) {
              throw e4 instanceof Ow2 ? e4 : new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async createDataChannels(e3, t3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
            let i2 = this.dataStreamChannelMap.get(e3);
            if (i2 && "open" === i2.readyState) sD.debug("[P2PConnection] Channels are already available and can be reused directly.");
            else {
              const t4 = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
              if ("number" != typeof t4) throw new Error("create DataChannel error, because cannot get dc id");
              i2 = this.peerConnection.createDataChannel("datastream-channel", { id: t4, negotiated: true, ordered: false, maxRetransmits: wN("DATASTREAM_MAX_RETRANSMITS") }), i2.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e3, i2);
            }
            t3.forEach((e4) => {
              e4._updateOriginDataChannel(i2);
            });
            const { needExchangeSDP: n3 } = this.remoteSDP.sendDataChannel();
            if (n3) {
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t4 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t4), sD.debug("[P2PConnection] createDataChannels by exchanging SDP.");
            } else sD.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
            return;
          } catch (e4) {
            throw e4 instanceof Ow2 ? e4 : new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopDataChannels(e3) {
          try {
            const t3 = this.dataStreamChannelMap.get(e3);
            return t3 && (t3.id && this.recoveredDataChannelIds.push(t3.id), t3.close()), void this.dataStreamChannelMap.delete(e3);
          } catch (e4) {
            throw e4 instanceof Ow2 ? e4 : new Ow2(ww2.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(e4.toString()));
          }
        }
        async stopSending(e3, t3) {
          const i2 = t3 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t4 = this.peerConnection.getTransceivers().filter((t5) => -1 !== e3.indexOf(t5.mid));
            if (t4.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t4.map((e4) => {
              var t5;
              EB2(this.id + e4.mid, this), e4.direction = "inactive", null === (t5 = e4.stop) || void 0 === t5 || t5.call(e4);
            });
            const n3 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n3.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n3), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t3, i2, n3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t3, i2, n3);
            o2 && (await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP.")));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!s2) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: r2, transceiver: s2 };
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t3, needExchangeSDP: i2 } = this.remoteSDP.batchSend(e3);
            return i2 && (await Bx2(this.peerConnection, this.remoteSDP, this.extension), sD.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."))), t3.map((e4) => {
              const t4 = this.peerConnection.getTransceivers().find((t5) => t5.mid === e4);
              if (!t4) throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t4.receiver.track, id: e4, transceiver: t4 };
            });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            e3.forEach((e4) => {
              Array.from(this.preMediaMap.entries()).some((t4) => {
                let [i3, { mid: n4, player: r2 }] = t4;
                if (n4 === e4) return this.preMediaMap.delete(i3), r2 && r2.destroy(), true;
              });
            }), this.remoteSDP.stopSending(e3);
            const t3 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t3, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const n3 = await this.peerConnection.createAnswer();
            null == i2 || i2(n3.sdp || ""), await this.peerConnection.setLocalDescription(n3);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t3 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t3, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const n3 = await this.peerConnection.createAnswer();
            null == i2 || i2(n3.sdp || ""), await this.peerConnection.setLocalDescription(n3);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t3 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t3, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const n3 = await this.peerConnection.createAnswer();
            null == i2 || i2(n3.sdp || ""), await this.peerConnection.setLocalDescription(n3);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map((e4) => {
              e4.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n3 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n3 || n3(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map(async (e4, t4) => {
              e4.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n3 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec(e3, this.remoteCodecs, this.store.codec);
            const r2 = this.remoteSDP.toString();
            null == n3 || n3(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t3 = this;
          return qb2(function* () {
            const i2 = yield Jb2(t3.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t3.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              const n3 = fD2().supportPCSetConfiguration, r2 = wN("FORCE_TURN_TCP") || t3.forceTurn;
              if (e3 === mV.RELAY && !n3) return;
              if (n3 && !r2) {
                const i3 = e3 === mV.RELAY ? "relay" : "all", n4 = t3.peerConnection.getConfiguration();
                n4.iceTransportPolicy !== i3 && (sD.debug("[".concat(t3.store.clientId, "] restartICE change iceTransportPolicy from [").concat(n4.iceTransportPolicy, "] to [").concat(i3, "]")), n4.iceTransportPolicy = i3, t3.peerConnection.setConfiguration(n4));
              }
              t3.remoteSDP.updateCandidates(e3);
              const o2 = yield Jb2(t3.peerConnection.createOffer({ iceRestart: true }));
              if (!o2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const s2 = vx2(o2.sdp), { remoteIceParameters: a3 } = yield s2.iceParameters;
              t3.remoteSDP.restartICE(a3);
              const c3 = t3.remoteSDP.toString(), d2 = t3.logSDPExchange(o2.sdp || "", "offer", "local", "restartICE");
              t3.store.descriptionStart(), yield Jb2(t3.peerConnection.setLocalDescription(o2)), null == d2 || d2(c3), yield Jb2(t3.peerConnection.setRemoteDescription({ type: "answer", sdp: c3 }));
            } catch (e4) {
              sD.warning("[".concat(t3.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          })();
        }
        async extendCandidate() {
          if (!this.remoteSDP || this.isFirstConnected) return;
          const e3 = await this.mutex.lock("From P2PConnection.extendCandidate");
          try {
            this.remoteSDP.updateCandidates(mV.TCP_RELAY), await Bx2(this.peerConnection, this.remoteSDP, this.extension);
          } catch (e4) {
            sD.warning("[".concat(this.store.clientId, "] extend candidate failed, abort operation"), e4);
          } finally {
            e3();
          }
        }
        close() {
          var e3;
          this.peerConnection.getTransceivers().forEach((e4) => {
            EB2(this.id + e4.mid, this);
          }), this.preMediaMap.forEach((e4) => {
            let { player: t3 } = e4;
            t3 && t3.destroy();
          }), this.preMediaMap.clear(), this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
        }
        getStats() {
          return IB2(IB2({}, this.statsFilter.getStats()), {}, { qualityLimitationReason: this.qualityLimitationReason });
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n3 = this.mungSendOfferSDP(i2.sdp, [t3], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t3);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n3, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n3 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t3) {
          const i2 = this.peerConnection.getTransceivers().filter((t4) => t4.mid === e3);
          1 === i2.length && (this.isVP8Simulcast(t3) ? iw2() || await this.applySimulcastEncodings(i2, [t3]) : await this.applySendEncodings(i2, [t3]));
        }
        setStatsRemoteVideoIsReady(e3, t3) {
          this.statsFilter.setVideoIsReady2(e3, t3);
        }
        async replaceTrack(e3, t3) {
          const i2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t3);
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t3 = e3[0].transport.iceTransport, { local: i2, remote: n3 } = t3.getSelectedCandidatePair();
            return { local: IB2(IB2({}, $O), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: IB2(IB2({}, $O), {}, { candidateType: n3.type, protocol: n3.protocol, address: n3.address, port: n3.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.isFirstConnected = true), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidateerror = (e3) => {
            if (e3 && (e3.errorCode || e3.errorText)) {
              var t3;
              const i2 = "code: ".concat(e3.errorCode, ", message: ").concat(e3.errorText), n3 = e3.port ? "local: ".concat(e3.port) : "", r2 = hx2(e3.url || "");
              sD.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICECandidateError(").concat(i2, "), url: ").concat(r2 || "", ", host_candidate:").concat(n3)), null === (t3 = this.onICECandidateError) || void 0 === t3 || t3.call(this, i2);
            }
          }, this.peerConnection.onicegatheringstatechange = (e3) => {
            e3 && e3.target && "iceGatheringState" in e3.target && sD.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] RTCPeerConnection.onicegatheringstatechange(").concat(e3.target.iceGatheringState, ")"));
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, sD.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, sD.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, wN("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t3) {
          const i2 = { iceServers: [] }, n3 = t3.cloudProxyServer || "disabled";
          return t3.iceServers ? i2.iceServers = t3.iceServers : t3.turnServer && (Qw2(t3.turnServer.servers) ? i2.iceServers = t3.turnServer.servers : wN("NEW_TURN_MODE") && i2.iceServers && "disabled" === n3 ? (wN("USE_TURN_SERVER_OF_GATEWAY") ? t3.turnServer.serversFromGateway && i2.iceServers.push(...e2.newTurnServerConfigToIceServers(t3.turnServer.serversFromGateway)) : i2.iceServers.push(...e2.newTurnServerConfigToIceServers(t3.turnServer.servers)), wN("NEW_FORCE_TURN") && (i2.iceTransportPolicy = "relay")) : "off" !== t3.turnServer.mode && (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t3.turnServer.servers)), wN("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t3.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t3.turnServer.serversFromGateway)), wN("FORCE_TURN_TCP") ? i2.iceTransportPolicy = "relay" : t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          }))), wN("ENABLE_ENCODED_TRANSFORM") && fD2().supportWebRTCEncodedTransform && (i2.encodedInsertableStreams = true), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t3 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(ix2(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !wN("FORCE_TURN_TCP") && t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t3;
        }
        static newTurnServerConfigToIceServers(e3) {
          const t3 = [];
          return e3.forEach((e4) => {
            const i2 = wN("NEW_TURN_MODE");
            1 === i2 ? t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=udp") }) : 2 === i2 ? t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=tcp") }) : 3 === i2 ? t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(ix2(e4.turnServerURL), ":443?transport=tcp") }) : 4 === i2 && (t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=udp") }), t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":3478?transport=tcp") }), t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(ix2(e4.turnServerURL), ":443?transport=tcp") }));
          }), t3;
        }
        tryBindTransportEvents(e3) {
          const t3 = e3.transport;
          if (t3) {
            this.transportEventReceiver = e3, t3.onstatechange = () => {
              var e4;
              null != t3 && t3.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t3.state));
            }, t3.onerror = (e4) => {
              var t4;
              null === (t4 = this.onDTLSTransportError) || void 0 === t4 || t4.call(this, "error" in e4 ? e4.error : e4);
            };
            const i2 = t3.iceTransport;
            i2 && (i2.onstatechange = () => {
              const e4 = null == t3 ? void 0 : t3.iceTransport.state;
              var i3;
              e4 && (null === (i3 = this.onICETransportStateChange) || void 0 === i3 || i3.call(this, e4));
            }, i2.getSelectedCandidatePair && (i2.onselectedcandidatepairchange = () => {
              if (i2.getSelectedCandidatePair()) {
                const { local: e4, remote: t4 } = i2.getSelectedCandidatePair() || {};
                if (e4 && t4) {
                  const i3 = e4.address + ":" + e4.port, n3 = t4.address + ":" + t4.port;
                  sD.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify(hx2(i3)), ", remote ").concat(JSON.stringify(hx2(n3))));
                }
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t3) {
          var i2, n3;
          if (!t3) {
            const i3 = this.peerConnection.getSenders();
            t3 = i3.find((t4) => t4.track === e3._mediaStreamTrack);
          }
          if (!t3) return sD.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3)) return sD.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!fD2().supportSetRtpSenderParameters) return sD.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const r2 = {}, o2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              r2.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              r2.degradationPreference = "maintain-resolution";
              break;
            case "balanced":
              r2.degradationPreference = "balanced";
          }
          const s2 = function(e4, t4) {
            return e4.getTransceivers().find((e5) => e5.sender.track === t4 || e5.receiver.track === t4);
          }(this.peerConnection, e3._mediaStreamTrack), a3 = JP(e3);
          if (function(e4) {
            var t4;
            return !(!wN("ENABLE_AG_ADAPTATION") || !(e4 instanceof Mk2 || Ln2(t4 = e4._hints).call(t4, xD.CUSTOM_TRACK)) || !wN("FORCE_SUPPORT_AG_ADAPTATION") && !(lw2(14, 0, false) && uw2(17, 4, true) || dw2(14) && hw2(17, 4, true)));
          }(e3) && s2 && t3 && a3 && this.getLocalVideoStats && Ln2(i2 = ["vp8", "vp9"]).call(i2, this.store.codec)) {
            var c3;
            const i3 = r2.degradationPreference || (Ln2(c3 = e3._hints).call(c3, xD.CUSTOM_TRACK) ? wN("CUSTOM_ADAPTATION_DEFAULT_MODE") : "maintain-framerate");
            !function(e4, t4, i4, n4, r3, o3) {
              if (EB2(e4, i4), r3(t4), "balanced" !== n4 && "maintain-framerate" !== n4 && "maintain-resolution" !== n4) return;
              let s3 = -1;
              dB2(e4, t4);
              const a4 = window.setInterval(() => {
                const a5 = _B.get(e4);
                if (!wN("ENABLE_AG_ADAPTATION") || !a5) return EB2(e4, i4), void r3(t4);
                const c5 = o3();
                if (c5.sendPackets > 0 && c5.OutgoingAvailableBandwidth > 0) {
                  if (-1 === s3) return void (s3 = Date.now());
                  if (Date.now() - s3 < 1e3) return;
                  const o4 = c5.sendFrameRate, d3 = c5.OutgoingAvailableBandwidth, [l3, u4] = uB2(e4, o4, d3, a5.adaptationConfig, t4, n4);
                  u4 && (i4.qualityLimitationReason = u4), l3 && a5.adaptationConfig.scale !== l3.scale && (sD.debug("[".concat(e4, "] applyAdaptation: ").concat(i4.qualityLimitationReason, "\n           sendFps ").concat(o4, ", bwe ").concat(d3, ", switch from ").concat(a5.adaptationConfig.scale, " to ").concat(l3.scale, " ")), a5.adaptationConfig = pB2(pB2({}, a5.adaptationConfig), l3), r3(l3));
                }
              }, wN("CHECK_LOCAL_STATS_INTERVAL")), c4 = pB2({}, t4);
              _B.set(e4, { timer: a4, adaptationConfig: c4, originConfig: t4, adaptationFunc: r3 }), sD.debug("[".concat(e4, "] start adaptation, originConfig: ").concat(JSON.stringify(t4), ", degradationPreference: ").concat(n4));
            }(this.id + s2.mid, a3, this, i3, (e4) => {
              t3 && this.updateAdaptation(t3, e4);
            }, this.getLocalVideoStats.bind(this));
          }
          if (e3._encoderConfig) {
            var d2;
            const { bitrateMax: t4, frameRate: i3, scaleResolutionDownBy: n4 } = e3._encoderConfig;
            t4 && (o2.maxBitrate = 1e3 * t4), (Ln2(d2 = e3._hints).call(d2, xD.LOW_STREAM) || e3.isUseScaleResolutionDownBy) && (i3 && (o2.maxFramerate = ox2(i3)), n4 && n4 >= 1 && (o2.scaleResolutionDownBy = n4));
          }
          const { maxFramerate: l2 } = wN("ENCODER_CONFIG_LIMIT");
          if (l2 && "number" == typeof l2 && (o2.maxFramerate = o2.maxFramerate ? Math.min(o2.maxFramerate, l2) : l2), wN("DSCP_TYPE") && vw2()) {
            var u3;
            const e4 = wN("DSCP_TYPE");
            Ln2(u3 = ["very-low", "low", "medium", "high"]).call(u3, e4) && (o2.networkPriority = e4);
          }
          const h2 = t3.getParameters(), p2 = null === (n3 = h2.encodings) || void 0 === n3 ? void 0 : n3[0];
          iw2() && !p2 && (r2.encodings = [o2]), p2 && Object.assign(p2, o2), Object.assign(h2, r2), sD.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(h2.encodings))), await t3.setParameters(h2), await async function(e4, t4, i3) {
            try {
              var n4;
              if (!fD2().supportSetRtpSenderParameters) return;
              if (!/* @__PURE__ */ function(e5) {
                return "vp9" === e5 || "av1" === e5;
              }(e4) || !wN("ENABLE_SVC")) return;
              const r3 = {}, o3 = {}, s3 = t4.getParameters(), a4 = null === (n4 = s3.encodings) || void 0 === n4 ? void 0 : n4[0];
              o3.scalabilityMode = px2(i3), a4 && Object.assign(a4, o3), Object.assign(s3, r3), await t4.setParameters(s3), sD.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: ".concat(JSON.stringify(s3.encodings)));
            } catch (e5) {
              sD.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed", e5);
            }
          }(this.store.codec, t3, wN("SVC_MODE"));
        }
        async updateAdaptation(e3, t3) {
          var i2, n3;
          if (!e3) return sD.debug("[updateAdaptation] no rtpSender found");
          if (!fD2().supportSetRtpSenderParameters) return sD.debug("[updateAdaptation] Browser not support set rtp-sender parameters");
          const r2 = {}, { bitrateMax: o2, frameRate: s2, scaleResolutionDownBy: a3 } = t3;
          o2 && (r2.maxBitrate = 1e3 * o2), s2 && (r2.maxFramerate = ox2(s2)), a3 && a3 >= 1 && Ln2(i2 = ["vp8", "vp9"]).call(i2, this.store.codec) && (r2.scaleResolutionDownBy = a3);
          const c3 = e3.getParameters(), d2 = null === (n3 = c3.encodings) || void 0 === n3 ? void 0 : n3[0];
          d2 && Object.assign(d2, r2), Object.assign(c3, {});
          try {
            await e3.setParameters(c3), sD.debug("[updateAdaptation] updateRtpSenderEncodings: ".concat(JSON.stringify(c3.encodings)));
          } catch (t4) {
            !("transport" in e3) || e3.transport && "connected" === e3.transport.state ? "connected" !== this.peerConnectionState ? sD.debug("[updateAdaptation] peerConnection not connected}") : sD.debug("[updateAdaptation] updateRtpSenderEncodings failed", t4) : sD.debug("[updateAdaptation] rtpSender transport not connected}");
          }
        }
        async applySendEncodings(e3, t3) {
          try {
            if (!fD2().supportSetRtpSenderParameters) return;
            if (e3.length !== t3.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n3 = e3[i2], r2 = t3[i2];
              r2 instanceof kk2 && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n3.sender);
            }
          } catch (e4) {
            sD.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t3, i2) {
          const n3 = FN(e3);
          return t3.forEach((e4, t4) => {
            const r2 = i2[t4], o2 = n3.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            o2 && (Ax2(o2, e4), Px2(o2, e4, this.store.codec));
          }), BN(n3);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t3;
            null === (t3 = this.onFirstAudioReceived) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t3;
            null === (t3 = this.onFirstVideoReceived) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t3;
            null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t3, i2) => {
            var n3;
            null === (n3 = this.onFirstVideoDecoded) || void 0 === n3 || n3.call(this, e3, t3, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t3) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t3);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t3) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t3);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t3;
            null === (t3 = this.onFirstVideoDecodedTimeout) || void 0 === t3 || t3.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t3) {
          if (e3.length === t3.length) for (let a3 = 0; a3 < e3.length; a3++) {
            var i2, n3, r2, o2, s2;
            const c3 = e3[a3], d2 = t3[a3];
            if (d2 instanceof kk2 && !Ln2(i2 = d2._hints).call(i2, xD.LOW_STREAM) && null !== (n3 = d2._encoderConfig) && void 0 !== n3 && n3.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t4 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t4.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t4.high }];
              const i3 = c3.sender.getParameters();
              await c3.sender.setParameters(Object.assign(i3, e4));
            }
          }
        }
        async applySimulcastEncodings(e3, t3) {
          if (!iw2() && e3.length === t3.length) for (let i2 = 0; i2 < e3.length; i2++) {
            const n3 = t3[i2];
            if (n3 instanceof kk2 && this.isVP8Simulcast(n3)) {
              const t4 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n3._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t4.sender.getParameters();
              await t4.sender.setParameters(Object.assign(s2, r2));
            }
          }
        }
        isVP8Simulcast(e3) {
          var t3, i2, n3, r2, o2;
          return !!(e3 instanceof kk2 && wN("SIMULCAST") && "vp8" === this.store.codec && !Ln2(t3 = e3._hints).call(t3, xD.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n3 = e3._encoderConfig) || void 0 === n3 ? void 0 : n3.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t3, i2, n3) {
          if (wN("SDP_LOGGING")) return sD.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t3, " SDP during P2PConnection.").concat(n3, "\n"), e3), "offer" === t3 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n3);
          } : void 0;
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP) return;
          const t3 = this.remoteSDP.getSSRC(e3);
          return t3 && 0 !== t3.length ? t3[0].ssrcId : void 0;
        }
        setConfiguration(t3) {
          if (fD2().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t3);
            this.peerConnection.setConfiguration(i2);
          }
          t3.isPreallocation && (this.isPreallocation = true);
        }
      }, OU(CB2.prototype, "updateRemoteRTPCapabilities", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "updateRemoteRTPCapabilities"), CB2.prototype), OU(CB2.prototype, "connect", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "connect"), CB2.prototype), OU(CB2.prototype, "updateRemoteConnect", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "updateRemoteConnect"), CB2.prototype), OU(CB2.prototype, "createDataChannels", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "createDataChannels"), CB2.prototype), OU(CB2.prototype, "receive", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "receive"), CB2.prototype), OU(CB2.prototype, "batchReceive", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "batchReceive"), CB2.prototype), OU(CB2.prototype, "stopReceiving", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "stopReceiving"), CB2.prototype), OU(CB2.prototype, "muteRemote", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "muteRemote"), CB2.prototype), OU(CB2.prototype, "unmuteRemote", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "unmuteRemote"), CB2.prototype), OU(CB2.prototype, "muteLocal", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "muteLocal"), CB2.prototype), OU(CB2.prototype, "unmuteLocal", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "unmuteLocal"), CB2.prototype), OU(CB2.prototype, "close", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "close"), CB2.prototype), OU(CB2.prototype, "updateEncoderConfig", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "updateEncoderConfig"), CB2.prototype), OU(CB2.prototype, "updateSendParameters", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "updateSendParameters"), CB2.prototype), OU(CB2.prototype, "replaceTrack", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "replaceTrack"), CB2.prototype), OU(CB2.prototype, "updateAdaptation", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "updateAdaptation"), CB2.prototype), OU(CB2.prototype, "getRemoteSSRC", [AB2], Object.getOwnPropertyDescriptor(CB2.prototype, "getRemoteSSRC"), CB2.prototype), CB2);
      function AB2(e2, t3, i2) {
        const n3 = e2[t3];
        if ("function" != typeof n3) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t3));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n3.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function wB2(e2, t3) {
        let i2 = document.createElement("video"), n3 = document.createElement("canvas");
        i2.setAttribute("style", "display:none"), n3.setAttribute("style", "display:none"), i2.setAttribute("muted", ""), i2.muted = true, i2.setAttribute("autoplay", ""), i2.autoplay = true, i2.setAttribute("playsinline", ""), n3.width = ox2(t3.width), n3.height = ox2(t3.height);
        const r2 = ox2(t3.framerate || 15);
        document.body.append(i2), document.body.append(n3);
        let o2 = e2._mediaStreamTrack;
        i2.srcObject = new MediaStream([o2]), i2.play();
        const s2 = n3.getContext("2d");
        if (!s2) throw new ED(ww2.UNEXPECTED_ERROR, "can not get canvas context");
        const a3 = fD2(), c3 = n3.captureStream(a3.supportRequestFrame ? 0 : r2).getVideoTracks()[0];
        c3.canvas || (c3.canvas = n3), n3.startCapture = () => {
          if (!i2) return n3.stopCapture && n3.stopCapture();
          if (i2.paused && i2.play(), i2.videoHeight > 2 && i2.videoWidth > 2) {
            const e3 = i2.videoWidth, t4 = i2.videoHeight / e3, r3 = n3.width * t4;
            Math.abs(r3 - n3.height) >= 2 && (sD.debug("adjust low stream resolution", "".concat(n3.width, "x").concat(n3.height, " -> ").concat(n3.width, "x").concat(r3)), n3.height = r3);
          }
          s2.drawImage(i2, 0, 0, n3.width, n3.height), c3.requestFrame && c3.requestFrame(), o2 !== e2._mediaStreamTrack && (o2 = e2._mediaStreamTrack, i2.srcObject = new MediaStream([o2]));
        }, n3.stopCapture = SP(() => n3.startCapture && n3.startCapture(), r2);
        const d2 = c3.stop;
        return c3.stop = () => {
          d2.call(c3), i2 && (i2.remove(), i2.srcObject = null, i2 = null), n3 && (n3.width = 0, n3.remove(), n3.stopCapture && n3.stopCapture(), n3.startCapture = void 0, n3.stopCapture = void 0, n3 = null), sD.debug("clean low stream renderer");
        }, c3;
      }
      var OB2 = function(e2) {
        return e2[e2.Video_Send_Type = 190] = "Video_Send_Type", e2;
      }(OB2 || {}), NB2 = function(e2) {
        return e2[e2.Video_Send_Qp_Sum = 2143] = "Video_Send_Qp_Sum", e2[e2.Video_Send_Freeze = 2082] = "Video_Send_Freeze", e2[e2.Video_Recv_Qp_Sum = 2144] = "Video_Recv_Qp_Sum", e2[e2.Video_Recv_Freeze = 2084] = "Video_Recv_Freeze", e2[e2.Video_Render_Freeze_Time = 2109] = "Video_Render_Freeze_Time", e2[e2.Video_Render_Freeze_Time_Render = 2147] = "Video_Render_Freeze_Time_Render", e2[e2.Video_Render_Freeze_Time_Render2 = 2223] = "Video_Render_Freeze_Time_Render2", e2[e2.Audio_Recv_Freeze = 2083] = "Audio_Recv_Freeze", e2;
      }(NB2 || {}), DB2 = function(e2) {
        return e2[e2.Video_Send_Retransmit = 2062] = "Video_Send_Retransmit", e2[e2.Video_Send_Target_Encoded = 2064] = "Video_Send_Target_Encoded", e2[e2.Video_Send_Actual_Encoded = 2060] = "Video_Send_Actual_Encoded", e2[e2.Video_Send_Transmit = 2066] = "Video_Send_Transmit", e2[e2.Video_Send_Bandwidth = 2061] = "Video_Send_Bandwidth", e2[e2.Video_Capture_Height = 2033] = "Video_Capture_Height", e2[e2.Video_Capture_Width = 2035] = "Video_Capture_Width", e2[e2.Video_Capture_Frame_Rate = 2034] = "Video_Capture_Frame_Rate", e2[e2.Video_Send_Low_Height = 2073] = "Video_Send_Low_Height", e2[e2.Video_Send_Low_Frame_Rate = 2075] = "Video_Send_Low_Frame_Rate", e2[e2.Video_Send_Low_Width = 2077] = "Video_Send_Low_Width", e2[e2.Video_Send_Low_Bitrate = 2069] = "Video_Send_Low_Bitrate", e2[e2.Video_Send_Low_Package_Lost = 2070] = "Video_Send_Low_Package_Lost", e2[e2.Video_Send_Low_Package_Rate = 2071] = "Video_Send_Low_Package_Rate", e2[e2.Video_Send_Frame_Rate = 2002] = "Video_Send_Frame_Rate", e2[e2.Video_Send_Width = 2003] = "Video_Send_Width", e2[e2.Video_Send_Height = 2004] = "Video_Send_Height", e2[e2.Video_Send_Disabled = 2095] = "Video_Send_Disabled", e2[e2.Video_Send_Adaptation = 2032] = "Video_Send_Adaptation", e2[e2.Video_Send_Player_Status = 2128] = "Video_Send_Player_Status", e2[e2.Video_Send_Nacks = 2009] = "Video_Send_Nacks", e2[e2.Video_Send_Plis = 2010] = "Video_Send_Plis", e2[e2.Video_Send_Firs = 2011] = "Video_Send_Firs", e2[e2.Video_Send_Avg_Encode = 2007] = "Video_Send_Avg_Encode", e2[e2.Video_Send_Huge_Frame_Sent = 2174] = "Video_Send_Huge_Frame_Sent", e2[e2.Video_Send_Bytes_Retransmit = 2173] = "Video_Send_Bytes_Retransmit", e2[e2.Video_Send_Packages_Retransmit = 2172] = "Video_Send_Packages_Retransmit", e2[e2.Video_Send_Key_Frames_Encoded = 2207] = "Video_Send_Key_Frames_Encoded", e2[e2.Video_Send_Bitrate = 2012] = "Video_Send_Bitrate", e2[e2.Video_Send_Package_Rate = 2031] = "Video_Send_Package_Rate", e2[e2.Video_Send_Package_Lost = 2005] = "Video_Send_Package_Lost", e2[e2.Audio_Capture_PCM_Level = 2104] = "Audio_Capture_PCM_Level", e2[e2.Audio_Send_Level = 2038] = "Audio_Send_Level", e2[e2.Audio_Send_Bitrate = 2039] = "Audio_Send_Bitrate", e2[e2.Audio_Send_Package_Rate = 2040] = "Audio_Send_Package_Rate", e2[e2.Audio_Send_AEC_Return_Loss = 2041] = "Audio_Send_AEC_Return_Loss", e2[e2.Audio_Send_AEC_Return_Loss_Enhancement = 2042] = "Audio_Send_AEC_Return_Loss_Enhancement", e2[e2.Audio_Send_Freeze = 2081] = "Audio_Send_Freeze", e2[e2.Audio_Send_Disabled = 2096] = "Audio_Send_Disabled", e2[e2.Audio_Send_Bytes_Retransmit = 2179] = "Audio_Send_Bytes_Retransmit", e2[e2.Audio_Send_Packages_Retransmit = 2180] = "Audio_Send_Packages_Retransmit", e2[e2.Video_Recv_Height = 2019] = "Video_Recv_Height", e2[e2.Video_Recv_Width = 2018] = "Video_Recv_Width", e2[e2.Video_Recv_Frame_Rate_Output = 2155] = "Video_Recv_Frame_Rate_Output", e2[e2.Video_Recv_Jitter_Buffer = 2023] = "Video_Recv_Jitter_Buffer", e2[e2.Video_Recv_Current_Delay = 2024] = "Video_Recv_Current_Delay", e2[e2.Video_Recv_Nacks = 2026] = "Video_Recv_Nacks", e2[e2.Video_Recv_Plis = 2027] = "Video_Recv_Plis", e2[e2.Video_Recv_Firs = 2028] = "Video_Recv_Firs", e2[e2.Video_Recv_Disabled = 2101] = "Video_Recv_Disabled", e2[e2.Video_Recv_Player_Status = 2129] = "Video_Recv_Player_Status", e2[e2.Video_Recv_I_Frame_Delay = 2149] = "Video_Recv_I_Frame_Delay", e2[e2.Video_Render_Frame_Rate_Render = 2022] = "Video_Render_Frame_Rate_Render", e2[e2.Video_Render_Freeze_Duration = 2156] = "Video_Render_Freeze_Duration", e2[e2.Audio_Render_Level = 2043] = "Audio_Render_Level", e2[e2.Audio_Render_Freeze_Time_80ms = 2226] = "Audio_Render_Freeze_Time_80ms", e2[e2.Audio_Render_Freeze_Time_200ms = 2227] = "Audio_Render_Freeze_Time_200ms", e2[e2.Audio_Render_Freeze_Samples_80ms = 2228] = "Audio_Render_Freeze_Samples_80ms", e2[e2.Audio_Render_Freeze_Samples_200ms = 2229] = "Audio_Render_Freeze_Samples_200ms", e2[e2.Audio_Recv_PCM_Level = 2105] = "Audio_Recv_PCM_Level", e2[e2.Audio_Recv_Disabled = 2102] = "Audio_Recv_Disabled", e2[e2.Audio_Recv_Jitter_Buffer = 2054] = "Audio_Recv_Jitter_Buffer", e2[e2.Audio_Recv_Current_Delay = 2047] = "Audio_Recv_Current_Delay", e2[e2.Audio_Recv_Player_Status = 2130] = "Audio_Recv_Player_Status", e2[e2.Audio_Recv_Bitrate = 2044] = "Audio_Recv_Bitrate", e2[e2.Audio_Recv_Concealed_Samples = 2148] = "Audio_Recv_Concealed_Samples", e2[e2.Audio_Recv_Total_Samples_Received = 2224] = "Audio_Recv_Total_Samples_Received", e2;
      }(DB2 || {}), PB2 = function(e2) {
        return e2[e2.Video_Render_Frame_Rate_Decode = 2021] = "Video_Render_Frame_Rate_Decode", e2[e2.Video_Recv_Frame_Rate = 2020] = "Video_Recv_Frame_Rate", e2[e2.Video_Recv_Frame_Dropped = 2181] = "Video_Recv_Frame_Dropped", e2[e2.Video_Recv_Bytes_Retransmit = 2175] = "Video_Recv_Bytes_Retransmit", e2[e2.Video_Recv_Packages_Retransmit = 2176] = "Video_Recv_Packages_Retransmit", e2[e2.Video_Recv_Packages_Discarded = 2198] = "Video_Recv_Packages_Discarded", e2[e2.Video_Recv_Avg_Decode = 2200] = "Video_Recv_Avg_Decode", e2[e2.Video_Recv_Avg_Processing_Delay = 2202] = "Video_Recv_Avg_Processing_Delay", e2[e2.Video_Recv_Avg_Assembly_Time = 2203] = "Video_Recv_Avg_Assembly_Time", e2[e2.Video_Recv_Avg_Inter_Frame_Delay = 2204] = "Video_Recv_Avg_Inter_Frame_Delay", e2[e2.Video_Recv_Key_Frames_Decoded = 2206] = "Video_Recv_Key_Frames_Decoded", e2[e2.Video_Recv_Package_Lost = 2014] = "Video_Recv_Package_Lost", e2[e2.Video_Recv_Bitrate = 2029] = "Video_Recv_Bitrate", e2[e2.Video_Recv_Package_Rate = 2078] = "Video_Recv_Package_Rate", e2[e2.Audio_Recv_Jitter = 2055] = "Audio_Recv_Jitter", e2[e2.Audio_Recv_Bytes_Retransmit = 2178] = "Audio_Recv_Bytes_Retransmit", e2[e2.Audio_Recv_Packages_Retransmit = 2177] = "Audio_Recv_Packages_Retransmit", e2[e2.Audio_Recv_Packages_Discarded = 2199] = "Audio_Recv_Packages_Discarded", e2[e2.Audio_Recv_Avg_Processing_Delay = 2201] = "Audio_Recv_Avg_Processing_Delay", e2[e2.Audio_Recv_Package_Rate = 2046] = "Audio_Recv_Package_Rate", e2[e2.Audio_Recv_Package_Lost = 2045] = "Audio_Recv_Package_Lost", e2;
      }(PB2 || {}), LB2 = function(e2) {
        return e2[e2.RTT = 2006] = "RTT", e2[e2.CONN_TYPE = 801] = "CONN_TYPE", e2[e2.STATS_UPDATE_INTERVAL = 2205] = "STATS_UPDATE_INTERVAL", e2;
      }(LB2 || {}), kB2 = function(e2) {
        return e2[e2.RTC_PEER_CONNECTION_STATE = 2219] = "RTC_PEER_CONNECTION_STATE", e2;
      }(kB2 || {});
      const MB2 = 1e3, UB2 = 6, VB2 = 3, xB2 = Math.max(UB2, VB2, 60);
      function FB2(e2, t3, i2) {
        null != i2 && Number.isFinite(i2) && (e2[t3] = Math.round(Math.max(0, i2)));
      }
      function BB2(e2) {
        const t3 = { [LB2.CONN_TYPE]: 0, [LB2.RTT]: e2.rtt, [LB2.STATS_UPDATE_INTERVAL]: e2.updateInterval ? Math.round(Math.max(0, e2.updateInterval)) : void 0 };
        switch (e2.selectedCandidatePair.localCandidate.candidateType) {
          case "relay": {
            const i2 = e2.selectedCandidatePair.localCandidate.relayProtocol;
            "udp" === i2 && (t3[LB2.CONN_TYPE] = 1), "tcp" === i2 && (t3[LB2.CONN_TYPE] = 3), "tls" === i2 && (t3[LB2.CONN_TYPE] = 4);
            break;
          }
          case "srflx":
            t3[LB2.CONN_TYPE] = 2;
            break;
          case "unknown":
            t3[LB2.CONN_TYPE] = 5;
            break;
          default:
            t3[LB2.CONN_TYPE] = 0;
        }
        return t3;
      }
      function jB2(e2) {
        let t3 = 0;
        switch (e2) {
          case "none":
            t3 = 0;
            break;
          case "cpu":
            t3 = 1;
            break;
          case "bandwidth":
            t3 = 2;
            break;
          case "other":
            t3 = 3;
        }
        return t3;
      }
      class GB2 extends Hw2 {
        constructor(e2) {
          super(), uI(this, "store", void 0), uI(this, "uploadWRTCStatsTimer", void 0), uI(this, "uploadOutboundDenoiserStatsTimer", void 0), uI(this, "uploadExtStatsTimer", void 0), uI(this, "uploadExtUsageStatsTimer", void 0), uI(this, "uploadInboundExtStatsTimer", void 0), uI(this, "requestStats", void 0), uI(this, "requestTransportStats", void 0), uI(this, "requestLocalMedia", void 0), uI(this, "requestRemoteMedia", void 0), uI(this, "requestAllTracks", void 0), uI(this, "requestVideoIsReady", void 0), uI(this, "requestUploadStats", void 0), uI(this, "requestUpload", void 0), uI(this, "uploadOutboundStarted", false), uI(this, "uploadInboundStarted", false), uI(this, "uploadTransportStarted", false), uI(this, "uploadBaseStatsStarted", false), uI(this, "uploadExtensionUsageStarted", false), uI(this, "lastRecvStats", void 0), uI(this, "lastSendStats", void 0), uI(this, "lastRefRecvStats", void 0), uI(this, "lastRefSendStats", void 0), uI(this, "lastNormalRecvStats", void 0), uI(this, "lastNormalSendStats", void 0), uI(this, "lastExtendStats", {}), uI(this, "needUploadStats", {}), uI(this, "needUploadRenderFreezeTime", true), uI(this, "lastUploadCompensateTime", -1), uI(this, "uploadCompensateDeltaTime", 0), this.store = e2;
        }
        uploadWRTCStats(e2) {
          if (!this.requestStats || !this.requestUploadStats) return;
          const t3 = e2 % VB2 == 0, i2 = e2 % UB2 == 0, n3 = e2 % 60 == 0;
          let r2, o2;
          if (this.uploadTransportStarted && (r2 = this.requestStats(), this.store.useP2P && (o2 = this.requestStats(true))), !r2 && this.uploadOutboundStarted && (r2 = this.requestStats()), !o2 && this.uploadInboundStarted && (o2 = this.requestStats(true)), r2 || o2) {
            var s2;
            const a3 = {};
            if (this.uploadTransportStarted && r2) {
              const e3 = this.getTransportStats(r2, o2, t3);
              e3 && (a3.misc = [e3]);
            }
            if (this.uploadOutboundStarted && r2) {
              const e3 = this.getOutboundStats(r2, i2 ? this.lastNormalSendStats : void 0, t3 ? this.lastRefSendStats : void 0, this.lastSendStats, n3);
              e3 && (a3.outbound = [e3]);
            }
            if (this.uploadInboundStarted && o2) {
              this.uploadCompensateStats(e2);
              const n4 = this.getInboundStats(o2, i2 ? this.lastNormalRecvStats : void 0, t3 ? this.lastRefRecvStats : void 0, this.lastRecvStats);
              n4 && (a3.inbound = n4);
            }
            const c3 = null === (s2 = this.requestTransportStats) || void 0 === s2 ? void 0 : s2.call(this).connectState;
            c3 && (Array.isArray(a3.misc) ? a3.misc[0] && a3.misc[0].addition && (a3.misc[0].addition[kB2.RTC_PEER_CONNECTION_STATE] = dN[c3]) : a3.misc = [{ addition: { [kB2.RTC_PEER_CONNECTION_STATE]: dN[c3] } }]), this.needUploadStats.sendType && (Array.isArray(a3.outbound) && a3.outbound[0] && a3.outbound[0].high && (a3.outbound[0].high[OB2.Video_Send_Type] = this.needUploadStats.sendType), this.needUploadStats.sendType = void 0), this.requestUploadStats(a3);
          }
          this.lastRecvStats = o2, this.lastSendStats = r2, i2 && (this.lastNormalRecvStats = o2, this.lastNormalSendStats = r2), t3 && (this.lastRefRecvStats = o2, this.lastRefSendStats = r2);
        }
        startUploadWRTCStats() {
          if (this.uploadWRTCStatsTimer) return;
          this.uploadBaseStatsStarted = true;
          let e2 = 1;
          this.uploadWRTCStatsTimer = window.setInterval(() => {
            if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) {
              if (this.uploadBaseStatsStarted) {
                var t3, i2;
                const e3 = null === (t3 = this.requestTransportStats) || void 0 === t3 ? void 0 : t3.call(this);
                return void (e3 && (null === (i2 = this.requestUploadStats) || void 0 === i2 || i2.call(this, { misc: [{ addition: { [kB2.RTC_PEER_CONNECTION_STATE]: dN[e3.connectState] } }] })));
              }
              return this.stopUploadWRTCStats();
            }
            this.uploadWRTCStats(e2), ++e2 === xB2 + 1 && (e2 = 1);
          }, MB2);
        }
        uploadCompensateStats(e2) {
          if (!this.requestStats || !this.requestUploadStats || !this.requestRemoteMedia) return;
          const t3 = e2 % VB2 == 0 && this.needUploadRenderFreezeTime;
          if (!this.uploadInboundStarted || !t3) return;
          if (-1 === this.lastUploadCompensateTime) return void (this.lastUploadCompensateTime = Date.now());
          const i2 = Math.max(-6e3, Date.now() - this.lastUploadCompensateTime - 6e3);
          if (this.uploadCompensateDeltaTime += i2, this.lastUploadCompensateTime = Date.now(), this.uploadCompensateDeltaTime < 6e3) return;
          const n3 = Math.min(Math.floor(this.uploadCompensateDeltaTime / 6e3), 10);
          this.uploadCompensateDeltaTime -= 6e3 * n3;
          const r2 = this.requestStats(true);
          new Array(n3).fill(0).forEach(() => {
            if (!this.requestStats || !this.requestUploadStats || !this.requestRemoteMedia) return;
            const e3 = {};
            if (this.uploadInboundStarted && r2) {
              const t4 = this.requestRemoteMedia() || [], i3 = [];
              t4.forEach((e4) => {
                let [t5, n4] = e4;
                const o2 = { peer: t5.uid };
                if ((t5._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(t5._videoSSRC) || false) && n4.has(EV.VIDEO) && t5.videoTrack) {
                  const e5 = function(e6, t6, i4) {
                    if (!t6.videoRecv.find((t7) => t7.ssrc === e6)) return;
                    const n5 = {};
                    if (i4 && i4._player) {
                      const e7 = i4._player, { renderFreezeAccTime2: t7, videoElementStatus: r3 } = e7;
                      if ("visible" === Qk2.visibility && r3 === iP.PLAYING && fD2().supportRequestVideoFrameCallback) {
                        const i5 = Math.min(6e3, t7);
                        e7.renderFreezeAccTime2 = Math.max(0, t7 - i5), FB2(n5, NB2.Video_Render_Freeze_Time_Render2, i5), wN("USE_NEW_RENDER_FREEZE_TIME") && FB2(n5, NB2.Video_Render_Freeze_Time_Render, i5);
                      }
                    }
                    return n5;
                  }(t5._videoSSRC, r2, t5.videoTrack);
                  e5 && (o2.video = e5);
                }
                o2.video && i3.push(o2);
              }), i3.length > 0 && (e3.inbound = i3, this.requestUploadStats(e3));
            }
          });
        }
        stopUploadWRTCStats() {
          window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0), this.lastRefSendStats && (this.lastRefSendStats.videoSend = [], this.lastRefSendStats.audioSend = [], this.lastRefSendStats = void 0), this.lastRefRecvStats && (this.lastRefRecvStats.videoRecv = [], this.lastRefRecvStats.audioRecv = [], this.lastRefRecvStats = void 0), this.lastNormalSendStats && (this.lastNormalSendStats.videoSend = [], this.lastNormalSendStats.audioSend = [], this.lastNormalSendStats = void 0), this.lastNormalRecvStats && (this.lastNormalRecvStats.videoRecv = [], this.lastNormalRecvStats.audioRecv = [], this.lastNormalRecvStats = void 0), this.lastExtendStats = {}, this.needUploadStats = {}, this.lastUploadCompensateTime = -1, this.uploadCompensateDeltaTime = 0, this.needUploadRenderFreezeTime = true;
        }
        getTransportStats(e2, t3, i2) {
          if (!this.requestStats) return;
          if (!i2) return null == e2.rtt ? void 0 : { addition: { [LB2.RTT]: e2.rtt, [LB2.CONN_TYPE]: void 0, [LB2.STATS_UPDATE_INTERVAL]: e2.updateInterval || void 0 } };
          const n3 = BB2(e2);
          if (this.store.useP2P) {
            if (t3) {
              const e3 = BB2(t3);
              n3[LB2.CONN_TYPE] += e3[LB2.CONN_TYPE] << 3;
            }
            n3[LB2.CONN_TYPE] += 110;
          } else n3[LB2.CONN_TYPE] += 100;
          return { addition: n3 };
        }
        getOutboundStats(e2, t3, i2, n3, r2) {
          if (!this.requestUploadStats || !this.requestLocalMedia) return;
          const o2 = this.requestLocalMedia();
          if (!o2 || 0 === o2.length) return;
          let s2, a3, c3;
          return o2.forEach((n4) => {
            let [o3, { track: d2, ssrcs: l2 }] = n4;
            switch (o3) {
              case gV.LocalVideoLowTrack:
              case gV.LocalVideoTrack:
                if (o3 === gV.LocalVideoTrack) {
                  var u3;
                  const n5 = function(e3, t4, i3, n6, r3, o5) {
                    const s4 = t4.videoSend.find((t5) => t5.ssrc === e3);
                    if (!s4) return;
                    const a4 = {}, { sentFrame: c5, inputFrame: d3 } = s4;
                    if (n6 && (FB2(a4, NB2.Video_Send_Qp_Sum, s4.qpSumPerFrame), d3 && c5)) {
                      const e4 = d3.frameRate, t5 = c5.frameRate;
                      a4[NB2.Video_Send_Freeze] = function(e5, t6) {
                        let i4 = true;
                        return i4 = !(e5 <= 5) && (e5 <= 10 ? t6 < 3 : e5 <= 20 ? t6 < 4 : t6 < 5), i4;
                      }(e4, t5) ? 1 : 0;
                    }
                    if (r3) {
                      switch (c5 && (FB2(a4, DB2.Video_Send_Height, c5.height), FB2(a4, DB2.Video_Send_Width, c5.width), FB2(a4, DB2.Video_Send_Frame_Rate, c5.frameRate)), a4[DB2.Video_Send_Disabled] = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? 1 : 0, s4.adaptionChangeReason) {
                        case "none":
                          a4[DB2.Video_Send_Adaptation] = 0;
                          break;
                        case "cpu":
                          a4[DB2.Video_Send_Adaptation] = 1;
                          break;
                        case "bandwidth":
                          a4[DB2.Video_Send_Adaptation] = 2;
                          break;
                        case "other":
                          a4[DB2.Video_Send_Adaptation] = 3;
                      }
                      let n7 = 0;
                      s4.adaptionChangeReason && (n7 += jB2(s4.adaptionChangeReason)), t4.qualityLimitationReason && (n7 += jB2(t4.qualityLimitationReason) << 3), a4[DB2.Video_Send_Adaptation] = n7, a4[DB2.Video_Send_Player_Status] = rP[i3._player ? i3._player.videoElementStatus : "uninit"], FB2(a4, DB2.Video_Send_Nacks, s4.nacksCount), FB2(a4, DB2.Video_Send_Plis, s4.plisCount), FB2(a4, DB2.Video_Send_Firs, s4.firsCount), FB2(a4, DB2.Video_Send_Avg_Encode, s4.avgEncodeMs), FB2(a4, DB2.Video_Send_Huge_Frame_Sent, s4.hugeFramesSent), FB2(a4, DB2.Video_Send_Bytes_Retransmit, s4.retransmittedBytesSent), FB2(a4, DB2.Video_Send_Packages_Retransmit, s4.retransmittedPacketsSent), FB2(a4, DB2.Video_Send_Key_Frames_Encoded, s4.keyFramesEncoded);
                      const o6 = r3.videoSend.find((t5) => t5.ssrc === e3);
                      if (o6) {
                        let e4 = MB2 * VB2;
                        o6.timestamp && s4.timestamp && (e4 = s4.timestamp - o6.timestamp), null != o6.packets && null != s4.packets && FB2(a4, DB2.Video_Send_Package_Rate, 1e3 * (s4.packets - o6.packets) / e4), null != s4.packetsLost && null != o6.packetsLost && FB2(a4, DB2.Video_Send_Package_Lost, s4.packetsLost - o6.packetsLost), null != o6.bytes && null != s4.bytes && FB2(a4, DB2.Video_Send_Bitrate, 8 * (s4.bytes - o6.bytes) / e4);
                      }
                    }
                    return a4;
                  }(l2[0].ssrcId, e2, d2, t3, i2), o4 = "CameraVideoTrack" === d2.__className__ ? 3 : Ln2(u3 = d2._hints).call(u3, xD.SCREEN_TRACK) ? 7 : 10;
                  (this.lastExtendStats.sendType !== o4 || r2) && (this.needUploadStats = { sendType: o4 }, this.lastExtendStats.sendType = o4);
                  const s3 = d2 && function(e3, t4, i3, n6) {
                    const r3 = t4.videoSend.find((t5) => t5.ssrc === e3);
                    if (!r3) return null;
                    const o5 = {};
                    if (n6) {
                      const e4 = r3.inputFrame, t5 = e4 && e4.height || i3.videoHeight || 0, n7 = e4 && e4.width || i3.videoWidth || 0, s4 = e4 && e4.frameRate || 0;
                      FB2(o5, DB2.Video_Capture_Height, t5), FB2(o5, DB2.Video_Capture_Width, n7), FB2(o5, DB2.Video_Capture_Frame_Rate, s4);
                    }
                    return o5;
                  }(l2[0].ssrcId, e2, d2, !!i2), c4 = function(e3, t4) {
                    const i3 = {};
                    return t4 && (FB2(i3, DB2.Video_Send_Retransmit, e3.bitrate.retransmit), FB2(i3, DB2.Video_Send_Target_Encoded, e3.bitrate.targetEncoded), FB2(i3, DB2.Video_Send_Actual_Encoded, e3.bitrate.actualEncoded), FB2(i3, DB2.Video_Send_Transmit, e3.bitrate.transmit), FB2(i3, DB2.Video_Send_Bandwidth, e3.sendBandwidth)), i3;
                  }(e2, !!i2);
                  a3 = Object.assign({}, n5, s3, c4);
                } else c3 = function(e3, t4, i3, n5, r3) {
                  const o4 = t4.videoSend.find((t5) => t5.ssrc === e3);
                  if (!o4) return;
                  const s3 = {};
                  if (n5) {
                    const t5 = o4.sentFrame;
                    t5 && (FB2(s3, DB2.Video_Send_Low_Height, t5.height), FB2(s3, DB2.Video_Send_Low_Width, t5.width), FB2(s3, DB2.Video_Send_Low_Frame_Rate, t5.frameRate));
                    const i4 = n5.videoSend.find((t6) => t6.ssrc === e3);
                    if (i4) {
                      let e4 = MB2 * UB2;
                      i4.timestamp && o4.timestamp && (e4 = o4.timestamp - i4.timestamp), null != i4.packets && null != o4.packets && FB2(s3, DB2.Video_Send_Low_Package_Rate, 1e3 * (o4.packets - i4.packets) / e4), null != o4.packetsLost && null != i4.packetsLost && FB2(s3, DB2.Video_Send_Low_Package_Lost, o4.packetsLost - i4.packetsLost), null != i4.bytes && null != o4.bytes && FB2(s3, DB2.Video_Send_Low_Bitrate, 8 * (o4.bytes - i4.bytes) / e4);
                    }
                  }
                  return s3;
                }(l2[0].ssrcId, e2, 0, i2);
                break;
              case gV.LocalAudioTrack:
                s2 = d2 && function(e3, t4, i3, n5, r3, o4) {
                  const s3 = t4.audioSend.find((t5) => t5.ssrc === e3);
                  if (!s3) return;
                  const a4 = {};
                  if (r3) {
                    a4[DB2.Audio_Send_Disabled] = i3._originMediaStreamTrack && !i3._originMediaStreamTrack.enabled || i3._mediaStreamTrack && !i3._mediaStreamTrack.enabled ? 1 : 0;
                    const t5 = 100 * i3._source.getAccurateVolumeLevel(), n6 = s3.inputLevel;
                    if (null != n6) {
                      const e4 = Math.ceil(50 * Math.log10(100 * n6 + 1));
                      FB2(a4, DB2.Audio_Send_Level, e4);
                    }
                    FB2(a4, DB2.Audio_Capture_PCM_Level, t5), FB2(a4, DB2.Audio_Send_AEC_Return_Loss, s3.aecReturnLoss), FB2(a4, DB2.Audio_Send_AEC_Return_Loss_Enhancement, s3.aecReturnLossEnhancement), FB2(a4, DB2.Audio_Send_Bytes_Retransmit, s3.retransmittedBytesSent), FB2(a4, DB2.Audio_Send_Packages_Retransmit, s3.retransmittedPacketsSent), a4[DB2.Audio_Send_Freeze] = 0;
                    const o5 = r3.audioSend.find((t6) => t6.ssrc === e3);
                    if (o5) {
                      let e4 = MB2 * UB2;
                      o5.timestamp && s3.timestamp && (e4 = s3.timestamp - o5.timestamp), null != o5.bytes && null != s3.bytes && FB2(a4, DB2.Audio_Send_Bitrate, 8 * (s3.bytes - o5.bytes) / e4), null != o5.packets && null != s3.packets && FB2(a4, DB2.Audio_Send_Package_Rate, 1e3 * (s3.packets - o5.packets) / e4);
                    }
                  }
                  return a4;
                }(l2[0].ssrcId, e2, d2, 0, i2);
            }
          }), { high: a3, low: c3, audio: s2 };
        }
        getInboundStats(e2, t3, i2, n3) {
          if (!this.requestRemoteMedia) return;
          const r2 = this.requestRemoteMedia() || [], o2 = [];
          return r2.forEach((r3) => {
            let [s2, a3] = r3;
            const c3 = { peer: s2.uid };
            if (a3.has(EV.VIDEO) && s2.videoTrack) {
              const r4 = s2._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(s2._videoSSRC) || false, o3 = s2.videoTrack ? function(e3, t4, i3, n4, r5, o4, s3, a4) {
                const c4 = t4.videoRecv.find((t5) => t5.ssrc === e3);
                if (!c4) return;
                const d2 = {}, { receivedFrame: l2, outputFrame: u3, decodeFrameRate: h2 } = c4;
                FB2(d2, PB2.Video_Render_Frame_Rate_Decode, h2), c4.framesRateFirefox && FB2(d2, PB2.Video_Recv_Frame_Rate, c4.framesRateFirefox), l2 && FB2(d2, PB2.Video_Recv_Frame_Rate, l2.frameRate), FB2(d2, PB2.Video_Recv_Frame_Dropped, c4.framesDroppedCount), FB2(d2, PB2.Video_Recv_Bytes_Retransmit, c4.retransmittedBytesReceived), FB2(d2, PB2.Video_Recv_Packages_Retransmit, c4.retransmittedPacketsReceived), FB2(d2, PB2.Video_Recv_Packages_Discarded, c4.packetsDiscarded), FB2(d2, PB2.Video_Recv_Avg_Decode, c4.avgDecodeMs), FB2(d2, PB2.Video_Recv_Avg_Processing_Delay, c4.avgProcessingDelayMs), FB2(d2, PB2.Video_Recv_Avg_Assembly_Time, c4.avgFramesAssembledFromMultiplePacketsMs), FB2(d2, PB2.Video_Recv_Avg_Inter_Frame_Delay, c4.avgInterFrameDelayMs), FB2(d2, PB2.Video_Recv_Key_Frames_Decoded, c4.keyFramesDecoded);
                const p2 = a4 && a4.videoRecv.find((t5) => t5.ssrc === e3);
                if (p2) {
                  const e4 = t4.timestamp - a4.timestamp || MB2;
                  null != c4.packetsLost && null != p2.packetsLost && FB2(d2, PB2.Video_Recv_Package_Lost, c4.packetsLost - p2.packetsLost), null != p2.bytes && null != c4.bytes && FB2(d2, PB2.Video_Recv_Bitrate, 8 * (c4.bytes - p2.bytes) / e4), null != p2.packets && null != c4.packets && FB2(d2, PB2.Video_Recv_Package_Rate, 1e3 * (c4.packets - p2.packets) / e4);
                }
                const _2 = o4 && o4.videoRecv.find((t5) => t5.ssrc === e3);
                if (_2 && (FB2(d2, NB2.Video_Recv_Qp_Sum, c4.qpSumPerFrame), d2[NB2.Video_Recv_Freeze] = n4 && XF.isRemoteVideoFreeze(i3, c4, _2) ? 1 : 0), s3) {
                  var E3;
                  const t5 = s3.videoRecv.find((t6) => t6.ssrc === e3);
                  l2 ? (FB2(d2, DB2.Video_Recv_Height, l2.height), FB2(d2, DB2.Video_Recv_Width, l2.width)) : i3 && (FB2(d2, DB2.Video_Recv_Height, i3._videoHeight || 0), FB2(d2, DB2.Video_Recv_Width, i3._videoWidth || 0)), u3 && FB2(d2, DB2.Video_Recv_Frame_Rate_Output, u3.frameRate);
                  const n5 = null === (E3 = i3._player) || void 0 === E3 ? void 0 : E3.rendFrameRate.toFixed(0);
                  if (n5 && FB2(d2, DB2.Video_Render_Frame_Rate_Render, +n5), FB2(d2, DB2.Video_Recv_Jitter_Buffer, c4.jitterBufferMs), FB2(d2, DB2.Video_Recv_Current_Delay, c4.currentDelayMs), FB2(d2, DB2.Video_Recv_Firs, c4.firsCount), FB2(d2, DB2.Video_Recv_Nacks, c4.nacksCount), FB2(d2, DB2.Video_Recv_Plis, c4.plisCount), i3) {
                    d2[DB2.Video_Recv_Disabled] = i3._originMediaStreamTrack.enabled && i3._mediaStreamTrack.enabled ? 0 : 1;
                    const e4 = i3._player;
                    if (e4) {
                      const { freezeTimeCounterList: i4, renderFreezeAccTime: n6, renderFreezeAccTime2: o5, videoElementStatus: s4 } = e4;
                      if (i4 && i4.length > 0 && FB2(d2, NB2.Video_Render_Freeze_Time, i4.splice(0, 1)[0]), r5 && "visible" === Qk2.visibility && s4 === iP.PLAYING && fD2().supportRequestVideoFrameCallback) {
                        const t6 = Math.min(6e3, o5);
                        e4.renderFreezeAccTime2 = Math.max(0, o5 - t6), FB2(d2, NB2.Video_Render_Freeze_Time_Render2, t6);
                        const i5 = Math.min(6e3, n6);
                        e4.renderFreezeAccTime = Math.max(0, n6 - i5), FB2(d2, NB2.Video_Render_Freeze_Time_Render, wN("USE_NEW_RENDER_FREEZE_TIME") ? t6 : i5);
                      }
                      if ("number" == typeof c4.totalFreezesDuration) {
                        const e5 = t5 && t5.totalFreezesDuration ? c4.totalFreezesDuration - t5.totalFreezesDuration : c4.totalFreezesDuration;
                        FB2(d2, DB2.Video_Render_Freeze_Duration, 1e3 * e5);
                      }
                    }
                  }
                  if (d2[DB2.Video_Recv_Player_Status] = rP[i3._player ? i3._player.videoElementStatus : "uninit"], t5 && void 0 !== c4.totalInterFrameDelay && void 0 !== c4.totalSquaredInterFrameDelay && void 0 !== t5.totalInterFrameDelay && void 0 !== t5.totalSquaredInterFrameDelay) {
                    const e4 = c4.totalInterFrameDelay - t5.totalInterFrameDelay, i4 = c4.totalSquaredInterFrameDelay - t5.totalSquaredInterFrameDelay, n6 = c4.framesDecodeCount - t5.framesDecodeCount, r6 = e4 / n6 * 1e3, o5 = Math.round(1e3 * Math.sqrt((i4 - Math.pow(e4, 2) / n6) / n6));
                    !isNaN(o5) && r6 + o5 > Math.max(3 * r6, r6 + 150) && (d2[DB2.Video_Recv_I_Frame_Delay] = o5);
                  }
                }
                return d2;
              }(s2._videoSSRC, e2, s2.videoTrack, true === r4, this.needUploadRenderFreezeTime, t3, i2, n3) : void 0;
              o3 && (c3.video = o3);
            }
            if (a3.has(EV.AUDIO) && s2.audioTrack) {
              const r4 = s2.audioTrack ? function(e3, t4, i3, n4, r5, o3) {
                const s3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
                if (!s3) return;
                const a4 = {};
                FB2(a4, PB2.Audio_Recv_Jitter, s3.jitterMs), FB2(a4, PB2.Audio_Recv_Bytes_Retransmit, s3.retransmittedBytesReceived), FB2(a4, PB2.Audio_Recv_Packages_Retransmit, s3.retransmittedPacketsReceived), FB2(a4, PB2.Audio_Recv_Packages_Discarded, s3.packetsDiscarded), FB2(a4, PB2.Audio_Recv_Avg_Processing_Delay, s3.avgProcessingDelayMs);
                const c4 = o3 && o3.audioRecv.find((t5) => t5.ssrc === e3);
                if (c4) {
                  const e4 = MB2;
                  null != s3.packets && null != c4.packets && FB2(a4, PB2.Audio_Recv_Package_Rate, 1e3 * (s3.packets - c4.packets) / e4), null != s3.packetsLost && null != c4.packetsLost && FB2(a4, PB2.Audio_Recv_Package_Lost, s3.packetsLost - c4.packetsLost);
                }
                if (n4) {
                  const { receivedFrames: e4, droppedFrames: t5 } = s3;
                  null != e4 && null != t5 && (a4[NB2.Audio_Recv_Freeze] = 0 === (d2 = e4) || 100 * t5 / d2 > 20 ? 1 : 0);
                }
                var d2;
                if (r5) {
                  const t5 = 100 * i3._source.getAccurateVolumeLevel(), n5 = s3.outputLevel;
                  if (null != n5) {
                    const e4 = Math.ceil(50 * Math.log10(100 * n5 + 1));
                    FB2(a4, DB2.Audio_Render_Level, e4);
                  }
                  FB2(a4, DB2.Audio_Recv_PCM_Level, t5), i3 && (a4[DB2.Audio_Recv_Disabled] = i3._originMediaStreamTrack.enabled && i3._mediaStreamTrack.enabled ? 0 : 1), FB2(a4, DB2.Audio_Recv_Jitter_Buffer, s3.jitterBufferMs), FB2(a4, DB2.Audio_Recv_Current_Delay, s3.jitterBufferMs), a4[DB2.Audio_Recv_Player_Status] = rP[xP.getPlayerState(i3.getTrackId())];
                  const o4 = r5.audioRecv.find((t6) => t6.ssrc === e3);
                  if (o4) {
                    null != o4.bytes && null != s3.bytes && FB2(a4, DB2.Audio_Recv_Bitrate, 8 * (s3.bytes - o4.bytes) / (MB2 * VB2));
                    const e4 = s3.concealedSamples - o4.concealedSamples;
                    e4 > 0 && FB2(a4, DB2.Audio_Recv_Concealed_Samples, e4);
                    const t6 = s3.totalSamplesReceived - o4.totalSamplesReceived;
                    t6 > 0 && FB2(a4, DB2.Audio_Recv_Total_Samples_Received, t6);
                    const i4 = s3.freezeSamples80 - o4.freezeSamples80;
                    i4 > 0 && FB2(a4, DB2.Audio_Render_Freeze_Samples_80ms, i4);
                    const n6 = s3.freezeSamples200 - o4.freezeSamples200;
                    n6 > 0 && FB2(a4, DB2.Audio_Render_Freeze_Samples_200ms, n6);
                    const r6 = s3.freezeMs80 - o4.freezeMs80;
                    FB2(a4, DB2.Audio_Render_Freeze_Time_80ms, r6 < 0 ? 0 : r6);
                    const c5 = s3.freezeMs200 - o4.freezeMs200;
                    FB2(a4, DB2.Audio_Render_Freeze_Time_200ms, c5 < 0 ? 0 : c5);
                  }
                }
                return a4;
              }(s2._audioSSRC, e2, s2.audioTrack, t3, i2, n3) : void 0;
              r4 && (c3.audio = r4);
            }
            (c3.video || c3.audio) && o2.push(c3);
          }), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, o2;
        }
        startUploadTransportStats() {
          this.uploadTransportStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted = false;
        }
        startUploadOutboundStats() {
          this.uploadOutboundStarted || (this.uploadOutboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {
            if (!this.requestAllTracks || !this.requestUpload) return;
            const e2 = (this.requestAllTracks() || []).find((e3) => e3 instanceof jL);
            if (e2 && e2._external.getDenoiserStats) {
              const t3 = e2._external.getDenoiserStats();
              t3 && this.requestUpload(xU.DENOISER_STATS, t3);
            }
          }, 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval(() => {
            if (!this.requestAllTracks || !this.requestUpload) return;
            this.requestAllTracks().forEach((e2) => {
              e2.getProcessorStats().forEach((e3) => {
                this.requestUpload && this.requestUpload(e3.type, e3.stats);
              });
            });
          }, 2e3));
        }
        stopUploadOutboundStats() {
          this.uploadOutboundStarted && (this.uploadOutboundStarted = false, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRefSendStats && (this.lastRefSendStats.videoSend = [], this.lastRefSendStats.audioSend = [], this.lastRefSendStats = void 0), this.lastNormalSendStats && (this.lastNormalSendStats.videoSend = [], this.lastNormalSendStats.audioSend = [], this.lastNormalSendStats = void 0), this.lastExtendStats = {}, this.needUploadStats = {}, this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0, this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = void 0);
        }
        startUploadInboundStats() {
          this.uploadInboundStarted || (this.uploadInboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval(() => {
            if (!this.requestUpload || !this.requestRemoteMedia) return;
            (this.requestRemoteMedia() || []).forEach((e2) => {
              let [t3, i2] = e2;
              if (i2.has(EV.VIDEO) && t3.videoTrack) {
                t3.videoTrack.getProcessorStats().forEach((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                });
              }
              if (i2.has(EV.AUDIO) && t3.audioTrack) {
                t3.audioTrack.getProcessorStats().forEach((e3) => {
                  this.requestUpload && this.requestUpload(e3.type, e3.stats);
                });
              }
            });
          }, 2e3));
        }
        stopUploadInboundStats() {
          this.uploadInboundStarted && (this.uploadInboundStarted = false, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0), this.lastRefRecvStats && (this.lastRefRecvStats.videoRecv = [], this.lastRefRecvStats.audioRecv = [], this.lastRefRecvStats = void 0), this.lastNormalRecvStats && (this.lastNormalRecvStats.videoRecv = [], this.lastNormalRecvStats.audioRecv = [], this.lastNormalRecvStats = void 0), this.lastUploadCompensateTime = -1, this.uploadCompensateDeltaTime = 0, this.needUploadRenderFreezeTime = true, this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = void 0);
        }
        startUploadExtensionUsageStats() {
          if (this.uploadExtensionUsageStarted) return;
          this.uploadExtensionUsageStarted = true, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);
          const e2 = /* @__PURE__ */ new Map();
          this.uploadExtUsageStatsTimer = window.setInterval(async () => {
            const t3 = Date.now(), i2 = { connectionInterval: wN("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: t3 };
            let n3 = [];
            const r2 = this.requestAllTracks && this.requestAllTracks() || [];
            for (const e3 of r2) !e3.muted && e3.enabled && (n3 = n3.concat(await e3.getProcessorUsage()));
            const o2 = this.requestRemoteMedia && this.requestRemoteMedia() || [];
            for (const [e3, t4] of o2) t4.has(EV.VIDEO) && e3.videoTrack && (n3 = n3.concat(await e3.videoTrack.getProcessorUsage())), t4.has(EV.AUDIO) && e3.audioTrack && (n3 = n3.concat(await e3.audioTrack.getProcessorUsage()));
            if (0 === n3.length) return;
            i2.details = function(e3, t4) {
              const i3 = {};
              for (const { id: s3, value: a4, level: c3, direction: d2 } of e3) {
                var n4;
                const e4 = null !== (n4 = t4.get(s3)) && void 0 !== n4 ? n4 : 0, l2 = 2 === a4 ? e4 + wN("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
                var r3, o3;
                t4.set(s3, l2), i3[s3] ? (2 === a4 && (i3[s3].value = a4), c3 > i3[s3].level && (i3[s3].level = c3), "remote" === d2 && (i3[s3].remoteUidCount += 1), i3[s3].totalTs = null !== (r3 = t4.get(s3)) && void 0 !== r3 ? r3 : 0) : i3[s3] = { value: a4, level: c3, remoteUidCount: "local" === d2 ? 0 : 1, totalTs: null !== (o3 = t4.get(s3)) && void 0 !== o3 ? o3 : 0 };
              }
              return Object.keys(i3).map((e4) => {
                const { level: t5, value: n5, totalTs: r4 } = i3[e4];
                return { id: e4, level: t5, value: n5, totalTs: r4 };
              });
            }(n3, e2);
            const s2 = Date.now(), a3 = s2 > t3 ? s2 : t3 + 1;
            this.requestUpload && this.requestUpload(xU.EXTENSION_USAGE_STATS, { usageStats: i2, sendTs: a3 });
          }, wN("EXTENSION_USAGE_UPLOAD_INTERVAL"));
        }
        stopUploadExtensionUsageStats() {
          this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);
        }
        stopUploadBaseStats() {
          this.uploadBaseStatsStarted = false;
        }
      }
      const WB2 = wN("ICE_RESTART_INTERVAL");
      let HB2 = /* @__PURE__ */ new Map(), KB2 = /* @__PURE__ */ new Map(), YB2 = [mV.UDP_TCP_RELAY, mV.TCP_RELAY, mV.RELAY], zB2 = wN("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && fD2().supportPCSetConfiguration;
      function qB2(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i2 = HB2.get(e2.id);
        i2 && (window.clearTimeout(i2), HB2.delete(e2.id));
        const n3 = KB2.get(e2.id);
        t3 && n3 && n3.index === YB2.length - 1 && (sD.debug("[".concat(e2.id, "] reset ICE restart policy")), KB2.delete(e2.id));
      }
      function XB2(e2, t3, i2) {
        if (0 === HB2.size && 0 === KB2.size && (Array.isArray(wN("RESTART_SEQUENCE")) && wN("RESTART_SEQUENCE").length > 0 && !function(e3, t4) {
          if (e3.length !== t4.length) return false;
          for (let i3 = 0; i3 < e3.length; i3 += 1) {
            const n4 = e3[i3];
            if (e3.filter((e4) => e4 === n4).length !== t4.filter((e4) => e4 === n4).length) return false;
          }
          return true;
        }(YB2, wN("RESTART_SEQUENCE")) && (YB2 = wN("RESTART_SEQUENCE").filter((e3) => {
          var t4;
          if (Ln2(t4 = Object.values(mV)).call(t4, e3)) return true;
        }), sD.debug("use reconnection policy from config distribution, queues: ".concat(YB2.join(" => ")))), zB2 = wN("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && fD2().supportPCSetConfiguration), 0 === YB2.length) return void i2();
        let n3, { index: r2 = 0, type: o2 } = KB2.get(e2.id) || {};
        if (zB2 && o2 === mV.RELAY) return void i2();
        let s2 = o2 && r2 >= YB2.length - 1;
        if (zB2) o2 = mV.RELAY;
        else {
          if (s2) return void i2();
          o2 ? (r2++, o2 = YB2[r2]) : (o2 = YB2[0], r2 = 0);
        }
        sD.debug("[".concat(e2.id, "] choose ICE restart policy: ").concat(o2, ", index: ").concat(r2)), t3(o2), KB2.set(e2.id, { index: r2, type: o2 }), n3 = window.setTimeout(() => XB2(e2, t3, i2), WB2), HB2.set(e2.id, n3);
      }
      var JB2;
      function ZB2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function QB2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? ZB2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : ZB2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      function $B2(e2) {
        var t3, i2, n3, r2 = 2;
        for ("undefined" != typeof Symbol && (i2 = Qb2, n3 = Symbol.iterator); r2--; ) {
          if (i2 && null != (t3 = e2[i2])) return t3.call(e2);
          if (n3 && null != (t3 = e2[n3])) return new ej2(t3.call(e2));
          i2 = "@@asyncIterator", n3 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function ej2(e2) {
        function t3(e3) {
          if (Object(e3) !== e3) return ip2.reject(new TypeError(e3 + " is not an object."));
          var t4 = e3.done;
          return ip2.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t4 };
          });
        }
        return ej2 = function(e3) {
          this.s = e3, this.n = e3.next;
        }, ej2.prototype = { s: null, n: null, next: function() {
          return t3(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? ip2.resolve({ value: e3, done: true }) : t3(i2.apply(this.s, arguments));
        }, throw: function(e3) {
          var i2 = this.s.return;
          return void 0 === i2 ? ip2.reject(e3) : t3(i2.apply(this.s, arguments));
        } }, new ej2(e2);
      }
      let tj2 = (JB2 = class extends Hw2 {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t3 = this._state;
          this._state = e2, this.emit(RV.StateChange, t3, this._state);
        }
        constructor(e2, t3) {
          super(), uI(this, "isPlanB", void 0), uI(this, "store", void 0), uI(this, "statsUploader", void 0), uI(this, "connection", void 0), uI(this, "localTrackMap", /* @__PURE__ */ new Map()), uI(this, "remoteUserMap", /* @__PURE__ */ new Map()), uI(this, "localDataChannels", []), uI(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), uI(this, "pendingLocalTracks", []), uI(this, "pendingRemoteTracks", []), uI(this, "pendingLocalDataChannels", []), uI(this, "pendingRemoteDataChannels", []), uI(this, "statsCollector", void 0), uI(this, "shouldForwardP2PCreation", void 0), uI(this, "iceFailedCount", 0), uI(this, "dtlsFailedCount", 0), uI(this, "mutex", void 0), uI(this, "_state", TV.Disconnected), uI(this, "_pcStatsUploadType", wN("NEW_ICE_RESTART") ? fV.FIRST_CONNECTION : fV.OLD_FIRST_CONNECTION), uI(this, "_isStartRestartIce", false), uI(this, "_restartTimer", void 0), uI(this, "_isTryConnecting", false), uI(this, "_iceError", null), uI(this, "_forceTurn", false), uI(this, "_isWaitPcToRePub", false), uI(this, "handleMuteLocalTrack", async (e3, t4, i2) => {
            const n3 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection || this.state !== TV.Connected) return void i2(new Ow2(ww2.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              const r2 = this.filterTobeMutedTracks(e3);
              if (0 === r2.length) return void t4();
              const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (o2) {
                const e4 = o2[1];
                this.store.enableInstantMuteRestore ? (e4.track._originMediaStreamTrack.enabled = false, sD.info("[".concat(this.store.clientId, "] P2PChannel muteLocalLowTrack without close sender because enableInstantMuteRestore is true"))) : e4.track._originMediaStreamTrack.stop();
              }
              this.store.enableInstantMuteRestore ? sD.info("[".concat(this.store.clientId, "] P2PChannel muteLocalTrack without close sender because enableInstantMuteRestore is true")) : await this.connection.muteLocal(r2.map((e4) => {
                let [, { id: t5 }] = e4;
                return t5;
              }));
              const s2 = this.createMuteMessage(r2);
              await sO(this, RV.RequestMuteLocal, s2), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              n3();
            }
          }), uI(this, "handleUnmuteLocalTrack", async (e3, t4, i2) => {
            const n3 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection || this.state !== TV.Connected) return void i2(new Ow2(ww2.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length) return void t4();
              const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
              if (o2) {
                const t5 = o2[1];
                if (this.store.enableInstantMuteRestore) t5.track._originMediaStreamTrack.enabled = true, sD.info("[".concat(this.store.clientId, "] P2PChannel unmuteLocalLowTrack without close sender because enableInstantMuteRestore is true"));
                else {
                  if (t5.track._originMediaStreamTrack.stop(), !wN("DISABLE_DUAL_STREAM_USE_ENCODING") && fD2().supportDualStreamEncoding) {
                    const i3 = e3._mediaStreamTrack.clone();
                    t5.track._mediaStreamTrack = i3, t5.track._originMediaStreamTrack = i3;
                  } else {
                    const i3 = wB2(e3, cO(this, RV.RequestLowStreamParameter));
                    t5.track._mediaStreamTrack = i3, t5.track._originMediaStreamTrack = i3;
                  }
                  await new ip2((e4, i3) => {
                    this.handleReplaceTrack(t5.track, e4, i3, true);
                  });
                }
              }
              this.store.enableInstantMuteRestore ? sD.info("[".concat(this.store.clientId, "] P2PChannel unmuteLocalTrack without close sender because enableInstantMuteRestore is true")) : await this.connection.unmuteLocal(r2.map((e4) => {
                let [, { id: t5 }] = e4;
                return t5;
              }));
              const s2 = this.createUnmuteMessage(r2);
              await sO(this, RV.RequestUnmuteLocal, s2), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              n3();
            }
          }), uI(this, "handleUpdateVideoEncoder", async (e3, t4, i2, n3) => {
            let r2;
            n3 || (r2 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoEncoder"));
            try {
              const i3 = this.localTrackMap.get(gV.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== TV.Connected) return void t4();
              const { id: n4, track: s2 } = i3;
              await this.connection.updateSendParameters(n4, s2), await this.connection.updateEncoderConfig(n4, s2), this.emit(RV.UpdateVideoEncoder, s2), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          }), uI(this, "handleUpdateVideoSendParameters", async (e3, t4, i2) => {
            const n3 = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoSendParameters");
            try {
              const i3 = this.localTrackMap.get(gV.LocalVideoTrack);
              if (!this.connection || !i3 || i3.track !== e3 || this.state !== TV.Connected) return void t4();
              const { id: r2, track: o2 } = i3;
              await this.connection.updateSendParameters(r2, o2), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              n3();
            }
          }), uI(this, "handleReplaceMixingTrack", async (e3, t4, i2, n3) => {
            if (!this.connection || this.state !== TV.Connected) return void t4();
            const r2 = SB2([e3]);
            let o2;
            sD.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(r2.getTrackId(), "]")), "boolean" == typeof n3 && n3 || (o2 = await this.mutex.lock("From P2PChannel.handleReplaceMixingTrack"));
            try {
              await this.replaceTrack(e3, r2), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = o2) || void 0 === s2 || s2();
            }
          }), uI(this, "handleReplaceTrack", async (e3, t4, i2, n3) => {
            let r2;
            sD.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n3 && n3 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              var o2;
              const i3 = Array.from(this.localTrackMap.entries()).find((t5) => {
                let [, { track: i4 }] = t5;
                return e3 === i4;
              });
              if (!this.connection || !i3 || this.state !== TV.Connected) return void t4();
              if (await (null === (o2 = this.connection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i3[1].id)), this.isPlanB) {
                const t5 = i3[1];
                t5.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i3[0], t5);
              }
              if (i3[0] === gV.LocalVideoTrack && !wN("DISABLE_DUAL_STREAM_USE_ENCODING") && fD2().supportDualStreamEncoding) {
                const t5 = this.localTrackMap.get(gV.LocalVideoLowTrack);
                if (t5) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t5.track._originMediaStreamTrack.stop(), t5.track._mediaStreamTrack = i4, t5.track._originMediaStreamTrack = i4, await new ip2((e4, i5) => {
                    this.handleReplaceTrack(t5.track, e4, i5, true);
                  });
                }
              }
              t4();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          }), uI(this, "handleGetRTCStats", (e3) => {
            e3(this.statsCollector.getRTCStats());
          }), uI(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), uI(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), uI(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), uI(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t3, this.statsCollector.addP2PChannel(this), this.statsUploader = new GB2(this.store), this.bindStatsUploaderEvents(), this.mutex = new xO("P2PChannel-mutex", this.store.clientId), this.isPlanB = !fD2().supportUnifiedPlan || wN("CHROME_FORCE_PLAN_B") && vw2(), this.shouldForwardP2PCreation = wN("FORWARD_P2P_CREATION") && fD2().supportPCSetConfiguration && Rw2(), this.shouldForwardP2PCreation && (this.connection = TB2(this.store), this.emit(RV.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection));
        }
        async startP2PConnection(e2, t3) {
          var i2;
          this.state = TV.New, this._forceTurn = vB2(e2), sD.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] forceTurn: ").concat(this._forceTurn));
          const n3 = this.shouldForwardP2PCreation && "closed" === (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.peerConnectionState);
          if ((!this.shouldForwardP2PCreation || n3 || t3) && ((n3 || t3) && this.connection && (sD.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.resetConnection(this.connection)), this.connection = TB2(this.store, e2), this.emit(RV.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), !this.connection) throw new Ow2(ww2.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
          return this._pcStatsUploadType = wN("NEW_ICE_RESTART") ? fV.FIRST_CONNECTION : fV.OLD_FIRST_CONNECTION, this._isTryConnecting = true, this._isStartRestartIce = false, this._iceError = null, this.connection.setConfiguration(e2), this.connection.establishPromise;
        }
        async connect(e2) {
          if (!this.connection) throw new Ow2(ww2.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          if (this.isPreallocation() && this.state === TV.Connected) {
            if (this.connection instanceof bB2) {
              if (this.connection.checkDtlsParameters(e2.dtlsParameters.fingerprints)) {
                sD.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] dtls parameters mismatch, try next."));
                return _D.reportApiInvoke(this.store.sessionId, { name: zw2.MISMATCH_DTLS_PARAMETERS, options: [e2.dtlsParameters.fingerprints], tag: qw2.TRACER }).onSuccess(), void setTimeout(() => {
                  this.emit(RV.RequestReconnect);
                });
              }
            }
            await this.connection.updateRemoteConnect(e2);
          } else this.store.peerConnectionStart(), await this.connection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = TV.Connected;
        }
        updateRemoteRTPCapabilities(e2) {
          const t3 = Array.from(this.localTrackMap.entries()).filter((e3) => {
            var t4;
            let [i3] = e3;
            return Ln2(t4 = [gV.LocalVideoLowTrack, gV.LocalVideoTrack]).call(t4, i3);
          }), i2 = t3.map((e3) => {
            let [, { id: t4 }] = e3;
            return t4;
          }), n3 = t3.map((e3) => {
            let [t4] = e3;
            return t4;
          });
          if (this.connection instanceof bB2) {
            if (_D.updateRemoteRTPCapabilities(this.store.sessionId, { trackTypes: JSON.stringify(n3), localCodecs: JSON.stringify(this.connection.localCodecs), remoteCodecs: JSON.stringify(e2) }), !Ln2(e2).call(e2, this.store.codec)) {
              const t4 = ["vp9", "vp8", "h264"].find((t5) => Ln2(e2).call(e2, t5));
              t4 && (this.store.codec = t4, sD.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t4, ".")));
            }
            this.connection.updateRemoteRTPCapabilities(i2, e2);
          }
        }
        async getEstablishParams() {
          var e2;
          if (this.connection instanceof bB2 && "closed" !== this.connection.peerConnectionState && Ln2(e2 = [TV.New, TV.Connected]).call(e2, this.state)) return this.connection.establishPromise;
        }
        async publishDataChannel(e2) {
          if (!this.connection || this.state !== TV.Connected) {
            if (this.state === TV.Disconnected) throw new Ow2(ww2.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
            return e2.forEach((e3) => {
              var t4;
              Ln2(t4 = this.pendingLocalDataChannels).call(t4, e3) || this.pendingLocalDataChannels.push(e3);
            }), [];
          }
          const t3 = this.filterTobePublishedDataChannels(e2);
          return 0 === t3.length ? [] : (t3.forEach((e3) => {
            const t4 = Date.now();
            this.store.publish(e3.id.toString(), "datachannel", t4);
          }), await this.connection.createDataChannels(this.store.uid, t3), t3.forEach((e3) => {
            this.localDataChannels.push(e3);
            const t4 = Date.now();
            this.store.publish(e3.id + "", "datachannel", void 0, t4);
          }), e2.map((e3) => ({ streamId: e3.id, ordered: e3.ordered, maxRetransmits: e3.maxRetransmits, metadata: e3.metadata, channelId: e3._originDataChannelId })));
        }
        publish(e2, t3, i2) {
          var n3 = this;
          return qb2(function* () {
            const r2 = yield Jb2(n3.mutex.lock("From P2PChannel.publish"));
            try {
              var o2;
              const s2 = n3.connection && Ln2(o2 = ["disconnected", "failed"]).call(o2, n3.connection.peerConnectionState);
              if (!n3.connection || n3.state !== TV.Connected || s2) {
                if (n3.state === TV.Disconnected) throw new Ow2(ww2.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                n3.throwIfTrackTypeNotMatch(e2);
                const t4 = e2.filter((e3) => -1 === n3.pendingLocalTracks.indexOf(e3));
                return n3.pendingLocalTracks = n3.pendingLocalTracks.concat(t4), void (s2 && (n3._isWaitPcToRePub = true));
              }
              n3.store.pubId = n3.store.pubId + 1, YF.markPublishStart(n3.store.clientId, n3.store.pubId);
              const a3 = n3.filterTobePublishedTracks(e2, t3, i2);
              if (0 === a3.length) return void (yield Jb2(n3.tryToUnmuteAudio(e2)));
              yield* Zb2($B2(n3.doPublish(n3.connection, a3)));
            } finally {
              r2();
            }
          })();
        }
        doPublish(e2, t3) {
          var i2 = this;
          return qb2(function* () {
            t3.forEach((e3) => {
              let { track: t4, type: n4 } = e3;
              const r3 = Date.now();
              i2.store.publish(t4.getTrackId(), n4 === gV.LocalAudioTrack ? "audio" : "video", r3);
            }), i2.bindLocalTrackEvents(t3);
            const n3 = t3.map((e3) => {
              let { track: t4 } = e3;
              return t4;
            }), r2 = yield Jb2(e2.send(n3, i2.store.codec, i2.store.audioCodec)), o2 = (yield Jb2(r2.next())).value, s2 = i2.createGatewayPublishMessage(t3, o2);
            let a3;
            try {
              a3 = yield s2;
            } catch (e3) {
              throw r2.throw(e3), (null == e3 ? void 0 : e3.code) === ww2.WS_ABORT && t3.forEach((e4) => {
                let { track: t4 } = e4;
                -1 === i2.pendingLocalTracks.indexOf(t4) && i2.pendingLocalTracks.push(t4);
              }), i2.unbindLocalTrackEvents(t3), e3;
            }
            const c3 = i2.mapPubResToRemoteConfig(s2, a3, n3), d2 = (yield Jb2(r2.next(c3))).value;
            if (i2.state === TV.Disconnected) throw new Ow2(ww2.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
            wN("ENABLE_VIDEO_SEI");
            const l2 = wN("ENABLE_ENCODED_TRANSFORM"), u3 = wN("ENABLE_AUDIO_METADATA");
            n3.forEach(async (e3) => {
              const t4 = e3.getRTCRtpTransceiver();
              if (!t4 || !l2) return;
              const { interceptLocalVideoFrame: i3, interceptLocalAudioFrame: n4 } = Qx2();
              e3.trackMediaType === EV.VIDEO ? await i3(t4.sender, e3) : e3.trackMediaType === EV.AUDIO && await n4(t4.sender, { metadata: u3 ? () => {
                const t5 = e3.metadata.shift();
                return t5 && t5.value;
              } : void 0 });
            }), t3.forEach((e3) => {
              let { type: t4 } = e3;
              i2.statsCollector.addLocalStats(t4);
            }), i2.assignLocalTracks(t3, d2), i2.statsUploader.startUploadOutboundStats(), t3.forEach((e3) => {
              let { track: t4, type: n4 } = e3;
              const r3 = Date.now();
              i2.store.publish(t4.getTrackId(), n4 === gV.LocalAudioTrack ? "audio" : "video", void 0, r3);
            });
          })();
        }
        async updateVideoStreamParameter(e2, t3) {
          const i2 = this.localTrackMap.get(t3);
          if (!i2 || !this.connection) return;
          if (!(i2.track instanceof kk2)) return sD.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
          const { track: n3 } = i2, r2 = function(e3, t4) {
            const i3 = {};
            return e3.height && e3.width && (i3.scaleResolutionDownBy = lx2(e3, t4)), i3.maxFramerate = e3.framerate ? ox2(e3.framerate) : void 0, i3.maxBitrate = e3.bitrate ? 1e3 * e3.bitrate : void 0, i3;
          }(e2, n3);
          if (n3._encoderConfig || (n3._encoderConfig = {}), t3 !== gV.LocalVideoLowTrack || !wN("DISABLE_DUAL_STREAM_USE_ENCODING") && fD2().supportDualStreamEncoding) null != r2.scaleResolutionDownBy && (n3._encoderConfig.scaleResolutionDownBy = r2.scaleResolutionDownBy);
          else {
            const t4 = n3._originMediaStreamTrack;
            if (!t4.canvas) return sD.warn("[".concat(n3.getTrackId(), "] no canvas on track"));
            !function(e3, t5) {
              const i3 = e3.canvas;
              t5.width && (i3.width = ox2(t5.width)), t5.height && (i3.height = ox2(t5.height)), t5.framerate && (i3.stopCapture && i3.stopCapture(), i3.stopCapture = SP(() => {
                !i3.startCapture && i3.stopCapture && i3.stopCapture(), i3.startCapture && i3.startCapture();
              }, ox2(t5.framerate)));
            }(t4, e2);
          }
          null != r2.maxBitrate && (n3._encoderConfig.bitrateMax = r2.maxBitrate / 1e3), null != r2.maxFramerate && (n3._encoderConfig.frameRate && "object" == typeof n3._encoderConfig.frameRate ? n3._encoderConfig.frameRate.max = r2.maxFramerate : n3._encoderConfig.frameRate = { max: r2.maxFramerate }), sD.debug("[".concat(n3.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(n3._encoderConfig))), await this.connection.updateRtpSenderEncodings(n3);
        }
        publishLowStream(e2) {
          var t3 = this;
          return qb2(function* () {
            if (!t3.connection || t3.state !== TV.Connected) return;
            const i2 = yield Jb2(t3.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const r2 = t3.localTrackMap.get(gV.LocalVideoTrack);
              if (!r2) throw new Ow2(ww2.UNEXPECTED_ERROR, "Could not find high stream");
              if (t3.localTrackMap.has(gV.LocalVideoLowTrack)) throw new Ow2(ww2.UNEXPECTED_ERROR, "[".concat(t3.store.clientId, "] Can't publish low stream when stream already publish"));
              const o2 = [{ track: t3.getLowVideoTrack(r2.track, e2), type: gV.LocalVideoLowTrack }];
              if (yield* Zb2($B2(t3.doPublish(t3.connection, o2))), r2.track.muted || !r2.track.enabled) {
                var n3;
                const e3 = null === (n3 = t3.localTrackMap.get(gV.LocalVideoLowTrack)) || void 0 === n3 ? void 0 : n3.id;
                void 0 !== e3 && (yield Jb2(t3.connection.muteLocal([e3])));
              }
            } finally {
              i2();
            }
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (sD.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await oO(this, RV.RequestRePublish, this.pendingLocalTracks), this.emit(RV.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (sD.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await oO(this, RV.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []), this._isWaitPcToRePub = false;
        }
        async reSubscribe(e2) {
          for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
            const { user: t3, kind: i2 } = this.pendingRemoteTracks[e3];
            (i2 !== EV.AUDIO || t3._audio_added_ && t3._audioSSRC) && (i2 !== EV.VIDEO || t3._video_added_ && t3._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
          }
          if (e2) await oO(this, RV.RequestReSubscribe, this.pendingRemoteTracks);
          else for (const { user: e3, kind: t3 } of this.pendingRemoteTracks) await this.subscribe(e3, t3, t3 === EV.VIDEO ? e3._videoSSRC : e3._audioSSRC);
          this.pendingRemoteTracks.forEach((e3) => {
            let { user: t3 } = e3;
            this.emit(RV.MediaReconnectEnd, t3.uid);
          }), this.pendingRemoteTracks = [];
        }
        async unpublish(e2) {
          if (!this.connection || this.state !== TV.Connected) return void e2.forEach((e3) => {
            const t4 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t4 && this.pendingLocalTracks.splice(t4, 1);
          });
          const t3 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t3.length) return;
          const i2 = t3.find((e3) => "videoLowTrack" === e3[0]);
          if (i2) {
            i2[1].track.close();
          }
          return this.doUnpublish(this.connection, t3);
        }
        async unpublishDataChannel(e2) {
          if (!this.connection || this.state !== TV.Connected) return void e2.forEach((e3) => {
            const t4 = this.pendingLocalDataChannels.indexOf(e3);
            -1 !== t4 && this.pendingLocalDataChannels.splice(t4, 1);
          });
          const t3 = this.filterTobeUnpublishedDataChannels(e2);
          return 0 !== t3.length ? (t3.forEach((e3) => {
            const t4 = this.localDataChannels.indexOf(e3);
            -1 !== t4 && this.localDataChannels.splice(t4, 1);
          }), 0 === this.localDataChannels.length && await this.connection.stopDataChannels(this.store.uid), t3.map((e3) => e3.id)) : void 0;
        }
        async unpublishLowStream() {
          if (!this.connection || this.state !== TV.Connected) return;
          const e2 = this.localTrackMap.get(gV.LocalVideoLowTrack);
          if (!e2) return;
          e2.track.close();
          const t3 = [[gV.LocalVideoLowTrack, e2]];
          return this.doUnpublish(this.connection, t3);
        }
        async doUnpublish(e2, t3) {
          const i2 = this.createGatewayUnpublishMessage(t3);
          return await e2.stopSending(t3.map((e3) => {
            let [, { id: t4 }] = e3;
            return t4;
          })), this.withdrawLocalTracks(t3), this.unbindLocalTrackEvents(t3.map((e3) => {
            let [t4, { track: i3 }] = e3;
            return { type: t4, track: i3 };
          })), t3.forEach((e3) => {
            let [t4] = e3;
            this.statsCollector.removeLocalStats(t4);
          }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadOutboundStats(), i2;
        }
        async subscribeDataChannel(e2, t3) {
          if (!this.connection || this.state !== TV.Connected) throw new Ow2(ww2.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          const i2 = t3.filter((t4) => {
            var i3;
            return !(null !== (i3 = this.remoteDataChannelMap.get(e2)) && void 0 !== i3 && i3.get(t4.id));
          });
          if (0 !== i2.length) return await this.connection.createDataChannels(e2.uid, i2), i2.forEach((t4) => {
            var i3;
            this.remoteDataChannelMap.has(e2) ? null === (i3 = this.remoteDataChannelMap.get(e2)) || void 0 === i3 || i3.set(t4.id, t4) : this.remoteDataChannelMap.set(e2, /* @__PURE__ */ new Map([[t4.id, t4]]));
            const n3 = this.pendingRemoteDataChannels.findIndex((i4) => {
              let { user: n4, id: r2 } = i4;
              return n4.uid === e2.uid && r2 === t4.id;
            });
            -1 !== n3 && this.pendingRemoteDataChannels.splice(n3, 1);
          }), i2.map((e3) => e3.id);
        }
        async subscribe(e2, t3, i2, n3, r2) {
          var o2;
          if (!this.connection || this.state !== TV.Connected) throw new Ow2(ww2.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (null !== (o2 = this.remoteUserMap.get(e2)) && void 0 !== o2 && o2.has(t3)) return;
          let s2, a3, c3, d2;
          const l2 = this.connection.getPreMedia(i2);
          if (l2) sD.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] preSSRCMap has ssrcId: ").concat(i2, ", no need to send sub to gateway.")), c3 = l2.transceiver, s2 = l2.track, a3 = l2.mid, d2 = l2.player, l2.firstVideoRender && this.store.firstVideoFrameDecoded(e2.uid, { firstPreRender: l2.firstVideoRender });
          else if (r2) {
            const i3 = r2.find((e3) => {
              let { stream_type: i4 } = e3;
              return i4 === t3;
            });
            if (!i3) throw new Ow2(ww2.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t3, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t3, "."));
            const n4 = await this.connection.receive(t3, i3.ssrcs, String(e2._uintid), i3.attributes);
            this.connection instanceof bB2 && (c3 = n4.transceiver), s2 = n4.track, a3 = n4.id;
          } else {
            const r3 = await this.connection.receive(t3, [{ ssrcId: i2, rtx: n3 }], String(e2._uintid), void 0);
            this.connection instanceof bB2 && (c3 = r3.transceiver), s2 = r3.track, a3 = r3.id;
          }
          if (t3 === EV.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new Zk2(s2, e2.uid, e2._uintid, this.store), sD.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c3 && e2._audioTrack._updateRtpTransceiver(c3), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new Jk2(s2, e2.uid, e2._uintid, this.store, d2), sD.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId())), e2._videoTrack.once(HD.PLAY_START, () => {
            this.store.firstVideoFrameDecoded(e2.uid, { playStart: Date.now() });
          }), e2._videoTrack.once(HD.PLAY_END, () => {
            this.store.firstVideoFrameDecoded(e2.uid, { playEnd: Date.now() }), this.reportVideoFirstFrameRender(e2);
          }), d2 ? e2._videoTrack.once(HD.FIRST_FRAME_RENDER, () => {
            this.store.firstVideoFrameDecoded(e2.uid, { firstRender: Date.now() }), this.reportVideoFirstFrameRender(e2);
          }) : e2._videoTrack.once(HD.FIRST_FRAME_DECODED, () => {
            this.store.firstVideoFrameDecoded(e2.uid, { firstRender: Date.now() }), this.reportVideoFirstFrameRender(e2);
          })), c3 && e2._videoTrack._updateRtpTransceiver(c3), this.bindRemoteTrackEvents(e2, e2._videoTrack)), c3 && wN("ENABLE_ENCODED_TRANSFORM")) {
            const { interceptRemoteVideoFrame: i3, interceptRemoteAudioFrame: n4 } = Qx2();
            t3 == EV.VIDEO ? await i3(c3.receiver, { onSei: wN("ENABLE_VIDEO_SEI") && ((t4) => {
              var i4;
              return null === (i4 = e2._videoTrack) || void 0 === i4 ? void 0 : i4._onSei(t4);
            }) }) : t3 == EV.AUDIO && await n4(c3.receiver, { enableTopn: !!wN("ENABLE_AUDIO_TOPN"), enableMetadata: !!wN("ENABLE_AUDIO_METADATA"), enablePts: !!wN("ENABLE_AUDIO_PTS"), onMetadata: (e3) => {
              this.safeEmit(RV.AudioMetadata, e3);
            }, onPts: (e3) => {
              this.safeEmit(RV.AudioPts, e3);
            } });
          }
          const u3 = this.remoteUserMap.get(e2);
          u3 ? u3.set(t3, a3) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t3, a3]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats();
          const h2 = this.pendingRemoteTracks.findIndex((i3) => {
            let { user: n4, kind: r3 } = i3;
            return n4.uid === e2.uid && t3 === r3;
          });
          -1 !== h2 && (this.pendingRemoteTracks.splice(h2, 1), this.emit(RV.MediaReconnectEnd, e2.uid));
        }
        async massSubscribe(e2) {
          return this.massSubscribeNoLock(e2);
        }
        async massSubscribeNoLock(e2) {
          if (!this.connection || this.state !== TV.Connected) throw new Ow2(ww2.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          e2 = e2.filter((e3) => {
            var t4;
            let { user: i3, mediaType: n4 } = e3;
            return !(null !== (t4 = this.remoteUserMap.get(i3)) && void 0 !== t4 && t4.has(n4));
          });
          const t3 = [], i2 = /* @__PURE__ */ new Map();
          e2.forEach((e3) => {
            if (!this.connection) return;
            const n4 = this.connection.getPreMedia(e3.ssrcId);
            if (n4) {
              const { track: t4, mid: r2, transceiver: o2, player: s2 } = n4;
              i2.set(e3.ssrcId, { track: t4, id: r2, transceiver: o2, player: s2 });
            } else t3.push(e3);
          });
          const n3 = await this.connection.batchReceive(t3.map((e3) => {
            let { user: t4, mediaType: i3, ssrcId: n4, rtxSsrcId: r2 } = e3;
            return { kind: i3, ssrcMsg: [{ ssrcId: n4, rtx: r2 }], mslabel: String(t4._uintid) };
          }));
          t3.forEach((e3, t4) => {
            i2.set(e3.ssrcId, n3[t4]);
          });
          for (const { user: t4, mediaType: n4, ssrcId: r2 } of e2) {
            const e3 = i2.get(r2);
            if (!e3) return void sD.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] cannot find ").concat(t4.uid, " subscribe data,").concat(n4, ", ").concat(r2));
            const { track: o2, id: s2, transceiver: a3, player: c3 } = e3;
            if (a3 && wN("ENABLE_ENCODED_TRANSFORM")) {
              const { interceptRemoteVideoFrame: e4, interceptRemoteAudioFrame: i3 } = Qx2();
              n4 == EV.VIDEO ? await e4(a3.receiver, { onSei: wN("ENABLE_VIDEO_SEI") && ((e5) => {
                var i4;
                return null === (i4 = t4._videoTrack) || void 0 === i4 ? void 0 : i4._onSei(e5);
              }) }) : n4 == EV.AUDIO && await i3(a3.receiver, { enableTopn: !!wN("ENABLE_AUDIO_TOPN"), enableMetadata: !!wN("ENABLE_AUDIO_METADATA"), enablePts: !!wN("ENABLE_AUDIO_PTS"), onMetadata: (e5) => {
                this.safeEmit(RV.AudioMetadata, e5);
              }, onPts: (e5) => {
                this.safeEmit(RV.AudioPts, e5);
              } });
            }
            if (n4 === EV.AUDIO ? (t4._audioTrack ? t4._audioTrack._updateOriginMediaStreamTrack(o2) : (t4._audioTrack = new Zk2(o2, t4.uid, t4._uintid, this.store), sD.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(t4._audioTrack.getTrackId()))), a3 && t4._audioTrack._updateRtpTransceiver(a3), this.bindRemoteTrackEvents(t4, t4._audioTrack)) : (t4._videoTrack ? t4._videoTrack._updateOriginMediaStreamTrack(o2) : (t4._videoTrack = new Jk2(o2, t4.uid, t4._uintid, this.store, c3), sD.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(t4._videoTrack.getTrackId()))), a3 && t4._videoTrack._updateRtpTransceiver(a3), this.bindRemoteTrackEvents(t4, t4._videoTrack)), wN("ENABLE_VIDEO_SEI") && a3) {
              const { interceptRemoteVideoFrame: e4, interceptRemoteAudioFrame: i3 } = Qx2();
              n4 == EV.VIDEO ? await e4(a3.receiver, { onSei: (e5) => {
                var i4;
                null === (i4 = t4._videoTrack) || void 0 === i4 || i4._onSei(e5);
              } }) : n4 == EV.AUDIO && await i3(a3.receiver);
            }
            const d2 = this.remoteUserMap.get(t4);
            d2 ? d2.set(n4, s2) : this.remoteUserMap.set(t4, /* @__PURE__ */ new Map([[n4, s2]])), this.statsCollector.addRemoteStats(t4.uid), this.statsUploader.startUploadInboundStats();
            const l2 = this.pendingRemoteTracks.findIndex((e4) => {
              let { user: i3, kind: r3 } = e4;
              return i3.uid === t4.uid && n4 === r3;
            });
            -1 !== l2 && (this.pendingRemoteTracks.splice(l2, 1), this.emit(RV.MediaReconnectEnd, t4.uid));
          }
        }
        async unsubscribe(e2, t3, i2) {
          const n3 = this.pendingRemoteTracks.filter((i3) => {
            let { user: n4, kind: r3 } = i3;
            return void 0 !== t3 ? n4.uid === e2.uid && t3 === r3 : n4.uid === e2.uid;
          });
          if (n3.forEach((e3) => {
            const t4 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t4, 1);
          }), this.connection && this.state === TV.Connected || i2 || n3.forEach((t4) => {
            let { kind: i3 } = t4;
            var n4;
            if (i3 === EV.AUDIO) null === (n4 = e2._audioTrack) || void 0 === n4 || n4._destroy(), e2._audioTrack = void 0;
            else if (i3 === EV.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.connection || this.state !== TV.Connected) return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t3);
          if (0 === r2.length) return;
          await this.connection.stopReceiving(r2.map((e3) => {
            let [, { id: t4 }] = e3;
            return t4;
          }));
          const o2 = this.createUnsubscribeMessage(r2);
          return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), r2.forEach((e3) => {
            let [t4, { kind: n4 }] = e3;
            var r3, o3;
            n4 === EV.VIDEO && t4._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t4._videoSSRC, false));
            if (n4 === EV.VIDEO) this.unbindRemoteTrackEvents(t4._videoTrack), i2 || (null === (o3 = t4._videoTrack) || void 0 === o3 || o3._destroy(), t4._videoTrack = void 0);
            else if (n4 === EV.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t4._audioTrack), !i2) null === (s2 = t4._audioTrack) || void 0 === s2 || s2._destroy(), t4._audioTrack = void 0;
            }
          }), o2;
        }
        async unsubscribeDataChannel(e2, t3) {
          if (t3.forEach((e3) => {
            const t4 = this.pendingRemoteDataChannels.findIndex((t5) => t5.id === e3.id);
            -1 !== t4 && this.pendingRemoteDataChannels.splice(t4, 1);
          }), !this.connection) return;
          const i2 = this.filterTobeUnSubscribedDataChannels(e2, t3);
          if (0 === i2.length) return;
          t3.forEach((e3) => {
            e3._close();
          });
          const n3 = this.remoteDataChannelMap.get(e2);
          return i2.forEach((e3) => {
            n3 && n3.delete(e3.id);
          }), n3 && 0 === n3.size && (this.remoteDataChannelMap.delete(e2), await this.connection.stopDataChannels(e2.uid)), i2.map((e3) => e3.id);
        }
        async massUnsubscribe(e2) {
          return this.massUnsubscribeNoLock(e2);
        }
        async massUnsubscribeNoLock(e2) {
          let t3 = [];
          for (const { user: i3, mediaType: n4 } of e2) {
            const e3 = this.pendingRemoteTracks.filter((e4) => {
              let { user: t4, kind: r2 } = e4;
              return void 0 !== n4 ? t4.uid === i3.uid && n4 === r2 : t4.uid === i3.uid;
            });
            e3.forEach((e4) => {
              const t4 = this.pendingRemoteTracks.indexOf(e4);
              this.pendingRemoteTracks.splice(t4, 1);
            }), t3 = t3.concat(e3);
          }
          if (!this.connection || this.state !== TV.Connected) return void t3.forEach((e3) => {
            let { user: t4, kind: i3 } = e3;
            var n4;
            if (i3 === EV.AUDIO) null === (n4 = t4._audioTrack) || void 0 === n4 || n4._destroy(), t4._audioTrack = void 0;
            else if (i3 === EV.VIDEO) {
              var r2;
              null === (r2 = t4._videoTrack) || void 0 === r2 || r2._destroy(), t4._videoTrack = void 0;
            }
          });
          const i2 = nr2(e2).call(e2, (e3, t4) => {
            let { user: i3, mediaType: n4 } = t4;
            const r2 = this.filterTobeUnSubscribedTracks(i3, n4);
            return e3.concat(r2);
          }, []);
          if (0 === i2.length) return;
          await this.connection.stopReceiving(i2.map((e3) => {
            let [, { id: t4 }] = e3;
            return t4;
          }));
          const n3 = this.createUnsubscribeAllMessage(i2);
          return this.withdrawRemoteTracks(i2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadInboundStats(), i2.forEach((e3) => {
            let [t4, { kind: i3 }] = e3;
            var n4, r2;
            i3 === EV.VIDEO && t4._videoSSRC && (null === (n4 = this.connection) || void 0 === n4 || n4.setStatsRemoteVideoIsReady(t4._videoSSRC, false));
            if (i3 === EV.VIDEO) this.unbindRemoteTrackEvents(t4._videoTrack), null === (r2 = t4._videoTrack) || void 0 === r2 || r2._destroy(), t4._videoTrack = void 0;
            else if (i3 === EV.AUDIO) {
              var o2;
              this.unbindRemoteTrackEvents(t4._audioTrack), null === (o2 = t4._audioTrack) || void 0 === o2 || o2._destroy(), t4._audioTrack = void 0;
            }
          }), n3;
        }
        isPreSubScribe(e2) {
          if (!this.connection || this.state !== TV.Connected) return false;
          return !!this.connection.getPreMedia(e2);
        }
        async muteRemote(e2, t3) {
          if (!this.connection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void sD.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t3)) return void sD.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t3, "."));
          const n3 = t3 === EV.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n3 && this.connection.setStatsRemoteVideoIsReady(n3, false);
        }
        async unmuteRemote(e2, t3) {
          return this.unmuteRemoteNoLock(e2, t3);
        }
        async unmuteRemoteNoLock(e2, t3) {
          if (!this.connection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void sD.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t3) || sD.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t3, "."));
        }
        addAudioMetadata(e2) {
          const t3 = this.localTrackMap.get(gV.LocalAudioTrack), i2 = t3 && t3.track;
          i2 && i2.metadata.push(e2);
        }
        getAllTracks(e2) {
          const t3 = this.localTrackMap.get(gV.LocalAudioTrack);
          if ((null == t3 ? void 0 : t3.track) instanceof WL) {
            const i2 = t3.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t4] = e3;
              return t4 !== gV.LocalAudioTrack;
            }).filter((t4) => {
              let [i3] = t4;
              return !(e2 && i3 === gV.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t4 }] = e3;
              return t4;
            }).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t4) => {
            let [i2] = t4;
            return !(e2 && i2 === gV.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t4 }] = e3;
            return t4;
          });
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        reportPublishEvent(e2, t3, i2, n3, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(gV.LocalAudioTrack), o3 = n3 ? this.localTrackMap.get(gV.LocalVideoLowTrack) : this.localTrackMap.get(gV.LocalVideoTrack);
            _D.publish(this.store.sessionId, { eventElapse: YF.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t3, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(xD.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i2 || (i2 = []);
            const s2 = i2.find((e3) => e3 instanceof BL), a3 = n3 ? null === (o2 = this.localTrackMap.get(gV.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find((e3) => e3 instanceof kk2);
            _D.publish(this.store.sessionId, { eventElapse: YF.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t3, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a3 ? void 0 : a3.getTrackLabel(), screenshare: -1 !== (null == a3 ? void 0 : a3._hints.indexOf(xD.SCREEN_TRACK)), audio: !!s2, video: !!a3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t3, i2, n3) {
          const r2 = n3 === EV.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && _D.subscribe(this.store.sessionId, { succ: e2, ec: t3, video: n3 === EV.VIDEO, audio: n3 === EV.AUDIO, peerid: i2.uid, subscribeRequestid: r2, p2pid: this.store.p2pId, eventElapse: YF.measureFromSubscribeStart(this.store.clientId, r2), preSsrc: this.isPreSubScribe(r2) });
        }
        reset() {
          sD.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new xO("P2PChannel-mutex", this.store.clientId), this.connection && (this.resetConnection(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = TB2(this.store), this.emit(RV.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.statsUploader.stopUploadBaseStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof WL) {
            if (e2.track.trackList.length > 0) {
              const t3 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t3.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = TV.Disconnected;
        }
        getStats() {
          var e2;
          return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t3;
          return (null === (t3 = this.connection) || void 0 === t3 ? void 0 : t3.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if (e2) return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(gV.LocalVideoTrack);
          if (e2) return { width: e2.track.videoWidth || 0, height: e2.track.videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t3 = this.localTrackMap.get(e2);
          return t3 && t3.track instanceof kk2 || t3 && t3.track instanceof BL ? t3.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t3) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t3 || i2.has(t3));
        }
        async hasRemoteMediaWithLock(e2, t3) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t3 || i2.has(t3));
        }
        getRemoteMedia(e2) {
          var t3;
          const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4.uid === e2);
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t4] = e3;
            return { uid: t4.uid, level: t4.audioTrack ? 100 * t4.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t3 = this.localTrackMap.get(gV.LocalAudioTrack);
          return t3 && e2.push({ level: 100 * t3.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Xp2(e2).call(e2, (e3, t4) => e3.level - t4.level), e2;
        }
        async disconnectForReconnect() {
          this.connection && (sD.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = TV.Reconnecting, wN("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t3] = e2;
            var i2;
            t3._videoTrack && t3._videoTrack._player && (null === (i2 = t3._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t3._videoTrack._player.isKeepLastFrame = true, t3._videoTrack._originMediaStreamTrack.stop());
          }), this.resetConnection(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = TB2(this.store), this.emit(RV.PeerConnectionStateChange, this.connection.peerConnectionState), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            var t3;
            let [i2, { track: n3 }] = e2;
            switch (i2) {
              case gV.LocalVideoTrack:
                Ln2(t3 = n3._hints).call(t3, xD.LOW_STREAM) ? n3.close() : this.pendingLocalTracks.push(n3);
                break;
              case gV.LocalAudioTrack:
                n3 instanceof WL ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n3.trackList) : this.pendingLocalTracks.push(n3);
              case gV.LocalVideoLowTrack:
            }
          }), this.emit(RV.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t3, i2] = e2;
            Array.from(XN(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteMedia(t3, e3);
            }), this.emit(RV.MediaReconnectStart, t3.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), 0 !== this.localDataChannels.length && (this.localDataChannels.forEach((e2) => {
            this.pendingLocalDataChannels.push(e2);
          }), this.localDataChannels.length = 0), 0 !== this.remoteDataChannelMap.size && (Array.from(this.remoteDataChannelMap.entries()).forEach((e2) => {
            let [t3, i2] = e2;
            Array.from(XN(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteDataChannel(t3, e3);
            });
          }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), sD.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteDataChannel(e2, t3) {
          for (const i2 of this.pendingRemoteDataChannels) {
            const { user: n3, id: r2 } = i2;
            if ((e2 instanceof QF ? e2.uid : e2) === n3.uid && r2 === t3) return true;
          }
          return false;
        }
        setPendingRemoteDataChannel(e2, t3) {
          this.hasPendingRemoteDataChannel(e2, t3) || this.pendingRemoteDataChannels.push({ user: e2, id: t3 });
        }
        hasPendingRemoteMedia(e2, t3) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n3, kind: r2 } = i2;
            if ((e2 instanceof QF ? e2.uid : e2) === n3.uid && t3 === r2) return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t3) {
          this.hasPendingRemoteMedia(e2, t3) || this.pendingRemoteTracks.push({ user: e2, kind: t3 });
        }
        restartICE(e2) {
          var t3 = this;
          return qb2(function* () {
            if (!t3.connection || t3.state !== TV.Connected) return;
            const i2 = yield Jb2(t3.mutex.lock("From P2PChannel.restartICE"));
            let n3;
            try {
              n3 = yield Jb2(t3.connection.restartICE(e2));
              const r3 = yield Jb2(n3.next());
              if (r3.done) return;
              const o2 = r3.value, s2 = yield o2;
              switch (RB2(t3.connection) && t3.reportPCStats(Date.now(), false, t3._pcStatsUploadType), e2) {
                case mV.UDP_TCP_RELAY:
                  t3._pcStatsUploadType = fV.UDP_TCP_RESTART;
                  break;
                case mV.TCP_RELAY:
                  t3._pcStatsUploadType = fV.TCP_RESTART;
                  break;
                case mV.RELAY:
                  t3._pcStatsUploadType = fV.RELAY_RESTART;
                  break;
                default:
                  t3._pcStatsUploadType = fV.OLD_RESTART;
              }
              t3._isTryConnecting = true, n3.next(s2);
            } catch (e3) {
              var r2;
              null === (r2 = n3) || void 0 === r2 || r2.throw(e3);
            } finally {
              i2();
            }
          })();
        }
        getUplinkNetworkQuality() {
          if (!this.connection) return 0;
          const e2 = this.connection.getStats(), t3 = this.localTrackMap.get(gV.LocalVideoTrack), i2 = this.localTrackMap.get(gV.LocalAudioTrack), n3 = e2.videoSend.find((e3) => e3.ssrc === (null == t3 ? void 0 : t3.ssrcs[0].ssrcId)), r2 = e2.audioSend.find((e3) => e3.ssrc === (null == i2 ? void 0 : i2.ssrcs[0].ssrcId));
          if (!n3 || !r2) return 1;
          const o2 = aO(this, RV.NeedSignalRTT), s2 = n3 ? n3.rttMs : void 0, a3 = r2 ? r2.rttMs : void 0, c3 = s2 && a3 ? (s2 + a3) / 2 : s2 || a3, d2 = (c3 && o2 ? (c3 + o2) / 2 : c3 || o2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u3 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t3 ? void 0 : t3.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(xD.SCREEN_TRACK)) {
            const t4 = h2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t4 && i3) {
              const e3 = (1e3 * t4 - i3) / (1e3 * t4);
              return GM[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u3];
            }
          }
          return u3;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection) return 0;
          const e2 = this.connection.getStats();
          let t3 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
            let [n3] = i2;
            const r2 = n3._audioSSRC, o2 = n3._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a3 = e2.videoRecv.find((e3) => e3.ssrc === o2);
            if (!s2 && !a3) return void (t3 += 1);
            const c3 = aO(this, RV.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c3 ? (d2 + c3) / 2 : d2 || c3) || 0, u3 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p2 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
            u3 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u3 / 400);
            t3 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t3 / this.remoteUserMap.size) : t3;
        }
        async muteLocalTrack(e2) {
          return new ip2((t3, i2) => {
            this.handleMuteLocalTrack(e2, t3, i2);
          });
        }
        async replaceTrack(e2, t3) {
          var i2;
          if (sD.debug("[".concat(this.store.clientId, "] P2PChannel replaceTrack from [").concat(e2.getTrackId(), "] to [").concat(t3.getTrackId(), "]")), !this.connection || this.state !== TV.Connected) return;
          const n3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i3 }] = t4;
            return e2 === i3;
          });
          if (!n3) return;
          const r2 = n3[0];
          if (e2 !== t3 && (this.unbindLocalTrackEvents([{ track: e2, type: r2 }]), this.bindLocalTrackEvents([{ track: t3, type: r2 }]), n3[1].track = t3), await (null === (i2 = this.connection) || void 0 === i2 ? void 0 : i2.replaceTrack(t3, n3[1].id)), this.isPlanB) {
            const e3 = n3[1];
            e3.id = t3._mediaStreamTrack.id, this.localTrackMap.set(r2, e3);
          }
          if (r2 === gV.LocalVideoTrack && !wN("DISABLE_DUAL_STREAM_USE_ENCODING") && fD2().supportDualStreamEncoding) {
            const t4 = this.localTrackMap.get(gV.LocalVideoLowTrack);
            if (t4) {
              const i3 = e2._mediaStreamTrack.clone();
              t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i3, t4.track._originMediaStreamTrack = i3, await new ip2((e3, i4) => {
                this.handleReplaceTrack(t4.track, e3, i4, true);
              });
            }
          }
        }
        filterTobePublishedTracks(e2, t3, i2) {
          const n3 = [], r2 = this.getAllTracks();
          e2 = uO(e2 = e2.filter((e3) => -1 === r2.indexOf(e3)));
          let o2, s2 = false;
          const a3 = this.localTrackMap.get(gV.LocalAudioTrack);
          for (const r3 of e2) {
            if (r3 instanceof kk2 && (this.localTrackMap.has(gV.LocalVideoTrack) || s2 ? new Ow2(ww2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n3.push({ track: r3, type: gV.LocalVideoTrack }), s2 = true), t3)) {
              const e3 = this.getLowVideoTrack(r3, i2);
              n3.push({ track: e3, type: gV.LocalVideoLowTrack });
            }
            if (r3 instanceof BL) if (a3) {
              const e3 = a3.track;
              if (e3 instanceof WL) fB2([r3]), e3.addAudioTrack(r3), this.bindLocalAudioTrackEvents(r3, true);
              else {
                const t4 = SB2([e3, r3]);
                sD.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(t4.getTrackId(), "]")), this.replaceTrack(e3, t4);
              }
            } else if (o2 instanceof WL) fB2([r3]), o2.addAudioTrack(r3);
            else if (o2 || !r3._useAudioElement && fD2().webAudioMediaStreamDest && !r3._bypassWebAudio) {
              o2 = SB2(o2 ? [r3, o2] : [r3]);
            } else o2 = r3;
          }
          return o2 && (sD.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will send audioTrack [").concat(o2.getTrackId(), "]")), n3.push({ track: o2, type: gV.LocalAudioTrack })), n3;
        }
        filterTobeUnpublishedTracks(e2) {
          const t3 = [], i2 = this.getAllTracks();
          e2 = uO(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
          for (const i3 of e2) {
            if (i3 instanceof BL) {
              const e3 = this.localTrackMap.get(gV.LocalAudioTrack);
              if (!e3) continue;
              e3.track instanceof WL ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t3.push([gV.LocalAudioTrack, e3]), e3.track.close())) : t3.push([gV.LocalAudioTrack, e3]);
            }
            if (i3 instanceof kk2) {
              const e3 = this.localTrackMap.get(gV.LocalVideoTrack);
              if (!e3) continue;
              t3.push([gV.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(gV.LocalVideoLowTrack);
              i4 && t3.push([gV.LocalVideoLowTrack, i4]);
            }
          }
          return t3;
        }
        filterTobePublishedDataChannels(e2) {
          return e2 = (e2 = uO(e2)).filter((e3) => -1 === this.localDataChannels.findIndex((t3) => t3.id === e3.id));
        }
        filterTobeUnpublishedDataChannels(e2) {
          return e2 = (e2 = (e2 = uO(e2)).filter((e3) => -1 !== this.localDataChannels.indexOf(e3))).filter((e3) => e3._originDataChannel);
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t3, type: i2 } = e3;
            switch (i2) {
              case gV.LocalVideoTrack:
                t3.addListener(VD.GET_STATS, this.handleGetLocalVideoStats), t3.addListener(VD.GET_RTC_STATS, this.handleGetRTCStats), t3.addListener(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t3.addListener(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t3.addListener(VD.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t3.addListener(VD.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t3.addListener(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), t3.addListener(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t3.addListener(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case gV.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t3);
              case gV.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t3) {
          e2 instanceof WL ? e2.trackList.forEach((e3) => {
            e3.addListener(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(VD.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(VD.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t3 || (e2.addListener(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.addListener(VD.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t3, { track: i2 }] = e3;
            return { track: i2, type: t3 };
          })), e2.forEach((e3) => {
            let { track: t3, type: i2 } = e3;
            switch (i2) {
              case gV.LocalVideoTrack:
                t3.off(VD.GET_STATS, this.handleGetLocalVideoStats), t3.off(VD.GET_RTC_STATS, this.handleGetRTCStats), t3.off(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t3.off(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t3.off(VD.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t3.off(VD.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t3.off(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), t3.off(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t3.off(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case gV.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t3);
              case gV.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof WL ? e2.trackList.forEach((e3) => {
            e3.off(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(VD.GET_STATS, this.handleGetLocalAudioStats), e3.off(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(VD.GET_STATS, this.handleGetLocalAudioStats), e2.off(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(VD.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), e2.off(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t3) {
          t3 instanceof Jk2 && t3.addListener(VD.GET_STATS, (t4) => {
            t4(this.handleGetRemoteVideoStats(e2));
          }), t3 instanceof Zk2 && t3.addListener(VD.GET_STATS, (t4) => {
            t4(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(VD.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t3, i2] = e2;
            i2.has(EV.AUDIO) && this.unbindRemoteTrackEvents(t3._audioTrack), i2.has(EV.VIDEO) && this.unbindRemoteTrackEvents(t3._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t3) {
          return e2.map((e3, i2) => {
            var n3;
            let r2, o2, { track: s2, type: a3 } = e3;
            switch (a3) {
              case gV.LocalAudioTrack:
                r2 = nV.Audio, o2 = { dtx: s2 instanceof jL && s2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case gV.LocalVideoTrack:
                r2 = Ln2(n3 = s2._hints).call(n3, xD.SCREEN_TRACK) ? nV.Screen : nV.High, o2 = QB2(QB2({}, sx2(s2)), {}, { codec: this.store.codec, svc_mode: px2() });
                break;
              case gV.LocalVideoLowTrack:
                r2 = nV.Low, o2 = QB2(QB2({}, sx2(s2)), {}, { codec: this.store.codec, svc_mode: px2() });
            }
            return { stream_type: r2, attributes: o2, ssrcs: t3[i2] };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            var t3;
            let i2, [n3, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n3) {
              case gV.LocalVideoTrack:
                i2 = Ln2(t3 = r2._hints).call(t3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalAudioTrack:
                i2 = nV.Audio;
                break;
              case gV.LocalVideoLowTrack:
                i2 = nV.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          });
        }
        assignLocalTracks(e2, t3) {
          e2.forEach((e3, i2) => {
            let { track: n3, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n3, id: t3[i2].id, ssrcs: t3[i2].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t3] = e3;
            this.localTrackMap.delete(t3);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t3) => {
            if (sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t3, ")")), this.emit(RV.PeerConnectionStateChange, t3), "connecting" === t3 && e2 instanceof bB2 && !iw2() && wN("FIRST_TCP_CANDIDATE") && window.setTimeout(() => {
              "connecting" === t3 && e2.extendCandidate();
            }, wN("FIRST_TCP_CANDIDATE_INTERVAL")), "connected" !== t3 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t3) {
              this._restartTimer && (window.clearTimeout(this._restartTimer), this._restartTimer = void 0), e2 instanceof bB2 && qB2(e2, true), this._isTryConnecting && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isTryConnecting = false, this._isStartRestartIce = false, this._pcStatsUploadType = fV.DISCONNECTED_OR_FAILED;
              if ("CONNECTED" === aO(this, RV.QueryClientConnectionState) && this._isWaitPcToRePub) {
                const e3 = this.pendingLocalTracks.map((e4) => e4.getTrackId()), t4 = this.pendingLocalDataChannels.map((e4) => "dc_".concat(e4.id));
                _D.reportApiInvoke(this.store.sessionId, { name: zw2.REPUB_AFTER_PC_CONNECTED, options: e3.concat(t4), tag: qw2.TRACER }).onSuccess(), this.republish();
              }
            }
            if (wN("NEW_ICE_RESTART") && e2 instanceof bB2 && !iw2() && !this._forceTurn) {
              if (Ln2(SV).call(SV, t3)) {
                if (this._isStartRestartIce) return;
                this._isStartRestartIce = true;
                const t4 = (t5) => {
                  if (RB2(e2)) {
                    sD.debug("[".concat(this.store.clientId, "] [P2PChannel] try to restartICE, type is ").concat(t5));
                    "CONNECTED" === aO(this, RV.QueryClientConnectionState) && this.emit(RV.RequestRestartICE, t5);
                  }
                }, i2 = () => {
                  RB2(e2) && (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), sD.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(RV.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
                };
                return void (this._restartTimer = window.setTimeout(() => {
                  XB2(e2, t4, i2);
                }, 800));
              }
            } else {
              if ("disconnected" === t3 && "disconnected" === e2.iceConnectionState) return setTimeout(() => {
                if ("disconnected" === e2.iceConnectionState && wN("ICE_RESTART")) {
                  "CONNECTED" === aO(this, RV.QueryClientConnectionState) && this.emit(RV.RequestRestartICE);
                }
              }, 800), void setTimeout(() => {
                "disconnected" === e2.peerConnectionState && (sD.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isTryConnecting = false, setTimeout(() => this.emit(RV.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
              }, 4e3);
              "failed" === t3 && (sD.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), setTimeout(() => this.emit(RV.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
            }
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), _D.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: qw2.TRACER }).onSuccess(), this.emit(RV.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._audioSSRC === e3);
            var n3;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n3 = i2.audioTrack) || void 0 === n3 || n3.emit(HD.FIRST_FRAME_DECODED), _D.firstRemoteFrame(this.store.sessionId, lD2.FIRST_AUDIO_DECODE, uD.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._audioSSRC === e3);
            i2 && _D.firstRemoteFrame(this.store.sessionId, lD2.FIRST_AUDIO_RECEIVED, uD.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t3, i2) => {
            var n3;
            const r2 = Array.from(XN(n3 = this.remoteUserMap).call(n3)).find((t4) => t4._videoSSRC === e3);
            r2 && this.store.firstVideoFrameDecoded(r2.uid, { firstDecoded: Date.now() }), this.reportVideoFirstFrameDecoded(e3, t3, i2);
          }, e2.onFirstVideoRender = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._videoSSRC === e3);
            i2 && (this.store.firstVideoFrameDecoded(i2.uid, { firstPreRender: Date.now() }), this.reportVideoFirstFrameRender(i2));
          }, e2.onFirstVideoReceived = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._videoSSRC === e3);
            i2 && (this.store.firstVideoFrameDecoded(i2.uid, { firstReceived: Date.now() }), _D.firstRemoteFrame(this.store.sessionId, lD2.FIRST_VIDEO_RECEIVED, uD.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onSelectedLocalCandidateChanged = (e3, t3) => {
            const i2 = "relay" === e3.candidateType, n3 = "relay" === t3.candidateType;
            "unknown" !== t3.candidateType && i2 === n3 || this.emit(RV.ConnectionTypeChange, i2), sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(ux2(t3)), " -> ").concat(JSON.stringify(ux2(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(ux2(t3)), " -> ").concat(JSON.stringify(ux2(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.getLocalVideoStats = () => {
            const e3 = this.statsCollector.getLocalVideoTrackStats(), t3 = this.statsCollector.getRTCStats();
            return QB2(QB2({}, e3), t3);
          }, e2.onICECandidateError = (e3) => {
            this._iceError = e3;
          };
        }
        resetConnection(e2) {
          e2 instanceof bB2 && function(e3) {
            KB2.delete(e3.id), qB2(e3);
          }(e2), e2.close(), this.emit(RV.PeerConnectionStateChange, "closed"), function(e3) {
            e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0, e3.getLocalVideoStats = void 0;
          }(e2), this._isWaitPcToRePub = false;
        }
        filterTobeMutedTracks(e2) {
          const t3 = [];
          if (-1 === this.getAllTracks().indexOf(e2)) return t3;
          const i2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if (e2 instanceof BL && (null == i2 ? void 0 : i2.track) instanceof WL) return i2.track.isActive || t3.push([gV.LocalAudioTrack, i2]), t3;
          const n3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i3 }] = t4;
            return e2 === i3;
          });
          if (n3 && (t3.push(n3), n3[0] === gV.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(gV.LocalVideoLowTrack);
            e3 && t3.push([gV.LocalVideoLowTrack, e3]);
          }
          return t3;
        }
        filterTobeUnmutedTracks(e2) {
          const t3 = [], i2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if (e2 instanceof BL && (null == i2 ? void 0 : i2.track) instanceof WL) return i2.track.isActive && t3.push([gV.LocalAudioTrack, i2]), t3;
          const n3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i3 }] = t4;
            return e2 === i3;
          });
          if (n3) if (n3[0] === gV.LocalVideoTrack) {
            t3.push(n3);
            const e3 = this.localTrackMap.get(gV.LocalVideoLowTrack);
            e3 && t3.push([gV.LocalVideoLowTrack, e3]);
          } else t3.push(n3);
          return t3;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            var t3;
            let i2, [n3, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n3) {
              case gV.LocalAudioTrack:
                i2 = nV.Audio;
                break;
              case gV.LocalVideoTrack:
                i2 = Ln2(t3 = r2._hints).call(t3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalVideoLowTrack:
                i2 = nV.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            var t3;
            let i2, [n3, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n3) {
              case gV.LocalAudioTrack:
                i2 = nV.Audio;
                break;
              case gV.LocalVideoTrack:
                i2 = Ln2(t3 = r2._hints).call(t3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalVideoLowTrack:
                i2 = nV.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t3) {
          const i2 = [], n3 = this.remoteUserMap.get(e2);
          if (!n3) return i2;
          if (t3) {
            const r2 = n3.get(t3);
            if (!r2) return i2;
            i2.push([e2, { kind: t3, id: r2 }]);
          } else Array.from(n3.entries()).forEach((t4) => {
            let [n4, r2] = t4;
            i2.push([e2, { kind: n4, id: r2 }]);
          });
          return i2;
        }
        filterTobeUnSubscribedDataChannels(e2, t3) {
          const i2 = [];
          return t3.forEach((t4) => {
            var n3;
            null !== (n3 = this.remoteDataChannelMap.get(e2)) && void 0 !== n3 && n3.has(t4.id) && i2.push(t4);
          }), i2;
        }
        createUnsubscribeMessage(e2) {
          const t3 = [];
          return e2.forEach((e3) => {
            let [i2, { kind: n3, id: r2 }] = e3;
            switch (n3) {
              case EV.VIDEO:
                return void (i2._videoSSRC && t3.push({ stream_type: EV.VIDEO, ssrcId: i2._videoSSRC }));
              case EV.AUDIO:
                return void (i2._audioSSRC && t3.push({ stream_type: EV.AUDIO, ssrcId: i2._audioSSRC }));
            }
          }), t3;
        }
        createUnsubscribeAllMessage(e2) {
          const t3 = /* @__PURE__ */ new Map();
          return e2.forEach((e3) => {
            let [i2, { kind: n3 }] = e3;
            if (t3.has(i2)) {
              let e4 = t3.get(i2);
              n3 === EV.VIDEO ? e4 |= sV.Video : e4 |= sV.Audio, t3.set(i2, e4);
            } else n3 === EV.VIDEO ? t3.set(i2, sV.Video) : t3.set(i2, sV.Audio);
          }), { users: Array.from(t3.entries()).map((e3) => {
            let [t4, i2] = e3;
            return { stream_id: t4.uid, stream_type: i2 };
          }) };
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t3, { kind: i2 }] = e3;
            const n3 = this.remoteUserMap.get(t3);
            n3 && (n3.delete(i2), 0 === Array.from(n3.entries()).length && this.remoteUserMap.delete(t3));
          });
        }
        async updateBitrateLimit(e2) {
          const t3 = this.localTrackMap.get(gV.LocalVideoTrack), i2 = this.localTrackMap.get(gV.LocalVideoLowTrack);
          t3 && (await t3.track.setBitrateLimit(e2.uplink), await new ip2((e3, i3) => {
            this.handleUpdateVideoEncoder(t3.track, e3, i3, true);
          })), i2 && e2.low_stream_uplink && (await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 }), await new ip2((e3, t4) => {
            this.handleUpdateVideoEncoder(i2.track, e3, t4, true);
          }));
        }
        isP2PDisconnected() {
          if (this.connection) {
            return "connected" !== this.connection.peerConnectionState;
          }
          return true;
        }
        isPreallocation() {
          return this.connection instanceof bB2 && this.connection.isPreallocation;
        }
        isPreSub() {
          return this.connection instanceof bB2 && this.connection.isPreSub();
        }
        mapPubResToRemoteConfig(e2, t3, i2) {
          return e2.map((e3, n3) => {
            var r2;
            let { stream_type: o2 } = e3;
            const s2 = null === (r2 = t3.find((e4) => {
              let { stream_type: t4 } = e4;
              return o2 === t4;
            })) || void 0 === r2 ? void 0 : r2.attributes;
            if (s2 && wN("DISABLE_SCREEN_SHARE_REMB")) {
              const e4 = i2[n3]._hints;
              (Ln2(e4).call(e4, xD.SCREEN_TRACK) || Ln2(e4).call(e4, xD.SCREEN_LOW_TRACK)) && (s2.remb = false, sD.debug("disable remb for screen share, hints:", e4));
            }
            return s2;
          });
        }
        async tryToUnmuteAudio(e2) {
          for (let i2 = 0; i2 < e2.length; i2++) if (e2[i2] instanceof BL) {
            var t3;
            const n3 = this.filterTobeUnmutedTracks(e2[i2]);
            if (0 === n3.length) continue;
            await (null === (t3 = this.connection) || void 0 === t3 ? void 0 : t3.unmuteLocal(n3.map((e3) => {
              let [, { id: t4 }] = e3;
              return t4;
            })));
            const r2 = this.createUnmuteMessage(n3);
            return void await sO(this, RV.RequestUnmuteLocal, r2);
          }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t3;
            return !(null === (t3 = this.connection) || void 0 === t3 || !t3.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t3) => this.emit(RV.RequestUpload, e2, t3), this.statsUploader.requestUploadStats = (e2) => this.emit(RV.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks(), this.statsUploader.requestTransportStats = () => {
            var e2;
            return { connectState: (null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.peerConnectionState) || "closed" };
          };
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await yO(jO(this.dtlsFailedCount, BO)), this.emit(RV.RequestReconnect);
        }
        async reconnectP2P() {
          const e2 = Array.from(this.localTrackMap.entries()), t3 = this.createGatewayUnpublishMessage(e2);
          Array.from(this.remoteUserMap.entries()), t3.length > 0 && await oO(this, RV.RequestUnpublishForReconnectPC, t3), this.disconnectForReconnect(), this.emit(RV.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(gV.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof kk2);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof kk2).length > 1) throw new Ow2(ww2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof BL).length > 1 && (e2.some((e3) => e3 instanceof BL && e3._bypassWebAudio) || !fD2().webAudioMediaStreamDest)) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t3 of e2) {
            if (t3 instanceof kk2 && this.pendingLocalTracks.some((e3) => e3 instanceof kk2)) throw new Ow2(ww2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t3 instanceof BL && this.pendingLocalTracks.some((e3) => e3 instanceof BL) && (!fD2().webAudioMediaStreamDest || t3._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof BL && e3._bypassWebAudio))) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t3) {
          var i2;
          const n3 = !wN("DISABLE_DUAL_STREAM_USE_ENCODING") && fD2().supportDualStreamEncoding, r2 = QB2(QB2({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t3);
          let o2;
          o2 = n3 ? e2._mediaStreamTrack.clone() : wB2(e2, r2);
          const s2 = IO(8, "track-low-"), a3 = new kk2(o2, QB2(QB2({}, n3 && { scaleResolutionDownBy: lx2(r2, e2) }), {}, { frameRate: r2.framerate, bitrateMax: r2.bitrate, bitrateMin: r2.bitrate }), void 0, void 0, s2);
          return a3.on(GD.TRANSCEIVER_UPDATED, (t4) => {
            e2._updateRtpTransceiver(t4, FD.LOW_STREAM);
          }), a3._hints.push(xD.LOW_STREAM), Ln2(i2 = e2._hints).call(i2, xD.SCREEN_TRACK) && a3._hints.push(xD.SCREEN_LOW_TRACK), e2.on("sei-to-send", (e3) => {
            a3.emit("sei-to-send", e3);
          }), e2.addListener(VD.NEED_CLOSE, () => {
            a3.close();
          }), a3;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
        async reportPCStats(e2, t3, i2) {
          let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
          if (this.connection && this.connection instanceof bB2) {
            var r2, o2, s2, a3;
            const c3 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: l2, peerConnectionState: u3 } = this.connection, { local: h2, remote: p2 } = await this.connection.getSelectedCandidatePair();
            _D.pcStats(this.store.sessionId, { startTime: c3, eventElapse: e2 - c3 || 0, iceconnectionsate: d2, dtlsstate: l2, connectionstate: u3, intSucc: t3 ? 1 : 2, error: this._iceError || n3 || "", selectedLocalCandidateProtocol: null !== (r2 = null == h2 ? void 0 : h2.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (o2 = h2.candidateType) && void 0 !== o2 ? o2 : "", selectedLocalCandidateAddress: "".concat(h2.address, ":").concat(h2.port), selectedRemoteCandidateProtocol: null !== (s2 = p2.protocol) && void 0 !== s2 ? s2 : "", selectedRemoteCandidateType: null !== (a3 = p2.candidateType) && void 0 !== a3 ? a3 : "", selectedRemoteCandidateAddress: "".concat(p2.address, ":").concat(p2.port), restartCnt: i2, preallocation: this.connection.isPreallocation }), this._iceError = null;
          }
        }
        reportVideoFirstFrameRender(e2) {
          const t3 = this.store.keyMetrics, i2 = t3.firstVideoFrameDecoded.find((t4) => t4.userId === e2.uid);
          if (!i2) return;
          const { isInternalUpload: n3, isExternalUpload: r2 } = i2;
          if (n3 && r2) return;
          const { subscribeEnd: o2, firstPreRender: s2, peerPublishDuration: a3, peerPubStatusMs: c3 } = i2;
          let { firstRender: d2 = 0 } = i2;
          if (o2 && (d2 || s2) && a3 && c3) {
            i2.isInternalUpload = true;
            const { playEnd: n4 } = i2;
            n4 && (i2.isExternalUpload = true);
            const { firstPreRender: r3 = 0 } = i2;
            d2 = r3 || d2;
            const s3 = e2.videoTrack, l2 = { peer: e2._uintid, width: (null == s3 ? void 0 : s3._videoWidth) || 0, height: (null == s3 ? void 0 : s3._videoHeight) || 0, ssrc: e2._videoSSRC || 0, p2pid: this.store.p2pId, peerPublishDuration: a3, peerPubStatusMs: c3, joinChannelStart: t3.joinStart || 0, preloadStart: t3.preloadStart || 0, preloadEnd: t3.preloadEnd || 0, apStart: t3.requestAPStart || 0, apEnd: t3.requestAPEnd || 0, suaEnd: t3.requestSUAEnd || 0, beforeConnect: t3.beforeConnect || 0, peerReceiver: t3.peerReceiver || 0, ice: t3.iceConnectionEnd || 0, pc: t3.peerConnectionEnd || 0, signalConnected: t3.signalConnected || 0, joinReq: t3.joinReq || 0, joinRes: t3.joinRep || 0, userJoinNotify: i2.userJoinNotify || 0, videoAddNotify: i2.videoAddNotify || 0, subscribeStart: i2.subscribeStart || 0, subscribeEnd: i2.subscribeEnd || 0, firstReceived: i2.firstReceived || 0, firstDecoded: i2.firstDecoded || 0, firstPreRender: r3 || 0, firstRender: n4 ? Math.max(d2, n4) : Math.max(d2, o2), playStart: i2.playStart || 0, playEnd: i2.playEnd || 0, isPreSub: !(!e2._videoSSRC || !this.isPreSubScribe(e2._videoSSRC)), isPrePc: this.isPreallocation(), isPreInstantVideo: RD(this.store) };
            _D.firstXLAPeerFirstVideoFrame(this.store.sessionId, l2);
          }
        }
        reportVideoFirstFrameDecoded(e2, t3, i2, n3) {
          var r2;
          const o2 = Array.from(XN(r2 = this.remoteUserMap).call(r2)).find((t4) => t4._videoSSRC === e2);
          if (o2) {
            n3 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e3) => e3.userId === o2.uid && "video" === e3.type);
            _D.firstRemoteVideoDecode(this.store.sessionId, lD2.FIRST_VIDEO_DECODE, uD.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t3, videoheight: i2, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n3 ? 1 : 0, firstFrame: (null == s2 ? void 0 : s2.firstFrame) || 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t3, i2) {
          if (!this.connection) return false;
          const n3 = this.remoteUserMap.get(e2);
          if (!n3) return false;
          const r2 = n3.get(t3);
          if (!r2) return false;
          const o2 = await this.connection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i2;
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t3, { track: i2 }] = e2;
            t3 === gV.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, FD.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          });
        }
      }, OU(JB2.prototype, "startP2PConnection", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "startP2PConnection"), JB2.prototype), OU(JB2.prototype, "connect", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "connect"), JB2.prototype), OU(JB2.prototype, "updateRemoteRTPCapabilities", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "updateRemoteRTPCapabilities"), JB2.prototype), OU(JB2.prototype, "publishDataChannel", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "publishDataChannel"), JB2.prototype), OU(JB2.prototype, "unpublish", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "unpublish"), JB2.prototype), OU(JB2.prototype, "unpublishDataChannel", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "unpublishDataChannel"), JB2.prototype), OU(JB2.prototype, "unpublishLowStream", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "unpublishLowStream"), JB2.prototype), OU(JB2.prototype, "subscribeDataChannel", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "subscribeDataChannel"), JB2.prototype), OU(JB2.prototype, "subscribe", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "subscribe"), JB2.prototype), OU(JB2.prototype, "massSubscribe", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "massSubscribe"), JB2.prototype), OU(JB2.prototype, "unsubscribe", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "unsubscribe"), JB2.prototype), OU(JB2.prototype, "unsubscribeDataChannel", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "unsubscribeDataChannel"), JB2.prototype), OU(JB2.prototype, "massUnsubscribe", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "massUnsubscribe"), JB2.prototype), OU(JB2.prototype, "muteRemote", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "muteRemote"), JB2.prototype), OU(JB2.prototype, "unmuteRemote", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "unmuteRemote"), JB2.prototype), OU(JB2.prototype, "hasRemoteMediaWithLock", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "hasRemoteMediaWithLock"), JB2.prototype), OU(JB2.prototype, "disconnectForReconnect", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "disconnectForReconnect"), JB2.prototype), OU(JB2.prototype, "updateBitrateLimit", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "updateBitrateLimit"), JB2.prototype), OU(JB2.prototype, "remoteMediaSsrcChanged", [ij2], Object.getOwnPropertyDescriptor(JB2.prototype, "remoteMediaSsrcChanged"), JB2.prototype), JB2);
      function ij2(e2, t3, i2) {
        const n3 = e2[t3];
        if ("function" != typeof n3) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PChannel.".concat(t3));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n3.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      function nj2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function rj2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? nj2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : nj2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const oj2 = Date.now(), sj2 = 20, aj2 = /* @__PURE__ */ new Map(), cj2 = /* @__PURE__ */ new Map();
      async function dj2(e2) {
        const t3 = aj2.get(e2), i2 = Array.isArray(t3) && t3[t3.length - 1], n3 = cj2.get(e2);
        if (!i2) return void (n3.isSyncing = false);
        const r2 = { uid: i2.uid, payload: i2.payload };
        0 === n3.firstRecvTs && (n3.firstRecvTs = i2.recvTs, n3.firstSendTs = i2.sendTs);
        const o2 = i2.sendTs - n3.firstSendTs, s2 = o2 - (Date.now() - n3.firstRecvTs);
        s2 > 0 && (n3.firstRecvTs = Date.now() - o2);
        let a3 = i2.mediaDelay + s2;
        a3 <= 0 ? (t3.pop(), lj2(i2.context, r2), a3 = 0) : a3 = Math.min(a3, sj2), setTimeout(() => t3.length && dj2(e2), a3);
      }
      function lj2(e2, t3) {
        e2.safeEmit(tO.STREAM_MESSAGE, t3.uid, t3.payload), e2.onStreamMessage && e2.onStreamMessage(t3);
      }
      function uj2(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
        if (!e2.syncWithAudio) return lj2(i2, { uid: e2.uid, payload: e2.payload });
        const n3 = "".concat(i2.id, "-").concat(e2.uid), r2 = aj2.get(n3) || [], o2 = r2.findIndex((t4) => e2.sendTs >= t4.sendTs), s2 = rj2(rj2({}, e2), {}, { context: i2, mediaDelay: t3, recvTs: Date.now() });
        -1 === o2 ? r2.push(s2) : r2.splice(o2, 0, s2), aj2.set(n3, r2);
        let a3 = false;
        var c3;
        cj2.has(n3) ? a3 = !(null === (c3 = cj2.get(n3)) || void 0 === c3 || !c3.isSyncing) : cj2.set(n3, { isSyncing: a3, firstRecvTs: 0, firstSendTs: 0 });
        a3 || dj2(n3);
      }
      const hj2 = zA2().name;
      function pj2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function _j(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? pj2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : pj2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const Ej2 = "websdk_ng_cache_parameter", mj2 = wN("MAX_PRELOAD_ASYNC_LENGTH"), fj2 = 1e4, Sj2 = /* @__PURE__ */ new Map(), gj2 = [];
      let Tj2 = null, Rj2 = 0, vj2 = 0;
      const Cj2 = /* @__PURE__ */ new Map(), yj2 = /* @__PURE__ */ function(e2, t3) {
        const i2 = [];
        let n3 = 0;
        const r2 = async () => {
          const e3 = i2.shift();
          e3 && await e3(), i2.length > 0 && n3 < t3 ? r2() : n3--;
        };
        return async function() {
          for (var o2 = arguments.length, s2 = new Array(o2), a3 = 0; a3 < o2; a3++) s2[a3] = arguments[a3];
          return new ip2(async (o3, a4) => {
            i2.push(async () => {
              try {
                const t4 = await e2(...s2);
                o3(t4);
              } catch (e3) {
                a4(e3);
              }
            }), n3 < t3 && (n3++, r2());
          });
        };
      }(bj2, mj2), Ij2 = UA2.CancelToken.source();
      async function bj2(e2, t3, i2, n3, r2, o2) {
        try {
          if (!wN("ENABLE_PRELOAD")) return;
          if (!fD2().supportWebCrypto) return void mO(() => {
            sD.warn("Your browser does not support preloading, this feature  be run in a secure environment");
          }, "preload_webcrypto_not_supported");
          if (!i2 && null !== i2) throw new Ow2(ww2.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
          i2 && kw2(i2, "token", 1, 2047), kw2(e2, "appid", 1, 2047), GU(t3), n3 && WU(n3);
          const s2 = bO();
          sD.debug("preload channel ".concat(t3, ", uid is ").concat(n3));
          const a3 = { appId: e2, cname: t3, token: i2 || e2, uid: "string" != typeof n3 ? n3 : null, sid: s2, proxyServer: r2 };
          let c3, d2;
          "string" == typeof n3 ? (a3.stringUid = n3, [d2, c3] = await ip2.all([MF(n3, { sid: s2, appId: e2 }, Ij2.token), VF(_j(_j({}, a3), {}, { token: i2 || e2, uid: 0 }), Ij2.token)]), a3.uid = d2.uid, c3.gatewayInfo.uid = a3.uid, c3.gatewayInfo.res.uid = a3.uid) : (o2 && (a3.stringUid = o2), c3 = await VF(a3, Ij2.token));
          const l2 = { sid: s2, appId: e2, cname: t3, token: i2 || e2, uid: a3.stringUid || n3, intUid: a3.uid || c3.gatewayInfo.uid, stringUid: a3.stringUid, ts: Date.now(), sua: d2, ap: c3 };
          await async function(e3) {
            let t4;
            try {
              e3.uid && wj2({ appId: e3.appId, cname: e3.cname, token: e3.token, uid: e3.uid, stringUid: e3.stringUid });
              const i3 = kj2(e3), n4 = await async function(e4, t5) {
                try {
                  const i4 = await window.crypto.subtle.importKey("raw", gO(t5), "AES-GCM", false, ["encrypt"]), n5 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, i4, fO(window.btoa(JSON.stringify(e4))));
                  return SO(new Uint8Array(n5));
                } catch (e5) {
                  return;
                }
              }(e3, e3.token || e3.appId);
              if (!n4) return;
              t4 = Pj2(Ej2);
              const r3 = t4 ? JSON.parse(t4) : [];
              r3.push({ [i3]: n4 }), r3.length > wN("AP_CACHE_NUM") && r3.shift(), Lj2(Ej2, JSON.stringify(r3));
            } catch (e4) {
              sD.warn("Error caching server parameters:", e4.message), Lj2(Ej2, "");
            }
          }(l2), Rj2++;
        } catch (e3) {
          throw vj2++, function(e4) {
            Tj2 || (Tj2 = window.setTimeout(() => {
              let t5 = "";
              Cj2.forEach((e5, i3) => {
                t5 += "".concat(i3, ": ").concat(e5, " ;");
              }), _D.reportApiInvoke(null, { name: zw2.PRELOAD, options: { success: Rj2, failed: vj2, err: t5 } }).onError(e4), Rj2 = 0, vj2 = 0, Cj2.clear(), Tj2 = null;
            }, fj2));
            const t4 = Cj2.get(e4.code) || 0;
            Cj2.set(e4.code, t4 + 1);
          }(e3), e3;
        }
      }
      async function Aj2(e2) {
        try {
          if (wN("AP_REQUEST_DETAIL") || wN("ENABLE_ROLE_SELECT_EDGE")) return;
          const t3 = wj2(e2);
          if (!t3 || "disabled" !== e2.cloudProxyServer) return;
          const i2 = await async function(e3, t4) {
            try {
              const i3 = await window.crypto.subtle.importKey("raw", gO(t4), "AES-GCM", false, ["decrypt"]), n3 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, i3, fO(e3));
              return JSON.parse(window.atob(SO(new Uint8Array(n3))));
            } catch (e4) {
              return;
            }
          }(t3, e2.token || e2.appId);
          if (!i2) return;
          if (!function(e3, t4) {
            const i3 = e3.cname === t4.cname && e3.appId === t4.appId && e3.token === t4.token;
            if (!i3) return false;
            return t4.stringUid ? e3.stringUid === t4.stringUid : "number" == typeof t4.uid ? e3.uid === t4.uid : e3.uid == t4.uid;
          }(i2, e2)) return;
          if (i2 && Date.now() - i2.ts < wN("AP_CACHE_LIFETIME")) return i2;
        } catch (e3) {
          sD.warn("Error get preloadInfo", e3.message);
        }
      }
      function wj2(e2) {
        let t3;
        try {
          if (t3 = Pj2(Ej2), !t3) return;
          const i2 = JSON.parse(t3), n3 = kj2(e2), r2 = function(e3, t4) {
            for (let i3 = e3.length - 1; i3 >= 0; i3--) if (t4(e3[i3])) return i3;
            return -1;
          }(i2, (e3) => n3 in e3);
          if (-1 === r2) return;
          const o2 = i2.splice(r2, 1)[0];
          return Lj2(Ej2, JSON.stringify(i2)), o2[n3];
        } catch (e3) {
          sD.warn("Error delete preload info: ".concat(t3), e3.message), Lj2(Ej2, "");
        }
      }
      function Oj2(e2) {
        if (e2) {
          let t3 = Sj2.get(e2);
          t3 && (window.clearTimeout(t3), t3 = null, Sj2.delete(e2)), Ln2(gj2).call(gj2, e2) || "disabled" !== e2.cloudProxyServer || gj2.push(e2);
        }
        if (Sj2.size < wN("AP_CACHE_NUM") && gj2.length > 0) {
          const e3 = gj2.shift();
          Sj2.set(e3, window.setTimeout(async () => {
            const { appId: t3, cname: i2, token: n3, stringUid: r2, uid: o2, proxyServer: s2 } = e3;
            try {
              await yj2(t3, i2, n3, o2, s2, r2), Sj2.has(e3) && Oj2(e3);
            } catch (t4) {
              sD.warn("update preload failed", t4.message), Nj2(e3);
            }
          }, wN("AP_UPDATE_INTERVAL")));
        }
      }
      function Nj2(e2) {
        const t3 = gj2.indexOf(e2);
        -1 !== t3 && gj2.splice(t3, 1);
        let i2 = Sj2.get(e2);
        i2 && (window.clearTimeout(i2), i2 = null, Sj2.delete(e2), Oj2());
      }
      function Dj2(e2, t3) {
        const i2 = e2.sua, n3 = e2.ap;
        t3 && i2 && _D.reqUserAccount(e2.sid, { lts: i2.requestTime, elapse: i2.elapse, success: true, serverAddr: i2.url, stringUid: t3, uid: e2.intUid, errorCode: null, extend: i2.req }), _D.reportResourceTiming(e2.ap.url, e2.sid), _D.joinWebProxyAP(e2.sid, { lts: n3.requestTime, elapse: n3.elapse, sucess: 1, apServerAddr: n3.url, turnServerAddrList: n3.proxyInfo.addresses.map((e3) => e3.ip).join(","), eventType: "disabled", unilbsServerIds: [$V.CHOOSE_SERVER, $V.CLOUD_PROXY_FALLBACK].toString() }), _D.joinChooseServer(e2.sid, { lts: n3.requestTime, elapse: n3.elapse, succ: true, csAddr: n3.url, opid: n3.opid, serverList: n3.gatewayInfo.gatewayAddrs.map((e3) => e3.address), ec: null, cid: n3.gatewayInfo.cid.toString(), uid: n3.gatewayInfo.uid.toString(), csIp: n3.gatewayInfo.csIp, unilbsServerIds: [$V.CHOOSE_SERVER].toString(), isHttp3: n3.isHttp3 });
      }
      function Pj2(e2) {
        return window.atob(window.localStorage.getItem(e2) || "");
      }
      function Lj2(e2, t3) {
        window.localStorage.setItem(e2, window.btoa(t3));
      }
      function kj2(e2) {
        let t3 = "".concat(e2.appId, "_").concat(e2.cname);
        return "string" == typeof e2.uid && (t3 += "_s_".concat(e2.uid)), "number" == typeof e2.uid && (t3 += "_".concat(e2.uid)), e2.token && (t3 += "_".concat(e2.token)), MO(t3);
      }
      function Mj2(e2) {
        let t3 = function() {
          const e3 = Fj2.pop();
          return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
        }();
        return function(e3, t4) {
          let i2 = e3.appId;
          void 0 !== i2 && (Jj2(t4, 10), Yj2(t4, i2));
          let n3 = e3.cid;
          void 0 !== n3 && (Jj2(t4, 16), Jj2(t4, n3));
          let r2 = e3.cname;
          void 0 !== r2 && (Jj2(t4, 26), Yj2(t4, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (Jj2(t4, 34), Yj2(t4, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (Jj2(t4, 40), Qj2(t4, s2));
          let a3 = e3.fileSize;
          void 0 !== a3 && (Jj2(t4, 48), Qj2(t4, xj2(a3)));
          let c3 = e3.height;
          void 0 !== c3 && (Jj2(t4, 56), Qj2(t4, xj2(c3)));
          let d2 = e3.jpg;
          void 0 !== d2 && (Jj2(t4, 66), Jj2(t4, d2.length), Hj2(t4, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (Jj2(t4, 72), Qj2(t4, xj2(l2)));
          let u3 = e3.osType;
          void 0 !== u3 && (Jj2(t4, 80), Qj2(t4, xj2(u3)));
          let h2 = e3.requestId;
          void 0 !== h2 && (Jj2(t4, 90), Yj2(t4, h2));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (Jj2(t4, 98), Yj2(t4, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (Jj2(t4, 104), Qj2(t4, xj2(_2)));
          let E3 = e3.sid;
          void 0 !== E3 && (Jj2(t4, 114), Yj2(t4, E3));
          let m3 = e3.timestamp;
          void 0 !== m3 && (Jj2(t4, 120), Qj2(t4, m3));
          let f2 = e3.uid;
          void 0 !== f2 && (Jj2(t4, 128), Jj2(t4, f2));
          let S3 = e3.vid;
          void 0 !== S3 && (Jj2(t4, 136), Jj2(t4, S3));
          let g2 = e3.width;
          void 0 !== g2 && (Jj2(t4, 144), Qj2(t4, xj2(g2)));
          let T3 = e3.service;
          void 0 !== T3 && (Jj2(t4, 152), Jj2(t4, T3));
          let R3 = e3.callbackData;
          void 0 !== R3 && (Jj2(t4, 162), Jj2(t4, R3.length), Hj2(t4, R3));
          let v3 = e3.ticket;
          void 0 !== v3 && (Jj2(t4, 170), Yj2(t4, v3));
          let C2 = e3.vendorConfigs;
          void 0 !== C2 && (Jj2(t4, 178), Yj2(t4, C2));
        }(e2, t3), function(e3) {
          let t4 = e3.bytes, i2 = e3.limit;
          return t4.length === i2 ? t4 : t4.subarray(0, i2);
        }(t3);
      }
      function Uj2(e2) {
        return function(e3) {
          let t4 = {};
          e: for (; !jj2(e3); ) {
            let i2 = Xj2(e3);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t4.code = Xj2(e3);
                break;
              case 2:
                t4.msg = Kj2(e3, Xj2(e3));
                break;
              case 3:
                t4.requestId = Kj2(e3, Xj2(e3));
                break;
              case 4:
                t4.timestamp = Zj2(e3, false);
                break;
              default:
                Vj2(e3, 7 & i2);
            }
          }
          return t4;
        }({ bytes: t3 = e2, offset: 0, limit: t3.length });
        var t3;
      }
      function Vj2(e2, t3) {
        switch (t3) {
          case 0:
            for (; 128 & zj2(e2); ) ;
            break;
          case 2:
            Bj2(e2, Xj2(e2));
            break;
          case 5:
            Bj2(e2, 4);
            break;
          case 1:
            Bj2(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t3);
        }
      }
      function xj2(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let Fj2 = [];
      function Bj2(e2, t3) {
        if (e2.offset + t3 > e2.limit) throw new Error("Skip past limit");
        e2.offset += t3;
      }
      function jj2(e2) {
        return e2.offset >= e2.limit;
      }
      function Gj2(e2, t3) {
        let i2 = e2.bytes, n3 = e2.offset, r2 = e2.limit, o2 = n3 + t3;
        if (o2 > i2.length) {
          let t4 = new Uint8Array(2 * o2);
          t4.set(i2), e2.bytes = t4;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n3;
      }
      function Wj2(e2, t3) {
        let i2 = e2.offset;
        if (i2 + t3 > e2.limit) throw new Error("Read past limit");
        return e2.offset += t3, i2;
      }
      function Hj2(e2, t3) {
        let i2 = Gj2(e2, t3.length);
        e2.bytes.set(t3, i2);
      }
      function Kj2(e2, t3) {
        let i2 = Wj2(e2, t3), n3 = String.fromCharCode, r2 = e2.bytes, o2 = "ï¿½", s2 = "";
        for (let e3 = 0; e3 < t3; e3++) {
          let a3, c3, d2, l2, u3 = r2[e3 + i2];
          0 == (128 & u3) ? s2 += n3(u3) : 192 == (224 & u3) ? e3 + 1 >= t3 ? s2 += o2 : (a3 = r2[e3 + i2 + 1], 128 != (192 & a3) ? s2 += o2 : (l2 = (31 & u3) << 6 | 63 & a3, l2 < 128 ? s2 += o2 : (s2 += n3(l2), e3++))) : 224 == (240 & u3) ? e3 + 2 >= t3 ? s2 += o2 : (a3 = r2[e3 + i2 + 1], c3 = r2[e3 + i2 + 2], 32896 != (49344 & (a3 | c3 << 8)) ? s2 += o2 : (l2 = (15 & u3) << 12 | (63 & a3) << 6 | 63 & c3, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n3(l2), e3 += 2))) : 240 == (248 & u3) ? e3 + 3 >= t3 ? s2 += o2 : (a3 = r2[e3 + i2 + 1], c3 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a3 | c3 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u3) << 18 | (63 & a3) << 12 | (63 & c3) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n3(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function Yj2(e2, t3) {
        let i2 = t3.length, n3 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t3.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t3.charCodeAt(++e3) - 56613888), n3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        Jj2(e2, n3);
        let r2 = Gj2(e2, n3), o2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n4 = t3.charCodeAt(e3);
          n4 >= 55296 && n4 <= 56319 && e3 + 1 < i2 && (n4 = (n4 << 10) + t3.charCodeAt(++e3) - 56613888), n4 < 128 ? o2[r2++] = n4 : (n4 < 2048 ? o2[r2++] = n4 >> 6 & 31 | 192 : (n4 < 65536 ? o2[r2++] = n4 >> 12 & 15 | 224 : (o2[r2++] = n4 >> 18 & 7 | 240, o2[r2++] = n4 >> 12 & 63 | 128), o2[r2++] = n4 >> 6 & 63 | 128), o2[r2++] = 63 & n4 | 128);
        }
      }
      function zj2(e2) {
        return e2.bytes[Wj2(e2, 1)];
      }
      function qj2(e2, t3) {
        let i2 = Gj2(e2, 1);
        e2.bytes[i2] = t3;
      }
      function Xj2(e2) {
        let t3, i2 = 0, n3 = 0;
        do {
          t3 = zj2(e2), i2 < 32 && (n3 |= (127 & t3) << i2), i2 += 7;
        } while (128 & t3);
        return n3;
      }
      function Jj2(e2, t3) {
        for (t3 >>>= 0; t3 >= 128; ) qj2(e2, 127 & t3 | 128), t3 >>>= 7;
        qj2(e2, t3);
      }
      function Zj2(e2, t3) {
        let i2, n3 = 0, r2 = 0, o2 = 0;
        return i2 = zj2(e2), n3 = 127 & i2, 128 & i2 && (i2 = zj2(e2), n3 |= (127 & i2) << 7, 128 & i2 && (i2 = zj2(e2), n3 |= (127 & i2) << 14, 128 & i2 && (i2 = zj2(e2), n3 |= (127 & i2) << 21, 128 & i2 && (i2 = zj2(e2), r2 = 127 & i2, 128 & i2 && (i2 = zj2(e2), r2 |= (127 & i2) << 7, 128 & i2 && (i2 = zj2(e2), r2 |= (127 & i2) << 14, 128 & i2 && (i2 = zj2(e2), r2 |= (127 & i2) << 21, 128 & i2 && (i2 = zj2(e2), o2 = 127 & i2, 128 & i2 && (i2 = zj2(e2), o2 |= (127 & i2) << 7))))))))), { low: n3 | r2 << 28, high: r2 >>> 4 | o2 << 24, unsigned: t3 };
      }
      function Qj2(e2, t3) {
        let i2 = t3.low >>> 0, n3 = (t3.low >>> 28 | t3.high << 4) >>> 0, r2 = t3.high >>> 24, o2 = 0 === r2 ? 0 === n3 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n3 < 16384 ? n3 < 128 ? 5 : 6 : n3 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = Gj2(e2, o2), a3 = e2.bytes;
        switch (o2) {
          case 10:
            a3[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a3[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a3[s2 + 7] = 8 !== o2 ? n3 >>> 21 | 128 : n3 >>> 21 & 127;
          case 7:
            a3[s2 + 6] = 7 !== o2 ? n3 >>> 14 | 128 : n3 >>> 14 & 127;
          case 6:
            a3[s2 + 5] = 6 !== o2 ? n3 >>> 7 | 128 : n3 >>> 7 & 127;
          case 5:
            a3[s2 + 4] = 5 !== o2 ? 128 | n3 : 127 & n3;
          case 4:
            a3[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a3[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a3[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a3[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
        }
      }
      const $j = {}, eG = {}, tG = 4294967296, iG = tG * tG, nG = iG / 2, rG = dG(0, true), oG = dG(0), sG = lG(0, -2147483648, false), aG = lG(-1, 2147483647, false), cG = lG(-1, -1, true);
      function dG(e2, t3) {
        let i2, n3, r2;
        return t3 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n3 = eG[e2], n3) ? n3 : (i2 = lG(e2, 0, true), r2 && (eG[e2] = i2), i2) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n3 = $j[e2], n3) ? n3 : (i2 = lG(e2, e2 < 0 ? -1 : 0, false), r2 && ($j[e2] = i2), i2);
      }
      function lG(e2, t3, i2) {
        return { low: 0 | e2, high: 0 | t3, unsigned: !!i2 };
      }
      function uG(e2, t3) {
        if (isNaN(e2)) return t3 ? rG : oG;
        if (t3) {
          if (e2 < 0) return rG;
          if (e2 >= iG) return cG;
        } else {
          if (e2 <= -nG) return sG;
          if (e2 + 1 >= nG) return aG;
        }
        return e2 < 0 ? t3 ? rG : oG : lG(e2 % tG | 0, e2 / tG | 0, t3);
      }
      function hG(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      class pG extends Hw2 {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2) return;
          const t3 = this._connectionState;
          this._connectionState = e2, this.emit(wV.CONNECTION_STATE_CHANGE, e2, t3);
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this._qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          var t3;
          super(), uI(this, "name", "AgoraRTCImageModeration"), uI(this, "_connectionState", AV.CONNECTING), uI(this, "_sequence", 0), uI(this, "_moderationStartTime", void 0), uI(this, "_workerConnection", void 0), uI(this, "_workerMessageLengthLimit", void 0), uI(this, "_qualityRatio", void 0), uI(this, "_connectInfo", void 0), uI(this, "_cancelTokenSource", UA2.CancelToken.source()), uI(this, "_retryConfig", void 0), uI(this, "_moderationInterval", void 0), uI(this, "_moderationTimer", null), uI(this, "_moderationMode", 1), uI(this, "_quality", 1), uI(this, "_qualityTimer", null), uI(this, "_ticket", void 0), uI(this, "_moderationIntervalMinimum", void 0), uI(this, "_uploadFailedNum", 0), uI(this, "_uploadNum", 0), uI(this, "_uploadTimer", null), uI(this, "_extraInfo", void 0), uI(this, "_vendor", ""), uI(this, "_encoder", new TextEncoder()), uI(this, "_moderationId", void 0), uI(this, "inspectImage", () => {
            if (this.connectionState !== AV.CONNECTED) throw new ED(ww2.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
            this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
              this.connectionState === AV.CONNECTED ? this.requestToInspectImage() : sD.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
            }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
          }), this._moderationId = IO(5, "image-moderation-"), this._workerMessageLengthLimit = wN("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = wN("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t3 = e2.interval) && void 0 !== t3 ? t3 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), this._qualityRatio = wN("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new JV("worker-" + this._moderationId, BO), this.on(wV.STATE_CHANGE, (e3, t4) => {
            sD.debug("[".concat(this._moderationId, "] Moderation operation :").concat(OV[e3], " ").concat(t4 || ""));
          }), this.handleWorkerEvents();
        }
        async init(e2, t3) {
          this.emit(wV.STATE_CHANGE, OV.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t3, new ip2((n3, r2) => {
            this.on(wV.CONNECTION_STATE_CHANGE, (e3, t4) => {
              e3 === AV.CONNECTED && n3();
            }), this.requestAP(e2, i2, t3).then((e3) => {
              this.connectWorker(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        updateConfig(e2) {
          var t3;
          this._moderationInterval = null !== (t3 = e2.interval) && void 0 !== t3 ? t3 : 1e3, e2.extraInfo && (this._extraInfo = this._encoder.encode(e2.extraInfo)), e2.vendor && (this._vendor = e2.vendor), sD.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === AV.CONNECTED && this.inspectImage();
        }
        async requestAP(e2, t3, i2) {
          const n3 = wN("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t4, i3, n4) {
            let { appId: r3, areaCode: o3, cname: s3, sid: a3, token: c3, uid: d2 } = t4;
            AF++;
            const l2 = "moderation_plugin", u3 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s3, command: "allocateEdge", requestId: AF, seq: AF, sid: a3, appToken: c3, ts: Date.now(), uid: d2 + "" }) };
            let h2, p2, _2 = e3[0];
            return GO(async () => {
              h2 = Date.now();
              const e4 = await oF(_2, { data: u3, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h2, 0 !== e4.code) {
                const t6 = new ED(ww2.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw sD.error(t6.toString()), t6;
              }
              const t5 = JSON.parse(e4.json_body);
              if (200 !== t5.code) {
                const e5 = new ED(ww2.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t5.code, ", reason: ").concat(t5.reason), { code: t5.code, responseTime: p2 });
                throw sD.error(e5.toString()), e5;
              }
              if (!t5.servers || !Array.isArray(t5.servers) || 0 === t5.servers.length) {
                const e5 = new ED(ww2.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t5.code, responseTime: p2 });
                throw sD.error(e5.toString()), e5;
              }
              if (!t5.servers.some((e5) => !!e5.wss)) {
                const e5 = new ED(ww2.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t5.code, responseTime: p2 });
                throw sD.error(e5.toString()), e5;
              }
              const n5 = wN("IMAGE_MODERATION_WORKER_HOST");
              return { addressList: t5.servers.map((e5) => {
                let { address: t6, wss: i4 } = e5;
                if (t6 && i4) return "wss://".concat(t6.replace(/\./g, "-"), ".").concat(n5, ":").concat(i4, "/moderation");
              }).filter((e5) => !!e5), workerToken: t5.workerToken, vid: t5.vid, ticket: t5.appTicket, responseTime: p2 };
            }, (t5, i4) => (_D.apworkerEvent(a3, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t5.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t5, i4) => (_D.apworkerEvent(a3, { success: false, sc: t5.data && t5.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t5.code !== ww2.OPERATION_ABORTED && t5.code !== ww2.UNEXPECTED_RESPONSE || t5.data && t5.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n4);
          }(n3, e2, t3, i2);
          this.emit(wV.STATE_CHANGE, OV.AP_CONNECTED);
          const { addressList: o2, ticket: s2 } = r2;
          return this._ticket = s2, o2;
        }
        async connectWorker(e2) {
          this.emit(wV.STATE_CHANGE, OV.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
        }
        handleWorkerEvents() {
          this._workerConnection.on(jU.CONNECTED, async () => {
            this.emit(wV.STATE_CHANGE, OV.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = AV.CONNECTED;
          }), this._workerConnection.on(jU.CLOSED, () => {
            this.connectionState = AV.CLOSED;
          }), this._workerConnection.on(jU.FAILED, () => {
            this.connectionState = AV.CLOSED;
          }), this._workerConnection.on(jU.RECONNECTING, () => {
            this.connectionState = this.connectionState === AV.CONNECTED ? AV.RECONNECTING : AV.CONNECTING;
          }), this._workerConnection.on(jU.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const t3 = Uj2(new Uint8Array(e2.data));
              wN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && sD.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t3)), this._uploadNum++, void 0 === t3.code || 0 === t3.code || (this._uploadFailedNum++, sD.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t3.code, ", msg is ").concat(t3.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
                _D.reportApiInvoke(this._connectInfo.sid || null, { name: zw2.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t3.code], tag: qw2.TRACER }).onError(new ED(ww2.IMAGE_MODERATION_UPLOAD_FAILED, t3.msg)), this._uploadTimer = null;
              }, wN("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
            } else sD.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
          }), this._workerConnection.on(jU.WILL_RECONNECT, (e2, t3, i2) => {
            "recover" === e2 && i2(e2), i2("tryNext");
          }), this._workerConnection.on(jU.REQUEST_NEW_URLS, (e2, t3) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t3);
          });
        }
        static intToLong(e2) {
          return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
        }
        async requestToInspectImage() {
          const e2 = aO(this, wV.CLIENT_LOCAL_VIDEO_TRACK), t3 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying) return void (wN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && sD.debug("Only the track being played can be inspected"));
            this._sequence++;
            const i2 = await this.generateRequestData(e2, t3);
            this._workerConnection.sendMessage(i2, true, true);
          } else wN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && sD.debug("Only the track being published can be inspected");
        }
        async generateRequestData(e2, t3) {
          let { appId: i2, cname: n3, cid: r2, vid: o2, sid: s2, uid: a3 } = t3;
          const c3 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await ZP(d2, i2, n3), u3 = this._sequence + "-" + r2 + "-" + a3 + "-" + c3 + "-" + IO(12, ""), h2 = { appId: i2, cid: r2, cname: n3, deviceId: "", elapse: pG.intToLong(Number(c3 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u3, sdkVersion: "4.24.0", sequence: this._sequence, sid: s2, timestamp: uG(c3), uid: a3, vid: o2, service: this._moderationMode, ticket: this._ticket, callbackData: this._extraInfo, vendorConfigs: this._vendor };
          void 0 === this._extraInfo && delete h2.callbackData;
          const p2 = Mj2(h2);
          if (p2.byteLength < this._workerMessageLengthLimit) {
            if (wN("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t4 = 1; t4 < arguments.length; t4++) {
                  var i3 = null != arguments[t4] ? arguments[t4] : {};
                  t4 % 2 ? hG(Object(i3), true).forEach(function(t5) {
                    uI(e4, t5, i3[t5]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : hG(Object(i3)).forEach(function(t5) {
                    Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(i3, t5));
                  });
                }
                return e4;
              }({}, h2);
              delete e3.jpg, sD.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
            }
            return p2;
          }
          {
            const t4 = this.quality * this._qualityRatio;
            return this.quality = t4, await this.generateRequestData(e2, { appId: i2, cname: n3, cid: r2, vid: o2, sid: s2, uid: a3 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = UA2.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = AV.CLOSED, this.emit(wV.STATE_CHANGE, OV.CLOSED);
        }
      }
      function _G(e2) {
        if (Pw2(e2.interval, "interval", 1e3, 1 / 0), e2 && e2.extraInfo && e2.extraInfo.length > 1024) throw new ED(ww2.INVALID_PARAMS, "config.extraInfo length cannot exceed 1024 bytes");
        if (e2 && e2.vendor && e2.vendor.length > 1024) throw new ED(ww2.INVALID_PARAMS, "config.vendor length cannot exceed 1024 bytes");
      }
      const EG = { name: "ImageModeration", create: function(e2) {
        let { config: t3 } = e2;
        return _G(t3), new pG(t3);
      } };
      var mG, fG, SG, gG, TG, RG, vG, CG, yG, IG, bG, AG, wG, OG, NG, DG, PG, LG, kG, MG, UG, VG, xG, FG, BG, jG, GG, WG, HG, KG, YG, zG, qG, XG, JG, ZG, QG, $G, eW, tW, iW, nW;
      function rW(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function oW(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? rW(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : rW(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      xO.setLogger(sD);
      let sW = (mG = pD2(), fG = pD2({ argsMap: (e2, t3) => {
        if (!Array.isArray(t3)) {
          if (!(t3 instanceof uP)) return [t3];
          t3 = [t3];
        }
        return t3.map((e3) => e3 ? Object(e3).toString() : "null");
      } }), SG = pD2({ argsMap: (e2, t3) => (t3 || (t3 = []), Array.isArray(t3) || t3.trackMediaType !== KD.DATA ? (Array.isArray(t3) || (t3 = [t3]), t3.map((e3) => e3.getTrackId())) : [t3.getChannelId()]) }), gG = pD2({ argsMap: (e2, t3, i2, n3) => ["object" == typeof t3 ? t3.uid : t3, i2, n3] }), TG = pD2({ argsMap: (e2, t3, i2) => [t3, i2] }), RG = pD2({ argsMap: (e2, t3) => t3.map((e3) => {
        let { user: t4, mediaType: i2 } = e3;
        return [null == t4 ? void 0 : t4.uid, i2];
      }) }), vG = pD2({ argsMap: (e2, t3, i2, n3) => ["object" == typeof t3 ? t3.uid : t3, i2, n3] }), CG = pD2({ argsMap: (e2, t3) => t3.map((e3) => {
        let { user: t4, mediaType: i2 } = e3;
        return { uid: null == t4 ? void 0 : t4.uid, mediaType: i2 };
      }) }), yG = pD2(), IG = pD2(), bG = pD2(), AG = pD2(), wG = pD2(), OG = pD2(), NG = pD2(), DG = pD2(), PG = pD2(), LG = pD2(), kG = pD2(), MG = pD2(), UG = pD2(), VG = pD2(), xG = pD2(), FG = pD2({ argsMap: (e2, t3) => [t3] }), BG = pD2(), jG = pD2(), GG = pD2(), WG = pD2(), HG = pD2(), KG = pD2(), YG = pD2(), zG = pD2(), qG = pD2({ argsMap: (e2, t3) => (Array.isArray(t3) || (t3 = [t3]), [JSON.stringify(t3)]) }), XG = pD2(), JG = pD2(), ZG = pD2(), QG = pD2(), $G = pD2(), eW = pD2(), tW = pD2({ reportResult: true }), iW = pD2(), nW = class extends Hw2 {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get localDataChannels() {
          return this._p2pChannel.getAllDataChannels();
        }
        get mode() {
          return this._config.mode;
        }
        get role() {
          var e2;
          return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
        }
        get codec() {
          return this._config.codec;
        }
        get audioCodec() {
          return this._config.audioCodec || "opus";
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        get __className__() {
          return "Client";
        }
        constructor(e2, t3) {
          let i2;
          if (super(), uI(this, "store", void 0), uI(this, "_uid", void 0), uI(this, "_channelName", void 0), uI(this, "_uintUid", void 0), uI(this, "_users", []), uI(this, "_config", void 0), uI(this, "_clientId", void 0), uI(this, "_appId", void 0), uI(this, "_sessionId", null), uI(this, "_key", void 0), uI(this, "_rtmConfig", {}), uI(this, "_joinInfo", void 0), uI(this, "_gateway", void 0), uI(this, "_statsCollector", void 0), uI(this, "_configDistribute", void 0), uI(this, "_leaveMutex", void 0), uI(this, "_publishMutex", void 0), uI(this, "_renewTokenMutex", void 0), uI(this, "_subscribeMutex", void 0), uI(this, "_encryptionMode", "none"), uI(this, "_encryptionSecret", null), uI(this, "_encryptionSalt", null), uI(this, "_encryptDataStream", false), uI(this, "_encryptDataStreamKey", null), uI(this, "_encryptDataStreamIv", null), uI(this, "_proxyServer", void 0), uI(this, "_turnServer", { servers: [], mode: "auto" }), uI(this, "_cloudProxyServerMode", "disabled"), uI(this, "_isDualStreamEnabled", false), uI(this, "_defaultStreamFallbackType", void 0), uI(this, "_lowStreamParameter", void 0), uI(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), uI(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), uI(this, "_axiosCancelSource", UA2.CancelToken.source()), uI(this, "_audioVolumeIndicationInterval", void 0), uI(this, "_networkQualityInterval", void 0), uI(this, "_userOfflineTimeout", void 0), uI(this, "_streamRemovedTimeout", void 0), uI(this, "_liveTranscodeStreamingClient", void 0), uI(this, "_liveRawStreamingClient", void 0), uI(this, "_channelMediaRelayClient", void 0), uI(this, "_networkQualitySensitivity", "normal"), uI(this, "_p2pChannel", void 0), uI(this, "_useLocalAccessPoint", false), uI(this, "_setLocalAPVersion", void 0), uI(this, "_joinAndNotLeaveYet", false), uI(this, "_numberOfJoinCount", 0), uI(this, "_joinResponse", null), uI(this, "_remoteDefaultVideoStreamType", void 0), uI(this, "_inspect", void 0), uI(this, "_moderation", void 0), uI(this, "_license", void 0), uI(this, "_pendingPublishedUsers", []), uI(this, "ntpAlignErrorCount", 0), uI(this, "remoteInboundOffset", 0), uI(this, "_peerConnectionState", void 0), uI(this, "_handleLocalTrackEnable", (e3, t4, i3) => {
            this.publish(e3, false).then(t4).catch(i3);
          }), uI(this, "_handleLocalTrackDisable", (e3, t4, i3) => {
            this.unpublish(e3).then(t4).catch(i3);
          }), uI(this, "_handleUserOnline", (e3) => {
            if (wN("BLOCK_LOCAL_CLIENT") && KM(e3.uid, this.channelName)) return void sD.debug("[".concat(e3.uid, "] will be ignored in local"));
            this.isStringUID && "string" != typeof e3.uid && sD.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
            const t4 = this._users.find((t5) => t5.uid === e3.uid);
            if (t4) t4._trust_in_room_ = true, t4._is_pre_created && (t4._is_pre_created = false, this.safeEmit(tO.USER_JOINED, t4));
            else {
              const t5 = new QF(e3.uid, e3.uint_id || e3.uid);
              this._users.push(t5), sD.debug("[".concat(this._clientId, "] user online"), e3.uid), this.store.firstVideoFrameDecoded(t5.uid, { userJoinNotify: Date.now() }), this.safeEmit(tO.USER_JOINED, t5);
            }
          }), uI(this, "_handleUserOffline", (e3) => {
            if (wN("BLOCK_LOCAL_CLIENT") && KM(e3.uid, this.channelName)) return;
            const t4 = this._users.find((t5) => t5.uid === e3.uid);
            t4 && (this._handleRemoveStream(e3), this._handleRemoveDataChannels(e3), t4._audio_pre_subscribed || t4._video_pre_subscribed ? t4._is_pre_created = true : lO(this._users, t4), this._remoteStreamTypeCacheMap.delete(t4.uid), this._streamFallbackTypeCacheMap.delete(t4.uid), sD.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(tO.USER_LEAVED, t4, e3.reason));
          }), uI(this, "_handleAddAudioOrVideoStream", (e3, t4, i3, n4, r2, o2, s2, a3) => {
            if (wN("BLOCK_LOCAL_CLIENT") && KM(t4, this.channelName)) return;
            const c3 = this._users.find((e4) => e4.uid === t4);
            if (!c3) return void sD.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            sD.debug("[".concat(this._clientId, "] stream added with uid ").concat(t4, ", type ").concat(e3)), this.store.subscribe(c3.uid, e3, void 0, void 0, void 0, Date.now()), "video" === e3 && this.store.firstVideoFrameDecoded(c3.uid, { videoAddNotify: Date.now() });
            const d2 = "audio" === e3 ? c3.hasAudio : c3.hasVideo;
            if (c3._uintid || (c3._uintid = o2 || t4), "audio" === e3 ? c3._trust_audio_stream_added_state_ = true : c3._trust_video_stream_added_state_ = true, "audio" === e3 ? (c3._audio_added_ = true, void 0 !== i3 && (c3._audioSSRC = i3), void 0 !== n4 && (c3._cname = n4), s2 && (c3._audioOrtc = s2)) : (c3._video_added_ = true, void 0 !== i3 && (c3._videoSSRC = i3), void 0 !== n4 && (c3._cname = n4), void 0 !== a3 && (c3._rtxSsrcId = a3), s2 && (c3._videoOrtc = s2)), ("audio" === e3 ? c3.hasAudio : c3.hasVideo) && !d2 && (sD.info("[".concat(this._clientId, "] remote user ").concat(c3.uid, " published ").concat(e3)), this.safeEmit(tO.USER_PUBLISHED, c3, e3)), "video" === e3 ? _D.onGatewayStream(this._sessionId, lD2.ON_ADD_VIDEO_STREAM, uD.ON_ADD_VIDEO_STREAM, { peer: o2 || t4, ssrc: c3._videoSSRC }) : _D.onGatewayStream(this._sessionId, lD2.ON_ADD_AUDIO_STREAM, uD.ON_ADD_AUDIO_STREAM, { peer: o2 || t4, ssrc: c3._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(c3, e3, i3).then((t5) => {
              if (t5 && (sD.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(c3.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof tj2)) return this._p2pChannel.unsubscribe(c3, e3, true).then(() => this._subscribe(c3, e3, true).catch((e4) => {
                sD.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
              }));
            }), this._p2pChannel.hasPendingRemoteMedia(c3, e3) && (sD.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(c3.uid, " after reconnect.")), this._subscribe(c3, e3, true).catch((e4) => {
              sD.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            })), "video" === e3 && !$A2() && !nw2()) {
              const e4 = this._getEncodingName(r2);
              (null == e4 ? void 0 : e4.toLocaleLowerCase()) == PN.av1 && DF().then((t5) => {
                t5 || this._gateway.downgradeCodec(e4);
              });
            }
          }), uI(this, "_handleRemoveStream", (e3) => {
            if (wN("BLOCK_LOCAL_CLIENT") && KM(e3.uid, this.channelName)) return;
            const t4 = this._users.find((t5) => t5.uid === e3.uid);
            if (!t4) return void sD.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
            sD.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
            let i3 = () => {
            };
            t4.hasAudio && t4.hasVideo ? i3 = () => {
              sD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished audio track")), this.safeEmit(tO.USER_UNPUBLISHED, t4, "audio"), sD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished video track")), this.safeEmit(tO.USER_UNPUBLISHED, t4, "video");
            } : t4.hasVideo ? i3 = () => {
              sD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished video track")), this.safeEmit(tO.USER_UNPUBLISHED, t4, "video");
            } : t4.hasAudio && (i3 = () => {
              sD.info("[".concat(this._clientId, "] remote user ").concat(t4.uid, " unpublished audio track")), this.safeEmit(tO.USER_UNPUBLISHED, t4, "audio");
            }), t4._video_pre_subscribed || t4._audio_pre_subscribed || (t4._trust_audio_stream_added_state_ = true, t4._trust_video_stream_added_state_ = true, t4._audio_added_ = false, t4._video_added_ = false, this._p2pChannel instanceof tj2 && this._p2pChannel.unsubscribe(t4).then((e4) => {
              if (e4) return this._gateway.unsubscribe(e4, t4.uid);
            }), t4._audioSSRC = void 0, t4._videoSSRC = void 0, t4._audioOrtc = void 0, t4._videoOrtc = void 0, t4._rtxSsrcId = void 0), _D.onGatewayStream(this._sessionId, lD2.ON_REMOVE_STREAM, uD.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), i3();
          }), uI(this, "_handleSetStreamLocalEnable", (e3, t4, i3) => {
            if (wN("BLOCK_LOCAL_CLIENT") && KM(t4, this.channelName)) return;
            const n4 = this._users.find((e4) => e4.uid === t4);
            if (!n4) return void sD.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
            sD.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i3 ? "enabled" : "disabled", " with uid ").concat(t4));
            const r2 = "audio" === e3 ? n4.hasAudio : n4.hasVideo;
            if ("audio" === e3) {
              n4._trust_audio_enabled_state_ = true;
              const e4 = n4._audio_enabled_;
              if (n4._audio_enabled_ = i3, n4._audio_enabled_ === e4) return;
              {
                const e5 = n4._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                sD.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t4, ", msg: ").concat(e5)), this.safeEmit(tO.USER_INFO_UPDATED, t4, e5);
              }
            } else {
              n4._trust_video_enabled_state_ = true;
              const e4 = n4._video_enabled_;
              if (n4._video_enabled_ = i3, n4._video_enabled_ === e4) return;
              {
                const e5 = n4._video_enabled_ ? "enable-local-video" : "disable-local-video";
                sD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t4, ", msg: ").concat(e5)), this.safeEmit(tO.USER_INFO_UPDATED, t4, e5);
              }
            }
            const o2 = "audio" === e3 ? n4.hasAudio : n4.hasVideo;
            return r2 !== o2 ? !r2 && o2 ? (sD.info("[".concat(this._clientId, "] remote user ").concat(t4, " published ").concat(e3)), void this.safeEmit(tO.USER_PUBLISHED, n4, e3)) : ("video" === e3 && n4._videoTrack && n4._videoTrack._destroy(), "audio" === e3 && n4._audioTrack, this._p2pChannel.muteRemote(n4, e3), sD.info("[".concat(this._clientId, "] remote user ").concat(t4, " unpublished ").concat(e3)), void this.safeEmit(tO.USER_UNPUBLISHED, n4, e3)) : void 0;
          }), uI(this, "_handleMuteStream", (e3, t4, i3) => {
            if (wN("BLOCK_LOCAL_CLIENT") && KM(e3, this.channelName)) return;
            sD.debug("[".concat(this._clientId, "] receive mute message"), e3, t4, i3);
            const n4 = this._users.find((t5) => t5.uid === e3);
            if (!n4) return void sD.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
            const r2 = "audio" === t4 ? n4.hasAudio : n4.hasVideo;
            if ("audio" === t4) {
              n4._trust_audio_mute_state_ = true;
              const t5 = n4._audio_muted_;
              if (n4._audio_muted_ = i3, n4._audio_muted_ === t5) return;
              {
                const t6 = n4._audio_muted_ ? "mute-audio" : "unmute-audio";
                sD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t6)), this.safeEmit(tO.USER_INFO_UPDATED, e3, t6);
              }
            } else {
              n4._trust_video_mute_state_ = true;
              const t5 = n4._video_muted_;
              if (n4._video_muted_ = i3, n4._video_muted_ === t5) return;
              {
                const t6 = n4._video_muted_ ? "mute-video" : "unmute-video";
                sD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t6)), this.safeEmit(tO.USER_INFO_UPDATED, e3, t6);
              }
            }
            const o2 = "audio" === t4 ? n4.hasAudio : n4.hasVideo;
            if (r2 !== o2) {
              if (!r2 && o2) {
                return ("audio" === t4 ? n4._audioSSRC : n4._videoSSRC) ? (sD.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t4)), void this.safeEmit(tO.USER_PUBLISHED, n4, t4)) : void sD.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t4, " unmute message  before add stream message, ").concat(t4, " SSRC doesn't exist yet."));
              }
              "video" === t4 && n4._videoTrack && !n4._video_pre_subscribed && n4._videoTrack._destroy(), "audio" === t4 && n4._audioTrack, this._p2pChannel.muteRemote(n4, t4), sD.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t4)), this.safeEmit(tO.USER_UNPUBLISHED, n4, t4);
            }
          }), uI(this, "_handleP2PLost", async (e3) => {
            sD.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : sD.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
          }), uI(this, "_handleTokenWillExpire", () => {
            sD.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(tO.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }), uI(this, "_handleBeforeUnload", (e3) => {
            "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), sD.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
          }), uI(this, "_handleUpdateNetworkQuality", () => {
            if ("normal" === this._networkQualitySensitivity) return;
            if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.safeEmit(tO.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(tO.NETWORK_QUALITY, e3);
          }), uI(this, "_handleP2PAddAudioOrVideoStream", (e3, t4, i3, n4) => {
            const r2 = this._users.find((e4) => e4.uid === t4);
            if (!r2) return void sD.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
            sD.debug("[".concat(this._clientId, "] stream added with uid ").concat(t4, ", type ").concat(e3)), this.store.subscribe(r2.uid, e3, void 0, void 0, void 0, Date.now());
            const o2 = "audio" === e3 ? r2.hasAudio : r2.hasVideo;
            "audio" === e3 ? r2._trust_audio_stream_added_state_ = true : r2._trust_video_stream_added_state_ = true, "audio" === e3 ? (r2._audio_added_ = true, void 0 !== i3 && (r2._audioSSRC = i3), void 0 !== n4 && (r2._audioMid = n4)) : (r2._video_added_ = true, void 0 !== i3 && (r2._videoSSRC = i3), void 0 !== n4 && (r2._videoMid = n4)), ("audio" === e3 ? r2.hasAudio : r2.hasVideo) && !o2 && (sD.info("[".concat(this._clientId, "] remote user ").concat(r2.uid, " published ").concat(e3)), this.safeEmit(tO.USER_PUBLISHED, r2, e3)), this._p2pChannel.hasPendingRemoteMedia(r2, e3) && (sD.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(r2.uid, " after reconnect.")), this._subscribe(r2, e3, true).catch((e4) => {
              sD.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
            }));
          }), this._config = e2, this._clientId = t3 || IO(5, "client-"), this.store = new class {
            constructor(e3, t4, i3, n4) {
              Iw2(this, "state", void 0), this.state = { codec: e3, audioCodec: t4, mode: i3, clientId: n4, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, keyMetrics: { publish: [], subscribe: [], firstVideoFrameDecoded: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useP2P: false, p2pTransport: TN.Default, hasStartJoinChannel: false, isABTestSuccess: false, autoSubscribe: false, enableInstantMuteRestore: false };
            }
            dispatch(e3) {
              this.state = function(e4, t4) {
                switch (t4.type) {
                  case DN.SET_SESSION_ID:
                    return Aw2(Aw2({}, e4), {}, { sessionId: t4.sessionId });
                  case DN.SET_P2P_ID:
                    return Aw2(Aw2({}, e4), {}, { p2pId: t4.p2pId });
                  case DN.SET_UID:
                    return Aw2(Aw2({}, e4), {}, { uid: t4.uid });
                  case DN.SET_INT_UID:
                    return Aw2(Aw2({}, e4), {}, { intUid: t4.intUid });
                  case DN.SET_PUB_ID:
                    return Aw2(Aw2({}, e4), {}, { pubId: t4.pubId });
                  case DN.KEY_METRIC_CLIENT_CREATED:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { clientCreated: t4.metric }) });
                  case DN.KEY_METRIC_JOIN_START:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { joinStart: t4.metric }) });
                  case DN.KEY_METRIC_PRELOAD_START:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { preloadStart: t4.metric }) });
                  case DN.KEY_METRIC_PRELOAD_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { preloadEnd: t4.metric }) });
                  case DN.KEY_METRIC_JOIN_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { joinEnd: t4.metric }) });
                  case DN.KEY_METRIC_REQUEST_AP_START:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { requestAPStart: t4.metric }) });
                  case DN.KEY_METRIC_REQUEST_AP_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { requestAPEnd: t4.metric }) });
                  case DN.KEY_METRIC_REQUEST_SUA_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { requestSUAEnd: t4.metric }) });
                  case DN.KEY_METRIC_BEFORE_CONNECT:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { beforeConnect: t4.metric }) });
                  case DN.KEY_METRIC_PEER_RECEIVER:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { peerReceiver: t4.metric }) });
                  case DN.KEY_METRIC_SIGNAL_CONNECTED:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { signalConnected: t4.metric }) });
                  case DN.KEY_METRIC_JOIN_REQ:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { joinReq: t4.metric }) });
                  case DN.KEY_METRIC_JOIN_REP:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { joinRep: t4.metric }) });
                  case DN.KEY_METRIC_JOIN_GATEWAY_START:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { joinGatewayStart: t4.metric }) });
                  case DN.KEY_METRIC_JOIN_GATEWAY_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { joinGatewayEnd: t4.metric }) });
                  case DN.KEY_METRIC_PEER_CONNECTION_START:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { peerConnectionStart: t4.metric }) });
                  case DN.KEY_METRIC_PEER_CONNECTION_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { peerConnectionEnd: t4.metric }) });
                  case DN.KEY_METRIC_DESCRIPTION_START:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { descriptionStart: t4.metric }) });
                  case DN.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { signalChannelOpen: t4.metric }) });
                  case DN.KEY_METRIC_ICE_CONNECTION_END:
                    return Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { iceConnectionEnd: t4.metric }) });
                  case DN.KEY_METRIC_PUBLISH: {
                    const i3 = e4.keyMetrics.publish, n4 = i3.findIndex((e5) => e5.trackId === t4.metric.trackId);
                    return -1 !== n4 ? (i3[n4] = Aw2(Aw2({}, i3[n4]), t4.metric), Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { publish: [...i3] }) })) : Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { publish: [...e4.keyMetrics.publish, t4.metric] }) });
                  }
                  case DN.KEY_METRIC_SUBSCRIBE: {
                    const i3 = e4.keyMetrics.subscribe, n4 = i3.findIndex((e5) => e5.userId === t4.metric.userId && e5.type === t4.metric.type);
                    return -1 !== n4 ? (i3[n4] = Aw2(Aw2({}, i3[n4]), t4.metric), Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { subscribe: [...i3] }) })) : Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { subscribe: [...e4.keyMetrics.subscribe, t4.metric] }) });
                  }
                  case DN.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED: {
                    const i3 = e4.keyMetrics.firstVideoFrameDecoded, n4 = i3.findIndex((e5) => e5.userId === t4.metric.userId);
                    return -1 !== n4 ? (i3[n4] = Aw2(Aw2({}, i3[n4]), t4.metric), Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { firstVideoFrameDecoded: [...i3] }) })) : Aw2(Aw2({}, e4), {}, { keyMetrics: Aw2(Aw2({}, e4.keyMetrics), {}, { firstVideoFrameDecoded: [...e4.keyMetrics.firstVideoFrameDecoded, t4.metric] }) });
                  }
                  case DN.RESET_FIRST_VIDEO_FRAME_DECODED:
                    return e4.keyMetrics.firstVideoFrameDecoded = [], e4;
                  case DN.SET_CLOUD_PROXY_SERVER_MODE:
                    return e4.cloudProxyServerMode = t4.mode, e4;
                  case DN.RECORD_JOIN_CHANNEL_SERVICE:
                    return "number" != typeof t4.index ? e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords, t4.record] : (e4.joinChannelServiceRecords[t4.index] = Aw2(Aw2({}, e4.joinChannelServiceRecords[t4.index]), t4.record), e4.joinChannelServiceRecords = [...e4.joinChannelServiceRecords]), e4;
                  case DN.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                    return e4.joinChannelServiceRecords = [], e4;
                  case DN.RESET_KEY_METRICS:
                    return e4.keyMetrics = { publish: [], subscribe: [], firstVideoFrameDecoded: [] }, e4;
                  case DN.SET_USE_P2P:
                    return Aw2(Aw2({}, e4), {}, { useP2P: t4.val });
                  case DN.SET_TRANSPORT_TYPE:
                    return Aw2(Aw2({}, e4), {}, { p2pTransport: t4.val });
                  default:
                    return e4;
                }
              }(this.state, e3);
            }
            set autoSubscribe(e3) {
              this.state.autoSubscribe = e3;
            }
            get autoSubscribe() {
              return this.state.autoSubscribe;
            }
            set enableInstantMuteRestore(e3) {
              this.state.enableInstantMuteRestore = e3;
            }
            get enableInstantMuteRestore() {
              return this.state.enableInstantMuteRestore;
            }
            set sessionId(e3) {
              this.dispatch({ type: DN.SET_SESSION_ID, sessionId: e3 });
            }
            get sessionId() {
              return this.state.sessionId;
            }
            set cid(e3) {
              this.state.cid = e3;
            }
            get cid() {
              return this.state.cid;
            }
            set codec(e3) {
              this.state.codec = e3;
            }
            get codec() {
              return this.state.codec;
            }
            get mode() {
              return this.state.mode;
            }
            get audioCodec() {
              return this.state.audioCodec;
            }
            get clientId() {
              return this.state.clientId;
            }
            set p2pId(e3) {
              this.dispatch({ type: DN.SET_P2P_ID, p2pId: e3 });
            }
            get p2pId() {
              return this.state.p2pId;
            }
            set dcId(e3) {
              this.dispatch({ type: DN.SET_DC_ID, dcId: e3 });
            }
            get dcId() {
              return this.state.dcId;
            }
            set uid(e3) {
              this.dispatch({ type: DN.SET_UID, uid: e3 });
            }
            get uid() {
              return this.state.uid;
            }
            set intUid(e3) {
              this.dispatch({ type: DN.SET_INT_UID, intUid: e3 });
            }
            get intUid() {
              return this.state.intUid;
            }
            set pubId(e3) {
              this.dispatch({ type: DN.SET_PUB_ID, pubId: e3 });
            }
            get pubId() {
              return this.state.pubId;
            }
            set cloudProxyServerMode(e3) {
              this.dispatch({ type: DN.SET_CLOUD_PROXY_SERVER_MODE, mode: e3 });
            }
            get cloudProxyServerMode() {
              return this.state.cloudProxyServerMode;
            }
            set useP2P(e3) {
              this.dispatch({ type: DN.SET_USE_P2P, val: e3 });
            }
            get useP2P() {
              return this.state.useP2P;
            }
            set p2pTransport(e3) {
              this.dispatch({ type: DN.SET_TRANSPORT_TYPE, val: e3 });
            }
            get p2pTransport() {
              return this.state.p2pTransport;
            }
            set hasStartJoinChannel(e3) {
              this.state.hasStartJoinChannel = e3;
            }
            get hasStartJoinChannel() {
              return this.state.hasStartJoinChannel;
            }
            set isABTestSuccess(e3) {
              this.state.isABTestSuccess = e3;
            }
            get isABTestSuccess() {
              return this.state.isABTestSuccess;
            }
            clientCreated() {
              this.dispatch({ type: DN.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
            }
            joinStart() {
              this.dispatch({ type: DN.KEY_METRIC_JOIN_START, metric: Date.now() });
            }
            preloadStart() {
              this.dispatch({ type: DN.KEY_METRIC_PRELOAD_START, metric: Date.now() });
            }
            preloadEnd() {
              this.dispatch({ type: DN.KEY_METRIC_PRELOAD_END, metric: Date.now() });
            }
            joinEnd() {
              this.dispatch({ type: DN.KEY_METRIC_JOIN_END, metric: Date.now() });
            }
            requestAPStart() {
              this.dispatch({ type: DN.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
            }
            requestAPEnd() {
              this.dispatch({ type: DN.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
            }
            requestSUAEnd() {
              this.dispatch({ type: DN.KEY_METRIC_REQUEST_SUA_END, metric: Date.now() });
            }
            beforeConnect() {
              this.dispatch({ type: DN.KEY_METRIC_BEFORE_CONNECT, metric: Date.now() });
            }
            peerReceiver() {
              this.dispatch({ type: DN.KEY_METRIC_PEER_RECEIVER, metric: Date.now() });
            }
            signalConnected() {
              this.dispatch({ type: DN.KEY_METRIC_SIGNAL_CONNECTED, metric: Date.now() });
            }
            joinReq() {
              this.dispatch({ type: DN.KEY_METRIC_JOIN_REQ, metric: Date.now() });
            }
            joinRep() {
              this.dispatch({ type: DN.KEY_METRIC_JOIN_REP, metric: Date.now() });
            }
            joinGatewayStart() {
              this.dispatch({ type: DN.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
            }
            joinGatewayEnd() {
              this.dispatch({ type: DN.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
            }
            peerConnectionStart() {
              this.dispatch({ type: DN.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
            }
            peerConnectionEnd() {
              this.dispatch({ type: DN.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
            }
            firstVideoFrameDecoded(e3, t4) {
              this.dispatch({ type: DN.KEY_METRIC_FIRST_VIDEO_FRAME_DECODED, metric: Aw2({ userId: e3 }, t4) });
            }
            descriptionStart() {
              this.dispatch({ type: DN.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
            }
            signalChannelOpen() {
              this.dispatch({ type: DN.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
            }
            iceConnectionEnd() {
              this.dispatch({ type: DN.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
            }
            publish(e3, t4, i3, n4) {
              this.dispatch({ type: DN.KEY_METRIC_PUBLISH, metric: Aw2(Aw2({ trackId: e3, type: t4 }, i3 && { publishStart: i3 }), n4 && { publishEnd: n4 }) });
            }
            subscribe(e3, t4, i3, n4, r2, o2, s2) {
              this.dispatch({ type: DN.KEY_METRIC_SUBSCRIBE, metric: Aw2(Aw2(Aw2(Aw2(Aw2({ userId: e3, type: t4 }, i3 && { subscribeStart: i3 }), n4 && { subscribeEnd: n4 }), r2 && { firstFrame: r2 }), o2 && { streamAdded: o2 }), s2 && { firstDecoded: s2 }) });
            }
            massSubscribe(e3, t4, i3, n4) {
              e3.forEach((e4) => {
                this.dispatch({ type: DN.KEY_METRIC_SUBSCRIBE, metric: Aw2(Aw2(Aw2({ userId: e4.userId, type: e4.type }, t4 && { subscribeStart: t4 }), i3 && { subscribeEnd: i3 }), n4 && { firstFrame: n4 }) });
              });
            }
            get keyMetrics() {
              return this.state.keyMetrics;
            }
            recordJoinChannelService(e3, t4) {
              "gateway" === e3.service && Array.isArray(e3.urls) && (e3.urls = e3.urls.map((e4) => e4.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
              try {
                return "number" != typeof t4 ? (this.dispatch({ type: DN.RECORD_JOIN_CHANNEL_SERVICE, record: Aw2(Aw2({}, e3), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t4 < 0 || t4 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: DN.RECORD_JOIN_CHANNEL_SERVICE, record: e3, index: t4 }), t4);
              } catch (e4) {
                return 0;
              }
            }
            resetJoinChannelServiceRecords() {
              this.dispatch({ type: DN.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
            }
            resetKeyMetrics() {
              this.dispatch({ type: DN.RESET_KEY_METRICS });
            }
            resetFirstVideoFrameDecoded() {
              this.dispatch({ type: DN.RESET_FIRST_VIDEO_FRAME_DECODED });
            }
            get joinChannelServiceRecords() {
              try {
                return this.state.joinChannelServiceRecords;
              } catch (e3) {
                return [];
              }
            }
          }(e2.codec, e2.audioCodec, e2.mode, this._clientId), this._leaveMutex = new xO("client-leave", this._clientId), this._publishMutex = new xO("client-publish", this._clientId), this._renewTokenMutex = new xO("client-renewtoken", this._clientId), this._subscribeMutex = new xO("client-subscribe", this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), sD.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(SN, " build: ").concat(yN, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions) try {
            eO(e2.clientRoleOptions), i2 = Object.assign({}, e2.clientRoleOptions);
          } catch (e3) {
            sD.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
          }
          var n3;
          this._statsCollector = new XF(this.store), this._statsCollector.onStatsException = (e3, t4, i3) => {
            sD.warn("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t4, ", uid: ").concat(i3)), e3 === KF.VIDEO_ENCODE_FAILED && this.localTracks.forEach((e4) => {
              e4 instanceof Mk2 && wN("ENABLE_ENCODE_EXCEPTION") && e4.findClosestProfile();
            }), this.safeEmit(tO.EXCEPTION, { code: e3, msg: t4, uid: i3 });
          }, this._statsCollector.onUploadPublishDuration = (e3, t4, i3, n4) => {
            const r2 = this._users.find((t5) => t5.uid === e3);
            if (r2) {
              this.store.keyMetrics && (this.store.firstVideoFrameDecoded(r2._uintid, { peerPublishDuration: i3, peerPubStatusMs: Date.now() }), this._p2pChannel.reportVideoFirstFrameRender(r2)), _D.peerPublishStatus(this._sessionId, { subscribeElapse: n4, audioPublishDuration: t4, videoPublishDuration: i3, peer: r2._uintid });
            }
          }, this._statsCollector.onVideoCodecChanged = (e3) => {
            if (wN("VIDEO_STANDARD_BITRATE_VERSION") && ("av1" === e3 || "h265" === e3 || "h264" === e3)) {
              const t4 = this.localTracks.find((e4) => e4 instanceof kk2);
              t4 && 1 !== t4._saveEncodeBitrateRatio && t4.setSaveEncodeBitrateRatio("h264" === e3 ? wN("BASELINE_MORE_H264_BITRATE_RATIO") : void 0);
            }
          }, this.store.useP2P = "p2p" === e2.mode, this._gateway = new iF(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || BO, httpRetryConfig: e2.httpRetryConfig || BO, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: i2 }), this._configDistribute = new WF(this._clientId, this.store), this.store.useP2P ? (this._p2pChannel = (n3 = { store: this.store, statsCollector: this._statsCollector }, Jx2("P2PChannel").create(n3)), this._handleP2PEvents()) : this._p2pChannel = new tj2(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
        }
        async joinMeta(e2, t3, i2, n3, r2) {
          let o2 = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], s2 = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
          AN("JOIN_GATEWAY_USE_443PORT_ONLY", o2), AN("JOIN_GATEWAY_USE_DUAL_DOMAIN", s2);
          const a3 = this._gateway.signal.websocket;
          return a3 instanceof XV && (a3.use443PortOnly = o2, a3.tryDoubleDomain = s2), async function(e3, t4, i3) {
            FA2.get(e3) || FA2.set(e3, []), BA2.get(e3) || BA2.set(e3, t4), jA2.get(e3) || jA2.set(e3, 0);
            const n4 = FA2.get(e3), r3 = BA2.get(e3);
            if (!n4 || !r3) throw new Error("concurrent: deferQueue or maxConcurrency is null");
            if (jA2.get(e3) === r3) {
              const e4 = xA2();
              n4.push(e4), await e4.promise;
            }
            jA2.set(e3, jA2.get(e3) + 1);
            for (var o3 = arguments.length, s3 = new Array(o3 > 3 ? o3 - 3 : 0), a4 = 3; a4 < o3; a4++) s3[a4 - 3] = arguments[a4];
            const c3 = await i3(...s3);
            return jA2.set(e3, jA2.get(e3) - 1), jA2.get(e3) === r3 - 1 && n4.length > 0 && (n4[0].resolve(), n4.shift()), 0 === jA2.get(e3) && (FA2.set(e3, []), BA2.set(e3, 0), jA2.set(e3, 0)), c3;
          }("client.join", wN("JOIN_MAX_CONCURRENCY"), this.join.bind(this), e2, t3, i2, n3, r2);
        }
        async join(e2, t3, i2, n3, r2) {
          const o2 = ++this._numberOfJoinCount;
          this.store.joinStart(), n3 && (this.store.uid = n3);
          const s2 = "HTTPS" === (WO || WO || (WO = (window.location.protocol.split(":")[0] || "").toUpperCase(), WO)), a3 = XO() ? window.isSecureContext : "Browser Not Support";
          if (!XO() && !s2 || !window.isSecureContext) {
            const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            sD.warning(e3);
          }
          let c3;
          _D.setAppId(e2);
          try {
            if (!i2 && null !== i2) throw new ED(ww2.INVALID_PARAMS, "Invalid token: ".concat(i2, ". If you don not use token, set it to null"));
            if (i2 && kw2(i2, "token", 1, 2047), kw2(e2, "appid", 1, 2047), GU(t3), n3 && WU(n3), r2) if ("string" == typeof r2) kw2(r2, "optionalInfo", 1, 256), c3 = r2;
            else {
              if ("object" != typeof r2) throw new ED(ww2.INVALID_PARAMS, "Invalid options: options is not a string or object");
              {
                const { autoSubscribe: e3, enableInstantMuteRestore: t4 } = r2;
                e3 && (Nw2(e3, "autoSubscribe"), sD.info("[".concat(this._clientId, "] join: autoSubscribe: ").concat(e3)), this.store.autoSubscribe = e3), t4 && (Nw2(t4, "enableInstantMuteRestore"), sD.info("[".concat(this._clientId, "] join: enableInstantMuteRestore: ").concat(t4)), this.store.enableInstantMuteRestore = t4);
              }
            }
          } catch (r3) {
            throw _D.reportApiInvoke(bO(), { name: zw2.JOIN, options: [e2, t3, i2, n3], states: { isHttps: s2, isSecureContext: a3 }, tag: qw2.TRACER }).onError(r3), r3;
          }
          if (this._leaveMutex.isLocked) {
            sD.debug("[".concat(this._clientId, "] join: waiting leave operation"));
            (await this._leaveMutex.lock())(), sD.debug("[".concat(this._clientId, "] join: continue"));
          }
          if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
            const r3 = new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw _D.reportApiInvoke(bO(), { name: zw2.JOIN, options: [e2, t3, i2, n3], states: { isHttps: s2, isSecureContext: a3 }, tag: qw2.TRACER }).onError(r3), r3;
          }
          this._gateway.state = "CONNECTING", this.store.preloadStart();
          const d2 = await Aj2({ appId: e2, cname: t3, uid: n3, stringUid: "string" == typeof n3 ? n3 : void 0, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode });
          if (this.store.preloadEnd(), !this._joinAndNotLeaveYet) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
          const l2 = (null == d2 ? void 0 : d2.sid) || bO();
          sD.info("[".concat(this._clientId, "] start join channel ").concat(t3, ", join number: ").concat(o2)), this._sessionId || (this._sessionId = l2, this.store.sessionId = this._sessionId);
          const u3 = _D.reportApiInvoke(l2, { id: this._clientId, name: zw2.JOIN, options: [e2, t3, i2, n3], states: { isHttps: s2, isSecureContext: a3 }, tag: qw2.TRACER }), h2 = oW(oW(oW({}, this._rtmConfig), {}, { role: this.role, clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t3, uid: "string" != typeof n3 ? n3 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i2 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: c3, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint, preload: !!d2 }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType }), {}, { apRequestDetail: wN("AP_REQUEST_DETAIL") || void 0 });
          if (this._useLocalAccessPoint && (h2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n3 && (h2.stringUid = n3, this._uintUid ? (h2.uid = this._uintUid, this._uintUid = void 0) : h2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
            if (h2.aesmode = this._encryptionMode, h2.aespassword = await (async (e3) => {
              const t4 = function(e4) {
                const t5 = window.atob("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i4 = new Uint8Array(new ArrayBuffer(t5.length));
                for (let e5 = 0; e5 < t5.length; e5 += 1) i4[e5] = t5.charCodeAt(e5);
                return i4;
              }(), i3 = await window.crypto.subtle.importKey("spki", t4, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n4 = jw2(e3), r3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i3, n4);
              return function(e4) {
                let t5 = "";
                for (let i4 = 0; i4 < e4.length; i4 += 1) t5 += String.fromCharCode(e4[i4]);
                return window.btoa(t5);
              }(new Uint8Array(r3));
            })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (h2.aessalt = this._encryptionSalt);
          }
          if (this._encryptDataStream && ("aes-128-gcm2" === this._encryptionMode || "aes-256-gcm2" === this._encryptionMode)) if (this._encryptionSalt && this._encryptionSecret) if (window.crypto.subtle) {
            const e3 = new TextEncoder(), t4 = wN("USE_PURE_ENCRYPTION_MASTER_KEY") ? e3.encode(h2.appId + this._encryptionSecret + this._encryptionSecret) : e3.encode(h2.appId + h2.cname + this._encryptionSecret);
            this._encryptDataStreamIv = await async function(e4, t5, i3) {
              const n4 = await window.crypto.subtle.importKey("raw", t5, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256, o3 = await window.crypto.subtle.deriveBits({ name: "PBKDF2", iterations: MN, hash: "SHA-256", salt: i3 }, n4, r3 + kN);
              return new Uint8Array(o3).subarray(r3 / 8);
            }(this._encryptionMode, t4, fO(this._encryptionSalt)), this._encryptDataStreamKey = await async function(e4, t5, i3) {
              const n4 = await window.crypto.subtle.importKey("raw", t5, "PBKDF2", false, ["deriveBits", "deriveKey"]), r3 = "aes-128-gcm2" === e4 ? 128 : 256;
              return await window.crypto.subtle.deriveKey({ name: "PBKDF2", iterations: MN, hash: "SHA-256", salt: i3 }, n4, { name: "AES-GCM", length: r3 }, true, ["encrypt", "decrypt"]);
            }(this._encryptionMode, t4, fO(this._encryptionSalt));
          } else a3 ? sD.warning("[".concat(this._clientId, "] encrypt datastream must be running in a secure context, fallback to plain data stream")) : sD.warning("[".concat(this._clientId, "] current browser do not support WebCrypto ,fallback to plain data stream")), this._encryptDataStream = false;
          else this._encryptDataStream = false, sD.debug("[".concat(this._clientId, "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"));
          this._startSession(this._sessionId, { channel: t3, appId: e2, stringUid: h2.stringUid });
          const p2 = this._sessionId;
          setTimeout(() => {
            "CONNECTING" === this.connectionState && p2 === this._sessionId && _D.joinChannelTimeout(this._sessionId, 5);
          }, 5e3);
          try {
            var _2;
            let n4;
            const r3 = h2.cloudProxyServer;
            if (Ln2(_2 = ["proxy3", "proxy4", "proxy5"]).call(_2, r3)) {
              const e3 = wN("PROXY_SERVER_TYPE3");
              Array.isArray(e3) ? h2.proxyServer = e3[0] : h2.proxyServer = e3;
            }
            if (_D.setProxyServer(h2.proxyServer), sD.setProxyServer(h2.proxyServer), this.store.requestAPStart(), d2) {
              if (sD.debug("[".concat(this._clientId, "] get serverInfo Success from Preload Cache ").concat(h2.stringUid ? ", ".concat(h2.stringUid, " => ").concat(d2.intUid) : "", " ")), h2.stringUid && !h2.uid && (h2.uid = d2.intUid), n4 = { gatewayInfo: d2.ap.gatewayInfo }, wN("JOIN_WITH_FALLBACK_MEDIA_PROXY") && "auto" === h2.turnServer.mode) if (0 === d2.ap.proxyInfo.addresses.length) sD.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers");
              else {
                const e3 = (await dx2(d2.ap.proxyInfo, d2.ap.gatewayInfo.uid)).map((e4) => ({ turnServerURL: e4.address, tcpport: e4.tcpport || RN.tcpport, udpport: e4.udpport || RN.udpport, username: e4.username || RN.username, password: e4.password || RN.password, forceturn: false, security: true }));
                h2.turnServer = { mode: "manual", servers: e3 };
              }
              Dj2(d2, h2.stringUid);
            } else {
              if (h2.stringUid && !h2.uid) {
                let e3;
                [e3, n4] = await ip2.all([kF(h2.stringUid, h2, this._axiosCancelSource.token, this._config.httpRetryConfig || BO, this.store).finally(() => {
                  this.store.requestSUAEnd();
                }), LF(h2, this._axiosCancelSource.token, this._config.httpRetryConfig || BO, true, this.store).finally(() => {
                  this.store.requestAPEnd();
                })]), sD.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(h2.stringUid, " => ").concat(e3)), h2.uid = e3, n4.gatewayInfo.uid = e3, n4.gatewayInfo.res.uid = e3;
              } else n4 = await LF(h2, this._axiosCancelSource.token, this._config.httpRetryConfig || BO, true, this.store);
              if (!this._joinAndNotLeaveYet) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            }
            this.store.requestAPEnd(), setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(h2, this._axiosCancelSource.token), this._configDistribute.on(uV.UPDATE_BITRATE_LIMIT, (e3) => {
                this._p2pChannel.updateBitrateLimit(e3);
              }), this._configDistribute.on(uV.UPDATE_CLIENT_ROLE_OPTIONS, (e3) => {
                this._setClientRoleOptions(e3);
              });
            }, 0), this._key = i2 || e2;
            const o3 = n4.gatewayInfo, s3 = h2.uid ? h2.uid : o3.uid;
            this._joinInfo = oW(oW({}, h2), {}, { cid: o3.cid, uid: s3, vid: o3.vid, apResponse: o3.res, apGatewayAddress: o3.apGatewayAddress, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs }), this.store.intUid = s3, this.store.cid = o3.cid;
            const a4 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            u3.onSuccess(a4), this._appId = e2, this._channelName = h2.cname, this._uid = a4, this.store.uid = a4, setTimeout(() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener($A2() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._statsCollector.startUpdateStats();
            }, 0);
            const c4 = h2.stringUid ? "string uid: ".concat(h2.stringUid, ",uid: ").concat(h2.uid) : "uid: ".concat(this._uid);
            return sD.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t3, ",").concat(c4)), setTimeout(() => {
              sD.startUpload();
            }, 5e3), this.store.joinEnd(), E3 = this, Ln2(WM).call(WM, E3) || WM.push(E3), "disabled" === this._cloudProxyServerMode && fD2().supportWebCrypto && wN("ENABLE_PRELOAD") && Oj2(this._joinInfo), a4;
          } catch (e3) {
            const t4 = Array.isArray(e3) ? e3[0] : e3;
            throw t4 && t4.code === ww2.OPERATION_ABORTED ? sD.warning("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t4) : sD.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t4), t4.code !== ww2.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), u3.onError(t4), t4;
          }
          var E3;
        }
        _joinGateway() {
          if (!this._joinInfo || !this._key) throw new ED(ww2.INVALID_OPERATION);
          return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !wN("JOIN_WITH_FALLBACK_SIGNAL_PROXY")));
        }
        async leave() {
          sD.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener($A2() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
            const t3 = WM.indexOf(e3);
            -1 !== t3 && WM.splice(t3, 1);
          }(this), this._statsCollector.stopUpdateStats();
          const e2 = await this._leaveMutex.lock();
          if ("DISCONNECTED" === this.connectionState) return sD.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e2();
          await this._gateway.leave("CONNECTED" !== this.connectionState, Zw2.LEAVE), sD.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e2();
        }
        async publish(e2) {
          let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!Array.isArray(e2)) {
            if (!(e2 instanceof uP)) return this._publishDataChannel(e2);
            e2 = [e2];
          }
          if (0 === e2.length) throw new ED(ww2.INVALID_PARAMS, "param list is empty");
          const i2 = e2;
          if ("audience" === this._gateway.role) throw new ED(ww2.INVALID_OPERATION, "audience can not publish stream");
          for (const e3 of i2) {
            if (!(e3 instanceof uP)) throw new ED(ww2.INVALID_PARAMS, "parameter is not local track");
            if (!e3._enabled && t3) throw new ED(ww2.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(e3.getTrackId()));
          }
          sD.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(i2.map((e3) => "".concat(e3.getTrackId(), " "))));
          const n3 = await this._publishMutex.lock();
          await this._configDistribute.awaitConfigDistributeComplete(), t3 && i2.forEach((e3) => {
            const t4 = this._configDistribute.getBitrateLimit();
            e3 instanceof kk2 && t4 && e3.setBitrateLimit(t4.uplink);
          });
          try {
            await this._publishHighStream(i2), sD.info("[".concat(this._clientId, "] Publish success, id ").concat(i2.map((e3) => "".concat(e3.getTrackId(), " "))));
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
          } finally {
            n3();
          }
        }
        async _publishDataChannel(e2) {
          if (null == e2) throw new ED(ww2.INVALID_PARAMS, "parameter is not local track or datachannel config, config is ".concat(JSON.stringify(e2)));
          Pw2(e2.id, "id", 0, 65535, true), Nw2(e2.ordered, "ordered"), kw2(e2.metadata, "metadata", 0, 512), sD.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(e2.id));
          const t3 = await this._publishMutex.lock();
          try {
            if (-1 !== this._p2pChannel.getAllDataChannels().findIndex((t4) => t4.id === e2.id)) throw new ED(ww2.INVALID_PARAMS, "Invalid id: ".concat(e2.id, ". If you want to republish the datachannel, unpublish first"));
            if (!this._joinInfo || void 0 === this._uid) throw new ED(ww2.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
            if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
            if ("auto" === this._turnServer.mode && wN("FORCE_TURN") && !wN("TURN_ENABLE_TCP") && !wN("TURN_ENABLE_UDP")) throw new ED(ww2.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
            const i2 = function(e3) {
              return Zx2(e3, false);
            }(e2), n3 = await this._p2pChannel.publishDataChannel([i2]);
            if (n3.length > 0) {
              if ("number" != typeof i2._originDataChannelId) throw sD.error("[".concat(this._clientId, "] can not publish with mediaType datachannel, cannot get RTCDatachannel id")), new ED(ww2.CREATE_DATACHANNEL_ERROR);
              try {
                await ip2.all(n3.map((e3) => this._uid && this._gateway.publishDataChannel(this._uid, e3, true))), await i2._waitTillOpen();
              } catch (e3) {
                if (e3.code !== ww2.DISCONNECT_P2P) throw e3;
              }
            }
            return sD.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(i2.id)), i2;
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] publish datachannels error"), e3.toString()), e3;
          } finally {
            t3();
          }
        }
        async unpublish(e2) {
          if (!this._joinInfo || void 0 === this._uid) throw new ED(ww2.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          let t3 = [];
          if (e2) if (Array.isArray(e2)) t3 = e2;
          else {
            if (!(e2 instanceof uP)) return this._unpublishDataChannel([e2]);
            t3 = [e2];
          }
          else this.store.useP2P || await this._unpublishDataChannel(), t3 = this._p2pChannel.getAllTracks(true);
          sD.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(t3.map((e3) => "".concat(e3.getTrackId(), " ")), " "));
          const i2 = await this._publishMutex.lock();
          try {
            if (this.store.useP2P) {
              const e3 = await this._p2pChannel.unpublish(t3);
              e3 && await this._gateway.sendExtensionMessage(NV.UNPUBLISH, { unpubMsg: e3 }, true);
            } else {
              const e3 = await this._p2pChannel.unpublish(t3);
              e3 && await this._gateway.unpublish(e3, this._uid), sD.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(t3.map((e4) => "".concat(e4.getTrackId()))));
            }
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
          } finally {
            i2 && i2();
          }
        }
        async _unpublishDataChannel(e2) {
          void 0 !== e2 && 0 !== e2.length || (e2 = this._p2pChannel.getAllDataChannels()), sD.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(e2.map((e3) => "".concat(e3.id, " ")), " "));
          const t3 = await this._publishMutex.lock();
          try {
            const i2 = await this._p2pChannel.unpublishDataChannel(e2);
            i2 && await this._gateway.unpublishDataChannel(i2), sD.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(e2.map((e3) => "".concat(e3.id))));
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] unpublish dataChannel error"), e3.toString()), e3;
          } finally {
            t3 && t3();
          }
        }
        async subscribe(e2, t3, i2) {
          if (!(e2 instanceof QF)) {
            const t4 = this.remoteUsers.find((t5) => t5.uid === e2);
            if (!t4) throw new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
            e2 = t4;
          }
          return "datachannel" === t3 ? this._subscribeDataChannel(e2, i2) : this._subscribe(e2, t3);
        }
        async presubscribe(e2, t3) {
          if (Dw2(t3, "mediaType", ["audio", "video"]), this.store.useP2P) throw new ED(ww2.INVALID_OPERATION, "can't presub at p2p mode");
          if (!this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "can't presub when not join");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "can't presub in ".concat(this.connectionState, " state"));
          const i2 = t3 === EV.AUDIO, n3 = t3 === EV.VIDEO, r2 = await this._subscribeMutex.lock();
          try {
            const { ssrcId: o2, ortc: s2, rtxSsrcId: a3, cname: c3, uint_id: d2 } = await this._gateway.presubscribe(e2, t3, true);
            if (null == o2) throw new ED(ww2.UNEXPECTED_RESPONSE, "no ssrc id");
            let l2 = this._users.find((t4) => t4.uid === e2);
            l2 || (l2 = new QF(e2, d2 || e2), l2._is_pre_created = true, this._users.push(l2)), c3 && (l2._cname = c3), l2._uintid || (l2._uintid = d2 || e2), i2 && (l2._audioSSRC = o2, l2._audio_pre_subscribed = true, s2 && (l2._audioOrtc = s2)), n3 && (l2._videoSSRC = o2, l2._video_pre_subscribed = true, s2 && (l2._videoOrtc = s2), null != a3 && (l2._rtxSsrcId = a3)), sD.info("[".concat(this._clientId, "] presub succeed ssrc: ").concat(o2)), await this._p2pChannel.subscribe(l2, t3, o2, a3, s2);
            const u3 = i2 ? l2._audioTrack : l2._videoTrack;
            if (!u3) throw new ED(ww2.UNEXPECTED_ERROR, "can not find remote track in user");
            return i2 && (l2._trust_audio_stream_added_state_ = true, l2._audio_added_ = true), n3 && (l2._trust_video_stream_added_state_ = true, l2._video_added_ = true), u3;
          } catch (t4) {
            throw sD.error("[".concat(this._clientId, "] presub user ").concat(e2, " error"), t4), t4;
          } finally {
            r2();
          }
        }
        async _subscribeDataChannel(e2, t3) {
          var i2;
          if (Pw2(t3, "channelId", 0, 65535, true), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
          const n3 = this._users.find((t4) => t4 === e2);
          if (!n3) throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
          if (!e2.hasAudio && !e2.hasVideo && 0 === e2._dataChannels.length) throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), new ED(ww2.INVALID_REMOTE_USER, "user is not published");
          const r2 = null === (i2 = e2._dataChannels) || void 0 === i2 ? void 0 : i2.find((e3) => e3.id === t3);
          if (!r2) throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, remote datachannel is not published")), new ED(ww2.REMOTE_USER_IS_NOT_PUBLISHED);
          const o2 = await this._subscribeMutex.lock();
          sD.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: datachannel"));
          try {
            const t4 = await this._p2pChannel.subscribeDataChannel(e2, [r2]);
            if (t4 && Ln2(t4).call(t4, r2.id)) try {
              var s2;
              if ("number" != typeof r2._originDataChannelId) throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new ED(ww2.CREATE_DATACHANNEL_ERROR);
              const t5 = { id: r2.id, datachannelId: r2._originDataChannelId, ordered: r2.ordered, maxRetransmits: r2.maxRetransmits, metadata: null !== (s2 = r2.metadata) && void 0 !== s2 ? s2 : "" };
              await this._gateway.subscribeDataChannel(e2.uid, t5, true), await r2._waitTillOpen();
            } catch (t5) {
              if ((null == t5 ? void 0 : t5.code) !== ww2.WS_ABORT) throw await this._p2pChannel.unsubscribeDataChannel(e2, [r2]), t5;
              await this._p2pChannel.unsubscribeDataChannel(e2, [r2]), this._p2pChannel.setPendingRemoteDataChannel(e2, r2.id);
            }
            return sD.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: datachannel")), r2;
          } finally {
            o2();
          }
        }
        async _p2pSubscribe(e2, t3, i2) {
          if (Dw2(t3, "mediaType", ["audio", "video"]), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const n3 = this._users.find((t4) => t4 === e2);
          if (!n3) {
            const t4 = new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
            throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t4;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t4 = new ED(ww2.INVALID_REMOTE_USER, "user is not published");
            throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t4;
          }
          if (!i2 && ("audio" === t3 && !e2.hasAudio || "video" === t3 && !e2.hasVideo)) {
            const i3 = new ED(ww2.REMOTE_USER_IS_NOT_PUBLISHED);
            throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t3, ", remote track is not published")), i3;
          }
          const r2 = await this._subscribeMutex.lock();
          sD.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t3));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t3)) await this._p2pChannel.unmuteRemote(e2, t3);
            else try {
              const i4 = "audio" === t3 ? e2._audioSSRC : e2._videoSSRC, n4 = "audio" === t3 ? e2._audioMid : e2._videoMid;
              this.store.subscribe(e2.uid, t3, Date.now()), this.store.useP2P && await this._p2pChannel.subscribe(e2, t3, i4, n4);
            } catch (e3) {
              throw e3;
            }
            sD.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t3)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              sD.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i3 = "audio" === t3 ? e2._audioTrack : e2._videoTrack;
            if (!i3) throw new ED(ww2.UNEXPECTED_ERROR, "can not find remote track in user object");
            return i3;
          } catch (t4) {
            throw sD.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t4), t4;
          } finally {
            r2();
          }
        }
        async _subscribe(e2, t3, i2) {
          if (this.store.useP2P) return this._p2pSubscribe(e2, t3);
          if (Dw2(t3, "mediaType", ["audio", "video"]), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const n3 = this._users.find((t4) => t4 === e2);
          if (!n3) {
            const t4 = new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
            throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t4;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t4 = new ED(ww2.INVALID_REMOTE_USER, "user is not published");
            throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t4;
          }
          if (!(i2 || ("audio" !== t3 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t3 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
            const i3 = new ED(ww2.REMOTE_USER_IS_NOT_PUBLISHED);
            throw sD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t3, ", remote track is not published")), i3;
          }
          let r2 = "audio" === t3 ? e2._audioSSRC : e2._videoSSRC, o2 = "audio" === t3 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t3 ? e2._rtxSsrcId : void 0, a3 = { stream_type: "audio" === t3 ? EV.AUDIO : EV.VIDEO, ssrcId: r2 };
          "video" === t3 && this.store.firstVideoFrameDecoded(e2.uid, { subscribeStart: Date.now() });
          const c3 = await this._subscribeMutex.lock();
          sD.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t3));
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t3)) await this._p2pChannel.unmuteRemote(e2, t3);
            else try {
              const i4 = "audio" === t3 ? e2._audioSSRC : e2._videoSSRC;
              void 0 !== i4 && i4 !== r2 && (r2 = i4, o2 = "audio" === t3 ? e2._audioOrtc : e2._videoOrtc, s2 = "video" === t3 ? e2._rtxSsrcId : void 0, a3 = { stream_type: "audio" === t3 ? EV.AUDIO : EV.VIDEO, ssrcId: r2 }), YF.markSubscribeStart(this.store.clientId, r2), this.store.subscribe(e2.uid, t3, Date.now()), await this._p2pChannel.subscribe(e2, t3, r2, s2, o2);
              try {
                this._p2pChannel.isPreSubScribe(r2) || await this._gateway.subscribe(e2.uid, a3, true);
              } catch (i5) {
                if ((null == i5 ? void 0 : i5.code) !== ww2.WS_ABORT) throw await this._p2pChannel.unsubscribe(e2, t3), i5;
                await this._p2pChannel.unsubscribe(e2, t3, true), this._p2pChannel.setPendingRemoteMedia(e2, t3);
              }
              this.store.subscribe(e2.uid, t3, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t3);
            } catch (i4) {
              throw this._p2pChannel.reportSubscribeEvent(false, null == i4 ? void 0 : i4.code, e2, t3), i4;
            }
            sD.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t3)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              sD.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
            });
            const i3 = "audio" === t3 ? e2._audioTrack : e2._videoTrack;
            if (!i3) throw new ED(ww2.UNEXPECTED_ERROR, "can not find remote track in user object");
            return "video" === t3 && (this.store.firstVideoFrameDecoded(e2.uid, { subscribeEnd: Date.now() }), this._p2pChannel.reportVideoFirstFrameRender(e2)), i3;
          } catch (t4) {
            throw sD.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t4), t4;
          } finally {
            c3();
          }
        }
        async massSubscribe(e2) {
          if (Mw2(e2, "subscribeList"), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe stream, not joined");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
          const t3 = Date.now(), i2 = /* @__PURE__ */ new Map(), n3 = await this._subscribeMutex.lock();
          sD.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
            let { user: t4, mediaType: i3 } = e3;
            return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i3);
          }).join("; ")));
          const r2 = (e2 = [...e2]).map((e3) => {
            let { user: t4, mediaType: i3 } = e3;
            return { user: t4, mediaType: i3 };
          }), o2 = await this._p2pChannel.globalLock();
          try {
            var s2;
            for (let t4 = e2.length - 1; t4 >= 0; t4--) {
              const n4 = e2[t4], { user: o3, mediaType: s3 } = n4;
              if (Dw2(s3, "mediaType", ["audio", "video"]), !o3) {
                const e3 = new ED(ww2.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw sD.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
              }
              const a4 = this._users.find((e3) => e3 === o3);
              if (!a4) {
                const i3 = new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
                sD.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o3.uid, ", this user is not in the channel")), r2[t4].error = i3, e2.splice(t4, 1);
                continue;
              }
              if ("audio" === s3 && (!o3.hasAudio || void 0 === o3._audioSSRC) || "video" === s3 && (!o3.hasVideo || void 0 === o3._videoSSRC)) {
                const i3 = new ED(ww2.REMOTE_USER_IS_NOT_PUBLISHED);
                sD.error("[".concat(this._clientId, "] can not subscribe ").concat(o3.uid, " with mediaType ").concat(s3, ", remote user is not published")), r2[t4].error = i3, e2.splice(t4, 1);
                continue;
              }
              const c3 = sV.Video | sV.LwoVideo, d2 = i2.get(o3);
              if (d2) {
                if ("video" === s3 ? d2 & c3 : d2 & sV.Audio) {
                  e2.splice(t4, 1), sD.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o3.uid, ", mediaType:").concat(s3, " twice"));
                  continue;
                }
                i2.set(o3, d2 | ("video" === s3 ? c3 : sV.Audio));
              } else i2.set(o3, "video" === s3 ? c3 : sV.Audio);
            }
            for (let t4 = e2.length - 1; t4 >= 0; t4--) {
              const n4 = e2[t4], { user: r3, mediaType: o3 } = n4, s3 = sV.Video | sV.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(r3, o3)) {
                await this._p2pChannel.unmuteRemoteNoLock(r3, o3);
                const n5 = i2.get(r3);
                i2.set(r3, "video" === o3 ? n5 ^ s3 : n5 ^ sV.Audio), e2.splice(t4, 1);
              }
            }
            this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), t3);
            let a3 = nr2(s2 = Array.from(i2.entries())).call(s2, (e3, t4) => {
              let [i3, n4] = t4;
              if (0 === n4) return e3;
              const r3 = { stream_id: i3.uid, stream_type: n4 };
              return n4 & sV.Audio && (r3.audio_ssrc = i3._audioSSRC), n4 & sV.Video && (r3.video_ssrc = i3._videoSSRC), e3.push(r3), e3;
            }, []);
            try {
              e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
                let { user: t4, mediaType: i4 } = e3;
                return { user: t4, mediaType: i4, ssrcId: i4 === EV.VIDEO ? t4._videoSSRC : t4._audioSSRC, rtxSsrcId: i4 === EV.VIDEO ? t4._rtxSsrcId : void 0 };
              }));
              const i3 = /* @__PURE__ */ new Map();
              if (a3 = a3.filter((e3) => e3.video_ssrc && !this._p2pChannel.isPreSubScribe(e3.video_ssrc) || e3.audio_ssrc && !this._p2pChannel.isPreSubScribe(e3.audio_ssrc) || !e3.video_ssrc && !e3.audio_ssrc), a3.length > 0) {
                const e3 = await this._gateway.subscribeAll(a3, true);
                ((null == e3 ? void 0 : e3.users) || []).forEach((e4) => {
                  let { stream_id: t4, video_error_code: n4, audio_error_code: r3, error_code: o3 } = e4;
                  (n4 || r3 || o3) && i3.set(t4, { video_error_code: n4, audio_error_code: r3, error_code: o3 });
                });
              }
              if (Array.from(i3.entries()).length > 0) {
                const e3 = [];
                Array.from(i3.entries()).forEach((t4) => {
                  let [i4, n4] = t4;
                  const r3 = this.remoteUsers.find((e4) => e4.uid === i4);
                  if (r3) {
                    let t5;
                    n4.error_code || n4.video_error_code && n4.audio_error_code ? t5 = void 0 : n4.video_error_code ? t5 = EV.VIDEO : n4.audio_error_code && (t5 = EV.AUDIO), e3.push({ user: r3, mediaType: t5 });
                  }
                }), e3.length > 0 && await this._p2pChannel.massUnsubscribeNoLock(e3);
              }
              for (const e3 of r2) {
                const t4 = i3.get(e3.user.uid);
                if (t4) {
                  const i4 = t4.error_code || "audio" === e3.mediaType && t4.audio_error_code || "video" === e3.mediaType && t4.video_error_code;
                  if (i4) {
                    const t5 = VV(i4);
                    sD.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t5.desc)), e3.error = new ED(ww2.SUBSCRIBE_FAILED, "code ".concat(i4, ": ").concat(t5.desc));
                  }
                }
                e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
              }
              return this.store.massSubscribe(r2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, Date.now()), r2.forEach((e3) => {
                var i4;
                _D.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i4 = e3.error) || void 0 === i4 ? void 0 : i4.code) || null, video: e3.mediaType === EV.VIDEO, audio: e3.mediaType === EV.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === EV.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t3), preSsrc: this._p2pChannel.isPreSubScribe(e3.user._videoSSRC) }, true);
              }), sD.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
                let { user: t4, mediaType: i4 } = e3;
                return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i4);
              }).join("; "))), r2;
            } catch (t4) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e2), t4;
            }
          } finally {
            o2(), n3();
          }
        }
        async unsubscribe(e2, t3, i2) {
          if (!(e2 instanceof QF)) {
            const t4 = this.remoteUsers.find((t5) => t5.uid === e2);
            if (!t4) throw new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
            e2 = t4;
          }
          if (t3 || this.store.useP2P) {
            if ("datachannel" === t3) return this._unsubscribeDataChannel(e2, i2);
          } else await this._unsubscribeDataChannel(e2, i2);
          if (t3 && Dw2(t3, "mediaType", ["audio", "video"]), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          const n3 = this._users.find((t4) => t4 === e2);
          if (!n3) {
            const t4 = new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
            throw sD.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t4;
          }
          sD.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t3));
          const r2 = await this._subscribeMutex.lock();
          try {
            if (this.store.useP2P) await this._p2pChannel.unsubscribe(e2, t3);
            else {
              const i3 = await this._p2pChannel.unsubscribe(e2, t3);
              i3 && await this._gateway.unsubscribe(i3, e2.uid), t3 && "audio" !== t3 || (e2._audio_pre_subscribed = false), t3 && "video" !== t3 || (e2._video_pre_subscribed = false), e2._is_pre_created && lO(this._users, e2), sD.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t3));
            }
          } catch (t4) {
            if (t4.code === ww2.DISCONNECT_P2P) return void sD.warning("disconnecting p2p, abort unsubscribe request.");
            throw sD.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t4.toString()), t4;
          } finally {
            r2();
          }
        }
        async _unsubscribeDataChannel(e2, t3) {
          if (t3 && Pw2(t3, "id", 0, 65535, true), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
          const i2 = this._users.find((t4) => t4 === e2);
          if (!i2) {
            const t4 = new ED(ww2.INVALID_REMOTE_USER, "user is not in the channel");
            throw sD.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t4;
          }
          let n3;
          if ("number" == typeof t3) {
            const i3 = e2._dataChannels.find((e3) => e3.id === t3);
            i3 && (n3 = [i3]);
          } else n3 = e2._dataChannels;
          if (void 0 === n3) {
            const i3 = new ED(ww2.REMOTE_USER_IS_NOT_PUBLISHED);
            throw sD.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, " with channelId ").concat(t3, ", remote datachannel is not published")), i3;
          }
          sD.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(n3.map((e3) => e3.id)));
          try {
            const t4 = await this._p2pChannel.unsubscribeDataChannel(e2, n3);
            t4 && await this._gateway.unsubscribeDataChannel(t4, e2.uid), sD.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(e2.uid, ", mediaType: datachannel, ids: ").concat(t4));
          } catch (t4) {
            if (t4.code === ww2.DISCONNECT_P2P) return void sD.warning("disconnecting p2p, abort unsubscribe request.");
            throw sD.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t4.toString()), t4;
          }
        }
        async massUnsubscribe(e2) {
          if (Mw2(e2, "unsubscribeList"), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
          sD.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
            let { user: t4, mediaType: i2 } = e3;
            return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i2, ";");
          }).join())), e2 = [...e2];
          const t3 = /* @__PURE__ */ new Map();
          for (let i2 = e2.length - 1; i2 >= 0; i2--) {
            const { user: n3, mediaType: r2 } = e2[i2];
            if (!n3) {
              const e3 = new ED(ww2.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw sD.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
            }
            Dw2(r2, "mediaType", ["video", "audio", void 0]);
            const o2 = this._users.find((e3) => e3 === n3);
            if (!o2) {
              sD.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n3.uid, ", user is not in the channel")), e2.splice(i2, 1);
              continue;
            }
            const s2 = sV.Video | sV.LwoVideo;
            if (t3.has(n3)) {
              const o3 = t3.get(n3);
              let a3;
              switch (r2) {
                case "video":
                  a3 = o3 & s2;
                  break;
                case "audio":
                  a3 = o3 & sV.Audio;
                  break;
                default:
                  a3 = o3 & (sV.Audio | s2);
              }
              if (a3) {
                sD.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n3.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i2, 1);
                continue;
              }
              r2 ? "audio" === r2 ? t3.set(n3, o3 | sV.Audio) : "video" === r2 && t3.set(n3, o3 | s2) : t3.set(n3, o3 | sV.Audio | s2);
            } else r2 ? "audio" === r2 ? t3.set(n3, sV.Audio) : "video" === r2 && t3.set(n3, s2) : t3.set(n3, sV.Audio | s2);
          }
          try {
            const t4 = await this._p2pChannel.massUnsubscribe(e2);
            t4 && await this._gateway.massUnsubscribe(t4), sD.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
              let { user: t5, mediaType: i2 } = e3;
              return "user: ".concat(null == t5 ? void 0 : t5.uid, ", mediaType: ").concat(i2, ";");
            }).join()));
          } catch (e3) {
            if (e3.code === ww2.DISCONNECT_P2P) return void sD.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
            throw sD.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
          }
        }
        async setLowStreamParameter(e2) {
          !function(e3) {
            if (!e3) throw new Ow2(ww2.INVALID_PARAMS);
            Uw2(e3.width) || Lw2(e3.width, "streamParameter.width"), Uw2(e3.height) || Lw2(e3.height, "streamParameter.height"), Uw2(e3.framerate) || Lw2(e3.framerate, "streamParameter.framerate"), Uw2(e3.bitrate) || Pw2(e3.bitrate, "streamParameter.bitrate");
          }(e2), (!e2.width && e2.height || e2.width && !e2.height) && sD.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), sD.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
          const t3 = this._configDistribute.getLowStreamConfigDistribute();
          if (t3 && t3.bitrate && e2.bitrate && t3.bitrate < e2.bitrate && (e2.bitrate = t3.bitrate), this._lowStreamParameter = e2, this._isDualStreamEnabled) return this._p2pChannel.updateVideoStreamParameter(e2, gV.LocalVideoLowTrack);
        }
        async enableDualStream() {
          if (!fD2().supportDualStream) throw _D.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new ED(ww2.NOT_SUPPORTED, "Your browser is not support dual stream");
          if (this._isDualStreamEnabled) throw new ED(ww2.INVALID_OPERATION, "Dual stream is already enabled");
          if (this._p2pChannel.canPublishLowStream()) try {
            await this._publishLowStream();
          } catch (e2) {
            throw _D.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
          }
          this._isDualStreamEnabled = true, _D.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), sD.info("[".concat(this._clientId, "] enable dual stream"));
        }
        async disableDualStream() {
          if (this._isDualStreamEnabled) {
            if (!this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
            if (this._p2pChannel.getLocalMedia(gV.LocalVideoLowTrack)) try {
              const e2 = await this._p2pChannel.unpublishLowStream();
              e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
            } catch (e2) {
              throw _D.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
            }
            this._isDualStreamEnabled = false, _D.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), sD.info("[".concat(this._clientId, "] disable dual stream"));
          }
        }
        async setClientRole(e2, t3) {
          if (function(e3) {
            Dw2(e3, "role", ["audience", "host"]);
          }(e2), t3 && eO(t3), "rtc" === this.mode || "p2p" === this.mode) throw sD.warning("[".concat(this._clientId, "]").concat(this.mode, " mode can not use setClientRole")), new ED(ww2.INVALID_OPERATION, "".concat(this.mode, " mode can not use setClientRole"));
          if (t3 && t3.level && "host" === e2) throw new ED(ww2.INVALID_OPERATION, "host mode can not set audience latency level");
          if ("audience" === e2 && this._p2pChannel.hasLocalMedia()) throw new ED(ww2.INVALID_OPERATION, "can not set client role to audience when publishing stream");
          const i2 = this._config.role;
          this._joinInfo && (this._joinInfo.role = e2), e2 !== i2 && wN("ENABLE_ROLE_SELECT_EDGE") ? (this._gateway.updateClientRole(e2, t3), this._config.role = e2, this._gateway.reconnect("recover", iO.REGIONAL_DISTRIBUTION)) : (await this._gateway.setClientRole(e2, t3), this._config.role = e2), sD.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t3 && t3.level));
        }
        async _setClientRoleOptions(e2) {
          if ("rtc" === this.mode || "p2p" === this.mode) return;
          if ("audience" !== this._config.role || this._p2pChannel.hasLocalMedia()) return;
          let t3 = false;
          try {
            e2 && eO(e2), await this._gateway.setClientRole(this._config.role, e2), t3 = true;
          } catch (e3) {
          } finally {
            sD.info("[".concat(this._clientId, "] set client role options ").concat(t3 ? "succeed" : "failed", ", options is ").concat(e2));
          }
        }
        getRemoteInboundOffset() {
          var e2;
          const t3 = null === (e2 = this._p2pChannel.getStats()) || void 0 === e2 ? void 0 : e2.audioSend[0];
          if (!t3 || !t3.timestamp) return 0;
          const i2 = t3.timestamp - Date.now();
          return Math.abs(i2) > 1e3 + t3.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? i2 : 0;
        }
        getNtpWallTimeInMs() {
          return "visible" === document.visibilityState && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
        }
        setProxyServer(e2, t3) {
          if (kw2(e2, "proxyServer"), !t3) {
            if ("DISCONNECTED" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Set proxy server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new ED(ww2.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e2, _D.setProxyServer(this._proxyServer), sD.setProxyServer(this._proxyServer), sD.info("[".concat(this._clientId, "] Set proxy server ").concat(t3 ? "by initialize call" : "", " success."));
        }
        setTurnServer(e2, t3) {
          if (Array.isArray(e2) || (e2 = [e2]), !t3) {
            if ("DISCONNECTED" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Set turn server before join channel");
            if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new ED(ww2.INVALID_OPERATION, "You have already set the proxy");
          }
          if (Qw2(e2)) return this._turnServer = { servers: e2, mode: "original-manual" }, void sD.info("[".concat(this._clientId, "] Set original turnserver ").concat(t3 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), "."));
          e2.forEach((e3) => $w2(e3)), this._turnServer = { servers: e2, mode: "manual" }, sD.info("[".concat(this._clientId, "] Set turnserver ").concat(t3 ? "by initialize call" : "", " success."));
        }
        setLicense(e2) {
          if ("DISCONNECTED" !== this.connectionState) {
            throw new ED(ww2.INVALID_OPERATION, "you should set license before join channel");
          }
          if (kw2(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2)) throw new ED(ww2.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
          this._license = e2, sD.info("[".concat(this._clientId, "] set license success"), e2);
        }
        startProxyServer(e2) {
          if ("DISCONNECTED" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Start proxy server before join channel");
          if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) throw new ED(ww2.INVALID_OPERATION, "You have already set the proxy");
          const t3 = [3, 4, 5];
          let i2;
          switch (void 0 === e2 && (e2 = 3), e2) {
            case 1:
            case 2:
              throw new ED(ww2.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
            case 3:
              i2 = "proxy3";
              break;
            case 4:
              i2 = "proxy4";
              break;
            case 5:
              i2 = "proxy5";
              break;
            default:
              throw new ED(ww2.INVALID_PARAMS, "proxy server mode must be ".concat(t3.join("|")));
          }
          this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, sD.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
        }
        stopProxyServer() {
          if ("DISCONNECTED" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "Stop proxy server after leave channel");
          _D.setProxyServer(), sD.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", sD.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
        }
        setLocalAccessPointsV2(e2) {
          if (!e2.accessPoints) throw new ED(ww2.INVALID_PARAMS, "accessPoints is required.");
          Mw2(e2.accessPoints.serverList, "accessPoints.serverList"), kw2(e2.accessPoints.domain, "accessPoints.domain");
          const t3 = (e3, t4) => {
            Pw2(e3, t4, 0, 65535, true);
          };
          let i2 = 443;
          if (e2.accessPoints.port && (t3(e2.accessPoints.port, "accessPoints.port"), i2 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new ED(ww2.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          wN("CLOSE_AFB_FOR_LOCAL_AP") && (AN("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), AN("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
          const n3 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, o2 = e2.accessPoints.serverList.map((e3) => n3.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3), s2 = o2.map((e3) => "".concat(e3, ":").concat(i2));
          this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, AN("WEBCS_DOMAIN", s2), AN("WEBCS_DOMAIN_BACKUP_LIST", s2), AN("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (Mw2(e2.report.hostname, "report.hostname"), AN("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), AN("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (AN("EVENT_REPORT_DOMAIN", o2[0]), AN("EVENT_REPORT_BACKUP_DOMAIN", o2[1] || o2[0]));
          let a3 = 6443;
          e2.report && e2.report.port && (t3(e2.report.port, "report.port"), a3 = e2.report.port), AN("STATS_COLLECTOR_PORT", a3), e2.report ? AN("ENABLE_EVENT_REPORT", true) : AN("ENABLE_EVENT_REPORT", false);
          let c3 = "";
          e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (Mw2(e2.log.hostname, "log.hostname"), c3 = e2.log.hostname[0]) : c3 = o2[0];
          let d2 = 6444;
          e2.log && e2.log.port && (t3(e2.log.port, "log.port"), d2 = e2.log.port), AN("LOG_UPLOAD_SERVER", "".concat(c3, ":").concat(d2));
          let l2 = [];
          e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (Mw2(e2.cds.hostname, "cds.hostname"), l2 = e2.cds.hostname) : l2 = o2;
          let u3 = 443;
          e2.cds && e2.cds.port && (t3(e2.cds.port, "cds.port"), u3 = e2.cds.port), AN("CDS_AP", l2.map((e3) => "".concat(e3, ":").concat(u3))), e2.cds ? AN("ENABLE_CONFIG_DISTRIBUTE", true) : AN("ENABLE_CONFIG_DISTRIBUTE", false), sD.info("set local access point v2 success");
        }
        setLocalAccessPoints(e2, t3) {
          if (Mw2(e2, "serverList"), kw2(t3, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new ED(ww2.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const i2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e2 = e2.map((e3) => i2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t3) : e3), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, AN("WEBCS_DOMAIN", e2), AN("WEBCS_DOMAIN_BACKUP_LIST", e2), AN("GATEWAY_DOMAINS", [t3]), AN("EVENT_REPORT_DOMAIN", e2[0]), AN("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), AN("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), sD.info("[".concat(this._clientId, "] set local access point success"));
        }
        async setRemoteDefaultVideoStreamType(e2) {
          if (Dw2(e2, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]), this._remoteDefaultVideoStreamType = e2, this._joinInfo) try {
            await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
          }
          else sD.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
        }
        async setRemoteVideoStreamType(e2, t3) {
          Dw2(t3, "streamType", [0, 1, 4, 5, 6, 7, 8, 9]);
          try {
            await this._gateway.setRemoteVideoStreamType(e2, t3), setTimeout(() => {
              const t4 = this._users.find((t5) => t5.uid === e2);
              t4 && t4.videoTrack && t4.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
          }
          sD.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t3)), this._remoteStreamTypeCacheMap.set(e2, t3);
        }
        async setStreamFallbackOption(e2, t3) {
          Dw2(t3, "fallbackType", [0, 1, 2, 3, 4, 5, 6, 7, 8]);
          try {
            await this._gateway.setStreamFallbackOption(e2, t3);
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
          }
          sD.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t3)), this._streamFallbackTypeCacheMap.set(e2, t3);
        }
        setEncryptionConfig(e2, t3, i2, n3) {
          !function(e3) {
            Dw2(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
          }(e2), kw2(t3, "secret");
          const r2 = ["aes-128-gcm2", "aes-256-gcm2"];
          if (Ln2(r2).call(r2, e2)) {
            if (!i2 || !(i2 instanceof Uint8Array && 32 === i2.length)) throw new ED(ww2.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
          } else if (i2) throw new ED(ww2.INVALID_PARAMS, "current encrypt mode does not need salt");
          if (n3) {
            if (Nw2(n3, "encryptDataStream"), !Ln2(r2).call(r2, e2)) throw new ED(ww2.INVALID_PARAMS, "current encrypt mode does not support data stream");
            this._encryptDataStream = true;
          }
          new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t3) || sD.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t3, i2 && (this._encryptionSalt = SO(i2));
        }
        async renewToken(e2) {
          if (kw2(e2, "token", 1, 2047), !this._key || !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "renewToken should not be called before user join");
          const t3 = this._key;
          this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
          const i2 = await this._renewTokenMutex.lock();
          try {
            if (wN("USE_NEW_TOKEN")) {
              sD.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
              const t4 = await BF(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || BO);
              sD.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t4 });
            } else sD.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
            sD.debug("[".concat(this._clientId, "] renewToken success"));
          } catch (e3) {
            throw this._key = t3, this._joinInfo.token = t3, sD.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
          } finally {
            i2();
          }
        }
        enableAudioVolumeIndicator() {
          this._audioVolumeIndicationInterval ? sD.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
            const e2 = this._p2pChannel.getAudioLevels();
            this.safeEmit(tO.VOLUME_INDICATOR, e2);
          }, wN("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
        }
        getRTCStats() {
          const e2 = this._statsCollector.getRTCStats(), t3 = this._gateway.getInChannelInfo();
          return e2.Duration = Math.round(t3.duration / 1e3), e2;
        }
        async startLiveStreaming(e2, t3) {
          if (!t3) {
            if ("h264" !== this.codec) throw new ED(ww2.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
            if (!this._p2pChannel.hasLocalMedia()) throw new ED(ww2.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2)) throw new ED(ww2.LIVE_STREAMING_TASK_CONFLICT);
          const i2 = t3 ? HU.TRANSCODE : HU.RAW;
          return this._createLiveStreamingClient(i2).startLiveStreamingTask(e2, i2);
        }
        setLiveTranscoding(e2) {
          return this._createLiveStreamingClient(HU.TRANSCODE).setTranscodingConfig(e2);
        }
        async stopLiveStreaming(e2) {
          const t3 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t4) => t4 && t4.hasUrl(e2));
          if (!t3.length) throw new ED(ww2.INVALID_PARAMS, "can not find live streaming url to stop");
          await ip2.all(t3.map((t4) => t4 && t4.stopLiveStreamingTask(e2)));
        }
        async startChannelMediaRelay(e2) {
          ZF(e2);
          const t3 = this._createChannelMediaRelayClient();
          await t3.startChannelMediaRelay(e2);
        }
        async updateChannelMediaRelay(e2) {
          ZF(e2);
          const t3 = this._createChannelMediaRelayClient();
          await t3.updateChannelMediaRelay(e2);
        }
        async stopChannelMediaRelay() {
          const e2 = this._createChannelMediaRelayClient();
          await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
        }
        sendAudioMetadata(e2) {
          this._p2pChannel instanceof tj2 && this._p2pChannel.addAudioMetadata(e2);
        }
        async sendStreamMessage(e2) {
          var t3;
          let i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (!this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "can not send data stream, not joined");
          if (("string" == typeof e2 || e2 instanceof Uint8Array) && (e2 = { payload: e2 }), "string" == typeof e2.payload) {
            const t4 = new TextEncoder();
            e2.payload = t4.encode(e2.payload);
          }
          let n3 = false;
          this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Ln2(t3 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t3, this._encryptionMode) && (n3 = true, e2.payload = await async function(e3, t4, i3) {
            var n4;
            const r2 = nr2(n4 = Array.from(i3)).call(n4, (e4, t5) => e4 + t5, 0), o2 = { serverTs: 0, seq: VN++, length: i3.length, checkSum: r2 }, s2 = new Uint8Array(PO(r2, 2)), a3 = new ArrayBuffer(UN), c3 = new DataView(a3);
            c3.setUint32(0, o2.serverTs), c3.setUint16(4, o2.seq), c3.setUint16(6, o2.length), c3.setUint16(8, o2.checkSum);
            const d2 = 16 - i3.length % 16;
            i3 = TO(i3, new Uint8Array(d2));
            const l2 = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: e3, tagLength: LN, additionalData: s2 }, t4, i3);
            return TO(new Uint8Array(a3), new Uint8Array(l2));
          }(this._encryptDataStreamIv, this._encryptDataStreamKey, e2.payload));
          if (new Blob([e2.payload]).size > 1024) throw new ED(ww2.INVALID_PARAMS, n3 ? "encrypted stream message out of range." : "stream message out of range.");
          return this._gateway.signal.request(VU.DATA_STREAM, { payload: SO(e2.payload), syncWithAudio: e2.syncWithAudio, sendTs: Date.now() - oj2 }, !i2);
        }
        sendMetadata(e2) {
          if (!this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e2]).size > 1024) throw new ED(ww2.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(VU.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: SO(e2) });
        }
        async sendCustomReportMessage(e2) {
          if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(cD2), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "can not send custom report, not joined");
          await _D.sendCustomReportMessage(this._joinInfo.sid, e2);
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          const e2 = this._statsCollector.getRemoteNetworkQualityStats();
          if (wN("DELETE_NEQ_AFTER_USER_LEAVE")) {
            const t3 = this._users.map((e3) => e3.uid + "");
            Object.keys(e2).forEach((i2) => {
              Ln2(t3).call(t3, i2) || delete e2[i2];
            });
          }
          return e2;
        }
        async pickSVCLayer(e2, t3) {
          Dw2(t3.spatialLayer, "spatialLayer", [0, 1, 2, 3]), Dw2(t3.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e2, t3);
          } catch (e3) {
            throw sD.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
          }
        }
        async setRTMConfig(e2) {
          const { apRTM: t3 = false, rtmFlag: i2 } = e2;
          if (Nw2(t3, "apRTM"), Pw2(i2, "rtmFlag", 0), this._rtmConfig.apRTM = t3, this._rtmConfig.rtmFlag = i2, sD.debug("[".concat(this._clientId, "] setRTMconfig ").concat(JSON.stringify(e2), " in ").concat(this.connectionState, " state")), ("CONNECTED" === this.connectionState || "RECONNECTING" === this.connectionState) && this._joinInfo) return this._joinInfo.apRTM = t3, this._joinInfo.rtmFlag = i2, this._gateway.setRTM2Flag(i2);
        }
        _reset() {
          if (sD.debug("[".concat(this._clientId, "] reset client")), function(e2) {
            const t3 = HM.indexOf(e2);
            -1 !== t3 && HM.splice(t3, 1);
          }(this._clientId), this.store.hasStartJoinChannel = false, this.store.isABTestSuccess = false, this.store.autoSubscribe = false, this._axiosCancelSource.cancel(), this._axiosCancelSource = UA2.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo && Nj2(this._joinInfo), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId && _D.removeSid(this._sessionId), this._sessionId = null, this.store.sessionId = null, this.store.resetFirstVideoFrameDecoded(), this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach((e2) => {
            e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy(), e2._dataChannels && (e2._dataChannels.forEach((e3) => e3._close()), e2._dataChannels.length = 0);
          }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new xO("client-publish", this._clientId), this._subscribeMutex = new xO("client-subscribe", this._clientId), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
          }
          if (this._moderation) try {
            this.setImageModeration(false);
          } catch (e2) {
          }
        }
        _startSession(e2, t3) {
          var i2;
          const n3 = e2 || bO();
          e2 ? sD.debug("[".concat(this._clientId, "] new Session ").concat(n3)) : sD.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(n3));
          const r2 = e2 ? "" : this._sessionId || "";
          this._sessionId = n3, this.store.sessionId = n3, _D.addSid(n3);
          const o2 = { lts: (/* @__PURE__ */ new Date()).getTime(), mode: this.mode, buildFormat: 1, stringUid: (null == t3 ? void 0 : t3.stringUid) || (null === (i2 = this._joinInfo) || void 0 === i2 ? void 0 : i2.stringUid), channelProfile: "live" === this.mode ? 1 : 0, channelMode: 0, isABTestSuccess: Number(this._configDistribute.isSuccess), lsid: r2, clientRole: "audience" === this.role ? 2 : 1 };
          _D.sessionInit(this._sessionId, oW({ cname: t3.channel, appid: t3.appId }, o2)), this._joinInfo && (this._joinInfo.sid = n3), this._gateway.joinInfo && (this._gateway.joinInfo.sid = n3);
        }
        async _publishHighStream(e2) {
          if (!this._joinInfo || void 0 === this._uid) throw new ED(ww2.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if ("auto" === this._turnServer.mode && wN("FORCE_TURN") && !wN("TURN_ENABLE_TCP") && !wN("TURN_ENABLE_UDP")) throw new ED(ww2.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          sD.debug("[".concat(this._clientId, "] publish high stream"));
          try {
            const i2 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter);
            if (this.store.useP2P) {
              const e3 = (await i2.next()).value;
              if (e3) {
                try {
                  await this._gateway.sendExtensionMessage(NV.PUBLISH, e3, true);
                } catch (e4) {
                  throw i2.throw(e4), e4;
                }
                await i2.next();
              }
              this._p2pChannel.reportPublishEvent(true, null);
            } else {
              const n3 = (await i2.next()).value;
              if (n3) {
                var t3;
                let e3;
                try {
                  e3 = await this._gateway.publish(this._uid, n3, true);
                } catch (e4) {
                  if (e4.code !== ww2.DISCONNECT_P2P) throw i2.throw(e4), e4;
                }
                await i2.next((null === (t3 = e3) || void 0 === t3 ? void 0 : t3.ortc) || []);
              }
              this._p2pChannel.reportPublishEvent(true, null);
              for (const t4 of e2) t4 instanceof kk2 && t4._encoderConfig && this._gateway.setVideoProfile(t4._encoderConfig).catch((e3) => {
                sD.debug("[".concat(this._clientId, "] stop setVideoProfile, because websocket is closed"));
              }), !t4.muted && t4.enabled || await this._p2pChannel.muteLocalTrack(t4);
            }
          } catch (t4) {
            if (this._p2pChannel.reportPublishEvent(false, null == t4 ? void 0 : t4.code, e2), (null == t4 ? void 0 : t4.code) === ww2.WS_ABORT) return;
            throw t4;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || void 0 === this._uid) throw new ED(ww2.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          sD.debug("[".concat(this._clientId, "] publish low stream"));
          const e2 = this._configDistribute.getLowStreamConfigDistribute();
          e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
          try {
            const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i2 = (await e3.next()).value;
            if (i2) {
              var t3;
              let n3;
              try {
                n3 = await this._gateway.publish(this._uid, i2, true);
              } catch (t4) {
                if (t4.code !== ww2.DISCONNECT_P2P) throw e3.throw(t4), t4;
              }
              e3.next((null === (t3 = n3) || void 0 === t3 ? void 0 : t3.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e3) {
            if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === ww2.WS_ABORT) return;
            throw e3;
          }
        }
        _createLiveStreamingClient(e2) {
          const t3 = () => {
            if (!this._joinInfo || !this._appId) {
              return new ED(ww2.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
            }
            const e3 = (t4 = { joinInfo: this._joinInfo, appId: this._appId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig }, Jx2("LiveStreaming").create(t4));
            var t4;
            return e3.onLiveStreamError = (e4, t5) => {
              _D.reportApiInvoke(this._sessionId, { name: zw2.ON_LIVE_STREAM_ERROR, options: [e4, t5], tag: qw2.TRACER }).onSuccess(), this.safeEmit(tO.LIVE_STREAMING_ERROR, e4, t5);
            }, e3.onLiveStreamWarning = (e4, t5) => {
              _D.reportApiInvoke(this._sessionId, { name: zw2.ON_LIVE_STREAM_WARNING, options: [e4, t5], tag: qw2.TRACER }).onSuccess(), this.safeEmit(tO.LIVE_STREAMING_WARNING, e4, t5);
            }, e3.on(JU.REQUEST_WORKER_MANAGER_LIST, (e4, t5, i2) => {
              if (!this._joinInfo) return i2(new ED(ww2.INVALID_OPERATION, "can not find join info to get worker manager"));
              (async function(e5, t6, i3, n3) {
                const r2 = wN("UAP_AP").slice(0, wN("AJAX_REQUEST_CONCURRENT")).map((e6) => t6.proxyServer ? "https://".concat(t6.proxyServer, "/ap/?url=").concat(e6 + "/api/v1?action=uap") : "https://".concat(e6, "/api/v1?action=uap"));
                return await SF(r2, e5, t6, i3, n3);
              })(e4, this._joinInfo, this._axiosCancelSource.token, BO).then(t5).catch(i2);
            }), e3;
          };
          return e2 === HU.RAW ? (this._liveRawStreamingClient = this._liveRawStreamingClient || t3(), this._liveRawStreamingClient) : (this._liveTranscodeStreamingClient = this._liveTranscodeStreamingClient || t3(), this._liveTranscodeStreamingClient);
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new ED(ww2.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          if (!this._channelMediaRelayClient) {
            const { sendResolutionWidth: t3, sendResolutionHeight: i2 } = this.getLocalVideoStats(), n3 = (e2 = { joinInfo: this._joinInfo, clientId: this._clientId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig, resolution: { width: t3, height: i2 } }, Jx2("ChannelMediaRelay").create(e2));
            n3.on("state", (e3) => {
              e3 === tV.RELAY_STATE_FAILURE && n3 && n3.dispose(), this.safeEmit(tO.CHANNEL_MEDIA_RELAY_STATE, e3);
            }), n3.on("event", (e3) => {
              this.safeEmit(tO.CHANNEL_MEDIA_RELAY_EVENT, e3);
            }), this._channelMediaRelayClient = n3, this._statsCollector.onStatsChanged = (e3, t4) => {
              var i3;
              "resolution" === e3 && (null === (i3 = this._channelMediaRelayClient) || void 0 === i3 || i3.setVideoProfile(t4));
            };
          }
          var e2;
          return this._channelMediaRelayClient;
        }
        _handleUpdateDataChannel(e2, t3) {
          const { added: i2, deleted: n3 } = e2, r2 = [];
          if (t3) {
            const e3 = [];
            this._users.forEach((t4) => {
              t4._dataChannels.forEach((n4) => {
                i2.every((e4) => e4.uid !== t4._uintid || e4.stream_id !== n4.id) && e3.push({ uid: t4._uintid, stream_id: n4.id, ordered: n4.ordered, max_retrans_times: n4.maxRetransmits, metadata: n4.metadata });
              });
            }), e3.length > 0 && this._handleUpdateDataChannel({ added: [], deleted: e3 });
          }
          Array.isArray(i2) && i2.length > 0 && i2.forEach((e3) => {
            const { uid: i3, stream_id: n4, ordered: o2, max_retrans_times: s2, metadata: a3 } = e3, c3 = this._users.find((e4) => e4._uintid === i3);
            if (!c3) return void sD.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
            sD.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(i3)), Ln2(r2).call(r2, c3) || r2.push(c3), c3._uintid || (c3._uintid = i3);
            if (!(-1 !== c3._dataChannels.findIndex((t4) => t4.id === e3.stream_id))) {
              const e4 = { id: n4, ordered: !!o2, maxRetransmits: s2, metadata: a3 }, i4 = function(e5) {
                return Zx2(e5, true);
              }(e4);
              c3._dataChannels.push(i4), sD.info("[".concat(this._clientId, "] remote user ").concat(c3.uid, " published datachannel")), t3 || this.safeEmit(tO.USER_PUBLISHED, c3, "datachannel", e4);
            }
            this._p2pChannel.hasPendingRemoteDataChannel(c3, e3.stream_id) && (sD.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(c3.uid, " after reconnect.")), this._subscribeDataChannel(c3, e3.stream_id).catch((e4) => {
              sD.error("[".concat(this._clientId, "] resubscribe datachannel error"), e4.toString());
            }));
          }), t3 && (this.safeEmit(tO.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(n3) && n3.length > 0 && n3.forEach((e3) => {
            const { uid: t4, stream_id: i3 } = e3, n4 = this._users.find((e4) => e4._uintid === t4);
            if (!n4) return void sD.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
            const r3 = n4._dataChannels.find((t5) => t5.id === e3.stream_id);
            r3 && (sD.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(t4)), this._p2pChannel.unsubscribeDataChannel(n4, [r3]).then((e4) => {
              if (n4._dataChannels = n4._dataChannels.filter((e5) => e5 !== r3), e4) return this._gateway.unsubscribeDataChannel(e4, n4.uid);
            }), sD.info("[".concat(this._clientId, "] remote user ").concat(t4, " unpublished datachannel ,id:").concat(r3.id)), this.safeEmit(tO.USER_UNPUBLISHED, n4, "datachannel", r3._config));
          });
        }
        _getEncodingName(e2) {
          var t3;
          if (!this._joinResponse) return;
          const i2 = null === (t3 = this._joinResponse.ortc.rtpCapabilities.sendrecv) || void 0 === t3 ? void 0 : t3.videoCodecs;
          if (i2) for (const t4 of i2) {
            var n3;
            if (t4.payloadType === e2) return null == t4 || null === (n3 = t4.rtpMap) || void 0 === n3 ? void 0 : n3.encodingName;
          }
        }
        _handleRemoveDataChannels(e2) {
          const t3 = this._users.find((t4) => t4.uid === e2.uid);
          if (t3) {
            if (void 0 !== t3._dataChannels && t3._dataChannels.length > 0) {
              sD.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(e2.uid));
              const i2 = () => {
                sD.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished datachannel")), t3._dataChannels.forEach((e3) => {
                  this.safeEmit(tO.USER_UNPUBLISHED, t3, "datachannel", e3._config);
                });
              };
              this._p2pChannel.unsubscribeDataChannel(t3, t3._dataChannels).then((e3) => {
                if (e3) return this._gateway.unsubscribeDataChannel(e3, t3.uid);
              }), i2();
            }
          } else sD.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
        }
        _handleGatewayEvents() {
          this._gateway.on(rV.UPDATE_GATEWAY_CONFIG, () => {
            !function() {
              let e2;
              try {
                e2 = window.localStorage.getItem("websdk_ng_global_parameter");
              } catch (e3) {
                return void sD.error("Error loading sdk config", e3.message);
              }
              if (e2) try {
                const t3 = JSON.parse(window.atob(e2)), i2 = Date.now();
                Object.keys(t3).forEach((e3) => {
                  const { value: n3, type: r2, expires: o2 } = t3[e3];
                  o2 && o2 <= i2 || r2 || YM() || !Object.prototype.hasOwnProperty.call(vN, e3) || (NN[e3] = n3, bN[e3] = n3, sD.debug("Update gateway parameters from config distribute", e3, n3));
                });
              } catch (e3) {
                sD.error("Error update config from local cache", e3.message);
              }
            }();
          }), this._gateway.on(rV.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }), this._gateway.on(rV.CONNECTION_STATE_CHANGE, (e2, t3, i2) => {
            var n3;
            if (i2 === Zw2.FALLBACK) return;
            const r2 = () => {
              this.safeEmit(tO.CONNECTION_STATE_CHANGE, e2, t3, i2);
            };
            if (_D.reportApiInvoke(this._sessionId || (null === (n3 = this._gateway.joinInfo) || void 0 === n3 ? void 0 : n3.sid) || null, { name: zw2.CONNECTION_STATE_CHANGE, options: [e2, t3, i2], tag: qw2.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t3, reason: i2 })), sD.info("[".concat(this._clientId, "] signal connection state change: ").concat(t3, " -> ").concat(e2)), "DISCONNECTED" === e2) return this._reset(), void r2();
            if ("RECONNECTING" === e2) this._users.forEach((e3) => {
              e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._is_pre_created || (e3._audio_pre_subscribed || (e3._audioSSRC = void 0, e3._audioOrtc = void 0), e3._video_pre_subscribed || (e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._rtxSsrcId = void 0), e3._cname = void 0);
            }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if ("CONNECTED" === e2) {
              var o2;
              this._streamFallbackTypeCacheMap.forEach((e3, t4) => {
                this._gateway.setStreamFallbackOption(t4, e3).catch((e4) => {
                  sD.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
                });
              }), this._remoteStreamTypeCacheMap.forEach((e3, t4) => {
                this._gateway.setRemoteVideoStreamType(t4, e3).catch((e4) => {
                  sD.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
                });
              }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                sD.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              }).catch((e3) => {
                sD.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
              }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                if ("CONNECTED" !== this.connectionState) return;
                this._userOfflineTimeout = void 0;
                this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                  sD.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                });
              }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                  e3._trust_audio_mute_state_ || (sD.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, EV.AUDIO, false)), e3._trust_video_mute_state_ || (sD.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, EV.VIDEO, false)), e3._trust_audio_enabled_state_ || (sD.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (sD.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (sD.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (sD.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (sD.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                }));
              }, 1e3));
            }
            r2();
          }), this._gateway.on(rV.REQUEST_NEW_GATEWAY_LIST, async (e2, t3) => {
            if (!this._joinInfo) return t3(new ED(ww2.UNEXPECTED_ERROR, "can not recover, no join info"));
            try {
              let t4;
              const i2 = await Aj2(oW(oW({}, this._joinInfo), {}, { uid: this._joinInfo.uid, stringUid: void 0 }));
              i2 ? (t4 = i2.ap, Dj2(i2), this._joinInfo.preload = true) : (t4 = await PF(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || BO, this.store), this._joinInfo.preload = false), this._joinInfo && (this._joinInfo.apResponse = t4.gatewayInfo.res, this._joinInfo.gatewayAddrs = t4.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t4.gatewayInfo.uni_lbs_ip);
              const n3 = [];
              t4.gatewayInfo.gatewayAddrs.forEach((e3) => {
                let { address: t5 } = e3;
                const [i3, r2] = t5.split(":");
                this._joinInfo && this._joinInfo.proxyServer ? n3.push({ proxy: this._joinInfo.proxyServer, host: i3, port: r2 }) : n3.push({ host: i3, port: r2 });
              }), e2(n3);
            } catch (e3) {
              t3(e3);
            }
          }), this._gateway.on(rV.NETWORK_QUALITY, (e2) => {
            "normal" === this._networkQualitySensitivity && this.safeEmit(tO.NETWORK_QUALITY, e2);
          }), this._gateway.on(rV.STREAM_TYPE_CHANGE, (e2, t3) => {
            this.safeEmit(tO.STREAM_TYPE_CHANGED, e2, t3);
            _D.reportApiInvoke(this._sessionId, { name: zw2.STREAM_TYPE_CHANGE, options: [e2, t3], tag: qw2.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t3 }));
          }), this._gateway.isPreSub = () => "isPreSub" in this._p2pChannel && this._p2pChannel.isPreSub(), this._gateway.isPreallocation = () => "isPreallocation" in this._p2pChannel && this._p2pChannel.isPreallocation(), this._gateway.on(rV.IS_P2P_DISCONNECTED, (e2) => {
            this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
          }), this._gateway.on(rV.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t3, i2) => {
            try {
              let i3 = await this._p2pChannel.getEstablishParams();
              i3 && "isPreallocation" in this._p2pChannel && this._p2pChannel.isPreallocation() || (i3 = await this._p2pChannel.startP2PConnection(e2)), t3(i3);
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.on(rV.JOIN_RESPONSE, (e2, t3) => {
            if (this.store.useP2P) return;
            let i2;
            this._joinResponse = e2, e2.attributes ? i2 = e2.attributes.userAttributes.preSubSsrcs : sD.debug("no attributes in joinResponse");
            const n3 = yx2(e2.ortc, t3, i2);
            this._p2pChannel.connect(n3);
          }), this._gateway.on(rV.PRE_CONNECT_PC, async (e2) => {
            const { candidates: t3, fingerprint: i2, turnServer: n3 } = e2;
            if (this._joinInfo && t3.length > 0 && !this._p2pChannel.isPlanB) {
              const { cert: e3, cid: o2 } = this._joinInfo.apResponse, s2 = "".concat(o2, "_").concat(e3);
              if (s2.length < 4 || s2.length > 256) return;
              await this._p2pChannel.startP2PConnection({ turnServer: n3, cloudProxyServer: this._joinInfo.cloudProxyServer, isPreallocation: true });
              try {
                var r2;
                await this._p2pChannel.connect({ iceParameters: { iceUfrag: "".concat(o2, "_").concat(e3), icePwd: "".concat(o2, "_").concat(e3) }, dtlsParameters: { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (r2 = wN("FINGERPRINT")) && void 0 !== r2 ? r2 : i2 }] }, candidates: t3, rtpCapabilities: { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, setup: "active", cname: "o/i14u9pJrxRKAsu", preallocation: true });
              } catch (e4) {
                e4.code && e4.code === ww2.EXCHANGE_SDP_FAILED && await this._p2pChannel.startP2PConnection({ turnServer: n3, cloudProxyServer: this._joinInfo.cloudProxyServer }, true);
              }
            }
          });
        }
        _handleGatewaySignalEvents() {
          this._gateway.signal.on(FU.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(FU.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(FU.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.pt, e2.uint_id, e2.ortc)), this._gateway.signal.on(FU.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.pt, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(FU.ON_REMOTE_DATASTREAM_UPDATE, (e2) => {
            this._handleUpdateDataChannel(e2);
          }), this._gateway.signal.on(FU.ON_REMOTE_FULL_DATASTREAM_INFO, (e2) => {
            this._handleUpdateDataChannel({ added: e2.datastreams || [], deleted: [] }, true);
          }), this._gateway.signal.on(FU.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(FU.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(FU.MUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, EV.AUDIO, true)), this._gateway.signal.on(FU.UNMUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, EV.AUDIO, false)), this._gateway.signal.on(FU.MUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, EV.VIDEO, true)), this._gateway.signal.on(FU.UNMUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, EV.VIDEO, false)), this._gateway.signal.on(FU.RECEIVE_METADATA, (e2) => {
            const t3 = fO(e2.metadata);
            this.safeEmit(tO.RECEIVE_METADATA, e2.uid, t3);
          }), this._gateway.signal.on(FU.ON_DATA_STREAM, async (e2) => {
            var t3;
            if (!e2) return;
            let i2 = fO(e2.payload);
            if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && Ln2(t3 = ["aes-128-gcm2", "aes-256-gcm2"]).call(t3, this._encryptionMode)) {
              if (e2.payload.length < UN) throw new ED(ww2.UNEXPECTED_RESPONSE, "payload length ".concat(e2.payload.length, " is less than header length ").concat(UN));
              const t4 = await async function(e3, t5, i3) {
                const n4 = i3.subarray(0, UN), r2 = n4.slice(8, UN), o2 = (r2[0] << 8) + r2[1], s2 = (n4[6] << 8) + n4[7], a3 = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: e3, tagLength: LN, additionalData: new Uint8Array(PO(o2, 2)) }, t5, i3.subarray(UN));
                return new Uint8Array(a3).subarray(0, s2);
              }(this._encryptDataStreamIv, this._encryptDataStreamKey, i2);
              i2 = t4;
            }
            let n3 = 0;
            if (e2.ordered || e2.syncWithAudio) {
              const t4 = this._p2pChannel.getStats(), i3 = this.remoteUsers.find((t5) => t5.uid === e2.uid), r2 = null == t4 ? void 0 : t4.audioRecv.find((e3) => e3.ssrc === (null == i3 ? void 0 : i3._audioSSRC));
              n3 = null == r2 ? void 0 : r2.jitterBufferMs;
            }
            (null == n3 || Number.isNaN(n3)) && (n3 = 0), uj2(oW(oW({}, e2), {}, { payload: i2 }), n3, { id: this._clientId, onStreamMessage: "function" == typeof this.onStreamMessage ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
          }), this._gateway.signal.on(FU.ON_CRYPT_ERROR, () => {
            mO(() => {
              sD.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(tO.CRYPT_ERROR);
            }, this._sessionId);
          }), this._gateway.signal.on(FU.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(FU.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            sD.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, Zw2.TOKEN_EXPIRE), this.safeEmit(tO.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          }), this._gateway.signal.on(FU.ON_STREAM_FALLBACK_UPDATE, (e2) => {
            sD.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(tO.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
          }), this._gateway.signal.on(FU.ON_PUBLISH_STREAM, (e2) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), sD.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
          }), this._gateway.signal.on(FU.ENABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, true);
          }), this._gateway.signal.on(FU.DISABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, false);
          }), this._gateway.signal.on(UU.REQUEST_TIMEOUT, (e2, t3) => {
            if (this._joinInfo) switch (e2) {
              case VU.PUBLISH: {
                if (!t3) return;
                const e3 = t3.ortc;
                if (e3) {
                  var i2, n3;
                  const r2 = e3.some((e4) => {
                    let { stream_type: t4 } = e4;
                    return t4 === nV.Audio;
                  }), o2 = e3.some((e4) => {
                    let { stream_type: t4 } = e4;
                    return t4 !== nV.Audio;
                  }), s2 = e3.some((e4) => {
                    let { stream_type: t4 } = e4;
                    return t4 === nV.Screen || t4 === nV.ScreenLow;
                  });
                  "offer" === t3.state && _D.publish(this._joinInfo.sid, { eventElapse: YF.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: ww2.TIMEOUT, audio: r2, video: o2, p2pid: t3.p2p_id, publishRequestid: this.store.pubId, screenshare: s2, audioName: r2 ? null === (i2 = e3.find((e4) => {
                    let { stream_type: t4 } = e4;
                    return t4 === nV.Audio;
                  })) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId.toString() : void 0, videoName: o2 ? null === (n3 = e3.find((e4) => {
                    let { stream_type: t4 } = e4;
                    return t4 !== nV.Audio;
                  })) || void 0 === n3 || null === (n3 = n3.ssrcs[0]) || void 0 === n3 ? void 0 : n3.ssrcId.toString() : void 0 });
                }
                break;
              }
              case VU.SUBSCRIBE:
                t3 && _D.subscribe(this._joinInfo.sid, { succ: false, ec: ww2.TIMEOUT, audio: t3.stream_type === EV.AUDIO, video: t3.stream_type === EV.VIDEO, peerid: t3.stream_id, subscribeRequestid: t3.ssrcId, p2pid: this.store.p2pId, eventElapse: YF.measureFromSubscribeStart(this.store.clientId, t3.ssrcId), preSsrc: this._p2pChannel.isPreSubScribe(t3.ssrcId) });
            }
          }), this._gateway.signal.on(FU.ON_P2P_OK, (e2) => {
            this.uid, this._uid;
          }), this._gateway.signal.on(FU.ON_PUBLISHED_USER_LIST, (e2) => {
            if (null == e2 || !e2.users) return;
            wN("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter((e3) => !KM(e3.string_id || e3.stream_id, this.channelName)));
            const t3 = [], i2 = [];
            for (const n3 of e2.users) {
              let e3 = this._users.find((e4) => e4._uintid === n3.stream_id);
              e3 ? e3._trust_in_room_ = true : (e3 = new QF(n3.string_id || n3.stream_id, n3.stream_id), this._users.push(e3), this.store.firstVideoFrameDecoded(e3.uid, { userJoinNotify: Date.now() }), 0 === this.getListeners(tO.PUBLISHED_USER_LIST).length && (sD.debug("[".concat(this._clientId, "] user online"), n3.stream_id), this.safeEmit(tO.USER_JOINED, e3)));
              const r2 = sV.Audio & n3.stream_type, o2 = (sV.Video | sV.LwoVideo) & n3.stream_type, s2 = 0 != (65280 & n3.stream_type), a3 = r2 && e3.hasAudio, c3 = o2 && e3.hasVideo;
              o2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n3.video_ssrc, e3._rtxSsrcId = n3.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n3.audio_ssrc), r2 && !a3 && 0 === this.getListeners(tO.PUBLISHED_USER_LIST).length && (sD.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(tO.USER_PUBLISHED, e3, "audio")), o2 && !c3 && 0 === this.getListeners(tO.PUBLISHED_USER_LIST).length && (sD.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(tO.USER_PUBLISHED, e3, "video")), (r2 && !a3 || o2 && !c3 || s2) && t3.push(e3), o2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i2.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i2.push({ user: e3, mediaType: "audio" });
            }
            i2.length > 0 && (sD.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i2.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(i2).catch((e3) => {
              sD.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
            })), this.getListeners(tO.PUBLISHED_USER_LIST).length > 0 ? wN("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = t3 : (sD.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t3.map((e3) => e3.uid).join(", "))), this.safeEmit(tO.PUBLISHED_USER_LIST, t3)) : sD.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t3.map((e3) => e3.uid).join(", ")));
          }), this._gateway.signal.on(FU.ON_RTP_CAPABILITY_CHANGE, (e2) => {
            const { video_codec: t3 } = e2;
            this._p2pChannel instanceof tj2 && this._p2pChannel.updateRemoteRTPCapabilities(t3.map((e3) => e3.toLowerCase()).filter((e3) => {
              var t4;
              return Ln2(t4 = Object.keys(PN)).call(t4, e3);
            }));
          });
        }
        _handleP2PEvents() {
          this._gateway.signal.on(FU.ON_USER_OFFLINE, () => {
            this._p2pChannel.disconnectForReconnect();
          }), this._gateway.signal.on(NV.PUBLISH, (e2, t3, i2) => {
            const { uid: n3 } = e2;
            e2.forEach((e3) => {
              const { kind: r2, ssrcs: o2, mid: s2, isMuted: a3 } = e3;
              this._handleP2PAddAudioOrVideoStream(r2, n3, o2[0].ssrcId, s2);
              const c3 = this._users.find((e4) => e4.uid === n3);
              return c3 && this.store.useP2P ? this._p2pChannel.mockSubscribe(c3, r2, o2[0].ssrcId, s2).then(() => {
                t3();
              }).catch(i2) : t3(), this._handleMuteStream(n3, r2, !!a3);
            });
          }), this._gateway.signal.on(NV.CALL, async (e2, t3, i2) => {
            if (this.store.useP2P) try {
              var n3;
              t3(await this._p2pChannel.startP2P({ turnServer: null === (n3 = this._joinInfo) || void 0 === n3 ? void 0 : n3.turnServer }, e2));
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.signal.on(UU.P2P_CONNECTION, async (e2) => {
            this.store.useP2P && (await this._p2pChannel).p2pConnect(e2);
          }), this._gateway.signal.on(NV.UNPUBLISH, async (e2, t3, i2) => {
            if (this.store.useP2P) {
              const { unpubMsg: n3, uid: r2 } = e2, o2 = this._users.find((e3) => e3.uid === r2);
              if (!o2) return sD.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r2)), void t3();
              try {
                n3.forEach(async (e3) => {
                  let { stream_type: t4 } = e3;
                  const i3 = t4 === nV.Audio ? EV.AUDIO : EV.VIDEO;
                  await this._p2pChannel.unsubscribe(o2, i3), this._handleMuteStream(r2, i3, true);
                }), t3();
              } catch (e3) {
                i2(e3);
              }
            }
          }), this._gateway.signal.on(NV.CONTROL, async (e2, t3) => {
            const { action: i2 } = e2;
            switch (i2) {
              case PV.MUTE_LOCAL_VIDEO:
                this._handleMuteStream(t3, EV.VIDEO, true);
                break;
              case PV.MUTE_LOCAL_AUDIO:
                this._handleMuteStream(t3, EV.AUDIO, true);
                break;
              case PV.UNMUTE_LOCAL_VIDEO:
                this._handleP2PAddAudioOrVideoStream("video", t3), this._handleMuteStream(t3, EV.VIDEO, false);
                break;
              case PV.UNMUTE_LOCAL_AUDIO:
                this._handleP2PAddAudioOrVideoStream("audio", t3), this._handleMuteStream(t3, EV.AUDIO, false);
            }
          }), this._gateway.signal.on(NV.RESTART_ICE, async (e2, t3, i2) => {
            if (this.store.useP2P) try {
              const { direction: i3, iceParameter: n3 } = e2;
              if (i3 !== BU.SEND_ONLY || n3) {
                t3(await this._p2pChannel.restartICE(i3, n3));
              } else this._p2pChannel.handleDisconnect(i3), t3();
            } catch (e3) {
              i2(e3);
            }
          }), this._gateway.signal.on(NV.CANDIDATE, (e2) => {
            if (this.store.useP2P) {
              const { candidate: t3, direction: i2 } = e2;
              this._p2pChannel.addRemoteCandidate(t3, i2);
            }
          }), this._p2pChannel.on(RV.RequestP2PRestartICE, async (e2, t3, i2) => {
            try {
              const { direction: i3 } = e2;
              t3(await this._gateway.sendExtensionMessage(NV.RESTART_ICE, e2, i3 === BU.SEND_ONLY));
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(RV.LocalCandidate, (e2) => {
            this._gateway.sendExtensionMessage(NV.CANDIDATE, JSON.stringify(e2), true);
          }), this._p2pChannel.on(RV.RequestP2PMuteLocal, async (e2, t3, i2) => {
            try {
              await this._gateway.sendExtensionMessage(NV.CONTROL, e2, true), t3();
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(RV.RequestP2PUnmuteRemote, async (e2, t3, i2) => {
            if (this._joinInfo) try {
              await this._gateway.unmuteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t3();
            } catch (e3) {
              e3.code === ww2.DISCONNECT_P2P ? t3() : i2(e3);
            }
            else t3();
          }), this._p2pChannel.on(RV.RequestP2PMuteRemote, async (e2, t3, i2) => {
            if (this._joinInfo) try {
              await this._gateway.muteRemote(e2, this._joinInfo.stringUid || this._joinInfo.uid), t3();
            } catch (e3) {
              e3.code === ww2.DISCONNECT_P2P ? t3() : i2(e3);
            }
            else t3();
          }), this._p2pChannel.on(RV.StateChange, (e2, t3) => {
            t3 === TV.Connected && this._p2pChannel.republish();
          });
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(RV.PeerConnectionStateChange, (e2) => {
            const t3 = this._peerConnectionState;
            e2 !== t3 && (this.safeEmit(tO.PEERCONNECTION_STATE_CHANGE, e2, t3), this._peerConnectionState = e2);
          }), this._p2pChannel.on(RV.RequestMuteLocal, async (e2, t3, i2) => {
            if (this._joinInfo) try {
              await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t3();
            } catch (e3) {
              e3.code === ww2.DISCONNECT_P2P ? t3() : i2(e3);
            }
            else t3();
          }), this._p2pChannel.on(RV.RequestUnmuteLocal, async (e2, t3, i2) => {
            if (this._joinInfo) try {
              await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t3();
            } catch (e3) {
              e3.code === ww2.DISCONNECT_P2P ? t3() : i2(e3);
            }
            else t3();
          }), this._p2pChannel.on(RV.RequestRePublish, (e2, t3, i2) => {
            this.publish(e2, false).then(t3).catch(i2);
          }), this._p2pChannel.on(RV.RequestRePublishDataChannel, (e2, t3, i2) => {
            ip2.all(e2.map(async (e3) => {
              const t4 = await this._p2pChannel.publishDataChannel([e3]);
              try {
                t4.forEach((e4) => {
                  this._uid && this._gateway.publishDataChannel(this._uid, e4, true);
                });
              } catch (e4) {
                if (e4.code !== ww2.DISCONNECT_P2P) throw e4;
              }
            })).then(t3).catch(i2);
          }), this._p2pChannel.on(RV.RequestReSubscribe, async (e2, t3, i2) => {
            try {
              for (const { user: t4, kind: i3 } of e2) i3 === EV.VIDEO ? await this.subscribe(t4, "video") : await this.subscribe(t4, "audio");
              t3();
            } catch (e3) {
              i2(e3);
            }
          }), this._p2pChannel.on(RV.RequestUpload, (e2, t3) => {
            this._gateway.upload(e2, t3);
          }), this._p2pChannel.on(RV.RequestUploadStats, (e2) => {
            this._gateway.uploadWRTCStats(e2);
          }), this._p2pChannel.on(RV.MediaReconnectStart, (e2) => {
            this.safeEmit(tO.MEDIA_RECONNECT_START, e2);
          }), this._p2pChannel.on(RV.MediaReconnectEnd, (e2) => {
            this.safeEmit(tO.MEDIA_RECONNECT_END, e2);
          }), this._p2pChannel.on(RV.NeedSignalRTT, (e2) => {
            e2(this._gateway.getSignalRTT());
          }), this._p2pChannel.on(RV.RequestRestartICE, async (e2) => {
            if (this.store.useP2P) return;
            const t3 = await this._p2pChannel.restartICE(e2), i2 = await t3.next();
            if (i2.done) return;
            const n3 = i2.value;
            let r2;
            try {
              r2 = await this._gateway.restartICE({ iceParameters: n3 });
            } catch (e3) {
              return void t3.throw(e3);
            }
            const { iceParameters: o2 } = function(e3) {
              const t4 = e3.iceParameters;
              return { iceParameters: { iceUfrag: t4.iceUfrag, icePwd: t4.icePwd } };
            }(r2);
            await t3.next({ remoteIceParameters: o2 });
          }), this._p2pChannel.on(RV.RequestReconnect, async () => {
            this._gateway.reconnect();
          }), this._p2pChannel.on(RV.RequestReconnectPC, async () => {
            var e2;
            const { iceParameters: t3, dtlsParameters: i2, rtpCapabilities: n3 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: o2 } = await this._gateway.reconnectPC({ iceParameters: t3, dtlsParameters: i2, rtpCapabilities: n3 }), s2 = yx2(r2, o2);
            await this._p2pChannel.connect(s2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          }), this._p2pChannel.on(RV.RequestUnpublishForReconnectPC, async (e2, t3, i2) => {
            this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t3()) : i2();
          }), this._p2pChannel.on(RV.P2PLost, () => {
            this.safeEmit(tO.P2P_LOST, this.store.uid);
          }), this._p2pChannel.on(RV.UpdateVideoEncoder, (e2) => {
            e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
          }), this._p2pChannel.on(RV.ConnectionTypeChange, (e2) => {
            this.safeEmit(tO.IS_USING_CLOUD_PROXY, e2);
          }), this._p2pChannel.on(RV.RequestLowStreamParameter, (e2) => {
            e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
          }), this._p2pChannel.on(RV.QueryClientConnectionState, (e2) => {
            e2(this.connectionState);
          }), this._p2pChannel.on(RV.AudioMetadata, (e2) => {
            this.safeEmit(tO.AUDIO_METADATA, e2);
          }), this._p2pChannel.on(RV.AudioPts, (e2) => {
            this.safeEmit(tO.AUDIO_PTS, Number(e2));
          });
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        async enableContentInspect(e2) {
          if (!this._joinInfo || "CONNECTED" !== this.connectionState) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] can not create content inspect, please join channel first"));
          if (this._inspect) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
          try {
            const i2 = (t3 = { config: e2 }, Jx2("ContentInspect").create(t3));
            this._inspect = i2, this.handleVideoInspectEvents(i2);
            const { appId: n3, cname: r2, sid: o2, token: s2, uid: a3, cid: c3, vid: d2 } = this._joinInfo;
            await i2.init({ appId: n3, areaCode: "", cname: r2, sid: o2, token: s2, uid: a3, cid: c3, vid: d2 ? Number(d2) : 0 }, BO);
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
          var t3;
        }
        handleVideoInspectEvents(e2) {
          e2.on(yV.CONNECTION_STATE_CHANGE, (t3, i2) => {
            if (this.safeEmit(tO.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t3, i2), i2 === vV.CONNECTED) {
              if ("CONNECTED" !== this.connectionState) return void this.safeEmit(tO.CONTENT_INSPECT_ERROR, new ED(ww2.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
              e2.inspectImage();
            }
          }), e2.on(yV.INSPECT_RESULT, (e3, t3) => {
            var i2;
            if ((null == t3 ? void 0 : t3.code) === ww2.INVALID_OPERATION && "DISCONNECTED" === this.connectionState) return sD.debug("Stop inspect content because that has left channel"), null == this || null === (i2 = this._inspect) || void 0 === i2 || i2.close(), void (this._inspect = void 0);
            this.safeEmit(tO.CONTENT_INSPECT_RESULT, e3, t3);
          }), e2.on(yV.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        async disableContentInspect() {
          if (!this._inspect) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
            throw Array.isArray(e2) ? e2[0] : e2;
          }
        }
        async setImageModeration(e2, t3) {
          if (Nw2(e2, "enabled"), e2) {
            if (!t3) throw new ED(ww2.INVALID_PARAMS, "config is required");
            if (_G(t3), !this._joinInfo) throw new ED(ww2.INVALID_OPERATION, "can not create image moderation, please join channel first");
            try {
              if (this._moderation) this._moderation.updateConfig(t3);
              else {
                const e3 = (i2 = { config: t3 }, Jx2("ImageModeration").create(i2));
                this._moderation = e3, this.handleImageModerationEvents(e3);
                const { appId: n3, cname: r2, sid: o2, token: s2, uid: a3, cid: c3, vid: d2 } = this._joinInfo;
                await e3.init({ appId: n3, areaCode: "", cname: r2, sid: o2, token: s2, uid: a3, cid: c3, vid: d2 ? Number(d2) : 0 }, BO);
              }
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          } else {
            var i2;
            if (!this._moderation) throw new ED(ww2.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
            try {
              this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
            } catch (e3) {
              throw Array.isArray(e3) ? e3[0] : e3;
            }
          }
        }
        handleImageModerationEvents(e2) {
          e2.on(wV.CONNECTION_STATE_CHANGE, (t3, i2) => {
            if (this.safeEmit(tO.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t3, i2), t3 === AV.CONNECTED) {
              if ("CONNECTED" !== this.connectionState) throw this.setImageModeration(false), new ED(ww2.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
              e2.inspectImage();
            }
          }), e2.on(wV.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
            e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
          });
        }
        setP2PTransport(e2) {
          if (function(e3) {
            Dw2(e3, "transport", ["default", "auto", "relay", "sd-rtn"]);
          }(e2), "p2p" !== this.mode) throw new ED(ww2.INVALID_OPERATION, "only p2p mode can set p2pTransport");
          this.store.p2pTransport = e2, sD.info("[".concat(this._clientId, "] set client p2pTransport to ").concat(e2));
        }
        getJoinChannelServiceRecords() {
          return sD.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
        async setPublishAudioFilterEnabled(e2) {
          Nw2(e2, "enabled"), AN("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
        }
        _handleResetAddStream(e2, t3) {
          switch (t3) {
            case "audio":
              e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
              break;
            case "video":
              e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
          }
        }
      }, OU(nW.prototype, "leave", [mG], Object.getOwnPropertyDescriptor(nW.prototype, "leave"), nW.prototype), OU(nW.prototype, "publish", [fG], Object.getOwnPropertyDescriptor(nW.prototype, "publish"), nW.prototype), OU(nW.prototype, "unpublish", [SG], Object.getOwnPropertyDescriptor(nW.prototype, "unpublish"), nW.prototype), OU(nW.prototype, "subscribe", [gG], Object.getOwnPropertyDescriptor(nW.prototype, "subscribe"), nW.prototype), OU(nW.prototype, "presubscribe", [TG], Object.getOwnPropertyDescriptor(nW.prototype, "presubscribe"), nW.prototype), OU(nW.prototype, "massSubscribe", [RG], Object.getOwnPropertyDescriptor(nW.prototype, "massSubscribe"), nW.prototype), OU(nW.prototype, "unsubscribe", [vG], Object.getOwnPropertyDescriptor(nW.prototype, "unsubscribe"), nW.prototype), OU(nW.prototype, "massUnsubscribe", [CG], Object.getOwnPropertyDescriptor(nW.prototype, "massUnsubscribe"), nW.prototype), OU(nW.prototype, "setLowStreamParameter", [yG], Object.getOwnPropertyDescriptor(nW.prototype, "setLowStreamParameter"), nW.prototype), OU(nW.prototype, "enableDualStream", [IG], Object.getOwnPropertyDescriptor(nW.prototype, "enableDualStream"), nW.prototype), OU(nW.prototype, "disableDualStream", [bG], Object.getOwnPropertyDescriptor(nW.prototype, "disableDualStream"), nW.prototype), OU(nW.prototype, "setClientRole", [AG], Object.getOwnPropertyDescriptor(nW.prototype, "setClientRole"), nW.prototype), OU(nW.prototype, "_setClientRoleOptions", [wG], Object.getOwnPropertyDescriptor(nW.prototype, "_setClientRoleOptions"), nW.prototype), OU(nW.prototype, "setProxyServer", [OG], Object.getOwnPropertyDescriptor(nW.prototype, "setProxyServer"), nW.prototype), OU(nW.prototype, "setTurnServer", [NG], Object.getOwnPropertyDescriptor(nW.prototype, "setTurnServer"), nW.prototype), OU(nW.prototype, "setLicense", [DG], Object.getOwnPropertyDescriptor(nW.prototype, "setLicense"), nW.prototype), OU(nW.prototype, "startProxyServer", [PG], Object.getOwnPropertyDescriptor(nW.prototype, "startProxyServer"), nW.prototype), OU(nW.prototype, "stopProxyServer", [LG], Object.getOwnPropertyDescriptor(nW.prototype, "stopProxyServer"), nW.prototype), OU(nW.prototype, "setLocalAccessPointsV2", [kG], Object.getOwnPropertyDescriptor(nW.prototype, "setLocalAccessPointsV2"), nW.prototype), OU(nW.prototype, "setLocalAccessPoints", [MG], Object.getOwnPropertyDescriptor(nW.prototype, "setLocalAccessPoints"), nW.prototype), OU(nW.prototype, "setRemoteDefaultVideoStreamType", [UG], Object.getOwnPropertyDescriptor(nW.prototype, "setRemoteDefaultVideoStreamType"), nW.prototype), OU(nW.prototype, "setRemoteVideoStreamType", [VG], Object.getOwnPropertyDescriptor(nW.prototype, "setRemoteVideoStreamType"), nW.prototype), OU(nW.prototype, "setStreamFallbackOption", [xG], Object.getOwnPropertyDescriptor(nW.prototype, "setStreamFallbackOption"), nW.prototype), OU(nW.prototype, "setEncryptionConfig", [FG], Object.getOwnPropertyDescriptor(nW.prototype, "setEncryptionConfig"), nW.prototype), OU(nW.prototype, "renewToken", [BG], Object.getOwnPropertyDescriptor(nW.prototype, "renewToken"), nW.prototype), OU(nW.prototype, "enableAudioVolumeIndicator", [jG], Object.getOwnPropertyDescriptor(nW.prototype, "enableAudioVolumeIndicator"), nW.prototype), OU(nW.prototype, "startLiveStreaming", [GG], Object.getOwnPropertyDescriptor(nW.prototype, "startLiveStreaming"), nW.prototype), OU(nW.prototype, "setLiveTranscoding", [WG], Object.getOwnPropertyDescriptor(nW.prototype, "setLiveTranscoding"), nW.prototype), OU(nW.prototype, "stopLiveStreaming", [HG], Object.getOwnPropertyDescriptor(nW.prototype, "stopLiveStreaming"), nW.prototype), OU(nW.prototype, "startChannelMediaRelay", [KG], Object.getOwnPropertyDescriptor(nW.prototype, "startChannelMediaRelay"), nW.prototype), OU(nW.prototype, "updateChannelMediaRelay", [YG], Object.getOwnPropertyDescriptor(nW.prototype, "updateChannelMediaRelay"), nW.prototype), OU(nW.prototype, "stopChannelMediaRelay", [zG], Object.getOwnPropertyDescriptor(nW.prototype, "stopChannelMediaRelay"), nW.prototype), OU(nW.prototype, "sendCustomReportMessage", [qG], Object.getOwnPropertyDescriptor(nW.prototype, "sendCustomReportMessage"), nW.prototype), OU(nW.prototype, "pickSVCLayer", [XG], Object.getOwnPropertyDescriptor(nW.prototype, "pickSVCLayer"), nW.prototype), OU(nW.prototype, "setRTMConfig", [JG], Object.getOwnPropertyDescriptor(nW.prototype, "setRTMConfig"), nW.prototype), OU(nW.prototype, "enableContentInspect", [ZG], Object.getOwnPropertyDescriptor(nW.prototype, "enableContentInspect"), nW.prototype), OU(nW.prototype, "disableContentInspect", [QG], Object.getOwnPropertyDescriptor(nW.prototype, "disableContentInspect"), nW.prototype), OU(nW.prototype, "setImageModeration", [$G], Object.getOwnPropertyDescriptor(nW.prototype, "setImageModeration"), nW.prototype), OU(nW.prototype, "setP2PTransport", [eW], Object.getOwnPropertyDescriptor(nW.prototype, "setP2PTransport"), nW.prototype), OU(nW.prototype, "getJoinChannelServiceRecords", [tW], Object.getOwnPropertyDescriptor(nW.prototype, "getJoinChannelServiceRecords"), nW.prototype), OU(nW.prototype, "setPublishAudioFilterEnabled", [iW], Object.getOwnPropertyDescriptor(nW.prototype, "setPublishAudioFilterEnabled"), nW.prototype), nW);
      class aW {
        constructor(e2, t3) {
          uI(this, "id", 0), uI(this, "element", void 0), uI(this, "peerPair", void 0), uI(this, "context", void 0), uI(this, "audioPlayerElement", void 0), uI(this, "audioTrack", void 0), aW.count += 1, this.id = aW.count, this.element = e2, this.context = t3;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
            const t3 = document.createElement("audio");
            t3.srcObject = new MediaStream([e2.track]), t3.play(), this.audioPlayerElement = t3;
          };
        }
        async switchSdp() {
          if (!this.peerPair) return;
          const e2 = async (e3, t4) => {
            const i2 = "offer" === t4 ? await e3.createOffer() : await e3.createAnswer();
            return await e3.setLocalDescription(i2), "complete" === e3.iceGatheringState ? e3.localDescription : new ip2((t5) => {
              e3.onicegatheringstatechange = () => {
                "complete" === e3.iceGatheringState && t5(e3.localDescription);
              };
            });
          }, t3 = async (e3, t4) => await e3.setRemoteDescription(t4);
          try {
            const i2 = await e2(this.peerPair[0], "offer");
            await t3(this.peerPair[1], i2);
            const n3 = await e2(this.peerPair[1], "answer");
            await t3(this.peerPair[0], n3);
          } catch (e3) {
            throw new ED(ww2.LOCAL_AEC_ERROR, e3.toString()).print();
          }
        }
        async getTracksFromMediaElement(e2) {
          if (this.audioTrack) return this.audioTrack;
          let t3;
          try {
            e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t3 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e2).connect(t3);
          } catch (e3) {
            throw new ED(ww2.LOCAL_AEC_ERROR, e3.toString()).print();
          }
          if (!t3) {
            throw new ED(ww2.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const i2 = t3.stream.getAudioTracks()[0];
          return this.audioTrack = i2, i2;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e2 = this.element, t3 = await this.getTracksFromMediaElement(e2);
          this.peerPair && this.peerPair[0].addTrack(t3), await this.switchSdp();
        }
        close() {
          sD.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
            e2.close();
          }), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      var cW, dW;
      uI(aW, "count", 0);
      const lW = window.AudioContext || window.webkitAudioContext;
      const uW = new (cW = pD2({ report: _D }), OU((dW = class {
        constructor() {
          uI(this, "units", []), uI(this, "context", void 0);
        }
        processExternalMediaAEC(e2) {
          if (!this._doesEnvironmentNeedAEC()) return sD.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new lW());
          let t3 = this.units.find((t4) => t4 && t4.getElement() === e2);
          return t3 || (t3 = new aW(e2, this.context), this.units.push(t3)), t3.startEchoCancellation(), sD.debug("start processing local audio echo cancellation, id is", t3.id), t3.id;
        }
        _doesEnvironmentNeedAEC() {
          return zA2().name !== WA2.SAFARI;
        }
      }).prototype, "processExternalMediaAEC", [cW], Object.getOwnPropertyDescriptor(dW.prototype, "processExternalMediaAEC"), dW.prototype), dW)();
      function hW(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function pW(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? hW(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : hW(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      const _W = window || document;
      function EW(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (!_W) return;
        const i2 = Mq2._cspEventHandlerPointer;
        if (i2 && t3) return void console.error(i2, t3);
        const n3 = (e3) => {
          if (!(e3 && e3.blockedURI && (Mq2.onSecurityPolicyViolation || Mq2.getListeners(bV.SECURITY_POLICY_VIOLATION).length > 0))) return;
          const t4 = e3.blockedURI;
          wN("CSP_DETECTED_HOSTNAME_LIST").some((e4) => Ln2(t4).call(t4, e4)) && (Mq2.onSecurityPolicyViolation && "function" == typeof Mq2.onSecurityPolicyViolation && Mq2.onSecurityPolicyViolation(e3), Mq2.getListeners(bV.SECURITY_POLICY_VIOLATION).length > 0 && Mq2.safeEmit(bV.SECURITY_POLICY_VIOLATION, e3));
        };
        i2 && _W.removeEventListener("securitypolicyviolation", i2), (t3 || e2 && "function" == typeof e2 || Mq2.getListeners(bV.SECURITY_POLICY_VIOLATION).length > 0) && _W.addEventListener("securitypolicyviolation", n3), Mq2._cspEventHandlerPointer = n3;
      }
      var mW = l, fW = wI, SW = RegExp.prototype, gW = function(e2) {
        return e2 === SW || mW(SW, e2) ? fW(e2) : e2.flags;
      }, TW = i(gW);
      function RW(e2) {
        let t3 = e2.length;
        for (; --t3 >= 0; ) e2[t3] = 0;
      }
      const vW = 256, CW = 286, yW = 30, IW = 15, bW = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), AW = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), wW = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), OW = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), NW = new Array(576);
      RW(NW);
      const DW = new Array(60);
      RW(DW);
      const PW = new Array(512);
      RW(PW);
      const LW = new Array(256);
      RW(LW);
      const kW = new Array(29);
      RW(kW);
      const MW = new Array(yW);
      function UW(e2, t3, i2, n3, r2) {
        this.static_tree = e2, this.extra_bits = t3, this.extra_base = i2, this.elems = n3, this.max_length = r2, this.has_stree = e2 && e2.length;
      }
      let VW, xW, FW;
      function BW(e2, t3) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t3;
      }
      RW(MW);
      const jW = (e2) => e2 < 256 ? PW[e2] : PW[256 + (e2 >>> 7)], GW = (e2, t3) => {
        e2.pending_buf[e2.pending++] = 255 & t3, e2.pending_buf[e2.pending++] = t3 >>> 8 & 255;
      }, WW = (e2, t3, i2) => {
        e2.bi_valid > 16 - i2 ? (e2.bi_buf |= t3 << e2.bi_valid & 65535, GW(e2, e2.bi_buf), e2.bi_buf = t3 >> 16 - e2.bi_valid, e2.bi_valid += i2 - 16) : (e2.bi_buf |= t3 << e2.bi_valid & 65535, e2.bi_valid += i2);
      }, HW = (e2, t3, i2) => {
        WW(e2, i2[2 * t3], i2[2 * t3 + 1]);
      }, KW = (e2, t3) => {
        let i2 = 0;
        do {
          i2 |= 1 & e2, e2 >>>= 1, i2 <<= 1;
        } while (--t3 > 0);
        return i2 >>> 1;
      }, YW = (e2, t3, i2) => {
        const n3 = new Array(16);
        let r2, o2, s2 = 0;
        for (r2 = 1; r2 <= IW; r2++) s2 = s2 + i2[r2 - 1] << 1, n3[r2] = s2;
        for (o2 = 0; o2 <= t3; o2++) {
          let t4 = e2[2 * o2 + 1];
          0 !== t4 && (e2[2 * o2] = KW(n3[t4]++, t4));
        }
      }, zW = (e2) => {
        let t3;
        for (t3 = 0; t3 < CW; t3++) e2.dyn_ltree[2 * t3] = 0;
        for (t3 = 0; t3 < yW; t3++) e2.dyn_dtree[2 * t3] = 0;
        for (t3 = 0; t3 < 19; t3++) e2.bl_tree[2 * t3] = 0;
        e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.sym_next = e2.matches = 0;
      }, qW = (e2) => {
        e2.bi_valid > 8 ? GW(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }, XW = (e2, t3, i2, n3) => {
        const r2 = 2 * t3, o2 = 2 * i2;
        return e2[r2] < e2[o2] || e2[r2] === e2[o2] && n3[t3] <= n3[i2];
      }, JW = (e2, t3, i2) => {
        const n3 = e2.heap[i2];
        let r2 = i2 << 1;
        for (; r2 <= e2.heap_len && (r2 < e2.heap_len && XW(t3, e2.heap[r2 + 1], e2.heap[r2], e2.depth) && r2++, !XW(t3, n3, e2.heap[r2], e2.depth)); ) e2.heap[i2] = e2.heap[r2], i2 = r2, r2 <<= 1;
        e2.heap[i2] = n3;
      }, ZW = (e2, t3, i2) => {
        let n3, r2, o2, s2, a3 = 0;
        if (0 !== e2.sym_next) do {
          n3 = 255 & e2.pending_buf[e2.sym_buf + a3++], n3 += (255 & e2.pending_buf[e2.sym_buf + a3++]) << 8, r2 = e2.pending_buf[e2.sym_buf + a3++], 0 === n3 ? HW(e2, r2, t3) : (o2 = LW[r2], HW(e2, o2 + vW + 1, t3), s2 = bW[o2], 0 !== s2 && (r2 -= kW[o2], WW(e2, r2, s2)), n3--, o2 = jW(n3), HW(e2, o2, i2), s2 = AW[o2], 0 !== s2 && (n3 -= MW[o2], WW(e2, n3, s2)));
        } while (a3 < e2.sym_next);
        HW(e2, 256, t3);
      }, QW = (e2, t3) => {
        const i2 = t3.dyn_tree, n3 = t3.stat_desc.static_tree, r2 = t3.stat_desc.has_stree, o2 = t3.stat_desc.elems;
        let s2, a3, c3, d2 = -1;
        for (e2.heap_len = 0, e2.heap_max = 573, s2 = 0; s2 < o2; s2++) 0 !== i2[2 * s2] ? (e2.heap[++e2.heap_len] = d2 = s2, e2.depth[s2] = 0) : i2[2 * s2 + 1] = 0;
        for (; e2.heap_len < 2; ) c3 = e2.heap[++e2.heap_len] = d2 < 2 ? ++d2 : 0, i2[2 * c3] = 1, e2.depth[c3] = 0, e2.opt_len--, r2 && (e2.static_len -= n3[2 * c3 + 1]);
        for (t3.max_code = d2, s2 = e2.heap_len >> 1; s2 >= 1; s2--) JW(e2, i2, s2);
        c3 = o2;
        do {
          s2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], JW(e2, i2, 1), a3 = e2.heap[1], e2.heap[--e2.heap_max] = s2, e2.heap[--e2.heap_max] = a3, i2[2 * c3] = i2[2 * s2] + i2[2 * a3], e2.depth[c3] = (e2.depth[s2] >= e2.depth[a3] ? e2.depth[s2] : e2.depth[a3]) + 1, i2[2 * s2 + 1] = i2[2 * a3 + 1] = c3, e2.heap[1] = c3++, JW(e2, i2, 1);
        } while (e2.heap_len >= 2);
        e2.heap[--e2.heap_max] = e2.heap[1], ((e3, t4) => {
          const i3 = t4.dyn_tree, n4 = t4.max_code, r3 = t4.stat_desc.static_tree, o3 = t4.stat_desc.has_stree, s3 = t4.stat_desc.extra_bits, a4 = t4.stat_desc.extra_base, c4 = t4.stat_desc.max_length;
          let d3, l2, u3, h2, p2, _2, E3 = 0;
          for (h2 = 0; h2 <= IW; h2++) e3.bl_count[h2] = 0;
          for (i3[2 * e3.heap[e3.heap_max] + 1] = 0, d3 = e3.heap_max + 1; d3 < 573; d3++) l2 = e3.heap[d3], h2 = i3[2 * i3[2 * l2 + 1] + 1] + 1, h2 > c4 && (h2 = c4, E3++), i3[2 * l2 + 1] = h2, l2 > n4 || (e3.bl_count[h2]++, p2 = 0, l2 >= a4 && (p2 = s3[l2 - a4]), _2 = i3[2 * l2], e3.opt_len += _2 * (h2 + p2), o3 && (e3.static_len += _2 * (r3[2 * l2 + 1] + p2)));
          if (0 !== E3) {
            do {
              for (h2 = c4 - 1; 0 === e3.bl_count[h2]; ) h2--;
              e3.bl_count[h2]--, e3.bl_count[h2 + 1] += 2, e3.bl_count[c4]--, E3 -= 2;
            } while (E3 > 0);
            for (h2 = c4; 0 !== h2; h2--) for (l2 = e3.bl_count[h2]; 0 !== l2; ) u3 = e3.heap[--d3], u3 > n4 || (i3[2 * u3 + 1] !== h2 && (e3.opt_len += (h2 - i3[2 * u3 + 1]) * i3[2 * u3], i3[2 * u3 + 1] = h2), l2--);
          }
        })(e2, t3), YW(i2, d2, e2.bl_count);
      }, $W = (e2, t3, i2) => {
        let n3, r2, o2 = -1, s2 = t3[1], a3 = 0, c3 = 7, d2 = 4;
        for (0 === s2 && (c3 = 138, d2 = 3), t3[2 * (i2 + 1) + 1] = 65535, n3 = 0; n3 <= i2; n3++) r2 = s2, s2 = t3[2 * (n3 + 1) + 1], ++a3 < c3 && r2 === s2 || (a3 < d2 ? e2.bl_tree[2 * r2] += a3 : 0 !== r2 ? (r2 !== o2 && e2.bl_tree[2 * r2]++, e2.bl_tree[32]++) : a3 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, a3 = 0, o2 = r2, 0 === s2 ? (c3 = 138, d2 = 3) : r2 === s2 ? (c3 = 6, d2 = 3) : (c3 = 7, d2 = 4));
      }, eH = (e2, t3, i2) => {
        let n3, r2, o2 = -1, s2 = t3[1], a3 = 0, c3 = 7, d2 = 4;
        for (0 === s2 && (c3 = 138, d2 = 3), n3 = 0; n3 <= i2; n3++) if (r2 = s2, s2 = t3[2 * (n3 + 1) + 1], !(++a3 < c3 && r2 === s2)) {
          if (a3 < d2) do {
            HW(e2, r2, e2.bl_tree);
          } while (0 != --a3);
          else 0 !== r2 ? (r2 !== o2 && (HW(e2, r2, e2.bl_tree), a3--), HW(e2, 16, e2.bl_tree), WW(e2, a3 - 3, 2)) : a3 <= 10 ? (HW(e2, 17, e2.bl_tree), WW(e2, a3 - 3, 3)) : (HW(e2, 18, e2.bl_tree), WW(e2, a3 - 11, 7));
          a3 = 0, o2 = r2, 0 === s2 ? (c3 = 138, d2 = 3) : r2 === s2 ? (c3 = 6, d2 = 3) : (c3 = 7, d2 = 4);
        }
      };
      let tH = false;
      const iH = (e2, t3, i2, n3) => {
        WW(e2, 0 + (n3 ? 1 : 0), 3), qW(e2), GW(e2, i2), GW(e2, ~i2), i2 && e2.pending_buf.set(e2.window.subarray(t3, t3 + i2), e2.pending), e2.pending += i2;
      };
      var nH = (e2) => {
        tH || ((() => {
          let e3, t3, i2, n3, r2;
          const o2 = new Array(16);
          for (i2 = 0, n3 = 0; n3 < 28; n3++) for (kW[n3] = i2, e3 = 0; e3 < 1 << bW[n3]; e3++) LW[i2++] = n3;
          for (LW[i2 - 1] = n3, r2 = 0, n3 = 0; n3 < 16; n3++) for (MW[n3] = r2, e3 = 0; e3 < 1 << AW[n3]; e3++) PW[r2++] = n3;
          for (r2 >>= 7; n3 < yW; n3++) for (MW[n3] = r2 << 7, e3 = 0; e3 < 1 << AW[n3] - 7; e3++) PW[256 + r2++] = n3;
          for (t3 = 0; t3 <= IW; t3++) o2[t3] = 0;
          for (e3 = 0; e3 <= 143; ) NW[2 * e3 + 1] = 8, e3++, o2[8]++;
          for (; e3 <= 255; ) NW[2 * e3 + 1] = 9, e3++, o2[9]++;
          for (; e3 <= 279; ) NW[2 * e3 + 1] = 7, e3++, o2[7]++;
          for (; e3 <= 287; ) NW[2 * e3 + 1] = 8, e3++, o2[8]++;
          for (YW(NW, 287, o2), e3 = 0; e3 < yW; e3++) DW[2 * e3 + 1] = 5, DW[2 * e3] = KW(e3, 5);
          VW = new UW(NW, bW, 257, CW, IW), xW = new UW(DW, AW, 0, yW, IW), FW = new UW(new Array(0), wW, 0, 19, 7);
        })(), tH = true), e2.l_desc = new BW(e2.dyn_ltree, VW), e2.d_desc = new BW(e2.dyn_dtree, xW), e2.bl_desc = new BW(e2.bl_tree, FW), e2.bi_buf = 0, e2.bi_valid = 0, zW(e2);
      }, rH = (e2, t3, i2, n3) => {
        let r2, o2, s2 = 0;
        e2.level > 0 ? (2 === e2.strm.data_type && (e2.strm.data_type = ((e3) => {
          let t4, i3 = 4093624447;
          for (t4 = 0; t4 <= 31; t4++, i3 >>>= 1) if (1 & i3 && 0 !== e3.dyn_ltree[2 * t4]) return 0;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return 1;
          for (t4 = 32; t4 < vW; t4++) if (0 !== e3.dyn_ltree[2 * t4]) return 1;
          return 0;
        })(e2)), QW(e2, e2.l_desc), QW(e2, e2.d_desc), s2 = ((e3) => {
          let t4;
          for ($W(e3, e3.dyn_ltree, e3.l_desc.max_code), $W(e3, e3.dyn_dtree, e3.d_desc.max_code), QW(e3, e3.bl_desc), t4 = 18; t4 >= 3 && 0 === e3.bl_tree[2 * OW[t4] + 1]; t4--) ;
          return e3.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
        })(e2), r2 = e2.opt_len + 3 + 7 >>> 3, o2 = e2.static_len + 3 + 7 >>> 3, o2 <= r2 && (r2 = o2)) : r2 = o2 = i2 + 5, i2 + 4 <= r2 && -1 !== t3 ? iH(e2, t3, i2, n3) : 4 === e2.strategy || o2 === r2 ? (WW(e2, 2 + (n3 ? 1 : 0), 3), ZW(e2, NW, DW)) : (WW(e2, 4 + (n3 ? 1 : 0), 3), ((e3, t4, i3, n4) => {
          let r3;
          for (WW(e3, t4 - 257, 5), WW(e3, i3 - 1, 5), WW(e3, n4 - 4, 4), r3 = 0; r3 < n4; r3++) WW(e3, e3.bl_tree[2 * OW[r3] + 1], 3);
          eH(e3, e3.dyn_ltree, t4 - 1), eH(e3, e3.dyn_dtree, i3 - 1);
        })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, s2 + 1), ZW(e2, e2.dyn_ltree, e2.dyn_dtree)), zW(e2), n3 && qW(e2);
      }, oH = (e2, t3, i2) => (e2.pending_buf[e2.sym_buf + e2.sym_next++] = t3, e2.pending_buf[e2.sym_buf + e2.sym_next++] = t3 >> 8, e2.pending_buf[e2.sym_buf + e2.sym_next++] = i2, 0 === t3 ? e2.dyn_ltree[2 * i2]++ : (e2.matches++, t3--, e2.dyn_ltree[2 * (LW[i2] + vW + 1)]++, e2.dyn_dtree[2 * jW(t3)]++), e2.sym_next === e2.sym_end), sH = (e2) => {
        WW(e2, 2, 3), HW(e2, 256, NW), ((e3) => {
          16 === e3.bi_valid ? (GW(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        })(e2);
      }, aH = { _tr_init: nH, _tr_stored_block: iH, _tr_flush_block: rH, _tr_tally: oH, _tr_align: sH };
      var cH = (e2, t3, i2, n3) => {
        let r2 = 65535 & e2 | 0, o2 = e2 >>> 16 & 65535 | 0, s2 = 0;
        for (; 0 !== i2; ) {
          s2 = i2 > 2e3 ? 2e3 : i2, i2 -= s2;
          do {
            r2 = r2 + t3[n3++] | 0, o2 = o2 + r2 | 0;
          } while (--s2);
          r2 %= 65521, o2 %= 65521;
        }
        return r2 | o2 << 16 | 0;
      };
      const dH = new Uint32Array((() => {
        let e2, t3 = [];
        for (var i2 = 0; i2 < 256; i2++) {
          e2 = i2;
          for (var n3 = 0; n3 < 8; n3++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t3[i2] = e2;
        }
        return t3;
      })());
      var lH = (e2, t3, i2, n3) => {
        const r2 = dH, o2 = n3 + i2;
        e2 ^= -1;
        for (let i3 = n3; i3 < o2; i3++) e2 = e2 >>> 8 ^ r2[255 & (e2 ^ t3[i3])];
        return -1 ^ e2;
      }, uH = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, hH = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      const { _tr_init: pH, _tr_stored_block: _H, _tr_flush_block: EH, _tr_tally: mH, _tr_align: fH } = aH, { Z_NO_FLUSH: SH, Z_PARTIAL_FLUSH: gH, Z_FULL_FLUSH: TH, Z_FINISH: RH, Z_BLOCK: vH, Z_OK: CH, Z_STREAM_END: yH, Z_STREAM_ERROR: IH, Z_DATA_ERROR: bH, Z_BUF_ERROR: AH, Z_DEFAULT_COMPRESSION: wH, Z_FILTERED: OH, Z_HUFFMAN_ONLY: NH, Z_RLE: DH, Z_FIXED: PH, Z_DEFAULT_STRATEGY: LH, Z_UNKNOWN: kH, Z_DEFLATED: MH } = hH, UH = 286, VH = 30, xH = 19, FH = 2 * UH + 1, BH = 15, jH = 258, GH = 262, WH = 42, HH = 113, KH = 666, YH = (e2, t3) => (e2.msg = uH[t3], t3), zH = (e2) => 2 * e2 - (e2 > 4 ? 9 : 0), qH = (e2) => {
        let t3 = e2.length;
        for (; --t3 >= 0; ) e2[t3] = 0;
      }, XH = (e2) => {
        let t3, i2, n3, r2 = e2.w_size;
        t3 = e2.hash_size, n3 = t3;
        do {
          i2 = e2.head[--n3], e2.head[n3] = i2 >= r2 ? i2 - r2 : 0;
        } while (--t3);
        t3 = r2, n3 = t3;
        do {
          i2 = e2.prev[--n3], e2.prev[n3] = i2 >= r2 ? i2 - r2 : 0;
        } while (--t3);
      };
      let JH = (e2, t3, i2) => (t3 << e2.hash_shift ^ i2) & e2.hash_mask;
      const ZH = (e2) => {
        const t3 = e2.state;
        let i2 = t3.pending;
        i2 > e2.avail_out && (i2 = e2.avail_out), 0 !== i2 && (e2.output.set(t3.pending_buf.subarray(t3.pending_out, t3.pending_out + i2), e2.next_out), e2.next_out += i2, t3.pending_out += i2, e2.total_out += i2, e2.avail_out -= i2, t3.pending -= i2, 0 === t3.pending && (t3.pending_out = 0));
      }, QH = (e2, t3) => {
        EH(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t3), e2.block_start = e2.strstart, ZH(e2.strm);
      }, $H = (e2, t3) => {
        e2.pending_buf[e2.pending++] = t3;
      }, eK = (e2, t3) => {
        e2.pending_buf[e2.pending++] = t3 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t3;
      }, tK = (e2, t3, i2, n3) => {
        let r2 = e2.avail_in;
        return r2 > n3 && (r2 = n3), 0 === r2 ? 0 : (e2.avail_in -= r2, t3.set(e2.input.subarray(e2.next_in, e2.next_in + r2), i2), 1 === e2.state.wrap ? e2.adler = cH(e2.adler, t3, r2, i2) : 2 === e2.state.wrap && (e2.adler = lH(e2.adler, t3, r2, i2)), e2.next_in += r2, e2.total_in += r2, r2);
      }, iK = (e2, t3) => {
        let i2, n3, r2 = e2.max_chain_length, o2 = e2.strstart, s2 = e2.prev_length, a3 = e2.nice_match;
        const c3 = e2.strstart > e2.w_size - GH ? e2.strstart - (e2.w_size - GH) : 0, d2 = e2.window, l2 = e2.w_mask, u3 = e2.prev, h2 = e2.strstart + jH;
        let p2 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
        e2.prev_length >= e2.good_match && (r2 >>= 2), a3 > e2.lookahead && (a3 = e2.lookahead);
        do {
          if (i2 = t3, d2[i2 + s2] === _2 && d2[i2 + s2 - 1] === p2 && d2[i2] === d2[o2] && d2[++i2] === d2[o2 + 1]) {
            o2 += 2, i2++;
            do {
            } while (d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && d2[++o2] === d2[++i2] && o2 < h2);
            if (n3 = jH - (h2 - o2), o2 = h2 - jH, n3 > s2) {
              if (e2.match_start = t3, s2 = n3, n3 >= a3) break;
              p2 = d2[o2 + s2 - 1], _2 = d2[o2 + s2];
            }
          }
        } while ((t3 = u3[t3 & l2]) > c3 && 0 != --r2);
        return s2 <= e2.lookahead ? s2 : e2.lookahead;
      }, nK = (e2) => {
        const t3 = e2.w_size;
        let i2, n3, r2;
        do {
          if (n3 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t3 + (t3 - GH) && (e2.window.set(e2.window.subarray(t3, t3 + t3 - n3), 0), e2.match_start -= t3, e2.strstart -= t3, e2.block_start -= t3, e2.insert > e2.strstart && (e2.insert = e2.strstart), XH(e2), n3 += t3), 0 === e2.strm.avail_in) break;
          if (i2 = tK(e2.strm, e2.window, e2.strstart + e2.lookahead, n3), e2.lookahead += i2, e2.lookahead + e2.insert >= 3) for (r2 = e2.strstart - e2.insert, e2.ins_h = e2.window[r2], e2.ins_h = JH(e2, e2.ins_h, e2.window[r2 + 1]); e2.insert && (e2.ins_h = JH(e2, e2.ins_h, e2.window[r2 + 3 - 1]), e2.prev[r2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = r2, r2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); ) ;
        } while (e2.lookahead < GH && 0 !== e2.strm.avail_in);
      }, rK = (e2, t3) => {
        let i2, n3, r2, o2 = e2.pending_buf_size - 5 > e2.w_size ? e2.w_size : e2.pending_buf_size - 5, s2 = 0, a3 = e2.strm.avail_in;
        do {
          if (i2 = 65535, r2 = e2.bi_valid + 42 >> 3, e2.strm.avail_out < r2) break;
          if (r2 = e2.strm.avail_out - r2, n3 = e2.strstart - e2.block_start, i2 > n3 + e2.strm.avail_in && (i2 = n3 + e2.strm.avail_in), i2 > r2 && (i2 = r2), i2 < o2 && (0 === i2 && t3 !== RH || t3 === SH || i2 !== n3 + e2.strm.avail_in)) break;
          s2 = t3 === RH && i2 === n3 + e2.strm.avail_in ? 1 : 0, _H(e2, 0, 0, s2), e2.pending_buf[e2.pending - 4] = i2, e2.pending_buf[e2.pending - 3] = i2 >> 8, e2.pending_buf[e2.pending - 2] = ~i2, e2.pending_buf[e2.pending - 1] = ~i2 >> 8, ZH(e2.strm), n3 && (n3 > i2 && (n3 = i2), e2.strm.output.set(e2.window.subarray(e2.block_start, e2.block_start + n3), e2.strm.next_out), e2.strm.next_out += n3, e2.strm.avail_out -= n3, e2.strm.total_out += n3, e2.block_start += n3, i2 -= n3), i2 && (tK(e2.strm, e2.strm.output, e2.strm.next_out, i2), e2.strm.next_out += i2, e2.strm.avail_out -= i2, e2.strm.total_out += i2);
        } while (0 === s2);
        return a3 -= e2.strm.avail_in, a3 && (a3 >= e2.w_size ? (e2.matches = 2, e2.window.set(e2.strm.input.subarray(e2.strm.next_in - e2.w_size, e2.strm.next_in), 0), e2.strstart = e2.w_size, e2.insert = e2.strstart) : (e2.window_size - e2.strstart <= a3 && (e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, e2.insert > e2.strstart && (e2.insert = e2.strstart)), e2.window.set(e2.strm.input.subarray(e2.strm.next_in - a3, e2.strm.next_in), e2.strstart), e2.strstart += a3, e2.insert += a3 > e2.w_size - e2.insert ? e2.w_size - e2.insert : a3), e2.block_start = e2.strstart), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), s2 ? 4 : t3 !== SH && t3 !== RH && 0 === e2.strm.avail_in && e2.strstart === e2.block_start ? 2 : (r2 = e2.window_size - e2.strstart, e2.strm.avail_in > r2 && e2.block_start >= e2.w_size && (e2.block_start -= e2.w_size, e2.strstart -= e2.w_size, e2.window.set(e2.window.subarray(e2.w_size, e2.w_size + e2.strstart), 0), e2.matches < 2 && e2.matches++, r2 += e2.w_size, e2.insert > e2.strstart && (e2.insert = e2.strstart)), r2 > e2.strm.avail_in && (r2 = e2.strm.avail_in), r2 && (tK(e2.strm, e2.window, e2.strstart, r2), e2.strstart += r2, e2.insert += r2 > e2.w_size - e2.insert ? e2.w_size - e2.insert : r2), e2.high_water < e2.strstart && (e2.high_water = e2.strstart), r2 = e2.bi_valid + 42 >> 3, r2 = e2.pending_buf_size - r2 > 65535 ? 65535 : e2.pending_buf_size - r2, o2 = r2 > e2.w_size ? e2.w_size : r2, n3 = e2.strstart - e2.block_start, (n3 >= o2 || (n3 || t3 === RH) && t3 !== SH && 0 === e2.strm.avail_in && n3 <= r2) && (i2 = n3 > r2 ? r2 : n3, s2 = t3 === RH && 0 === e2.strm.avail_in && i2 === n3 ? 1 : 0, _H(e2, e2.block_start, i2, s2), e2.block_start += i2, ZH(e2.strm)), s2 ? 3 : 1);
      }, oK = (e2, t3) => {
        let i2, n3;
        for (; ; ) {
          if (e2.lookahead < GH) {
            if (nK(e2), e2.lookahead < GH && t3 === SH) return 1;
            if (0 === e2.lookahead) break;
          }
          if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = JH(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== i2 && e2.strstart - i2 <= e2.w_size - GH && (e2.match_length = iK(e2, i2)), e2.match_length >= 3) if (n3 = mH(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
            e2.match_length--;
            do {
              e2.strstart++, e2.ins_h = JH(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
            } while (0 != --e2.match_length);
            e2.strstart++;
          } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = JH(e2, e2.ins_h, e2.window[e2.strstart + 1]);
          else n3 = mH(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n3 && (QH(e2, false), 0 === e2.strm.avail_out)) return 1;
        }
        return e2.insert = e2.strstart < 2 ? e2.strstart : 2, t3 === RH ? (QH(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (QH(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      }, sK = (e2, t3) => {
        let i2, n3, r2;
        for (; ; ) {
          if (e2.lookahead < GH) {
            if (nK(e2), e2.lookahead < GH && t3 === SH) return 1;
            if (0 === e2.lookahead) break;
          }
          if (i2 = 0, e2.lookahead >= 3 && (e2.ins_h = JH(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, 0 !== i2 && e2.prev_length < e2.max_lazy_match && e2.strstart - i2 <= e2.w_size - GH && (e2.match_length = iK(e2, i2), e2.match_length <= 5 && (e2.strategy === OH || 3 === e2.match_length && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
            r2 = e2.strstart + e2.lookahead - 3, n3 = mH(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
            do {
              ++e2.strstart <= r2 && (e2.ins_h = JH(e2, e2.ins_h, e2.window[e2.strstart + 3 - 1]), i2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
            } while (0 != --e2.prev_length);
            if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, n3 && (QH(e2, false), 0 === e2.strm.avail_out)) return 1;
          } else if (e2.match_available) {
            if (n3 = mH(e2, 0, e2.window[e2.strstart - 1]), n3 && QH(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return 1;
          } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n3 = mH(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, t3 === RH ? (QH(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.sym_next && (QH(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
      };
      function aK(e2, t3, i2, n3, r2) {
        this.good_length = e2, this.max_lazy = t3, this.nice_length = i2, this.max_chain = n3, this.func = r2;
      }
      const cK = [new aK(0, 0, 0, 0, rK), new aK(4, 4, 8, 4, oK), new aK(4, 5, 16, 8, oK), new aK(4, 6, 32, 32, oK), new aK(4, 4, 16, 16, sK), new aK(8, 16, 32, 32, sK), new aK(8, 16, 128, 128, sK), new aK(8, 32, 128, 256, sK), new aK(32, 128, 258, 1024, sK), new aK(32, 258, 258, 4096, sK)];
      function dK() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = MH, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * FH), this.dyn_dtree = new Uint16Array(2 * (2 * VH + 1)), this.bl_tree = new Uint16Array(2 * (2 * xH + 1)), qH(this.dyn_ltree), qH(this.dyn_dtree), qH(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(BH + 1), this.heap = new Uint16Array(2 * UH + 1), qH(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * UH + 1), qH(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      const lK = (e2) => {
        if (!e2) return 1;
        const t3 = e2.state;
        return !t3 || t3.strm !== e2 || t3.status !== WH && 57 !== t3.status && 69 !== t3.status && 73 !== t3.status && 91 !== t3.status && 103 !== t3.status && t3.status !== HH && t3.status !== KH ? 1 : 0;
      }, uK = (e2) => {
        if (lK(e2)) return YH(e2, IH);
        e2.total_in = e2.total_out = 0, e2.data_type = kH;
        const t3 = e2.state;
        return t3.pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = 2 === t3.wrap ? 57 : t3.wrap ? WH : HH, e2.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = -2, pH(t3), CH;
      }, hK = (e2) => {
        const t3 = uK(e2);
        return t3 === CH && ((e3) => {
          e3.window_size = 2 * e3.w_size, qH(e3.head), e3.max_lazy_match = cK[e3.level].max_lazy, e3.good_match = cK[e3.level].good_length, e3.nice_match = cK[e3.level].nice_length, e3.max_chain_length = cK[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = 2, e3.match_available = 0, e3.ins_h = 0;
        })(e2.state), t3;
      }, pK = (e2, t3, i2, n3, r2, o2) => {
        if (!e2) return IH;
        let s2 = 1;
        if (t3 === wH && (t3 = 6), n3 < 0 ? (s2 = 0, n3 = -n3) : n3 > 15 && (s2 = 2, n3 -= 16), r2 < 1 || r2 > 9 || i2 !== MH || n3 < 8 || n3 > 15 || t3 < 0 || t3 > 9 || o2 < 0 || o2 > PH || 8 === n3 && 1 !== s2) return YH(e2, IH);
        8 === n3 && (n3 = 9);
        const a3 = new dK();
        return e2.state = a3, a3.strm = e2, a3.status = WH, a3.wrap = s2, a3.gzhead = null, a3.w_bits = n3, a3.w_size = 1 << a3.w_bits, a3.w_mask = a3.w_size - 1, a3.hash_bits = r2 + 7, a3.hash_size = 1 << a3.hash_bits, a3.hash_mask = a3.hash_size - 1, a3.hash_shift = ~~((a3.hash_bits + 3 - 1) / 3), a3.window = new Uint8Array(2 * a3.w_size), a3.head = new Uint16Array(a3.hash_size), a3.prev = new Uint16Array(a3.w_size), a3.lit_bufsize = 1 << r2 + 6, a3.pending_buf_size = 4 * a3.lit_bufsize, a3.pending_buf = new Uint8Array(a3.pending_buf_size), a3.sym_buf = a3.lit_bufsize, a3.sym_end = 3 * (a3.lit_bufsize - 1), a3.level = t3, a3.strategy = o2, a3.method = i2, hK(e2);
      };
      var _K = (e2, t3) => {
        if (lK(e2) || t3 > vH || t3 < 0) return e2 ? YH(e2, IH) : IH;
        const i2 = e2.state;
        if (!e2.output || 0 !== e2.avail_in && !e2.input || i2.status === KH && t3 !== RH) return YH(e2, 0 === e2.avail_out ? AH : IH);
        const n3 = i2.last_flush;
        if (i2.last_flush = t3, 0 !== i2.pending) {
          if (ZH(e2), 0 === e2.avail_out) return i2.last_flush = -1, CH;
        } else if (0 === e2.avail_in && zH(t3) <= zH(n3) && t3 !== RH) return YH(e2, AH);
        if (i2.status === KH && 0 !== e2.avail_in) return YH(e2, AH);
        if (i2.status === WH && 0 === i2.wrap && (i2.status = HH), i2.status === WH) {
          let t4 = MH + (i2.w_bits - 8 << 4) << 8, n4 = -1;
          if (n4 = i2.strategy >= NH || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3, t4 |= n4 << 6, 0 !== i2.strstart && (t4 |= 32), t4 += 31 - t4 % 31, eK(i2, t4), 0 !== i2.strstart && (eK(i2, e2.adler >>> 16), eK(i2, 65535 & e2.adler)), e2.adler = 1, i2.status = HH, ZH(e2), 0 !== i2.pending) return i2.last_flush = -1, CH;
        }
        if (57 === i2.status) {
          if (e2.adler = 0, $H(i2, 31), $H(i2, 139), $H(i2, 8), i2.gzhead) $H(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), $H(i2, 255 & i2.gzhead.time), $H(i2, i2.gzhead.time >> 8 & 255), $H(i2, i2.gzhead.time >> 16 & 255), $H(i2, i2.gzhead.time >> 24 & 255), $H(i2, 9 === i2.level ? 2 : i2.strategy >= NH || i2.level < 2 ? 4 : 0), $H(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && ($H(i2, 255 & i2.gzhead.extra.length), $H(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69;
          else if ($H(i2, 0), $H(i2, 0), $H(i2, 0), $H(i2, 0), $H(i2, 0), $H(i2, 9 === i2.level ? 2 : i2.strategy >= NH || i2.level < 2 ? 4 : 0), $H(i2, 3), i2.status = HH, ZH(e2), 0 !== i2.pending) return i2.last_flush = -1, CH;
        }
        if (69 === i2.status) {
          if (i2.gzhead.extra) {
            let t4 = i2.pending, n4 = (65535 & i2.gzhead.extra.length) - i2.gzindex;
            for (; i2.pending + n4 > i2.pending_buf_size; ) {
              let r3 = i2.pending_buf_size - i2.pending;
              if (i2.pending_buf.set(i2.gzhead.extra.subarray(i2.gzindex, i2.gzindex + r3), i2.pending), i2.pending = i2.pending_buf_size, i2.gzhead.hcrc && i2.pending > t4 && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending - t4, t4)), i2.gzindex += r3, ZH(e2), 0 !== i2.pending) return i2.last_flush = -1, CH;
              t4 = 0, n4 -= r3;
            }
            let r2 = new Uint8Array(i2.gzhead.extra);
            i2.pending_buf.set(r2.subarray(i2.gzindex, i2.gzindex + n4), i2.pending), i2.pending += n4, i2.gzhead.hcrc && i2.pending > t4 && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending - t4, t4)), i2.gzindex = 0;
          }
          i2.status = 73;
        }
        if (73 === i2.status) {
          if (i2.gzhead.name) {
            let t4, n4 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size) {
                if (i2.gzhead.hcrc && i2.pending > n4 && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending - n4, n4)), ZH(e2), 0 !== i2.pending) return i2.last_flush = -1, CH;
                n4 = 0;
              }
              t4 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, $H(i2, t4);
            } while (0 !== t4);
            i2.gzhead.hcrc && i2.pending > n4 && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending - n4, n4)), i2.gzindex = 0;
          }
          i2.status = 91;
        }
        if (91 === i2.status) {
          if (i2.gzhead.comment) {
            let t4, n4 = i2.pending;
            do {
              if (i2.pending === i2.pending_buf_size) {
                if (i2.gzhead.hcrc && i2.pending > n4 && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending - n4, n4)), ZH(e2), 0 !== i2.pending) return i2.last_flush = -1, CH;
                n4 = 0;
              }
              t4 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, $H(i2, t4);
            } while (0 !== t4);
            i2.gzhead.hcrc && i2.pending > n4 && (e2.adler = lH(e2.adler, i2.pending_buf, i2.pending - n4, n4));
          }
          i2.status = 103;
        }
        if (103 === i2.status) {
          if (i2.gzhead.hcrc) {
            if (i2.pending + 2 > i2.pending_buf_size && (ZH(e2), 0 !== i2.pending)) return i2.last_flush = -1, CH;
            $H(i2, 255 & e2.adler), $H(i2, e2.adler >> 8 & 255), e2.adler = 0;
          }
          if (i2.status = HH, ZH(e2), 0 !== i2.pending) return i2.last_flush = -1, CH;
        }
        if (0 !== e2.avail_in || 0 !== i2.lookahead || t3 !== SH && i2.status !== KH) {
          let n4 = 0 === i2.level ? rK(i2, t3) : i2.strategy === NH ? ((e3, t4) => {
            let i3;
            for (; ; ) {
              if (0 === e3.lookahead && (nK(e3), 0 === e3.lookahead)) {
                if (t4 === SH) return 1;
                break;
              }
              if (e3.match_length = 0, i3 = mH(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, i3 && (QH(e3, false), 0 === e3.strm.avail_out)) return 1;
            }
            return e3.insert = 0, t4 === RH ? (QH(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (QH(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i2, t3) : i2.strategy === DH ? ((e3, t4) => {
            let i3, n5, r2, o2;
            const s2 = e3.window;
            for (; ; ) {
              if (e3.lookahead <= jH) {
                if (nK(e3), e3.lookahead <= jH && t4 === SH) return 1;
                if (0 === e3.lookahead) break;
              }
              if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (r2 = e3.strstart - 1, n5 = s2[r2], n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2])) {
                o2 = e3.strstart + jH;
                do {
                } while (n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2] && n5 === s2[++r2] && r2 < o2);
                e3.match_length = jH - (o2 - r2), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= 3 ? (i3 = mH(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (i3 = mH(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), i3 && (QH(e3, false), 0 === e3.strm.avail_out)) return 1;
            }
            return e3.insert = 0, t4 === RH ? (QH(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.sym_next && (QH(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
          })(i2, t3) : cK[i2.level].func(i2, t3);
          if (3 !== n4 && 4 !== n4 || (i2.status = KH), 1 === n4 || 3 === n4) return 0 === e2.avail_out && (i2.last_flush = -1), CH;
          if (2 === n4 && (t3 === gH ? fH(i2) : t3 !== vH && (_H(i2, 0, 0, false), t3 === TH && (qH(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), ZH(e2), 0 === e2.avail_out)) return i2.last_flush = -1, CH;
        }
        return t3 !== RH ? CH : i2.wrap <= 0 ? yH : (2 === i2.wrap ? ($H(i2, 255 & e2.adler), $H(i2, e2.adler >> 8 & 255), $H(i2, e2.adler >> 16 & 255), $H(i2, e2.adler >> 24 & 255), $H(i2, 255 & e2.total_in), $H(i2, e2.total_in >> 8 & 255), $H(i2, e2.total_in >> 16 & 255), $H(i2, e2.total_in >> 24 & 255)) : (eK(i2, e2.adler >>> 16), eK(i2, 65535 & e2.adler)), ZH(e2), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? CH : yH);
      }, EK = (e2, t3) => {
        let i2 = t3.length;
        if (lK(e2)) return IH;
        const n3 = e2.state, r2 = n3.wrap;
        if (2 === r2 || 1 === r2 && n3.status !== WH || n3.lookahead) return IH;
        if (1 === r2 && (e2.adler = cH(e2.adler, t3, i2, 0)), n3.wrap = 0, i2 >= n3.w_size) {
          0 === r2 && (qH(n3.head), n3.strstart = 0, n3.block_start = 0, n3.insert = 0);
          let e3 = new Uint8Array(n3.w_size);
          e3.set(t3.subarray(i2 - n3.w_size, i2), 0), t3 = e3, i2 = n3.w_size;
        }
        const o2 = e2.avail_in, s2 = e2.next_in, a3 = e2.input;
        for (e2.avail_in = i2, e2.next_in = 0, e2.input = t3, nK(n3); n3.lookahead >= 3; ) {
          let e3 = n3.strstart, t4 = n3.lookahead - 2;
          do {
            n3.ins_h = JH(n3, n3.ins_h, n3.window[e3 + 3 - 1]), n3.prev[e3 & n3.w_mask] = n3.head[n3.ins_h], n3.head[n3.ins_h] = e3, e3++;
          } while (--t4);
          n3.strstart = e3, n3.lookahead = 2, nK(n3);
        }
        return n3.strstart += n3.lookahead, n3.block_start = n3.strstart, n3.insert = n3.lookahead, n3.lookahead = 0, n3.match_length = n3.prev_length = 2, n3.match_available = 0, e2.next_in = s2, e2.input = a3, e2.avail_in = o2, n3.wrap = r2, CH;
      }, mK = { deflateInit: (e2, t3) => pK(e2, t3, MH, 15, 8, LH), deflateInit2: pK, deflateReset: hK, deflateResetKeep: uK, deflateSetHeader: (e2, t3) => lK(e2) || 2 !== e2.state.wrap ? IH : (e2.state.gzhead = t3, CH), deflate: _K, deflateEnd: (e2) => {
        if (lK(e2)) return IH;
        const t3 = e2.state.status;
        return e2.state = null, t3 === HH ? YH(e2, bH) : CH;
      }, deflateSetDictionary: EK, deflateInfo: "pako deflate (from Nodeca project)" };
      const fK = (e2, t3) => Object.prototype.hasOwnProperty.call(e2, t3);
      var SK = { assign: function(e2) {
        const t3 = Array.prototype.slice.call(arguments, 1);
        for (; t3.length; ) {
          const i2 = t3.shift();
          if (i2) {
            if ("object" != typeof i2) throw new TypeError(i2 + "must be non-object");
            for (const t4 in i2) fK(i2, t4) && (e2[t4] = i2[t4]);
          }
        }
        return e2;
      }, flattenChunks: (e2) => {
        let t3 = 0;
        for (let i3 = 0, n3 = e2.length; i3 < n3; i3++) t3 += e2[i3].length;
        const i2 = new Uint8Array(t3);
        for (let t4 = 0, n3 = 0, r2 = e2.length; t4 < r2; t4++) {
          let r3 = e2[t4];
          i2.set(r3, n3), n3 += r3.length;
        }
        return i2;
      } };
      let gK = true;
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        gK = false;
      }
      const TK = new Uint8Array(256);
      for (let e2 = 0; e2 < 256; e2++) TK[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
      TK[254] = TK[254] = 1;
      var RK = { string2buf: (e2) => {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(e2);
        let t3, i2, n3, r2, o2, s2 = e2.length, a3 = 0;
        for (r2 = 0; r2 < s2; r2++) i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < s2 && (n3 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n3) && (i2 = 65536 + (i2 - 55296 << 10) + (n3 - 56320), r2++)), a3 += i2 < 128 ? 1 : i2 < 2048 ? 2 : i2 < 65536 ? 3 : 4;
        for (t3 = new Uint8Array(a3), o2 = 0, r2 = 0; o2 < a3; r2++) i2 = e2.charCodeAt(r2), 55296 == (64512 & i2) && r2 + 1 < s2 && (n3 = e2.charCodeAt(r2 + 1), 56320 == (64512 & n3) && (i2 = 65536 + (i2 - 55296 << 10) + (n3 - 56320), r2++)), i2 < 128 ? t3[o2++] = i2 : i2 < 2048 ? (t3[o2++] = 192 | i2 >>> 6, t3[o2++] = 128 | 63 & i2) : i2 < 65536 ? (t3[o2++] = 224 | i2 >>> 12, t3[o2++] = 128 | i2 >>> 6 & 63, t3[o2++] = 128 | 63 & i2) : (t3[o2++] = 240 | i2 >>> 18, t3[o2++] = 128 | i2 >>> 12 & 63, t3[o2++] = 128 | i2 >>> 6 & 63, t3[o2++] = 128 | 63 & i2);
        return t3;
      }, buf2string: (e2, t3) => {
        const i2 = t3 || e2.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(e2.subarray(0, t3));
        let n3, r2;
        const o2 = new Array(2 * i2);
        for (r2 = 0, n3 = 0; n3 < i2; ) {
          let t4 = e2[n3++];
          if (t4 < 128) {
            o2[r2++] = t4;
            continue;
          }
          let s2 = TK[t4];
          if (s2 > 4) o2[r2++] = 65533, n3 += s2 - 1;
          else {
            for (t4 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; s2 > 1 && n3 < i2; ) t4 = t4 << 6 | 63 & e2[n3++], s2--;
            s2 > 1 ? o2[r2++] = 65533 : t4 < 65536 ? o2[r2++] = t4 : (t4 -= 65536, o2[r2++] = 55296 | t4 >> 10 & 1023, o2[r2++] = 56320 | 1023 & t4);
          }
        }
        return ((e3, t4) => {
          if (t4 < 65534 && e3.subarray && gK) return String.fromCharCode.apply(null, e3.length === t4 ? e3 : e3.subarray(0, t4));
          let i3 = "";
          for (let n4 = 0; n4 < t4; n4++) i3 += String.fromCharCode(e3[n4]);
          return i3;
        })(o2, r2);
      }, utf8border: (e2, t3) => {
        (t3 = t3 || e2.length) > e2.length && (t3 = e2.length);
        let i2 = t3 - 1;
        for (; i2 >= 0 && 128 == (192 & e2[i2]); ) i2--;
        return i2 < 0 || 0 === i2 ? t3 : i2 + TK[e2[i2]] > t3 ? i2 : t3;
      } };
      var vK = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
      const CK = Object.prototype.toString, { Z_NO_FLUSH: yK, Z_SYNC_FLUSH: IK, Z_FULL_FLUSH: bK, Z_FINISH: AK, Z_OK: wK, Z_STREAM_END: OK, Z_DEFAULT_COMPRESSION: NK, Z_DEFAULT_STRATEGY: DK, Z_DEFLATED: PK } = hH;
      function LK(e2) {
        this.options = SK.assign({ level: NK, method: PK, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: DK }, e2 || {});
        let t3 = this.options;
        t3.raw && t3.windowBits > 0 ? t3.windowBits = -t3.windowBits : t3.gzip && t3.windowBits > 0 && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new vK(), this.strm.avail_out = 0;
        let i2 = mK.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
        if (i2 !== wK) throw new Error(uH[i2]);
        if (t3.header && mK.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
          let e3;
          if (e3 = "string" == typeof t3.dictionary ? RK.string2buf(t3.dictionary) : "[object ArrayBuffer]" === CK.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, i2 = mK.deflateSetDictionary(this.strm, e3), i2 !== wK) throw new Error(uH[i2]);
          this._dict_set = true;
        }
      }
      function kK(e2, t3) {
        const i2 = new LK(t3);
        if (i2.push(e2, true), i2.err) throw i2.msg || uH[i2.err];
        return i2.result;
      }
      LK.prototype.push = function(e2, t3) {
        const i2 = this.strm, n3 = this.options.chunkSize;
        let r2, o2;
        if (this.ended) return false;
        for (o2 = t3 === ~~t3 ? t3 : true === t3 ? AK : yK, "string" == typeof e2 ? i2.input = RK.string2buf(e2) : "[object ArrayBuffer]" === CK.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) if (0 === i2.avail_out && (i2.output = new Uint8Array(n3), i2.next_out = 0, i2.avail_out = n3), (o2 === IK || o2 === bK) && i2.avail_out <= 6) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
        else {
          if (r2 = mK.deflate(i2, o2), r2 === OK) return i2.next_out > 0 && this.onData(i2.output.subarray(0, i2.next_out)), r2 = mK.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === wK;
          if (0 !== i2.avail_out) {
            if (o2 > 0 && i2.next_out > 0) this.onData(i2.output.subarray(0, i2.next_out)), i2.avail_out = 0;
            else if (0 === i2.avail_in) break;
          } else this.onData(i2.output);
        }
        return true;
      }, LK.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, LK.prototype.onEnd = function(e2) {
        e2 === wK && (this.result = SK.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var MK = { Deflate: LK, deflate: kK, deflateRaw: function(e2, t3) {
        return (t3 = t3 || {}).raw = true, kK(e2, t3);
      }, gzip: function(e2, t3) {
        return (t3 = t3 || {}).gzip = true, kK(e2, t3);
      }, constants: hH };
      const UK = 16209;
      var VK = function(e2, t3) {
        let i2, n3, r2, o2, s2, a3, c3, d2, l2, u3, h2, p2, _2, E3, m3, f2, S3, g2, T3, R3, v3, C2, y3, I3;
        const b2 = e2.state;
        i2 = e2.next_in, y3 = e2.input, n3 = i2 + (e2.avail_in - 5), r2 = e2.next_out, I3 = e2.output, o2 = r2 - (t3 - e2.avail_out), s2 = r2 + (e2.avail_out - 257), a3 = b2.dmax, c3 = b2.wsize, d2 = b2.whave, l2 = b2.wnext, u3 = b2.window, h2 = b2.hold, p2 = b2.bits, _2 = b2.lencode, E3 = b2.distcode, m3 = (1 << b2.lenbits) - 1, f2 = (1 << b2.distbits) - 1;
        e: do {
          p2 < 15 && (h2 += y3[i2++] << p2, p2 += 8, h2 += y3[i2++] << p2, p2 += 8), S3 = _2[h2 & m3];
          t: for (; ; ) {
            if (g2 = S3 >>> 24, h2 >>>= g2, p2 -= g2, g2 = S3 >>> 16 & 255, 0 === g2) I3[r2++] = 65535 & S3;
            else {
              if (!(16 & g2)) {
                if (0 == (64 & g2)) {
                  S3 = _2[(65535 & S3) + (h2 & (1 << g2) - 1)];
                  continue t;
                }
                if (32 & g2) {
                  b2.mode = 16191;
                  break e;
                }
                e2.msg = "invalid literal/length code", b2.mode = UK;
                break e;
              }
              T3 = 65535 & S3, g2 &= 15, g2 && (p2 < g2 && (h2 += y3[i2++] << p2, p2 += 8), T3 += h2 & (1 << g2) - 1, h2 >>>= g2, p2 -= g2), p2 < 15 && (h2 += y3[i2++] << p2, p2 += 8, h2 += y3[i2++] << p2, p2 += 8), S3 = E3[h2 & f2];
              i: for (; ; ) {
                if (g2 = S3 >>> 24, h2 >>>= g2, p2 -= g2, g2 = S3 >>> 16 & 255, !(16 & g2)) {
                  if (0 == (64 & g2)) {
                    S3 = E3[(65535 & S3) + (h2 & (1 << g2) - 1)];
                    continue i;
                  }
                  e2.msg = "invalid distance code", b2.mode = UK;
                  break e;
                }
                if (R3 = 65535 & S3, g2 &= 15, p2 < g2 && (h2 += y3[i2++] << p2, p2 += 8, p2 < g2 && (h2 += y3[i2++] << p2, p2 += 8)), R3 += h2 & (1 << g2) - 1, R3 > a3) {
                  e2.msg = "invalid distance too far back", b2.mode = UK;
                  break e;
                }
                if (h2 >>>= g2, p2 -= g2, g2 = r2 - o2, R3 > g2) {
                  if (g2 = R3 - g2, g2 > d2 && b2.sane) {
                    e2.msg = "invalid distance too far back", b2.mode = UK;
                    break e;
                  }
                  if (v3 = 0, C2 = u3, 0 === l2) {
                    if (v3 += c3 - g2, g2 < T3) {
                      T3 -= g2;
                      do {
                        I3[r2++] = u3[v3++];
                      } while (--g2);
                      v3 = r2 - R3, C2 = I3;
                    }
                  } else if (l2 < g2) {
                    if (v3 += c3 + l2 - g2, g2 -= l2, g2 < T3) {
                      T3 -= g2;
                      do {
                        I3[r2++] = u3[v3++];
                      } while (--g2);
                      if (v3 = 0, l2 < T3) {
                        g2 = l2, T3 -= g2;
                        do {
                          I3[r2++] = u3[v3++];
                        } while (--g2);
                        v3 = r2 - R3, C2 = I3;
                      }
                    }
                  } else if (v3 += l2 - g2, g2 < T3) {
                    T3 -= g2;
                    do {
                      I3[r2++] = u3[v3++];
                    } while (--g2);
                    v3 = r2 - R3, C2 = I3;
                  }
                  for (; T3 > 2; ) I3[r2++] = C2[v3++], I3[r2++] = C2[v3++], I3[r2++] = C2[v3++], T3 -= 3;
                  T3 && (I3[r2++] = C2[v3++], T3 > 1 && (I3[r2++] = C2[v3++]));
                } else {
                  v3 = r2 - R3;
                  do {
                    I3[r2++] = I3[v3++], I3[r2++] = I3[v3++], I3[r2++] = I3[v3++], T3 -= 3;
                  } while (T3 > 2);
                  T3 && (I3[r2++] = I3[v3++], T3 > 1 && (I3[r2++] = I3[v3++]));
                }
                break;
              }
            }
            break;
          }
        } while (i2 < n3 && r2 < s2);
        T3 = p2 >> 3, i2 -= T3, p2 -= T3 << 3, h2 &= (1 << p2) - 1, e2.next_in = i2, e2.next_out = r2, e2.avail_in = i2 < n3 ? n3 - i2 + 5 : 5 - (i2 - n3), e2.avail_out = r2 < s2 ? s2 - r2 + 257 : 257 - (r2 - s2), b2.hold = h2, b2.bits = p2;
      };
      const xK = 15, FK = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), BK = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), jK = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), GK = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
      var WK = (e2, t3, i2, n3, r2, o2, s2, a3) => {
        const c3 = a3.bits;
        let d2, l2, u3, h2, p2, _2, E3 = 0, m3 = 0, f2 = 0, S3 = 0, g2 = 0, T3 = 0, R3 = 0, v3 = 0, C2 = 0, y3 = 0, I3 = null;
        const b2 = new Uint16Array(16), A2 = new Uint16Array(16);
        let w3, O3, N3, D3 = null;
        for (E3 = 0; E3 <= xK; E3++) b2[E3] = 0;
        for (m3 = 0; m3 < n3; m3++) b2[t3[i2 + m3]]++;
        for (g2 = c3, S3 = xK; S3 >= 1 && 0 === b2[S3]; S3--) ;
        if (g2 > S3 && (g2 = S3), 0 === S3) return r2[o2++] = 20971520, r2[o2++] = 20971520, a3.bits = 1, 0;
        for (f2 = 1; f2 < S3 && 0 === b2[f2]; f2++) ;
        for (g2 < f2 && (g2 = f2), v3 = 1, E3 = 1; E3 <= xK; E3++) if (v3 <<= 1, v3 -= b2[E3], v3 < 0) return -1;
        if (v3 > 0 && (0 === e2 || 1 !== S3)) return -1;
        for (A2[1] = 0, E3 = 1; E3 < xK; E3++) A2[E3 + 1] = A2[E3] + b2[E3];
        for (m3 = 0; m3 < n3; m3++) 0 !== t3[i2 + m3] && (s2[A2[t3[i2 + m3]]++] = m3);
        if (0 === e2 ? (I3 = D3 = s2, _2 = 20) : 1 === e2 ? (I3 = FK, D3 = BK, _2 = 257) : (I3 = jK, D3 = GK, _2 = 0), y3 = 0, m3 = 0, E3 = f2, p2 = o2, T3 = g2, R3 = 0, u3 = -1, C2 = 1 << g2, h2 = C2 - 1, 1 === e2 && C2 > 852 || 2 === e2 && C2 > 592) return 1;
        for (; ; ) {
          w3 = E3 - R3, s2[m3] + 1 < _2 ? (O3 = 0, N3 = s2[m3]) : s2[m3] >= _2 ? (O3 = D3[s2[m3] - _2], N3 = I3[s2[m3] - _2]) : (O3 = 96, N3 = 0), d2 = 1 << E3 - R3, l2 = 1 << T3, f2 = l2;
          do {
            l2 -= d2, r2[p2 + (y3 >> R3) + l2] = w3 << 24 | O3 << 16 | N3 | 0;
          } while (0 !== l2);
          for (d2 = 1 << E3 - 1; y3 & d2; ) d2 >>= 1;
          if (0 !== d2 ? (y3 &= d2 - 1, y3 += d2) : y3 = 0, m3++, 0 == --b2[E3]) {
            if (E3 === S3) break;
            E3 = t3[i2 + s2[m3]];
          }
          if (E3 > g2 && (y3 & h2) !== u3) {
            for (0 === R3 && (R3 = g2), p2 += f2, T3 = E3 - R3, v3 = 1 << T3; T3 + R3 < S3 && (v3 -= b2[T3 + R3], !(v3 <= 0)); ) T3++, v3 <<= 1;
            if (C2 += 1 << T3, 1 === e2 && C2 > 852 || 2 === e2 && C2 > 592) return 1;
            u3 = y3 & h2, r2[u3] = g2 << 24 | T3 << 16 | p2 - o2 | 0;
          }
        }
        return 0 !== y3 && (r2[p2 + y3] = E3 - R3 << 24 | 64 << 16 | 0), a3.bits = g2, 0;
      };
      const { Z_FINISH: HK, Z_BLOCK: KK, Z_TREES: YK, Z_OK: zK, Z_STREAM_END: qK, Z_NEED_DICT: XK, Z_STREAM_ERROR: JK, Z_DATA_ERROR: ZK, Z_MEM_ERROR: QK, Z_BUF_ERROR: $K, Z_DEFLATED: eY } = hH, tY = 16180, iY = 16190, nY = 16191, rY = 16192, oY = 16194, sY = 16199, aY = 16200, cY = 16206, dY = 16209, lY = (e2) => (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      function uY() {
        this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      const hY = (e2) => {
        if (!e2) return 1;
        const t3 = e2.state;
        return !t3 || t3.strm !== e2 || t3.mode < tY || t3.mode > 16211 ? 1 : 0;
      }, pY = (e2) => {
        if (hY(e2)) return JK;
        const t3 = e2.state;
        return e2.total_in = e2.total_out = t3.total = 0, e2.msg = "", t3.wrap && (e2.adler = 1 & t3.wrap), t3.mode = tY, t3.last = 0, t3.havedict = 0, t3.flags = -1, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new Int32Array(852), t3.distcode = t3.distdyn = new Int32Array(592), t3.sane = 1, t3.back = -1, zK;
      }, _Y = (e2) => {
        if (hY(e2)) return JK;
        const t3 = e2.state;
        return t3.wsize = 0, t3.whave = 0, t3.wnext = 0, pY(e2);
      }, EY = (e2, t3) => {
        let i2;
        if (hY(e2)) return JK;
        const n3 = e2.state;
        return t3 < 0 ? (i2 = 0, t3 = -t3) : (i2 = 5 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? JK : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = i2, n3.wbits = t3, _Y(e2));
      }, mY = (e2, t3) => {
        if (!e2) return JK;
        const i2 = new uY();
        e2.state = i2, i2.strm = e2, i2.window = null, i2.mode = tY;
        const n3 = EY(e2, t3);
        return n3 !== zK && (e2.state = null), n3;
      };
      let fY, SY, gY = true;
      const TY = (e2) => {
        if (gY) {
          fY = new Int32Array(512), SY = new Int32Array(32);
          let t3 = 0;
          for (; t3 < 144; ) e2.lens[t3++] = 8;
          for (; t3 < 256; ) e2.lens[t3++] = 9;
          for (; t3 < 280; ) e2.lens[t3++] = 7;
          for (; t3 < 288; ) e2.lens[t3++] = 8;
          for (WK(1, e2.lens, 0, 288, fY, 0, e2.work, { bits: 9 }), t3 = 0; t3 < 32; ) e2.lens[t3++] = 5;
          WK(2, e2.lens, 0, 32, SY, 0, e2.work, { bits: 5 }), gY = false;
        }
        e2.lencode = fY, e2.lenbits = 9, e2.distcode = SY, e2.distbits = 5;
      }, RY = (e2, t3, i2, n3) => {
        let r2;
        const o2 = e2.state;
        return null === o2.window && (o2.wsize = 1 << o2.wbits, o2.wnext = 0, o2.whave = 0, o2.window = new Uint8Array(o2.wsize)), n3 >= o2.wsize ? (o2.window.set(t3.subarray(i2 - o2.wsize, i2), 0), o2.wnext = 0, o2.whave = o2.wsize) : (r2 = o2.wsize - o2.wnext, r2 > n3 && (r2 = n3), o2.window.set(t3.subarray(i2 - n3, i2 - n3 + r2), o2.wnext), (n3 -= r2) ? (o2.window.set(t3.subarray(i2 - n3, i2), 0), o2.wnext = n3, o2.whave = o2.wsize) : (o2.wnext += r2, o2.wnext === o2.wsize && (o2.wnext = 0), o2.whave < o2.wsize && (o2.whave += r2))), 0;
      };
      var vY = (e2, t3) => {
        let i2, n3, r2, o2, s2, a3, c3, d2, l2, u3, h2, p2, _2, E3, m3, f2, S3, g2, T3, R3, v3, C2, y3 = 0;
        const I3 = new Uint8Array(4);
        let b2, A2;
        const w3 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (hY(e2) || !e2.output || !e2.input && 0 !== e2.avail_in) return JK;
        i2 = e2.state, i2.mode === nY && (i2.mode = rY), s2 = e2.next_out, r2 = e2.output, c3 = e2.avail_out, o2 = e2.next_in, n3 = e2.input, a3 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, u3 = a3, h2 = c3, C2 = zK;
        e: for (; ; ) switch (i2.mode) {
          case tY:
            if (0 === i2.wrap) {
              i2.mode = rY;
              break;
            }
            for (; l2 < 16; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            if (2 & i2.wrap && 35615 === d2) {
              0 === i2.wbits && (i2.wbits = 15), i2.check = 0, I3[0] = 255 & d2, I3[1] = d2 >>> 8 & 255, i2.check = lH(i2.check, I3, 2, 0), d2 = 0, l2 = 0, i2.mode = 16181;
              break;
            }
            if (i2.head && (i2.head.done = false), !(1 & i2.wrap) || (((255 & d2) << 8) + (d2 >> 8)) % 31) {
              e2.msg = "incorrect header check", i2.mode = dY;
              break;
            }
            if ((15 & d2) !== eY) {
              e2.msg = "unknown compression method", i2.mode = dY;
              break;
            }
            if (d2 >>>= 4, l2 -= 4, v3 = 8 + (15 & d2), 0 === i2.wbits && (i2.wbits = v3), v3 > 15 || v3 > i2.wbits) {
              e2.msg = "invalid window size", i2.mode = dY;
              break;
            }
            i2.dmax = 1 << i2.wbits, i2.flags = 0, e2.adler = i2.check = 1, i2.mode = 512 & d2 ? 16189 : nY, d2 = 0, l2 = 0;
            break;
          case 16181:
            for (; l2 < 16; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            if (i2.flags = d2, (255 & TW(i2)) !== eY) {
              e2.msg = "unknown compression method", i2.mode = dY;
              break;
            }
            if (57344 & TW(i2)) {
              e2.msg = "unknown header flags set", i2.mode = dY;
              break;
            }
            i2.head && (i2.head.text = d2 >> 8 & 1), 512 & TW(i2) && 4 & i2.wrap && (I3[0] = 255 & d2, I3[1] = d2 >>> 8 & 255, i2.check = lH(i2.check, I3, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16182;
          case 16182:
            for (; l2 < 32; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            i2.head && (i2.head.time = d2), 512 & TW(i2) && 4 & i2.wrap && (I3[0] = 255 & d2, I3[1] = d2 >>> 8 & 255, I3[2] = d2 >>> 16 & 255, I3[3] = d2 >>> 24 & 255, i2.check = lH(i2.check, I3, 4, 0)), d2 = 0, l2 = 0, i2.mode = 16183;
          case 16183:
            for (; l2 < 16; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            i2.head && (i2.head.xflags = 255 & d2, i2.head.os = d2 >> 8), 512 & TW(i2) && 4 & i2.wrap && (I3[0] = 255 & d2, I3[1] = d2 >>> 8 & 255, i2.check = lH(i2.check, I3, 2, 0)), d2 = 0, l2 = 0, i2.mode = 16184;
          case 16184:
            if (1024 & TW(i2)) {
              for (; l2 < 16; ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              i2.length = d2, i2.head && (i2.head.extra_len = d2), 512 & TW(i2) && 4 & i2.wrap && (I3[0] = 255 & d2, I3[1] = d2 >>> 8 & 255, i2.check = lH(i2.check, I3, 2, 0)), d2 = 0, l2 = 0;
            } else i2.head && (i2.head.extra = null);
            i2.mode = 16185;
          case 16185:
            if (1024 & TW(i2) && (p2 = i2.length, p2 > a3 && (p2 = a3), p2 && (i2.head && (v3 = i2.head.extra_len - i2.length, i2.head.extra || (i2.head.extra = new Uint8Array(i2.head.extra_len)), i2.head.extra.set(n3.subarray(o2, o2 + p2), v3)), 512 & TW(i2) && 4 & i2.wrap && (i2.check = lH(i2.check, n3, p2, o2)), a3 -= p2, o2 += p2, i2.length -= p2), i2.length)) break e;
            i2.length = 0, i2.mode = 16186;
          case 16186:
            if (2048 & TW(i2)) {
              if (0 === a3) break e;
              p2 = 0;
              do {
                v3 = n3[o2 + p2++], i2.head && v3 && i2.length < 65536 && (i2.head.name += String.fromCharCode(v3));
              } while (v3 && p2 < a3);
              if (512 & TW(i2) && 4 & i2.wrap && (i2.check = lH(i2.check, n3, p2, o2)), a3 -= p2, o2 += p2, v3) break e;
            } else i2.head && (i2.head.name = null);
            i2.length = 0, i2.mode = 16187;
          case 16187:
            if (4096 & TW(i2)) {
              if (0 === a3) break e;
              p2 = 0;
              do {
                v3 = n3[o2 + p2++], i2.head && v3 && i2.length < 65536 && (i2.head.comment += String.fromCharCode(v3));
              } while (v3 && p2 < a3);
              if (512 & TW(i2) && 4 & i2.wrap && (i2.check = lH(i2.check, n3, p2, o2)), a3 -= p2, o2 += p2, v3) break e;
            } else i2.head && (i2.head.comment = null);
            i2.mode = 16188;
          case 16188:
            if (512 & TW(i2)) {
              for (; l2 < 16; ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              if (4 & i2.wrap && d2 !== (65535 & i2.check)) {
                e2.msg = "header crc mismatch", i2.mode = dY;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.head && (i2.head.hcrc = TW(i2) >> 9 & 1, i2.head.done = true), e2.adler = i2.check = 0, i2.mode = nY;
            break;
          case 16189:
            for (; l2 < 32; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            e2.adler = i2.check = lY(d2), d2 = 0, l2 = 0, i2.mode = iY;
          case iY:
            if (0 === i2.havedict) return e2.next_out = s2, e2.avail_out = c3, e2.next_in = o2, e2.avail_in = a3, i2.hold = d2, i2.bits = l2, XK;
            e2.adler = i2.check = 1, i2.mode = nY;
          case nY:
            if (t3 === KK || t3 === YK) break e;
          case rY:
            if (i2.last) {
              d2 >>>= 7 & l2, l2 -= 7 & l2, i2.mode = cY;
              break;
            }
            for (; l2 < 3; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            switch (i2.last = 1 & d2, d2 >>>= 1, l2 -= 1, 3 & d2) {
              case 0:
                i2.mode = 16193;
                break;
              case 1:
                if (TY(i2), i2.mode = sY, t3 === YK) {
                  d2 >>>= 2, l2 -= 2;
                  break e;
                }
                break;
              case 2:
                i2.mode = 16196;
                break;
              case 3:
                e2.msg = "invalid block type", i2.mode = dY;
            }
            d2 >>>= 2, l2 -= 2;
            break;
          case 16193:
            for (d2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            if ((65535 & d2) != (d2 >>> 16 ^ 65535)) {
              e2.msg = "invalid stored block lengths", i2.mode = dY;
              break;
            }
            if (i2.length = 65535 & d2, d2 = 0, l2 = 0, i2.mode = oY, t3 === YK) break e;
          case oY:
            i2.mode = 16195;
          case 16195:
            if (p2 = i2.length, p2) {
              if (p2 > a3 && (p2 = a3), p2 > c3 && (p2 = c3), 0 === p2) break e;
              r2.set(n3.subarray(o2, o2 + p2), s2), a3 -= p2, o2 += p2, c3 -= p2, s2 += p2, i2.length -= p2;
              break;
            }
            i2.mode = nY;
            break;
          case 16196:
            for (; l2 < 14; ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            if (i2.nlen = 257 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ndist = 1 + (31 & d2), d2 >>>= 5, l2 -= 5, i2.ncode = 4 + (15 & d2), d2 >>>= 4, l2 -= 4, i2.nlen > 286 || i2.ndist > 30) {
              e2.msg = "too many length or distance symbols", i2.mode = dY;
              break;
            }
            i2.have = 0, i2.mode = 16197;
          case 16197:
            for (; i2.have < i2.ncode; ) {
              for (; l2 < 3; ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              i2.lens[w3[i2.have++]] = 7 & d2, d2 >>>= 3, l2 -= 3;
            }
            for (; i2.have < 19; ) i2.lens[w3[i2.have++]] = 0;
            if (i2.lencode = i2.lendyn, i2.lenbits = 7, b2 = { bits: i2.lenbits }, C2 = WK(0, i2.lens, 0, 19, i2.lencode, 0, i2.work, b2), i2.lenbits = b2.bits, C2) {
              e2.msg = "invalid code lengths set", i2.mode = dY;
              break;
            }
            i2.have = 0, i2.mode = 16198;
          case 16198:
            for (; i2.have < i2.nlen + i2.ndist; ) {
              for (; y3 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m3 = y3 >>> 24, f2 = y3 >>> 16 & 255, S3 = 65535 & y3, !(m3 <= l2); ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              if (S3 < 16) d2 >>>= m3, l2 -= m3, i2.lens[i2.have++] = S3;
              else {
                if (16 === S3) {
                  for (A2 = m3 + 2; l2 < A2; ) {
                    if (0 === a3) break e;
                    a3--, d2 += n3[o2++] << l2, l2 += 8;
                  }
                  if (d2 >>>= m3, l2 -= m3, 0 === i2.have) {
                    e2.msg = "invalid bit length repeat", i2.mode = dY;
                    break;
                  }
                  v3 = i2.lens[i2.have - 1], p2 = 3 + (3 & d2), d2 >>>= 2, l2 -= 2;
                } else if (17 === S3) {
                  for (A2 = m3 + 3; l2 < A2; ) {
                    if (0 === a3) break e;
                    a3--, d2 += n3[o2++] << l2, l2 += 8;
                  }
                  d2 >>>= m3, l2 -= m3, v3 = 0, p2 = 3 + (7 & d2), d2 >>>= 3, l2 -= 3;
                } else {
                  for (A2 = m3 + 7; l2 < A2; ) {
                    if (0 === a3) break e;
                    a3--, d2 += n3[o2++] << l2, l2 += 8;
                  }
                  d2 >>>= m3, l2 -= m3, v3 = 0, p2 = 11 + (127 & d2), d2 >>>= 7, l2 -= 7;
                }
                if (i2.have + p2 > i2.nlen + i2.ndist) {
                  e2.msg = "invalid bit length repeat", i2.mode = dY;
                  break;
                }
                for (; p2--; ) i2.lens[i2.have++] = v3;
              }
            }
            if (i2.mode === dY) break;
            if (0 === i2.lens[256]) {
              e2.msg = "invalid code -- missing end-of-block", i2.mode = dY;
              break;
            }
            if (i2.lenbits = 9, b2 = { bits: i2.lenbits }, C2 = WK(1, i2.lens, 0, i2.nlen, i2.lencode, 0, i2.work, b2), i2.lenbits = b2.bits, C2) {
              e2.msg = "invalid literal/lengths set", i2.mode = dY;
              break;
            }
            if (i2.distbits = 6, i2.distcode = i2.distdyn, b2 = { bits: i2.distbits }, C2 = WK(2, i2.lens, i2.nlen, i2.ndist, i2.distcode, 0, i2.work, b2), i2.distbits = b2.bits, C2) {
              e2.msg = "invalid distances set", i2.mode = dY;
              break;
            }
            if (i2.mode = sY, t3 === YK) break e;
          case sY:
            i2.mode = aY;
          case aY:
            if (a3 >= 6 && c3 >= 258) {
              e2.next_out = s2, e2.avail_out = c3, e2.next_in = o2, e2.avail_in = a3, i2.hold = d2, i2.bits = l2, VK(e2, h2), s2 = e2.next_out, r2 = e2.output, c3 = e2.avail_out, o2 = e2.next_in, n3 = e2.input, a3 = e2.avail_in, d2 = i2.hold, l2 = i2.bits, i2.mode === nY && (i2.back = -1);
              break;
            }
            for (i2.back = 0; y3 = i2.lencode[d2 & (1 << i2.lenbits) - 1], m3 = y3 >>> 24, f2 = y3 >>> 16 & 255, S3 = 65535 & y3, !(m3 <= l2); ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            if (f2 && 0 == (240 & f2)) {
              for (g2 = m3, T3 = f2, R3 = S3; y3 = i2.lencode[R3 + ((d2 & (1 << g2 + T3) - 1) >> g2)], m3 = y3 >>> 24, f2 = y3 >>> 16 & 255, S3 = 65535 & y3, !(g2 + m3 <= l2); ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              d2 >>>= g2, l2 -= g2, i2.back += g2;
            }
            if (d2 >>>= m3, l2 -= m3, i2.back += m3, i2.length = S3, 0 === f2) {
              i2.mode = 16205;
              break;
            }
            if (32 & f2) {
              i2.back = -1, i2.mode = nY;
              break;
            }
            if (64 & f2) {
              e2.msg = "invalid literal/length code", i2.mode = dY;
              break;
            }
            i2.extra = 15 & f2, i2.mode = 16201;
          case 16201:
            if (i2.extra) {
              for (A2 = i2.extra; l2 < A2; ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              i2.length += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
            }
            i2.was = i2.length, i2.mode = 16202;
          case 16202:
            for (; y3 = i2.distcode[d2 & (1 << i2.distbits) - 1], m3 = y3 >>> 24, f2 = y3 >>> 16 & 255, S3 = 65535 & y3, !(m3 <= l2); ) {
              if (0 === a3) break e;
              a3--, d2 += n3[o2++] << l2, l2 += 8;
            }
            if (0 == (240 & f2)) {
              for (g2 = m3, T3 = f2, R3 = S3; y3 = i2.distcode[R3 + ((d2 & (1 << g2 + T3) - 1) >> g2)], m3 = y3 >>> 24, f2 = y3 >>> 16 & 255, S3 = 65535 & y3, !(g2 + m3 <= l2); ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              d2 >>>= g2, l2 -= g2, i2.back += g2;
            }
            if (d2 >>>= m3, l2 -= m3, i2.back += m3, 64 & f2) {
              e2.msg = "invalid distance code", i2.mode = dY;
              break;
            }
            i2.offset = S3, i2.extra = 15 & f2, i2.mode = 16203;
          case 16203:
            if (i2.extra) {
              for (A2 = i2.extra; l2 < A2; ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              i2.offset += d2 & (1 << i2.extra) - 1, d2 >>>= i2.extra, l2 -= i2.extra, i2.back += i2.extra;
            }
            if (i2.offset > i2.dmax) {
              e2.msg = "invalid distance too far back", i2.mode = dY;
              break;
            }
            i2.mode = 16204;
          case 16204:
            if (0 === c3) break e;
            if (p2 = h2 - c3, i2.offset > p2) {
              if (p2 = i2.offset - p2, p2 > i2.whave && i2.sane) {
                e2.msg = "invalid distance too far back", i2.mode = dY;
                break;
              }
              p2 > i2.wnext ? (p2 -= i2.wnext, _2 = i2.wsize - p2) : _2 = i2.wnext - p2, p2 > i2.length && (p2 = i2.length), E3 = i2.window;
            } else E3 = r2, _2 = s2 - i2.offset, p2 = i2.length;
            p2 > c3 && (p2 = c3), c3 -= p2, i2.length -= p2;
            do {
              r2[s2++] = E3[_2++];
            } while (--p2);
            0 === i2.length && (i2.mode = aY);
            break;
          case 16205:
            if (0 === c3) break e;
            r2[s2++] = i2.length, c3--, i2.mode = aY;
            break;
          case cY:
            if (i2.wrap) {
              for (; l2 < 32; ) {
                if (0 === a3) break e;
                a3--, d2 |= n3[o2++] << l2, l2 += 8;
              }
              if (h2 -= c3, e2.total_out += h2, i2.total += h2, 4 & i2.wrap && h2 && (e2.adler = i2.check = TW(i2) ? lH(i2.check, r2, h2, s2 - h2) : cH(i2.check, r2, h2, s2 - h2)), h2 = c3, 4 & i2.wrap && (TW(i2) ? d2 : lY(d2)) !== i2.check) {
                e2.msg = "incorrect data check", i2.mode = dY;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.mode = 16207;
          case 16207:
            if (i2.wrap && TW(i2)) {
              for (; l2 < 32; ) {
                if (0 === a3) break e;
                a3--, d2 += n3[o2++] << l2, l2 += 8;
              }
              if (4 & i2.wrap && d2 !== (4294967295 & i2.total)) {
                e2.msg = "incorrect length check", i2.mode = dY;
                break;
              }
              d2 = 0, l2 = 0;
            }
            i2.mode = 16208;
          case 16208:
            C2 = qK;
            break e;
          case dY:
            C2 = ZK;
            break e;
          case 16210:
            return QK;
          default:
            return JK;
        }
        return e2.next_out = s2, e2.avail_out = c3, e2.next_in = o2, e2.avail_in = a3, i2.hold = d2, i2.bits = l2, (i2.wsize || h2 !== e2.avail_out && i2.mode < dY && (i2.mode < cY || t3 !== HK)) && RY(e2, e2.output, e2.next_out, h2 - e2.avail_out), u3 -= e2.avail_in, h2 -= e2.avail_out, e2.total_in += u3, e2.total_out += h2, i2.total += h2, 4 & i2.wrap && h2 && (e2.adler = i2.check = TW(i2) ? lH(i2.check, r2, h2, e2.next_out - h2) : cH(i2.check, r2, h2, e2.next_out - h2)), e2.data_type = i2.bits + (i2.last ? 64 : 0) + (i2.mode === nY ? 128 : 0) + (i2.mode === sY || i2.mode === oY ? 256 : 0), (0 === u3 && 0 === h2 || t3 === HK) && C2 === zK && (C2 = $K), C2;
      }, CY = { inflateReset: _Y, inflateReset2: EY, inflateResetKeep: pY, inflateInit: (e2) => mY(e2, 15), inflateInit2: mY, inflate: vY, inflateEnd: (e2) => {
        if (hY(e2)) return JK;
        let t3 = e2.state;
        return t3.window && (t3.window = null), e2.state = null, zK;
      }, inflateGetHeader: (e2, t3) => {
        if (hY(e2)) return JK;
        const i2 = e2.state;
        return 0 == (2 & i2.wrap) ? JK : (i2.head = t3, t3.done = false, zK);
      }, inflateSetDictionary: (e2, t3) => {
        const i2 = t3.length;
        let n3, r2, o2;
        return hY(e2) ? JK : (n3 = e2.state, 0 !== n3.wrap && n3.mode !== iY ? JK : n3.mode === iY && (r2 = 1, r2 = cH(r2, t3, i2, 0), r2 !== n3.check) ? ZK : (o2 = RY(e2, t3, i2, i2), o2 ? (n3.mode = 16210, QK) : (n3.havedict = 1, zK)));
      }, inflateInfo: "pako inflate (from Nodeca project)" };
      var yY = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
      const IY = Object.prototype.toString, { Z_NO_FLUSH: bY, Z_FINISH: AY, Z_OK: wY, Z_STREAM_END: OY, Z_NEED_DICT: NY, Z_STREAM_ERROR: DY, Z_DATA_ERROR: PY, Z_MEM_ERROR: LY } = hH;
      function kY(e2) {
        this.options = SK.assign({ chunkSize: 65536, windowBits: 15, to: "" }, e2 || {});
        const t3 = this.options;
        t3.raw && t3.windowBits >= 0 && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(t3.windowBits >= 0 && t3.windowBits < 16) || e2 && e2.windowBits || (t3.windowBits += 32), t3.windowBits > 15 && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new vK(), this.strm.avail_out = 0;
        let i2 = CY.inflateInit2(this.strm, t3.windowBits);
        if (i2 !== wY) throw new Error(uH[i2]);
        if (this.header = new yY(), CY.inflateGetHeader(this.strm, this.header), t3.dictionary && ("string" == typeof t3.dictionary ? t3.dictionary = RK.string2buf(t3.dictionary) : "[object ArrayBuffer]" === IY.call(t3.dictionary) && (t3.dictionary = new Uint8Array(t3.dictionary)), t3.raw && (i2 = CY.inflateSetDictionary(this.strm, t3.dictionary), i2 !== wY))) throw new Error(uH[i2]);
      }
      function MY(e2, t3) {
        const i2 = new kY(t3);
        if (i2.push(e2), i2.err) throw i2.msg || uH[i2.err];
        return i2.result;
      }
      kY.prototype.push = function(e2, t3) {
        const i2 = this.strm, n3 = this.options.chunkSize, r2 = this.options.dictionary;
        let o2, s2, a3;
        if (this.ended) return false;
        for (s2 = t3 === ~~t3 ? t3 : true === t3 ? AY : bY, "[object ArrayBuffer]" === IY.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length; ; ) {
          for (0 === i2.avail_out && (i2.output = new Uint8Array(n3), i2.next_out = 0, i2.avail_out = n3), o2 = CY.inflate(i2, s2), o2 === NY && r2 && (o2 = CY.inflateSetDictionary(i2, r2), o2 === wY ? o2 = CY.inflate(i2, s2) : o2 === PY && (o2 = NY)); i2.avail_in > 0 && o2 === OY && i2.state.wrap > 0 && 0 !== e2[i2.next_in]; ) CY.inflateReset(i2), o2 = CY.inflate(i2, s2);
          switch (o2) {
            case DY:
            case PY:
            case NY:
            case LY:
              return this.onEnd(o2), this.ended = true, false;
          }
          if (a3 = i2.avail_out, i2.next_out && (0 === i2.avail_out || o2 === OY)) if ("string" === this.options.to) {
            let e3 = RK.utf8border(i2.output, i2.next_out), t4 = i2.next_out - e3, r3 = RK.buf2string(i2.output, e3);
            i2.next_out = t4, i2.avail_out = n3 - t4, t4 && i2.output.set(i2.output.subarray(e3, e3 + t4), 0), this.onData(r3);
          } else this.onData(i2.output.length === i2.next_out ? i2.output : i2.output.subarray(0, i2.next_out));
          if (o2 !== wY || 0 !== a3) {
            if (o2 === OY) return o2 = CY.inflateEnd(this.strm), this.onEnd(o2), this.ended = true, true;
            if (0 === i2.avail_in) break;
          }
        }
        return true;
      }, kY.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, kY.prototype.onEnd = function(e2) {
        e2 === wY && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = SK.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      };
      var UY = { Inflate: kY, inflate: MY, inflateRaw: function(e2, t3) {
        return (t3 = t3 || {}).raw = true, MY(e2, t3);
      }, ungzip: MY, constants: hH };
      const { Deflate: VY, deflate: xY, deflateRaw: FY, gzip: BY } = MK, { Inflate: jY, inflate: GY, inflateRaw: WY, ungzip: HY } = UY;
      var KY = xY, YY = GY, zY = function(e2) {
        return e2[e2.ONE_BYTE = 0] = "ONE_BYTE", e2[e2.TWO_BYTE = 1] = "TWO_BYTE", e2;
      }(zY || {});
      class qY {
        constructor() {
          uI(this, "_sequence", 0), uI(this, "_startTime", Date.now()), uI(this, "isUseOneByte", true);
        }
        get startTime() {
          const e2 = Date.now() - this._startTime;
          return e2 < Math.pow(2, 16) ? e2 : (this._startTime += Math.pow(2, 16), this.startTime);
        }
        get sequence() {
          return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
        }
        serialize(e2) {
          const t3 = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e2 };
          if (e2.byteLength > 128) {
            const i3 = new Uint8Array(4);
            i3.set([1, 0, 0, 0]);
            const n4 = { id: 0, length: 4, data: i3.buffer }, r3 = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [n4] };
            t3.commonPacketHeader.extension = 1, t3.extension = r3, t3.payload = this.compress(e2), t3.commonPacketHeader.length = 8 + (t3.extension.length + 2) + t3.payload.byteLength;
          } else t3.commonPacketHeader.length = 8 + t3.payload.byteLength;
          wN("SHOW_DATASTREAM2_LOG") && sD.debug("send data header: ".concat(JSON.stringify(t3.commonPacketHeader)));
          const i2 = new ArrayBuffer(t3.commonPacketHeader.length), n3 = new Uint8Array(i2), r2 = new DataView(i2);
          let o2 = 0;
          if (r2.setUint16(o2, t3.commonPacketHeader.extension << 15 | t3.commonPacketHeader.reserved << 14 | t3.commonPacketHeader.length, true), o2 += 2, r2.setUint32(o2, t3.commonPacketHeader.sequence, true), o2 += 4, r2.setUint16(o2, t3.commonStreamHeader, true), o2 += 2, t3.extension) {
            const e3 = this.serializeExtension(t3.extension);
            n3.set(new Uint8Array(e3), o2), o2 += e3.byteLength;
          }
          if (n3.set(new Uint8Array(t3.payload), o2), o2 += t3.payload.byteLength, o2 !== t3.commonPacketHeader.length) throw Error("serialize error!");
          return i2;
        }
        deserialize(e2) {
          if (e2.byteLength < 4) return new ArrayBuffer(0);
          const t3 = new DataView(e2);
          let i2 = 0;
          const n3 = t3.getUint16(i2, true);
          i2 += 2;
          const r2 = { length: 16383 & n3, reserved: (16384 & n3) >> 14, extension: (32768 & n3) >> 15, sequence: t3.getUint16(i2 + 2, true) << 16 | t3.getUint16(i2, true) };
          let o2, s2;
          if (i2 += 4, wN("SHOW_DATASTREAM2_LOG") && sD.debug("receive data header: ".concat(JSON.stringify(r2))), t3.getUint16(i2, true), i2 += 2, r2.extension) {
            s2 = this.deserializeExtension(e2.slice(i2)), i2 += 2 + s2.length, o2 = e2.slice(i2);
            let t4 = false;
            if (s2.datas.length > 0) {
              const e3 = s2.datas.find((e4) => 0 === e4.id);
              if (e3) {
                t4 = 1 == (1 & new DataView(e3.data).getUint32(0, true));
              }
            }
            o2 = t4 ? this.decompress(o2) : o2;
          } else o2 = e2.slice(8);
          return o2;
        }
        serializeExtension(e2) {
          const { profile: t3, length: i2, datas: n3 } = e2, r2 = new ArrayBuffer(i2 + 2), o2 = new Uint8Array(r2), s2 = new DataView(r2);
          let a3 = 0;
          if (s2.setUint8(a3++, t3), s2.setUint8(a3++, i2), n3.forEach((e3) => {
            t3 ? (s2.setUint8(a3++, e3.id), s2.setUint8(a3++, e3.length), o2.set(new Uint8Array(e3.data), a3), a3 += e3.data.byteLength) : (s2.setUint8(a3++, e3.id | e3.length << 4), o2.set(new Uint8Array(e3.data), a3), a3 += e3.data.byteLength);
          }), a3 !== i2 + 2) throw Error("serialize extension error, is ".concat(a3, "!==").concat(i2 + 2));
          return r2;
        }
        deserializeExtension(e2) {
          const t3 = new DataView(e2);
          let i2 = 0;
          const n3 = t3.getUint8(i2);
          i2++;
          const r2 = t3.getUint8(i2);
          i2++;
          const o2 = n3 === zY.TWO_BYTE, s2 = [], a3 = new DataView(e2, 2);
          let c3 = 0;
          for (; c3 < r2; ) {
            let e3 = 0, t4 = 0, i3 = new ArrayBuffer(0);
            o2 ? (e3 = a3.getUint8(c3), c3++, t4 = a3.getUint8(c3), c3++) : (e3 = 15 & a3.getUint8(c3), t4 = a3.getUint8(c3) >> 4, c3++), t4 > 0 && (i3 = a3.buffer.slice(c3 + 2, c3 + 2 + t4), c3 += i3.byteLength), s2.push({ id: e3, length: t4, data: i3 });
          }
          if (c3 !== r2) throw Error("parse error");
          return { profile: n3, length: r2, datas: s2 };
        }
        decompress(e2) {
          return YY(new Uint8Array(e2));
        }
        compress(e2) {
          return KY(new Uint8Array(e2));
        }
      }
      const XY = { name: "DataStream", create: (e2, t3) => {
        const i2 = t3 ? new eM(e2) : new tM(e2);
        return i2.useDataStream(new qY()), i2;
      } };
      class JY extends Hw2 {
        constructor(e2, t3, i2) {
          super(), uI(this, "ws", void 0), uI(this, "requestId", 1), uI(this, "heartBeatTimer", void 0), uI(this, "joinInfo", void 0), uI(this, "clientId", void 0), uI(this, "onOpen", () => {
            this.emit("open"), this.startHeartBeatCheck();
          }), uI(this, "onClose", (e3) => {
            this.emit("close"), this.dispose();
          }), uI(this, "onMessage", (e3) => {
            const t4 = JSON.parse(e3.data);
            if (!t4 || "serverResponse" !== t4.command || !t4.requestId) return t4 && "serverStatus" === t4.command && t4.serverStatus && t4.serverStatus.command ? (this.emit("status", t4.serverStatus), void this.emit(t4.serverStatus.command, t4.serverStatus)) : void 0;
            this.emit("req_".concat(t4.requestId), t4);
          }), this.joinInfo = e2, this.clientId = t3, this.ws = new JV("cross-channel-".concat(this.clientId), i2), this.ws.on(jU.RECONNECTING, () => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          }), this.ws.on(jU.CONNECTED, this.onOpen), this.ws.on(jU.ON_MESSAGE, this.onMessage), this.ws.on(jU.CLOSED, this.onClose);
        }
        isConnect() {
          return "connected" === this.ws.state;
        }
        sendMessage(e2) {
          const t3 = this.requestId++;
          return e2.requestId = t3, e2.seq = t3, this.ws.sendMessage(e2), t3;
        }
        waitStatus(e2) {
          return new ip2((t3, i2) => {
            const n3 = window.setTimeout(() => {
              i2(new ED(ww2.TIMEOUT, "wait status timeout, status: ".concat(e2)));
            }, 5e3);
            this.once(e2, (r2) => {
              window.clearTimeout(n3), r2.state && 0 !== r2.state ? i2(new ED(ww2.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t3(void 0);
            }), this.once("dispose", () => {
              window.clearTimeout(n3), i2(new ED(ww2.WS_ABORT));
            });
          });
        }
        async request(e2) {
          if ("closed" === this.ws.state) throw new ED(ww2.WS_DISCONNECT);
          const t3 = () => new ip2((e3, t4) => {
            this.ws.once(jU.CLOSED, () => t4(new ED(ww2.WS_ABORT))), this.ws.once(jU.CONNECTED, e3);
          });
          "connected" !== this.ws.state && await t3();
          const i2 = this.sendMessage(e2), n3 = new ip2((e3, t4) => {
            const n4 = () => {
              t4(new ED(ww2.WS_ABORT));
            };
            this.ws.once(jU.RECONNECTING, n4), this.ws.once(jU.CLOSED, n4), this.once("req_".concat(i2), e3), yO(3e3).then(() => {
              this.removeAllListeners("req_".concat(i2)), this.ws.off(jU.RECONNECTING, n4), this.ws.off(jU.CLOSED, n4), t4(new ED(ww2.TIMEOUT, "cross channel ws request timeout"));
            });
          }), r2 = await n3;
          if (!r2 || 200 !== r2.code) throw new ED(ww2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
          return r2;
        }
        async connect(e2) {
          this.ws.removeAllListeners(jU.REQUEST_NEW_URLS), this.ws.on(jU.REQUEST_NEW_URLS, (t3) => {
            t3(e2);
          }), await this.ws.init(e2);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e2) {
          const t3 = this.requestId++;
          return e2.requestId = t3, this.ws.sendMessage(e2), t3;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
          }, 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class ZY extends Hw2 {
        set state(e2) {
          e2 !== this._state && (e2 !== tV.RELAY_STATE_FAILURE && (this.errorCode = iV.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
        }
        get state() {
          return this._state;
        }
        constructor(e2, t3, i2, n3, r2) {
          super(), uI(this, "joinInfo", void 0), uI(this, "sid", void 0), uI(this, "clientId", void 0), uI(this, "cancelToken", UA2.CancelToken.source()), uI(this, "workerToken", void 0), uI(this, "requestId", 0), uI(this, "signal", void 0), uI(this, "prevChannelMediaConfig", void 0), uI(this, "httpRetryConfig", void 0), uI(this, "_resolution", void 0), uI(this, "_state", tV.RELAY_STATE_IDLE), uI(this, "errorCode", iV.RELAY_OK), uI(this, "onStatus", (e3) => {
            sD.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", eV.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", eV.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = iV.SRC_TOKEN_EXPIRED, this.state = tV.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = iV.DEST_TOKEN_EXPIRED, this.state = tV.RELAY_STATE_FAILURE));
          }), uI(this, "onReconnect", async () => {
            sD.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", eV.NETWORK_DISCONNECTED), this.state = tV.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
              this.state !== tV.RELAY_STATE_IDLE && (sD.error("auto restart channel media relay failed", e3.toString()), this.errorCode = iV.SERVER_CONNECTION_LOST, this.state = tV.RELAY_STATE_FAILURE);
            });
          }), this.joinInfo = e2, this.clientId = t3, this.sid = bO(), this.signal = new JY(this.joinInfo, this.clientId, i2), this.httpRetryConfig = n3, this._resolution = r2;
        }
        async startChannelMediaRelay(e2) {
          if (this.state !== tV.RELAY_STATE_IDLE) throw new ED(ww2.INVALID_OPERATION);
          this.state = tV.RELAY_STATE_CONNECTING, await this.connect(), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e2);
          } catch (e3) {
            if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command) throw new ED(ww2.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command) throw new ED(ww2.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command) throw new ED(ww2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e3;
          }
          this.prevChannelMediaConfig = e2;
        }
        async updateChannelMediaRelay(e2) {
          if (this.state !== tV.RELAY_STATE_RUNNING) throw new ED(ww2.INVALID_OPERATION);
          await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
        }
        async setVideoProfile(e2) {
          if (this._resolution = e2, this.state !== tV.RELAY_STATE_RUNNING) throw new ED(ww2.INVALID_OPERATION);
          const t3 = this.genMessage($U.SetVideoProfile);
          await this.signal.request(t3), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), sD.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = tV.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          sD.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = UA2.CancelToken.source(), this.state = tV.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e2 = await FF(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", eV.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e2) {
          const t3 = this.genMessage($U.StopPacketTransfer);
          await this.signal.request(t3), await this.signal.waitStatus("Normal Quit"), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
          const i2 = this.genMessage($U.SetSdkProfile, e2);
          await this.signal.request(i2), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const n3 = this.genMessage($U.SetSourceChannel, e2);
          await this.signal.request(n3), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", eV.PACKET_JOINED_SRC_CHANNEL), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const r2 = this.genMessage($U.SetSourceUserId, e2);
          await this.signal.request(r2), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const o2 = this.genMessage($U.SetDestChannel, e2);
          await this.signal.request(o2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", eV.PACKET_JOINED_DEST_CHANNEL), sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const s2 = this.genMessage($U.StartPacketTransfer, e2);
          await this.signal.request(s2), this.emit("event", eV.PACKET_SENT_TO_DEST_CHANNEL), this.state = tV.RELAY_STATE_RUNNING, sD.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
        }
        async sendUpdateMessage(e2) {
          const t3 = this.genMessage($U.UpdateDestChannel, e2);
          await this.signal.request(t3), this.emit("event", eV.PACKET_UPDATE_DEST_CHANNEL), sD.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e2 = this.genMessage($U.StopPacketTransfer);
          await this.signal.request(e2), sD.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e2, t3) {
          const i2 = [], n3 = [], r2 = [];
          this.requestId += 1;
          const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: SN, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          "4.24.0" === o2.sdkVersion && (o2.sdkVersion = "0.0.1");
          let s2 = null, a3 = null;
          switch (e2) {
            case $U.SetSdkProfile:
              return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
            case $U.SetSourceChannel:
              if (a3 = t3 && t3.getSrcChannelMediaInfo(), !a3) throw new ED(ww2.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a3.channelName, token: a3.token || this.joinInfo.appId }, o2;
            case $U.SetSourceUserId:
              if (a3 = t3 && t3.getSrcChannelMediaInfo(), !a3) throw new ED(ww2.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceUserId", uid: a3.uid + "" }, o2;
            case $U.SetDestChannel:
              if (s2 = t3 && t3.getDestChannelMediaInfo(), !s2) throw new ED(ww2.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                i2.push(e3.channelName), n3.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "SetDestChannel", channelName: i2, uid: n3, token: r2 }, o2;
            case $U.StartPacketTransfer:
              return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
            case $U.Reconnect:
              return o2.clientRequest = { command: "Reconnect" }, o2;
            case $U.StopPacketTransfer:
              return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
            case $U.UpdateDestChannel:
              if (s2 = t3 && t3.getDestChannelMediaInfo(), !s2) throw new ED(ww2.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                i2.push(e3.channelName), n3.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "UpdateDestChannel", channelName: i2, uid: n3, token: r2 }, o2;
            case $U.SetVideoProfile:
              o2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
          }
          return o2;
        }
      }
      const QY = { name: "ChannelMediaRelay", create: function(e2) {
        return new ZY(e2.joinInfo, e2.clientId, e2.websocketRetryConfig || BO, e2.httpRetryConfig || BO, e2.resolution);
      } };
      function $Y(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function ez2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? $Y(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : $Y(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      class tz2 extends Hw2 {
        constructor(e2, t3, i2, n3) {
          super(), uI(this, "spec", void 0), uI(this, "token", void 0), uI(this, "websocket", void 0), uI(this, "pingpongTimer", void 0), uI(this, "reconnectMode", "retry"), uI(this, "serviceMode", void 0), uI(this, "reqId", 0), uI(this, "commandReqId", 0), uI(this, "handleWebSocketOpen", () => {
            this.reconnectMode = "retry", this.startPingPong();
          }), uI(this, "handleWebSocketMessage", (e3) => {
            if (!e3.data) return;
            const t4 = JSON.parse(e3.data);
            t4.requestId ? this.emit("@".concat(t4.requestId, "-").concat(t4.sid), t4) : (_D.workerEvent(this.spec.sid, { actionType: "status", serverCode: t4.code, workerType: this.serviceMode === HU.TRANSCODE ? 1 : 2 }), this.emit(XU.PUBLISH_STREAM_STATUS, t4));
          }), this.spec = t3, this.token = e2, this.serviceMode = n3, this.websocket = new JV("live-streaming", i2), this.websocket.on(jU.CONNECTED, this.handleWebSocketOpen), this.websocket.on(jU.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(jU.REQUEST_NEW_URLS, (e3, t4) => {
            oO(this, XU.REQUEST_NEW_ADDRESS).then(e3).catch(t4);
          }), this.websocket.on(jU.RECONNECTING, () => {
            this.websocket.reconnectMode = this.reconnectMode;
          });
        }
        init(e2) {
          return this.websocket.init(e2);
        }
        async request(e2, t3, i2, n3) {
          this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
          const r2 = this.commandReqId, o2 = this.reqId;
          if (!o2 || !this.websocket) throw new ED(ww2.UNEXPECTED_ERROR);
          const s2 = ez2({ command: e2, sdkVersion: "4.24.0" === SN ? "0.0.1" : SN, seq: o2, requestId: o2, allocate: i2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t3);
          if ("closed" === this.websocket.state) throw new ED(ww2.WS_DISCONNECT);
          const a3 = () => new ip2((e3, t4) => {
            this.websocket.once(jU.CLOSED, () => t4(new ED(ww2.WS_ABORT))), this.websocket.once(jU.CONNECTED, e3);
          });
          "connected" !== this.websocket.state && await a3(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
          const c3 = new ip2((e3, t4) => {
            const i3 = () => {
              t4(new ED(ww2.WS_ABORT));
            };
            this.websocket.once(jU.RECONNECTING, i3), this.websocket.once(jU.CLOSED, i3), this.once("@".concat(o2, "-").concat(this.spec.sid), (t5) => {
              e3(t5);
            });
          });
          n3 && _D.workerEvent(this.spec.sid, ez2(ez2({}, n3), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t3.clientRequest), serverCode: 0, code: 0 }));
          const d2 = Date.now();
          this.websocket.sendMessage(s2);
          let l2 = null;
          try {
            l2 = await c3;
          } catch (n4) {
            if ("closed" === this.websocket.state) throw n4;
            return await a3(), await this.request(e2, t3, i2);
          }
          return n3 && _D.workerEvent(this.spec.sid, ez2(ez2({}, n3), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(l2.serverResponse), serverCode: l2.code, success: 200 === l2.code, responseTime: Date.now() - d2 })), 200 !== l2.code && this.handleResponseError(l2), l2;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e2 = "4.24.0" === SN ? "0.0.1" : SN;
          this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e2) {
          switch (e2.code) {
            case ZU.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void sD.warning("live stream response already exists stream");
            case ZU.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case ZU.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case ZU.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new ED(ww2.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
            case ZU.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if ("UnpublishStream" === e2.serverResponse.command) return;
              throw new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case ZU.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new ED(ww2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
            case ZU.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t3 = new ED(ww2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(XU.WARNING, t3, e2.serverResponse.url);
            }
            case ZU.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t3 = new ED(ww2.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(XU.WARNING, t3, e2.serverResponse.url);
            }
            case ZU.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case ZU.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new ED(ww2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
            case ZU.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t3 = new ED(ww2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(XU.WARNING, t3, e2.serverResponse.url);
            }
            case ZU.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
            case ZU.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case ZU.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case ZU.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if ("UnpublishStream" === e2.serverResponse.command) return;
              throw new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case ZU.ERROR_FAIL_SEND_MESSAGE:
              if ("UnpublishStream" === e2.serverResponse.command) return;
              if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command) return new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
              throw new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case ZU.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case ZU.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case ZU.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case ZU.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new ED(ww2.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
            "connected" === this.websocket.state && this.request("ping", {}).catch(AO);
          }, 6e3);
        }
      }
      function iz2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function nz2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? iz2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : iz2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      class rz2 extends Hw2 {
        constructor(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : BO, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : BO;
          super(), uI(this, "onLiveStreamWarning", void 0), uI(this, "onLiveStreamError", void 0), uI(this, "spec", void 0), uI(this, "retryTimeout", 1e4), uI(this, "connection", void 0), uI(this, "httpRetryConfig", void 0), uI(this, "wsRetryConfig", void 0), uI(this, "streamingTasks", /* @__PURE__ */ new Map()), uI(this, "isStartingStreamingTask", false), uI(this, "taskMutex", new xO("live-streaming")), uI(this, "cancelToken", UA2.CancelToken.source()), uI(this, "transcodingConfig", void 0), uI(this, "uapResponse", void 0), uI(this, "lastTaskId", 1), uI(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i2, this.wsRetryConfig = t3;
        }
        async setTranscodingConfig(e2) {
          const t3 = nz2(nz2({}, qU), e2);
          66 !== t3.videoCodecProfile && 77 !== t3.videoCodecProfile && 100 !== t3.videoCodecProfile && (sD.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t3.videoCodecProfile, " -> 100")), t3.videoCodecProfile = 100), t3.transcodingUsers || (t3.transcodingUsers = t3.userConfigs), t3.transcodingUsers && (t3.transcodingUsers = t3.transcodingUsers.map((e3) => nz2(nz2(nz2({}, KU), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
            Uw2(e3.width) || Pw2(e3.width, "config.width", 0, 1e4), Uw2(e3.height) || Pw2(e3.height, "config.height", 0, 1e4), Uw2(e3.videoBitrate) || Pw2(e3.videoBitrate, "config.videoBitrate", 1, 1e6), Uw2(e3.videoFrameRate) || Pw2(e3.videoFrameRate, "config.videoFrameRate"), Uw2(e3.lowLatency) || Nw2(e3.lowLatency, "config.lowLatency"), Uw2(e3.audioSampleRate) || Dw2(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), Uw2(e3.audioBitrate) || Pw2(e3.audioBitrate, "config.audioBitrate", 1, 128), Uw2(e3.audioChannels) || Dw2(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), Uw2(e3.videoGop) || Pw2(e3.videoGop, "config.videoGop"), Uw2(e3.videoCodecProfile) || Dw2(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), Uw2(e3.userCount) || Pw2(e3.userCount, "config.userCount", 0, 17), Uw2(e3.backgroundColor) || Pw2(e3.backgroundColor, "config.backgroundColor", 0, 16777215), Uw2(e3.userConfigExtraInfo) || kw2(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !Uw2(e3.transcodingUsers) && (Mw2(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t4) => {
              WU(e4.uid), Uw2(e4.x) || Pw2(e4.x, "transcodingUser[".concat(t4, "].x"), 0, 1e4), Uw2(e4.y) || Pw2(e4.y, "transcodingUser[".concat(t4, "].y"), 0, 1e4), Uw2(e4.width) || Pw2(e4.width, "transcodingUser[".concat(t4, "].width"), 0, 1e4), Uw2(e4.height) || Pw2(e4.height, "transcodingUser[".concat(t4, "].height"), 0, 1e4), Uw2(e4.zOrder) || Pw2(e4.zOrder - 1, "transcodingUser[".concat(t4, "].zOrder"), 0, 100), Uw2(e4.alpha) || Pw2(e4.alpha, "transcodingUser[".concat(t4, "].alpha"), 0, 1, false);
            })), Uw2(e3.watermark) || zU(e3.watermark, "watermark"), Uw2(e3.backgroundImage) || zU(e3.backgroundImage, "backgroundImage"), e3.images && !Uw2(e3.images) && (Mw2(e3.images, "config.images"), e3.images.forEach((e4, t4) => {
              zU(e4, "images[".concat(t4, "]"));
            }));
          }(t3);
          const i2 = [];
          t3.images && i2.push(...t3.images.map((e3) => nz2(nz2(nz2({}, YU), e3), {}, { zOrder: 255 }))), t3.backgroundImage && (i2.push(nz2(nz2(nz2({}, YU), t3.backgroundImage), {}, { zOrder: 0 })), delete t3.backgroundImage), t3.watermark && (i2.push(nz2(nz2(nz2({}, YU), t3.watermark), {}, { zOrder: 255 })), delete t3.watermark), t3.images = i2, t3.transcodingUsers && (t3.userConfigs = t3.transcodingUsers.map((e3) => nz2({}, e3)), t3.userCount = t3.transcodingUsers.length, delete t3.transcodingUsers);
          const n3 = (t3.userConfigs || []).map((e3) => "number" == typeof e3.uid ? ip2.resolve(e3.uid) : kF(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
          if ((await ip2.all(n3)).forEach((e3, i3) => {
            t3.userConfigs && t3.userConfigs[i3] && (t3.userConfigs[i3].uid = e3);
          }), this.transcodingConfig = t3, this.connection) try {
            var r2;
            const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(up2(r2 = this.streamingTasks).call(r2)).map((e4) => e4.taskId).join("#") });
            sD.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
          } catch (e3) {
            if (!e3.data || !e3.data.retry) throw e3;
            e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t4) => {
              sD.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t4.url), this.startLiveStreamingTask(t4.url, t4.mode, e3).then(() => {
                sD.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t4.url, " success"));
              }).catch((e4) => {
                sD.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t4.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t4.url, e4);
              });
            });
          }
        }
        async startLiveStreamingTask(e2, t3, i2) {
          if (!this.transcodingConfig && t3 === HU.TRANSCODE) throw new ED(ww2.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          const n3 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          sD.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t3));
          const r2 = await this.taskMutex.lock();
          if (!this.connection && i2) return void r2();
          if (this.streamingTasks.get(e2) && !i2) return r2(), new ED(ww2.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t3));
          } catch (e3) {
            throw r2(), e3;
          }
          switch (t3) {
            case HU.TRANSCODE:
              n3.transcodingConfig = nz2({}, this.transcodingConfig);
            case HU.RAW:
          }
          this.uapResponse && this.uapResponse.vid && (n3.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const o2 = this.lastTaskId++;
          try {
            const s2 = new ip2((t4, n4) => {
              yO(this.retryTimeout).then(() => {
                if (i2) return n4(i2);
                const t5 = this.statusError.get(e2);
                return t5 ? (this.statusError.delete(e2), n4(t5)) : void 0;
              });
            }), a3 = await ip2.race([this.connection.request("request", { clientRequest: n3 }, true, { url: e2, command: "PublishStream", workerType: t3 === HU.TRANSCODE ? 1 : 2, requestByUser: !i2, tid: o2.toString() }), s2]);
            this.isStartingStreamingTask = false, sD.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a3.code)), this.streamingTasks.set(e2, { clientRequest: n3, mode: t3, url: e2, taskId: o2 }), r2();
          } catch (n4) {
            if (r2(), this.isStartingStreamingTask = false, !n4.data || !n4.data.retry || i2) throw n4;
            return n4.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t3, n4)) : await this.startLiveStreamingTask(e2, t3, n4);
          }
        }
        stopLiveStreamingTask(e2) {
          return new ip2((t3, i2) => {
            const n3 = this.streamingTasks.get(e2);
            if (!n3 || !this.connection) return new ED(ww2.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const r2 = n3.mode;
            n3.abortTask = () => {
              sD.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t3();
            }, this.connection.request("request", { clientRequest: { command: "UnpublishStream", url: n3.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === HU.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i3) => {
              sD.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i3.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && (this.connection && this.connection.close(), this.connection = void 0), t3();
            }).catch(i2);
          });
        }
        resetAllTask() {
          var e2;
          const t3 = Array.from(up2(e2 = this.streamingTasks).call(e2));
          this.terminate();
          for (const e3 of t3) this.startLiveStreamingTask(e3.url, e3.mode).catch((t4) => {
            this.onLiveStreamError && this.onLiveStreamError(e3.url, t4);
          });
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = UA2.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e2) {
          if (this.connection) throw new ED(ww2.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t3 = await oO(this, JU.REQUEST_WORKER_MANAGER_LIST, e2);
          return this.uapResponse = t3, this.connection = new tz2(t3.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(XU.WARNING, (e3, t4) => this.onLiveStreamWarning && this.onLiveStreamWarning(t4, e3)), this.connection.on(XU.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(XU.REQUEST_NEW_ADDRESS, (t4, i2) => {
            if (!this.connection) return i2(new ED(ww2.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            oO(this, JU.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
              this.uapResponse = e3, t4(e3.addressList);
            }).catch(i2);
          }), await this.connection.init(t3.addressList), this.connection;
        }
        handlePublishStreamServer(e2) {
          const t3 = e2.serverStatus && e2.serverStatus.url || "empty_url", i2 = this.streamingTasks.get(t3), n3 = e2.reason;
          switch (e2.code) {
            case ZU.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case ZU.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case ZU.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case ZU.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const n4 = new ED(ww2.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
              if (i2) return sD.error(n4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3, n4);
              if (!this.isStartingStreamingTask) return;
              this.statusError.set(t3, n4);
            }
            case ZU.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e3 = new ED(ww2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n3);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3);
            }
            case ZU.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case ZU.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var r2;
              if (!this.connection) return;
              this.connection.tryNextAddress();
              const t4 = Array.from(up2(r2 = this.streamingTasks).call(r2));
              for (const i3 of t4) i3.abortTask ? i3.abortTask() : (sD.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i3.url), this.startLiveStreamingTask(i3.url, i3.mode, new ED(ww2.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                sD.debug("[".concat(this.spec.clientId, "] republish live stream success"), i3.url);
              }).catch((e3) => {
                sD.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i3.url, e3);
              }));
              return;
            }
          }
        }
        hasUrl(e2) {
          return this.streamingTasks.has(e2);
        }
      }
      const oz2 = { name: "LiveStreaming", create: function(e2) {
        return new rz2(e2.joinInfo, e2.websocketRetryConfig || BO, e2.httpRetryConfig || BO);
      } };
      function sz2(e2) {
        let t3 = fz2();
        return function(e3, t4) {
          let i2 = e3.appId;
          void 0 !== i2 && (Dz2(t4, 10), yz2(t4, i2));
          let n3 = e3.cid;
          void 0 !== n3 && (Dz2(t4, 16), Dz2(t4, n3));
          let r2 = e3.cname;
          void 0 !== r2 && (Dz2(t4, 26), yz2(t4, r2));
          let o2 = e3.deviceId;
          void 0 !== o2 && (Dz2(t4, 34), yz2(t4, o2));
          let s2 = e3.elapse;
          void 0 !== s2 && (Dz2(t4, 40), Pz2(t4, s2));
          let a3 = e3.fileSize;
          void 0 !== a3 && (Dz2(t4, 48), Pz2(t4, Ez2(a3)));
          let c3 = e3.height;
          void 0 !== c3 && (Dz2(t4, 56), Pz2(t4, Ez2(c3)));
          let d2 = e3.jpg;
          void 0 !== d2 && (Dz2(t4, 66), Dz2(t4, d2.length), function(e4, t5) {
            let i3 = Rz2(e4, t5.length);
            e4.bytes.set(t5, i3);
          }(t4, d2));
          let l2 = e3.networkType;
          void 0 !== l2 && (Dz2(t4, 72), Pz2(t4, Ez2(l2)));
          let u3 = e3.osType;
          void 0 !== u3 && (Dz2(t4, 80), Pz2(t4, Ez2(u3)));
          let h2 = e3.requestId;
          void 0 !== h2 && (Dz2(t4, 90), yz2(t4, h2));
          let p2 = e3.sdkVersion;
          void 0 !== p2 && (Dz2(t4, 98), yz2(t4, p2));
          let _2 = e3.sequence;
          void 0 !== _2 && (Dz2(t4, 104), Pz2(t4, Ez2(_2)));
          let E3 = e3.sid;
          void 0 !== E3 && (Dz2(t4, 114), yz2(t4, E3));
          let m3 = e3.timestamp;
          void 0 !== m3 && (Dz2(t4, 120), Pz2(t4, m3));
          let f2 = e3.uid;
          void 0 !== f2 && (Dz2(t4, 128), Dz2(t4, f2));
          let S3 = e3.vid;
          void 0 !== S3 && (Dz2(t4, 136), Dz2(t4, S3));
          let g2 = e3.width;
          void 0 !== g2 && (Dz2(t4, 144), Pz2(t4, Ez2(g2)));
          let T3 = e3.service;
          void 0 !== T3 && (Dz2(t4, 152), Dz2(t4, T3));
          let R3 = e3.callbackData;
          void 0 !== R3 && (Dz2(t4, 162), yz2(t4, R3));
          let v3 = e3.jpgEncryption;
          void 0 !== v3 && (Dz2(t4, 168), Dz2(t4, v3));
          let C2 = e3.requestType;
          void 0 !== C2 && (Dz2(t4, 176), Dz2(t4, C2));
          let y3 = e3.scorePorn;
          void 0 !== y3 && (Dz2(t4, 185), Oz2(t4, y3));
          let I3 = e3.scoreSexy;
          void 0 !== I3 && (Dz2(t4, 193), Oz2(t4, I3));
          let b2 = e3.scoreNeutral;
          void 0 !== b2 && (Dz2(t4, 201), Oz2(t4, b2));
          let A2 = e3.scene;
          void 0 !== A2 && (Dz2(t4, 208), Dz2(t4, A2));
          let w3 = e3.ossFilePrefix;
          void 0 !== w3 && (Dz2(t4, 218), yz2(t4, w3));
          let O3 = e3.serviceVendor;
          if (void 0 !== O3) for (let e4 of O3) {
            Dz2(t4, 226);
            let i3 = fz2();
            dz2(e4, i3), Dz2(t4, i3.limit), Iz2(t4, i3), Sz2(i3);
          }
        }(e2, t3), function(e3) {
          let t4 = e3.bytes, i2 = e3.limit;
          return t4.length === i2 ? t4 : t4.subarray(0, i2);
        }(t3);
      }
      function az2(e2) {
        return function(e3) {
          let t4 = {};
          e: for (; !Tz2(e3); ) {
            let i2 = Nz2(e3);
            switch (i2 >>> 3) {
              case 0:
                break e;
              case 1:
                t4.code = Nz2(e3);
                break;
              case 2:
                t4.msg = Cz2(e3, Nz2(e3));
                break;
              case 3: {
                let i3 = lz2(e3);
                t4.data = cz2(e3), e3.limit = i3;
                break;
              }
              default:
                uz2(e3, 7 & i2);
            }
          }
          return t4;
        }({ bytes: t3 = e2, offset: 0, limit: t3.length });
        var t3;
      }
      function cz2(e2) {
        let t3 = {};
        e: for (; !Tz2(e2); ) {
          let i2 = Nz2(e2);
          switch (i2 >>> 3) {
            case 0:
              break e;
            case 1:
              t3.requestId = Cz2(e2, Nz2(e2));
              break;
            case 2:
              t3.requestType = Nz2(e2) >>> 0;
              break;
            case 3:
              t3.scorePorn = wz2(e2);
              break;
            case 4:
              t3.scoreSexy = wz2(e2);
              break;
            case 5:
              t3.scoreNeutral = wz2(e2);
              break;
            case 6:
              t3.requestScene = Nz2(e2) >>> 0;
              break;
            case 7:
              t3.scene = Nz2(e2) >>> 0;
              break;
            default:
              uz2(e2, 7 & i2);
          }
        }
        return t3;
      }
      function dz2(e2, t3) {
        let i2 = e2.service;
        void 0 !== i2 && (Dz2(t3, 8), Dz2(t3, i2));
        let n3 = e2.vendor;
        void 0 !== n3 && (Dz2(t3, 16), Dz2(t3, n3));
        let r2 = e2.token;
        void 0 !== r2 && (Dz2(t3, 26), yz2(t3, r2));
        let o2 = e2.callbackUrl;
        void 0 !== o2 && (Dz2(t3, 34), yz2(t3, o2));
      }
      function lz2(e2) {
        let t3 = Nz2(e2), i2 = e2.limit;
        return e2.limit = e2.offset + t3, i2;
      }
      function uz2(e2, t3) {
        switch (t3) {
          case 0:
            for (; 128 & bz2(e2); ) ;
            break;
          case 2:
            gz2(e2, Nz2(e2));
            break;
          case 5:
            gz2(e2, 4);
            break;
          case 1:
            gz2(e2, 8);
            break;
          default:
            throw new Error("Unimplemented type: " + t3);
        }
      }
      let hz2 = new Float32Array(1);
      new Uint8Array(hz2.buffer);
      let pz2 = new Float64Array(1), _z = new Uint8Array(pz2.buffer);
      function Ez2(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      let mz2 = [];
      function fz2() {
        const e2 = mz2.pop();
        return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }
      function Sz2(e2) {
        mz2.push(e2);
      }
      function gz2(e2, t3) {
        if (e2.offset + t3 > e2.limit) throw new Error("Skip past limit");
        e2.offset += t3;
      }
      function Tz2(e2) {
        return e2.offset >= e2.limit;
      }
      function Rz2(e2, t3) {
        let i2 = e2.bytes, n3 = e2.offset, r2 = e2.limit, o2 = n3 + t3;
        if (o2 > i2.length) {
          let t4 = new Uint8Array(2 * o2);
          t4.set(i2), e2.bytes = t4;
        }
        return e2.offset = o2, o2 > r2 && (e2.limit = o2), n3;
      }
      function vz2(e2, t3) {
        let i2 = e2.offset;
        if (i2 + t3 > e2.limit) throw new Error("Read past limit");
        return e2.offset += t3, i2;
      }
      function Cz2(e2, t3) {
        let i2 = vz2(e2, t3), n3 = String.fromCharCode, r2 = e2.bytes, o2 = "ï¿½", s2 = "";
        for (let e3 = 0; e3 < t3; e3++) {
          let a3, c3, d2, l2, u3 = r2[e3 + i2];
          0 == (128 & u3) ? s2 += n3(u3) : 192 == (224 & u3) ? e3 + 1 >= t3 ? s2 += o2 : (a3 = r2[e3 + i2 + 1], 128 != (192 & a3) ? s2 += o2 : (l2 = (31 & u3) << 6 | 63 & a3, l2 < 128 ? s2 += o2 : (s2 += n3(l2), e3++))) : 224 == (240 & u3) ? e3 + 2 >= t3 ? s2 += o2 : (a3 = r2[e3 + i2 + 1], c3 = r2[e3 + i2 + 2], 32896 != (49344 & (a3 | c3 << 8)) ? s2 += o2 : (l2 = (15 & u3) << 12 | (63 & a3) << 6 | 63 & c3, l2 < 2048 || l2 >= 55296 && l2 <= 57343 ? s2 += o2 : (s2 += n3(l2), e3 += 2))) : 240 == (248 & u3) ? e3 + 3 >= t3 ? s2 += o2 : (a3 = r2[e3 + i2 + 1], c3 = r2[e3 + i2 + 2], d2 = r2[e3 + i2 + 3], 8421504 != (12632256 & (a3 | c3 << 8 | d2 << 16)) ? s2 += o2 : (l2 = (7 & u3) << 18 | (63 & a3) << 12 | (63 & c3) << 6 | 63 & d2, l2 < 65536 || l2 > 1114111 ? s2 += o2 : (l2 -= 65536, s2 += n3(55296 + (l2 >> 10), 56320 + (1023 & l2)), e3 += 3))) : s2 += o2;
        }
        return s2;
      }
      function yz2(e2, t3) {
        let i2 = t3.length, n3 = 0;
        for (let e3 = 0; e3 < i2; e3++) {
          let r3 = t3.charCodeAt(e3);
          r3 >= 55296 && r3 <= 56319 && e3 + 1 < i2 && (r3 = (r3 << 10) + t3.charCodeAt(++e3) - 56613888), n3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
        }
        Dz2(e2, n3);
        let r2 = Rz2(e2, n3), o2 = e2.bytes;
        for (let e3 = 0; e3 < i2; e3++) {
          let n4 = t3.charCodeAt(e3);
          n4 >= 55296 && n4 <= 56319 && e3 + 1 < i2 && (n4 = (n4 << 10) + t3.charCodeAt(++e3) - 56613888), n4 < 128 ? o2[r2++] = n4 : (n4 < 2048 ? o2[r2++] = n4 >> 6 & 31 | 192 : (n4 < 65536 ? o2[r2++] = n4 >> 12 & 15 | 224 : (o2[r2++] = n4 >> 18 & 7 | 240, o2[r2++] = n4 >> 12 & 63 | 128), o2[r2++] = n4 >> 6 & 63 | 128), o2[r2++] = 63 & n4 | 128);
        }
      }
      function Iz2(e2, t3) {
        let i2 = Rz2(e2, t3.limit), n3 = e2.bytes, r2 = t3.bytes;
        for (let e3 = 0, o2 = t3.limit; e3 < o2; e3++) n3[e3 + i2] = r2[e3];
      }
      function bz2(e2) {
        return e2.bytes[vz2(e2, 1)];
      }
      function Az2(e2, t3) {
        let i2 = Rz2(e2, 1);
        e2.bytes[i2] = t3;
      }
      function wz2(e2) {
        let t3 = vz2(e2, 8), i2 = e2.bytes;
        return _z[0] = i2[t3++], _z[1] = i2[t3++], _z[2] = i2[t3++], _z[3] = i2[t3++], _z[4] = i2[t3++], _z[5] = i2[t3++], _z[6] = i2[t3++], _z[7] = i2[t3++], pz2[0];
      }
      function Oz2(e2, t3) {
        let i2 = Rz2(e2, 8), n3 = e2.bytes;
        pz2[0] = t3, n3[i2++] = _z[0], n3[i2++] = _z[1], n3[i2++] = _z[2], n3[i2++] = _z[3], n3[i2++] = _z[4], n3[i2++] = _z[5], n3[i2++] = _z[6], n3[i2++] = _z[7];
      }
      function Nz2(e2) {
        let t3, i2 = 0, n3 = 0;
        do {
          t3 = bz2(e2), i2 < 32 && (n3 |= (127 & t3) << i2), i2 += 7;
        } while (128 & t3);
        return n3;
      }
      function Dz2(e2, t3) {
        for (t3 >>>= 0; t3 >= 128; ) Az2(e2, 127 & t3 | 128), t3 >>>= 7;
        Az2(e2, t3);
      }
      function Pz2(e2, t3) {
        let i2 = t3.low >>> 0, n3 = (t3.low >>> 28 | t3.high << 4) >>> 0, r2 = t3.high >>> 24, o2 = 0 === r2 ? 0 === n3 ? i2 < 16384 ? i2 < 128 ? 1 : 2 : i2 < 1 << 21 ? 3 : 4 : n3 < 16384 ? n3 < 128 ? 5 : 6 : n3 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = Rz2(e2, o2), a3 = e2.bytes;
        switch (o2) {
          case 10:
            a3[s2 + 9] = r2 >>> 7 & 1;
          case 9:
            a3[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
          case 8:
            a3[s2 + 7] = 8 !== o2 ? n3 >>> 21 | 128 : n3 >>> 21 & 127;
          case 7:
            a3[s2 + 6] = 7 !== o2 ? n3 >>> 14 | 128 : n3 >>> 14 & 127;
          case 6:
            a3[s2 + 5] = 6 !== o2 ? n3 >>> 7 | 128 : n3 >>> 7 & 127;
          case 5:
            a3[s2 + 4] = 5 !== o2 ? 128 | n3 : 127 & n3;
          case 4:
            a3[s2 + 3] = 4 !== o2 ? i2 >>> 21 | 128 : i2 >>> 21 & 127;
          case 3:
            a3[s2 + 2] = 3 !== o2 ? i2 >>> 14 | 128 : i2 >>> 14 & 127;
          case 2:
            a3[s2 + 1] = 2 !== o2 ? i2 >>> 7 | 128 : i2 >>> 7 & 127;
          case 1:
            a3[s2] = 1 !== o2 ? 128 | i2 : 127 & i2;
        }
      }
      function Lz2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      const kz2 = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
      class Mz2 extends Hw2 {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          if (this._connectionState === e2) return;
          const t3 = this._connectionState;
          this._connectionState = e2, this.emit(yV.CONNECTION_STATE_CHANGE, t3, e2);
        }
        get inspectType() {
          return this._inspectType;
        }
        set inspectType(e2) {
          var t3;
          this._inspectMode = nr2(t3 = e2.map((e3) => kz2.get(e3) || 0)).call(t3, (e3, t4) => e3 + t4), this._inspectType = e2;
        }
        get quality() {
          return this._quality;
        }
        set quality(e2) {
          this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
            this.quality = this._quality / this.qualityRatio;
          }, 6e4));
        }
        constructor(e2) {
          super(), uI(this, "name", "AgoraRTCVideoContentInspect"), uI(this, "_connectionState", vV.CONNECTING), uI(this, "_innerConnectionState", void 0), uI(this, "sequence", 0), uI(this, "inspectStartTime", void 0), uI(this, "workerManagerConnection", void 0), uI(this, "workerConnection", void 0), uI(this, "workerMessageLengthLimit", void 0), uI(this, "inspectIntervalMinimum", void 0), uI(this, "qualityRatio", void 0), uI(this, "_connectInfo", void 0), uI(this, "_cancelTokenSource", UA2.CancelToken.source()), uI(this, "_retryConfig", void 0), uI(this, "wmSequence", 0), uI(this, "inspectInterval", void 0), uI(this, "inspectTimer", null), uI(this, "ossFilePrefix", void 0), uI(this, "extraInfo", void 0), uI(this, "_inspectType", void 0), uI(this, "_inspectMode", void 0), uI(this, "_quality", 1), uI(this, "qualityTimer", null), uI(this, "_inspectId", void 0), uI(this, "_needWorkUrlOnly", false), uI(this, "inspectImage", () => {
            if (this.connectionState !== vV.CONNECTED) throw new ED(ww2.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
            this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
              this.connectionState === vV.CONNECTED ? this.requestToInspectImage() : sD.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
            }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
          }), this._inspectId = IO(5, "inspect-"), this.workerMessageLengthLimit = wN("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = wN("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = wN("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new JV("worker-manager-" + this._inspectId, BO), this.on(yV.STATE_CHANGE, (e3, t3) => {
            this._innerConnectionState = e3, sD.debug("[".concat(this._inspectId, "] Inspect operation :").concat(CV[e3], " ").concat(t3 || ""));
          }), this.handleWorkerManagerEvents(), this.workerConnection = new JV("worker-" + this._inspectId, BO), this.handleWorkerEvents();
        }
        async init(e2, t3) {
          this.emit(yV.STATE_CHANGE, CV.CONNECT_AP), this._connectInfo = e2;
          const i2 = this._cancelTokenSource.token;
          return this._retryConfig = t3, new ip2((n3, r2) => {
            this.on(yV.CONNECTION_STATE_CHANGE, (e3, t4) => {
              t4 === vV.CONNECTED && n3();
            }), this.requestAP(e2, i2, t3).then((e3) => {
              this.connectWorkerManager(e3);
            }).catch((e3) => {
              r2(e3);
            });
          });
        }
        async requestAP(e2, t3, i2) {
          const n3 = wN("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t4, i3, n4) {
            let { appId: r3, areaCode: o3, cname: s2, sid: a3, token: c3, uid: d2 } = t4;
            AF++;
            const l2 = "image_moderation_api", u3 = { service_name: l2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s2, command: "allocateEdge", requestId: AF, seq: AF, sid: a3, token: c3, ts: Date.now(), uid: d2 + "" }) };
            let h2, p2, _2 = e3[0];
            return GO(async () => {
              h2 = Date.now();
              const e4 = await oF(_2, { data: u3, cancelToken: i3, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
              if (p2 = Date.now() - h2, 0 !== e4.code) {
                const t6 = new ED(ww2.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p2 });
                throw sD.error(t6.toString()), t6;
              }
              const t5 = JSON.parse(e4.json_body);
              if (200 !== t5.code) {
                const e5 = new ED(ww2.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t5.code, ", reason: ").concat(t5.reason), { code: t5.code, responseTime: p2 });
                throw sD.error(e5.toString()), e5;
              }
              if (!t5.servers || !Array.isArray(t5.servers) || 0 === t5.servers.length) {
                const e5 = new ED(ww2.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t5.code, responseTime: p2 });
                throw sD.error(e5.toString()), e5;
              }
              const n5 = wN("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = wN("VIDEO_INSPECT_WORKER_MANAGER_PORT");
              return { addressList: t5.servers.map((e5) => {
                let { address: t6, wss: i4 } = e5;
                if (t6 && i4) return "wss://".concat(t6.replace(/\./g, "-"), ".").concat(n5, ":").concat(r4 || i4);
              }).filter((e5) => !!e5), workerToken: t5.workerToken, vid: t5.vid, responseTime: p2 };
            }, (t5, i4) => (_D.apworkerEvent(a3, { success: true, sc: 200, serviceName: l2, responseDetail: JSON.stringify(t5.addressList), firstSuccess: 0 === i4, responseTime: p2, serverIp: e3[i4 % e3.length] }), false), (t5, i4) => (_D.apworkerEvent(a3, { success: false, sc: t5.data && t5.data.code || 200, serviceName: l2, responseTime: p2, serverIp: e3[i4 % e3.length] }), !!(t5.code !== ww2.OPERATION_ABORTED && t5.code !== ww2.UNEXPECTED_RESPONSE || t5.data && t5.data.retry) && (_2 = e3[(i4 + 1) % e3.length], true)), n4);
          }(n3, e2, t3, i2);
          this.emit(yV.STATE_CHANGE, CV.AP_CONNECTED);
          const { addressList: o2 } = r2;
          return this.wmSequence++, o2;
        }
        async connectWorkerManager(e2) {
          let t3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._needWorkUrlOnly = t3, this.emit(yV.STATE_CHANGE, CV.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
        }
        async connectWorker(e2) {
          await this.workerConnection.init([e2]);
        }
        handleWorkerManagerEvents() {
          this.workerManagerConnection.on(jU.CONNECTED, async () => {
            this.emit(yV.STATE_CHANGE, CV.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.24.0", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
          }), this.workerManagerConnection.on(jU.CLOSED, () => {
            this._innerConnectionState < CV.GET_WORKER_MANAGER_RESPONSE && sD.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
          }), this.workerManagerConnection.on(jU.FAILED, () => {
            this._innerConnectionState < CV.GET_WORKER_MANAGER_RESPONSE && sD.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
          }), this.workerManagerConnection.on(jU.RECONNECTING, () => {
            this._innerConnectionState < CV.GET_WORKER_MANAGER_RESPONSE && sD.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
          }), this.workerManagerConnection.on(jU.ON_MESSAGE, async (e2) => {
            this.emit(yV.STATE_CHANGE, CV.GET_WORKER_MANAGER_RESPONSE);
            const t3 = this.workerManagerConnection.url;
            this.workerManagerConnection.close();
            const i2 = JSON.parse(e2.data);
            if (200 !== i2.code) throw sD.error("[".concat(this._inspectId, "] Unexpected code ").concat(i2.code, " from worker manager")), new ED(ww2.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i2);
            if (!(i2.serverResponse && i2.serverResponse.portWss && t3)) throw sD.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i2))), new ED(ww2.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i2);
            {
              const e3 = wN("VIDEO_INSPECT_WORKER_PORT") || i2.serverResponse.portWss, n3 = t3.replace(/:\d+\/?$/, ":".concat(e3));
              this.emit(yV.STATE_CHANGE, CV.CONNECT_WORKER, n3), this._needWorkUrlOnly ? this.emit(yV.REQUEST_NEW_WORKER_URL, n3) : await this.connectWorker(n3);
            }
          }), this.workerManagerConnection.on(jU.WILL_RECONNECT, (e2, t3, i2) => {
            i2(e2);
          }), this.workerManagerConnection.on(jU.REQUEST_NEW_URLS, (e2, t3) => {
            this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t3);
          });
        }
        handleWorkerEvents() {
          this.workerConnection.on(jU.CONNECTED, async () => {
            this.emit(yV.STATE_CHANGE, CV.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = vV.CONNECTED;
          }), this.workerConnection.on(jU.ON_MESSAGE, async (e2) => {
            if (e2.data instanceof ArrayBuffer) {
              const i2 = az2(new Uint8Array(e2.data));
              if (wN("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && sD.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i2)), 200 === i2.code) {
                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0]) return void this.emit(yV.INSPECT_RESULT, void 0, void 0);
                if (i2.data && i2.data.scorePorn && i2.data.scoreSexy && i2.data.scoreNeutral) {
                  var t3;
                  const e3 = { porn: i2.data.scorePorn, sexy: i2.data.scoreSexy, neutral: i2.data.scoreNeutral }, n3 = nr2(t3 = Object.keys(e3)).call(t3, (t4, i3) => e3[t4] > e3[i3] ? t4 : i3, "porn"), r2 = Object.keys(e3).find((e4) => e4 === n3);
                  this.emit(yV.INSPECT_RESULT, r2);
                } else this.emit(yV.INSPECT_RESULT, void 0, new ED(ww2.UNEXPECTED_RESPONSE, i2.code + "", "There is an unexpected data on message"));
              } else this.emit(yV.INSPECT_RESULT, void 0, new ED(ww2.UNEXPECTED_RESPONSE, i2.code + "", i2.msg));
            } else sD.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(yV.INSPECT_RESULT, void 0, new ED(ww2.UNEXPECTED_RESPONSE, "invalid worker message type"));
          }), this.workerConnection.on(jU.CLOSED, () => {
            this.connectionState = vV.CLOSED;
          }), this.workerConnection.on(jU.FAILED, () => {
            this.connectionState = vV.CLOSED;
          }), this.workerConnection.on(jU.RECONNECTING, () => {
            this.connectionState = this.connectionState === vV.CONNECTED ? vV.RECONNECTING : vV.CONNECTING;
          }), this.workerConnection.on(jU.WILL_RECONNECT, (e2, t3, i2) => {
            "recover" === e2 && i2(e2), i2("tryNext");
          }), this.workerConnection.on(jU.REQUEST_NEW_URLS, (e2, t3) => {
            this.workerManagerConnection.close(), this.once(yV.REQUEST_NEW_WORKER_URL, (t4) => {
              e2([t4]);
            }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e3) => {
              this.connectWorkerManager(e3, true);
            }).catch((e3) => {
              t3(e3);
            });
          });
        }
        async requestToInspectImage() {
          this.sequence++;
          const e2 = aO(this, yV.CLIENT_LOCAL_VIDEO_TRACK), t3 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
          if (e2) {
            if (!e2.isPlaying) return void this.emit(yV.INSPECT_RESULT, void 0, new ED(ww2.INVALID_OPERATION, "Only the track being played can be inspected"));
            const i2 = await this.generateRequestData(e2, t3);
            this.workerConnection.sendMessage(i2, true, true);
          } else this.emit(yV.INSPECT_RESULT, void 0, new ED(ww2.INVALID_OPERATION, "Only the track being published can be inspected"));
        }
        async generateRequestData(e2, t3) {
          let { appId: i2, cname: n3, cid: r2, vid: o2, sid: s2, uid: a3 } = t3;
          const c3 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), l2 = await ZP(d2, i2, n3), u3 = this.sequence + "-" + r2 + "-" + a3 + "-" + c3 + "-" + IO(12, ""), h2 = { appId: i2, cid: r2, cname: n3, deviceId: "", elapse: (p2 = Number(c3 - this.inspectStartTime), { low: p2 |= 0, high: p2 >> 31, unsigned: p2 >= 0 }), fileSize: l2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: l2, networkType: 6, osType: 7, requestId: u3, sdkVersion: "4.24.0", sequence: this.sequence, sid: s2, timestamp: uG(c3), uid: a3, vid: o2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
          var p2;
          void 0 === this.extraInfo && delete h2.callbackData, void 0 === this.ossFilePrefix && delete h2.ossFilePrefix;
          const _2 = sz2(h2);
          if (_2.byteLength < this.workerMessageLengthLimit) {
            if (wN("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
              const e3 = function(e4) {
                for (var t4 = 1; t4 < arguments.length; t4++) {
                  var i3 = null != arguments[t4] ? arguments[t4] : {};
                  t4 % 2 ? Lz2(Object(i3), true).forEach(function(t5) {
                    uI(e4, t5, i3[t5]);
                  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i3)) : Lz2(Object(i3)).forEach(function(t5) {
                    Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(i3, t5));
                  });
                }
                return e4;
              }({}, h2);
              delete e3.jpg, sD.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
            }
            return _2;
          }
          {
            const t4 = this.quality * this.qualityRatio;
            return this.quality = t4, await this.generateRequestData(e2, { appId: i2, cname: n3, cid: r2, vid: o2, sid: s2, uid: a3 });
          }
        }
        close() {
          this._cancelTokenSource.cancel(), this._cancelTokenSource = UA2.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = vV.CLOSED, this.emit(yV.STATE_CHANGE, CV.CLOSED);
        }
      }
      const Uz2 = { name: "ContentInspect", create: function(e2) {
        let { config: t3 } = e2;
        return function(e3) {
          if (!e3) throw new ED(ww2.INVALID_PARAMS, "inspectConfig is necessary.");
          if (!e3.inspectType || !Array.isArray(e3.inspectType)) throw new ED(ww2.INVALID_PARAMS, "inspectConfig.inspectType is necessary and is an instance of Array.");
          {
            const t4 = [...new Set(e3.inspectType)];
            t4.forEach((e4) => {
              var t5;
              if (!Ln2(t5 = ["supervise", "moderation"]).call(t5, e4)) throw new ED(ww2.INVALID_PARAMS, "".concat(e4, " is not a valid inspect type."));
            }), e3.inspectType = t4;
          }
          if (e3 && e3.extraInfo && e3.extraInfo.length > 1024) throw new ED(ww2.INVALID_PARAMS, "inspectConfig.extraInfo length cannot exceed 1024 bytes");
        }(t3), new Mz2(t3);
      } };
      var Vz2 = i($.Object.getOwnPropertySymbols), xz2 = Oi2, Fz2 = qi2.indexOf, Bz2 = Wn2, jz2 = y2([].indexOf), Gz2 = !!jz2 && 1 / jz2([1], 1, -0) < 0;
      xz2({ target: "Array", proto: true, forced: Gz2 || !Bz2("indexOf") }, { indexOf: function(e2) {
        var t3 = arguments.length > 1 ? arguments[1] : void 0;
        return Gz2 ? jz2(this, e2, t3) || 0 : Fz2(this, e2, t3);
      } });
      var Wz2 = Qi2("Array", "indexOf"), Hz2 = l, Kz2 = Wz2, Yz2 = Array.prototype, zz2 = function(e2) {
        var t3 = e2.indexOf;
        return e2 === Yz2 || Hz2(Yz2, e2) && t3 === Yz2.indexOf ? Kz2 : t3;
      }, qz2 = i(zz2);
      function Xz2(e2, t3) {
        if (null == e2) return {};
        var i2, n3, r2 = function(e3, t4) {
          if (null == e3) return {};
          var i3 = {};
          for (var n4 in e3) if ({}.hasOwnProperty.call(e3, n4)) {
            if (-1 !== qz2(t4).call(t4, n4)) continue;
            i3[n4] = e3[n4];
          }
          return i3;
        }(e2, t3);
        if (Vz2) {
          var o2 = Vz2(e2);
          for (n3 = 0; n3 < o2.length; n3++) i2 = o2[n3], -1 === qz2(t3).call(t3, i2) && {}.propertyIsEnumerable.call(e2, i2) && (r2[i2] = e2[i2]);
        }
        return r2;
      }
      let Jz2 = class {
        get localCapabilities() {
          return pO(this._localCapabilities);
        }
        get rtpCapabilities() {
          return pO(this._rtpCapabilities);
        }
        get candidates() {
          return pO(this._candidates);
        }
        get iceParameters() {
          return pO(this._iceParameters);
        }
        get dtlsParameters() {
          return pO(this._dtlsParameters);
        }
        constructor(e2) {
          uI(this, "sessionDesc", void 0), uI(this, "_localCapabilities", void 0), uI(this, "_rtpCapabilities", void 0), uI(this, "_candidates", void 0), uI(this, "_iceParameters", void 0), uI(this, "_dtlsParameters", void 0), uI(this, "setup", void 0), uI(this, "currentMidIndex", void 0), uI(this, "cname", "o/i14u9pJrxRKAsu"), uI(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = pO(e2);
          const { remoteIceParameters: t3, remoteDtlsParameters: i2, candidates: n3, remoteRTPCapabilities: r2, localCapabilities: o2, direction: s2, setup: a3, videoCodec: c3, audioCodec: d2 } = e2;
          let l2;
          this.setup = a3, l2 = s2 === BU.RECEIVE_ONLY ? FN("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n") : FN("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=extmap-allow-mixed\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=recvonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n"), this._rtpCapabilities = r2, this._candidates = n3, this._iceParameters = t3, this._dtlsParameters = i2, this._localCapabilities = o2;
          const u3 = s2 === BU.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv, h2 = s2 === BU.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send, p2 = s2 === BU.RECEIVE_ONLY ? r2.send.videoCodecs : xx2(EV.VIDEO, u3, h2, c3), _2 = s2 === BU.RECEIVE_ONLY ? r2.send.audioCodecs : xx2(EV.AUDIO, u3, h2, d2);
          for (const e3 of l2.mediaDescriptions) e3.attributes.iceUfrag = t3.iceUfrag, e3.attributes.icePwd = t3.icePwd, e3.attributes.fingerprints = i2.fingerprints, e3.attributes.candidates = n3, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = p2.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = p2, e3.attributes.extmaps = u3.videoExtensions), "audio" === e3.media.mediaType && (e3.media.fmts = _2.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = _2, e3.attributes.extmaps = u3.audioExtensions, Vx2(e3));
          this.sessionDesc = l2, this.currentMidIndex = l2.mediaDescriptions.length - 1;
        }
        toString() {
          return BN(this.sessionDesc);
        }
        hasMid(e2) {
          return Array.isArray(e2) ? e2.every((e3) => this.hasMid(e3)) : this.sessionDesc.mediaDescriptions.some((t3) => t3.attributes.mid === e2);
        }
        send(e2, t3, i2, n3, r2) {
          i2 = i2.replace(/ /g, "-");
          const { ssrcs: o2, ssrcGroups: s2 } = bx2(t3, this.cname, wN("SYNC_GROUP") ? i2 : void 0), a3 = this.findPreloadMediaDesc(o2);
          if (a3) {
            if (iw2() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, a3.attributes.mid), r2 && (r2.twcc || r2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(a3);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(a3, r2), { mid: a3.attributes.mid, needExchangeSDP: true };
            }
            return { mid: a3.attributes.mid, needExchangeSDP: false };
          }
          {
            const t4 = this.findAvailableMediaIndex(e2, o2, n3);
            let i3;
            return -1 === t4 ? (i3 = this.createOrRecycleSendMedia(e2, o2, s2, "sendonly", n3, r2), this.updateBundleMids()) : (i3 = pO(this.sessionDesc.mediaDescriptions[t4]), i3.attributes.direction = "sendonly", i3.attributes.ssrcs = o2, i3.attributes.ssrcGroups = s2, this.sessionDesc.mediaDescriptions[t4] = this.mungSendMediaDesc(i3, r2)), iw2() && this.firefoxSsrcMidMap.set(o2[0].ssrcId, i3.attributes.mid), { needExchangeSDP: true, mid: i3.attributes.mid };
          }
        }
        stopSending(e2) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => t4.attributes.mid && -1 !== e2.indexOf(t4.attributes.mid));
          if (t3.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t3.forEach((e3) => {
            e3.attributes.ssrcs = [];
          }), this.updateBundleMids();
        }
        receive(e2, t3, i2) {
          const n3 = [];
          return e2.forEach((e3) => {
            const r2 = e3._mediaStreamTrack.kind, o2 = this.findAvailableRecvMediaIndex(r2);
            let s2, a3 = false;
            -1 === o2 ? (a3 = true, s2 = this.createOrRecycleRecvMedia(e3, [], "recvonly", t3, i2), this.updateBundleMids()) : (s2 = pO(this.sessionDesc.mediaDescriptions[o2]), s2.attributes.direction = "recvonly"), n3.push({ mid: s2.attributes.mid, needCreateTransceiver: a3 });
          }), n3;
        }
        stopReceiving(e2) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => -1 !== e2.indexOf(t4.attributes.mid));
          if (t3.length !== e2.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t3.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        addRemoteCandidate(e2) {
          const { foundation: t3, protocol: i2, address: n3, port: r2, type: o2, relatedAddress: s2, relatedPort: a3, priority: c3 } = new RTCIceCandidate(e2), d2 = { foundation: null != t3 ? t3 : "", componentId: "1", transport: null != i2 ? i2 : "", priority: c3 ? c3 + "" : "", connectionAddress: null != n3 ? n3 : "", port: r2 ? r2 + "" : "", type: o2 ? o2 + "" : "", relAddr: null != s2 ? s2 : "", relPort: a3 ? a3 + "" : "", extension: {} };
          this.candidates.some((e3) => e3.priority === d2.priority && e3.connectionAddress === d2.connectionAddress && e3.port === d2.port) || (this._candidates.push(d2), this.sessionDesc.mediaDescriptions.forEach((e3) => {
            e3.attributes.candidates = this.candidates;
          }));
        }
        clearRemoteCandidate() {
          this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;
        }
        createOrRecycleRecvMedia(e2, t3, i2, n3, r2) {
          const o2 = e2._mediaStreamTrack.kind, s2 = this.rtpCapabilities.recv, a3 = xx2(o2, s2, this.localCapabilities.send, o2 === EV.AUDIO ? r2 : n3), c3 = o2 === EV.VIDEO ? s2.videoExtensions : s2.audioExtensions, d2 = "".concat(++this.currentMidIndex);
          let l2 = { media: { mediaType: o2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a3.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: a3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(d2) } };
          l2 = this.mungRecvMediaDsec(l2, e2);
          const u3 = this.findFirstClosedMedia(o2);
          if (u3) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u3);
            this.sessionDesc.mediaDescriptions[e3] = l2;
          } else this.sessionDesc.mediaDescriptions.push(l2);
          return l2;
        }
        muteRemote(e2) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => Ln2(e2).call(e2, t4.attributes.mid || ""));
          if (t3.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t3.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t3 = this.sessionDesc.mediaDescriptions.filter((t4) => Ln2(e2).call(e2, t4.attributes.mid || ""));
          if (t3.length !== e2.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t3.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        findAvailableMediaIndex(e2, t3, i2) {
          return this.sessionDesc.mediaDescriptions.findIndex((n3) => {
            const r2 = n3.media.mediaType === e2 && "0" !== n3.media.port && ("sendonly" === n3.attributes.direction || "sendrecv" === n3.attributes.direction) && 0 === n3.attributes.ssrcs.length;
            if (iw2()) {
              if (r2) {
                const e3 = this.firefoxSsrcMidMap.get(t3[0].ssrcId);
                return !(e3 || "0" !== n3.attributes.mid && "1" !== n3.attributes.mid) || !(!e3 || e3 !== n3.attributes.mid);
              }
              return false;
            }
            return r2 && n3.attributes.mid === i2;
          });
        }
        findAvailableRecvMediaIndex(e2) {
          return this.sessionDesc.mediaDescriptions.findIndex((t3) => {
            const i2 = t3.media.mediaType === e2 && "0" !== t3.media.port && ("recvonly" === t3.attributes.direction || "sendrecv" === t3.attributes.direction);
            return "0" !== t3.attributes.mid && "1" !== t3.attributes.mid && i2;
          });
        }
        predictReceivingMids(e2) {
          const t3 = [];
          for (let i2 = 0; i2 < e2; i2++) t3.push((this.currentMidIndex + i2 + 1).toString(10));
          return t3;
        }
        restartICE(e2) {
          e2 = pO(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e2.iceUfrag, t3.attributes.icePwd = e2.icePwd;
          });
        }
        createOrRecycleSendMedia(e2, t3, i2, n3, r2, o2) {
          const s2 = this.rtpCapabilities.send, a3 = e2 === EV.VIDEO ? s2.videoCodecs : s2.audioCodecs, c3 = e2 === EV.VIDEO ? s2.videoExtensions : s2.audioExtensions;
          iw2() && (r2 = "".concat(++this.currentMidIndex));
          let d2 = { media: { mediaType: e2, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a3.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t3, ssrcGroups: i2, rtcpFeedbackWildcards: [], payloads: a3, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n3, rtcpMux: true, rtcpRsize: true, mid: r2 } };
          d2 = this.mungSendMediaDesc(d2, o2);
          const l2 = this.findFirstClosedMedia(e2);
          if (l2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(l2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        mungRecvMediaDsec(e2, t3, i2) {
          const n3 = pO(e2);
          return wx2(n3), Ax2(n3, t3), Ox2(n3, t3), Nx2(n3), Dx2(n3, i2, this.localCapabilities.send), n3;
        }
        mungSendMediaDesc(e2, t3) {
          const i2 = pO(e2);
          return Dx2(i2, t3, this.localCapabilities.recv), Vx2(i2), i2;
        }
        updateRecvMedia(e2, t3) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t3);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t3) => {
            var i2;
            return (null === (i2 = t3.attributes) || void 0 === i2 || null === (i2 = i2.ssrcs[0]) || void 0 === i2 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
          });
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t3) => iw2() ? "0" === t3.media.port && t3.media.mediaType === e2 : "0" === t3.media.port);
        }
      };
      const Zz2 = ["sdp"];
      var Qz2;
      function $z2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function eq2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? $z2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : $z2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      let tq2 = (Qz2 = class e2 extends pV {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get dtlsTransportState() {
          var e3, t3;
          return null !== (e3 = null === (t3 = this.peerConnection.getReceivers()[0]) || void 0 === t3 || null === (t3 = t3.transport) || void 0 === t3 ? void 0 : t3.state) && void 0 !== e3 ? e3 : null;
        }
        get localCodecs() {
          return [];
        }
        set isInRestartIce(e3) {
          this._isInRestartIce = e3;
        }
        get isInRestartIce() {
          return this._isInRestartIce;
        }
        constructor(t3, i2, n3) {
          super(t3, i2), uI(this, "direction", void 0), uI(this, "name", void 0), uI(this, "store", void 0), uI(this, "spec", void 0), uI(this, "peerConnection", void 0), uI(this, "initialOffer", void 0), uI(this, "transport", void 0), uI(this, "statsFilter", void 0), uI(this, "localCandidateCount", 0), uI(this, "_isInRestartIce", false), uI(this, "mutex", void 0), uI(this, "onLocalCandidate", void 0), uI(this, "remoteSDP", void 0), uI(this, "pendingCandidates", []), uI(this, "localCapabilities", void 0), uI(this, "isReady", false), uI(this, "restartCnt", 0), uI(this, "curTurnServerIndex", 0), this.store = i2, this.spec = t3, this.mutex = new xO("P2PConnection-mutex", i2.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t3, i2.p2pTransport), { optional: [{ googDscp: true }] }), this.direction = null != n3 ? n3 : BU.SEND_ONLY, this.name = this.direction === BU.SEND_ONLY ? "sendP2PConnection" : "recvP2PConnection", this.statsFilter = EN(this.peerConnection, wN("STATS_UPDATE_INTERVAL"), void 0, iw2() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish(e3) {
          try {
            const t3 = await Lx2();
            if (this.localCapabilities = Ux2(t3), e3) {
              const { sdp: t4 } = e3, i2 = Xz2(e3, Zz2), n3 = function() {
                const e4 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, t5 = Rx2(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, "sendonly"), i3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n4 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r3 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
                if (Mx2(t5, e4, "videoExtensions", i3, n4, r3), Mx2(t5, e4, "videoCodecs", i3, n4, r3), Mx2(t5, e4, "audioExtensions", i3, n4, r3), Mx2(t5, e4, "audioCodecs", i3, n4, r3), wN("RAISE_H264_BASELINE_PRIORITY")) {
                  const e5 = r3.videoCodecs.findIndex((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" === e6.fmtp.parameters["profile-level-id"]);
                  if (-1 !== e5) {
                    const t6 = r3.videoCodecs.findIndex((e6) => e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase());
                    if (t6 < e5) {
                      sD.debug("raising H264 baseline profile priority");
                      const i4 = r3.videoCodecs[e5];
                      r3.videoCodecs.splice(e5, 1), r3.videoCodecs.splice(t6, 0, i4);
                    }
                    -1 !== t6 && wN("FILTER_SEND_H264_BASELINE") && (i3.videoCodecs = i3.videoCodecs.filter((e6) => !(e6.rtpMap && "h264" === e6.rtpMap.encodingName.toLocaleLowerCase() && e6.fmtp && "42001f" !== e6.fmtp.parameters["profile-level-id"])));
                  }
                }
                return { send: i3, recv: n4, sendrecv: r3 };
              }({}, {}, t4);
              this.remoteSDP = new Jz2({ remoteIceParameters: i2.iceParameters, remoteDtlsParameters: i2.dtlsParameters, candidates: [], remoteRTPCapabilities: n3, localCapabilities: this.localCapabilities, direction: this.direction, setup: "actpass", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() }), this.isReady = true;
              const r2 = await this.peerConnection.createAnswer();
              if (!r2.sdp) throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
              const o2 = vx2(r2.sdp);
              await this.peerConnection.setLocalDescription(r2);
              const s2 = await kx2({}, {}, r2.sdp);
              this.localCapabilities = Ux2(s2);
              const a3 = this.peerConnection.getTransceivers()[0];
              return null != a3 && a3.receiver && a3.receiver.transport && this.tryBindTransportEvents(a3.receiver.transport), eq2(eq2({}, o2), {}, { sdp: r2.sdp });
            }
            {
              this.peerConnection.addTransceiver("video", { direction: "sendonly" }), this.peerConnection.addTransceiver("audio", { direction: "sendonly" });
              const e4 = await this.peerConnection.createOffer();
              if (!e4.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
              const t4 = vx2(e4.sdp);
              return this.initialOffer = e4, eq2(eq2({}, t4), {}, { sdp: e4.sdp });
            }
          } catch (e4) {
            throw new Ow2(ww2.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
          }
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            await this.peerConnection.setLocalDescription(this.initialOffer);
            const { sdp: t3, iceParameters: i2, dtlsParameters: n3 } = e3, r2 = await kx2({}, {}, t3);
            this.remoteSDP = new Jz2({ remoteIceParameters: i2, remoteDtlsParameters: n3, candidates: [], remoteRTPCapabilities: r2, localCapabilities: this.localCapabilities, direction: this.direction, setup: "active", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() });
            const o2 = this.peerConnection.getTransceivers()[0];
            null != o2 && o2.sender && o2.sender.transport && this.tryBindTransportEvents(o2.sender.transport);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async addRemoteCandidate(e3) {
          try {
            e3 && this.pendingCandidates.push(e3), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach((e4) => {
              this.peerConnection.addIceCandidate(e4);
            }), this.pendingCandidates = []);
          } catch (e4) {
            throw new Ow2(ww2.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(e4.toString()));
          }
        }
        send(e3, t3, i2) {
          var n3 = this;
          return qb2(function* () {
            const r2 = yield Jb2(n3.mutex.lock("From P2PConnection.send"));
            try {
              if (!n3.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [], s2 = n3.remoteSDP.receive(e3, t3, i2);
              e3.forEach((e4, t4) => {
                if (s2[t4].needCreateTransceiver) {
                  const t5 = n3.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                  o2.push(t5), e4._updateRtpTransceiver(t5);
                } else {
                  const i3 = n3.peerConnection.getTransceivers().find((e5) => e5.mid === s2[t4].mid);
                  if (!i3) throw new Error("cannot find transceiver when sendPeerconnection send, mid is ".concat(s2[t4].mid));
                  o2.push(i3), e4._updateRtpTransceiver(i3);
                }
              }), iw2() && true === wN("SIMULCAST") && (yield Jb2(n3.applySimulcastForFirefox(o2, e3)));
              const a3 = s2.map((e4) => e4.mid), c3 = yield Jb2(n3.peerConnection.createOffer()), d2 = n3.mungSendOfferSDP(c3.sdp, e3, a3), l2 = FN(d2), u3 = a3.map((e4) => {
                const t4 = l2.mediaDescriptions.find((t5) => t5.attributes.mid === e4);
                if (!t4) throw new Error("Cannot extract ssrc from mediaDescription.");
                return Cx2(t4, wN("USE_PUB_RTX"));
              }), h2 = o2.map((e4, t4) => {
                const i3 = a3[t4];
                return { localSSRC: u3[t4], id: i3 };
              });
              yield Jb2(n3.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }));
              try {
                yield h2;
              } catch (e4) {
                const t4 = n3.remoteSDP.toString();
                throw yield Jb2(n3.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Jb2(n3.peerConnection.setRemoteDescription({ type: "answer", sdp: t4 })), yield Jb2(n3.stopSending(a3, true)), e4;
              }
              yield Jb2(n3.applySimulcastEncodings(o2, e3)), yield Jb2(n3.applySendEncodings(o2, e3));
              const p2 = n3.remoteSDP.toString(), _2 = n3.logSDPExchange(d2, "offer", "local", "send");
              return null == _2 || _2(p2), yield Jb2(n3.setRemoteDescription({ type: "answer", sdp: p2 })), o2.map((e4, t4) => {
                const i3 = a3[t4];
                return { localSSRC: u3[t4], id: i3 };
              });
            } catch (e4) {
              throw e4 instanceof Ow2 ? e4 : new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              r2();
            }
          })();
        }
        async stopSending(e3, t3) {
          const i2 = t3 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t4 = this.peerConnection.getTransceivers().filter((t5) => -1 !== e3.indexOf(t5.mid));
            if (t4.length !== e3.length) throw new Error("Transceivers' length (".concat(t4.length, ") doesn't match mids' length (").concat(e3.length, ") when trying to call P2PConnection.stopSending."));
            t4.map((e4) => {
              var t5;
              e4.direction = "inactive", null === (t5 = e4.stop) || void 0 === t5 || t5.call(e4);
            });
            const n3 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n3.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(n3), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            null == r2 || r2(o2), await this.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            i2 && i2();
          }
        }
        async receive(e3, t3, i2, n3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t3, i2, n3);
            if (o2) {
              const t4 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t4, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t4 });
              const n4 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n4.sdp, r2, e3);
              null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), sD.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else sD.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
            if (!s2 || null === s2.mid) throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, mid: s2.mid, transceiver: s2 };
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async mockReceive(e3, t3, i2, n3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t3, i2, n3);
            if (o2) {
              const t4 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t4, "offer", "remote", "receive");
              await this.setRemoteDescription({ type: "offer", sdp: t4 });
              const n4 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n4.sdp, r2, e3);
              null == i3 || i3(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), sD.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
            } else sD.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t3 = this.remoteSDP.toString(), i2 = this.logSDPExchange(t3, "offer", "remote", "stopReceiving");
            await this.setRemoteDescription({ type: "offer", sdp: t3 });
            const n3 = await this.peerConnection.createAnswer();
            null == i2 || i2(n3.sdp || ""), await this.peerConnection.setLocalDescription(n3);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async restartICE(t3) {
          try {
            if (this.store.p2pTransport === TN.Auto && (this.store.p2pTransport = TN.SdRtn, fD2().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, fD2().supportPCSetConfiguration && this.peerConnection.setConfiguration(e2.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !t3) {
              this.restartCnt++, this.isReady = false;
              const e3 = await this.peerConnection.createOffer({ iceRestart: true });
              if (!e3.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const { iceParameters: t4 } = vx2(e3.sdp);
              return this.store.descriptionStart(), this.direction === BU.SEND_ONLY && await this.peerConnection.setLocalDescription(e3), t4;
            }
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            if (this.remoteSDP.restartICE(t3), this.store.descriptionStart(), this.direction === BU.RECEIVE_ONLY) {
              this.restartCnt++, await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() });
              const e3 = await this.peerConnection.createAnswer();
              if (!e3.sdp) throw new Error("Cannot get answer sdp when trying to iceRestart.");
              const { iceParameters: t4 } = vx2(e3.sdp);
              return await this.peerConnection.setLocalDescription(e3), t4;
            }
            await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() }), this.isReady = true;
          } catch (e3) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e3.toString()));
          }
        }
        close() {
          var e3;
          this.peerConnection.close(), this.peerConnection.onicecandidate = null, null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const i2 = await this.peerConnection.createOffer(), n3 = this.mungSendOfferSDP(i2.sdp, [t3], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t3);
            const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n3, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: n3 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t3) {
          const i2 = this.peerConnection.getTransceivers().filter((t4) => t4.mid === e3);
          1 === i2.length && (this.isVP8Simulcast(t3) ? iw2() || await this.applySimulcastEncodings(i2, [t3]) : await this.applySendEncodings(i2, [t3]));
        }
        setStatsRemoteVideoIsReady(e3, t3) {
          this.statsFilter.setVideoIsReady2(e3, t3);
        }
        async replaceTrack(e3, t3) {
          const i2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t3);
          i2 && await i2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async getSelectedCandidatePair() {
          const e3 = this.peerConnection.getReceivers();
          if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
            const t3 = e3[0].transport.iceTransport, { local: i2, remote: n3 } = t3.getSelectedCandidatePair();
            return { local: eq2(eq2({}, $O), {}, { candidateType: i2.type, protocol: i2.protocol, address: i2.address, port: i2.port }), remote: eq2(eq2({}, $O), {}, { candidateType: n3.type, protocol: n3.protocol, address: n3.address, port: n3.port }) };
          }
          return this.statsFilter.getSelectedCandidatePair();
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3, t3;
            Ln2(e3 = ["connected", "completed"]).call(e3, this.peerConnection.iceConnectionState) && (this.isReady = false), null === (t3 = this.onICEConnectionStateChange) || void 0 === t3 || t3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            "connected" === this.peerConnection.connectionState && (this.restartCnt = 0), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.startICECandidate();
        }
        startICECandidate() {
          this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = (e3) => {
            if (e3.candidate) {
              var t3;
              if (e3.candidate.candidate) null === (t3 = this.onLocalCandidate) || void 0 === t3 || t3.call(this, e3.candidate.toJSON());
              this.localCandidateCount += 1;
            } else sD.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount);
          });
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t3, i2) {
          let n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const r2 = { iceServers: [] };
          var o2;
          t3.iceServers ? r2.iceServers = t3.iceServers : t3.turnServer && "off" !== t3.turnServer.mode && (Qw2(t3.turnServer.servers) ? r2.iceServers = t3.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e2.turnServerConfigToIceServers(t3.turnServer.servers, i2, n3)), wN("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t3.turnServer.serversFromGateway && r2.iceServers.push(...e2.turnServerConfigToIceServers(t3.turnServer.serversFromGateway, i2, n3)), Ln2(o2 = [TN.Relay, TN.SdRtn]).call(o2, i2) && (r2.iceTransportPolicy = "relay"), wN("FORCE_TURN_TCP") ? r2.iceTransportPolicy = "relay" : t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (r2.iceTransportPolicy = "relay");
          })));
          return wN("ENABLE_ENCODED_TRANSFORM") && fD2().supportWebRTCEncodedTransform && (r2.encodedInsertableStreams = true), sD.debug("P2PConnection p2pTransport is ".concat(i2)), r2;
        }
        static turnServerConfigToIceServers(e3, t3) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          const n3 = [], r2 = e3.filter((e4) => e4.tcpport);
          sD.debug("P2PConnection turnServers is ".concat(r2, ", current index is ").concat(i2));
          const o2 = r2.length > i2 ? r2[i2] : r2[0];
          switch (t3) {
            case TN.SdRtn:
              const t4 = e3.filter((e4) => {
                var t5;
                return Ln2(t5 = e4.username).call(t5, "glb:") && e4.turnServerURL == e4.turnServerURL;
              }), r3 = t4.length > i2 ? t4[i2] : t4[0];
              r3 && (n3.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turn:".concat(ix2(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=udp") }), n3.push({ username: r3.username, credential: r3.password, credentialType: "password", urls: "turns:".concat(ix2(r3.turnServerURL), ":").concat(r3.tcpport, "?transport=tcp") }));
              break;
            case TN.Relay:
              o2 && (n3.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n3.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(ix2(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }));
              break;
            default:
              o2 && (n3.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turn:".concat(o2.turnServerURL, ":").concat(o2.tcpport, "?transport=udp") }), n3.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "turns:".concat(ix2(o2.turnServerURL), ":").concat(o2.tcpport, "?transport=tcp") }), n3.push({ username: o2.username, credential: o2.password, credentialType: "password", urls: "stun:".concat(o2.turnServerURL, ":").concat(o2.tcpport) }));
          }
          return n3;
        }
        tryBindTransportEvents(e3) {
          if (e3) {
            this.transport = e3, e3.onstatechange = () => {
              var t4;
              null != e3 && e3.state && (null === (t4 = this.onDTLSTransportStateChange) || void 0 === t4 || t4.call(this, e3.state));
            }, e3.onerror = (e4) => {
              var t4;
              null === (t4 = this.onDTLSTransportError) || void 0 === t4 || t4.call(this, "error" in e4 ? e4.error : e4);
            };
            const t3 = e3.iceTransport;
            t3 && (t3.onstatechange = () => {
              const t4 = null == e3 ? void 0 : e3.iceTransport.state;
              var i2;
              t4 && (null === (i2 = this.onICETransportStateChange) || void 0 === i2 || i2.call(this, t4));
            }, t3.getSelectedCandidatePair && (t3.onselectedcandidatepairchange = () => {
              if (t3.getSelectedCandidatePair()) {
                const { local: e4, remote: i2 } = t3.getSelectedCandidatePair() || {};
                if (e4 && i2) {
                  const t4 = e4.address + ":" + e4.port, n3 = i2.address + ":" + i2.port;
                  sD.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify(hx2(t4)), ", remote ").concat(JSON.stringify(hx2(n3))));
                }
              }
            }));
          }
        }
        tryUnbindTransportEvents() {
          this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));
        }
        async updateRtpSenderEncodings(e3, t3) {
          var i2;
          if (!t3) {
            t3 = this.peerConnection.getSenders().find((t4) => t4.track === e3._mediaStreamTrack);
          }
          if (!t3) return sD.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (this.isVP8Simulcast(e3)) return sD.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
          if (!fD2().supportSetRtpSenderParameters) return sD.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
          const n3 = {}, r2 = {};
          switch (e3._optimizationMode) {
            case "motion":
              n3.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n3.degradationPreference = "maintain-resolution";
              break;
            default:
              n3.degradationPreference = "balanced";
          }
          if (e3._encoderConfig) {
            var o2;
            const { bitrateMax: t4, frameRate: i3, scaleResolutionDownBy: n4 } = e3._encoderConfig;
            t4 && (r2.maxBitrate = 1e3 * t4), Ln2(o2 = e3._hints).call(o2, xD.LOW_STREAM) && (i3 && (r2.maxFramerate = ox2(i3)), n4 && n4 >= 1 && (r2.scaleResolutionDownBy = n4));
          }
          if (wN("DSCP_TYPE") && vw2()) {
            var s2;
            const e4 = wN("DSCP_TYPE");
            Ln2(s2 = ["very-low", "low", "medium", "high"]).call(s2, e4) && (r2.networkPriority = e4);
          }
          const a3 = t3.getParameters(), c3 = null === (i2 = a3.encodings) || void 0 === i2 ? void 0 : i2[0];
          iw2() && !c3 && (n3.encodings = [r2]), c3 && Object.assign(c3, r2), Object.assign(a3, n3), sD.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a3.encodings))), await t3.setParameters(a3);
        }
        async applySendEncodings(e3, t3) {
          try {
            if (!fD2().supportSetRtpSenderParameters) return;
            if (e3.length !== t3.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n3 = e3[i2], r2 = t3[i2];
              r2 instanceof kk2 && !this.isVP8Simulcast(r2) && await this.updateRtpSenderEncodings(r2, n3.sender);
            }
          } catch (e4) {
            sD.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t3, i2) {
          const n3 = FN(e3);
          return t3.forEach((e4, t4) => {
            const r2 = i2[t4], o2 = n3.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
            o2 && (Ax2(o2, e4), Px2(o2, e4, this.store.codec));
          }), BN(n3);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t3;
            null === (t3 = this.onFirstAudioReceived) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t3;
            null === (t3 = this.onFirstVideoReceived) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t3;
            null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t3, i2) => {
            var n3;
            null === (n3 = this.onFirstVideoDecoded) || void 0 === n3 || n3.call(this, e3, t3, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t3) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t3);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t3) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t3);
          }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
            var t3;
            null === (t3 = this.onFirstVideoDecodedTimeout) || void 0 === t3 || t3.call(this, e3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
        }
        async applySimulcastForFirefox(e3, t3) {
          if (e3.length === t3.length) for (let a3 = 0; a3 < e3.length; a3++) {
            var i2, n3, r2, o2, s2;
            const c3 = e3[a3], d2 = t3[a3];
            if (d2 instanceof kk2 && !Ln2(i2 = d2._hints).call(i2, xD.LOW_STREAM) && null !== (n3 = d2._encoderConfig) && void 0 !== n3 && n3.bitrateMax && (null === (r2 = d2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax) > 200 && null !== (o2 = d2._scalabilityMode) && void 0 !== o2 && o2.numSpatialLayers && (null === (s2 = d2._scalabilityMode) || void 0 === s2 ? void 0 : s2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t4 = { high: 1e3 * (d2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t4.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t4.high }];
              const i3 = c3.sender.getParameters();
              await c3.sender.setParameters(Object.assign(i3, e4));
            }
          }
        }
        async applySimulcastEncodings(e3, t3) {
          if (!iw2() && e3.length === t3.length) for (let i2 = 0; i2 < e3.length; i2++) {
            const n3 = t3[i2];
            if (n3 instanceof kk2 && this.isVP8Simulcast(n3)) {
              const t4 = e3[i2], r2 = {}, o2 = { high: 1e3 * (n3._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t4.sender.getParameters();
              await t4.sender.setParameters(Object.assign(s2, r2));
            }
          }
        }
        isVP8Simulcast(e3) {
          var t3, i2, n3, r2, o2;
          return !!(e3 instanceof kk2 && wN("SIMULCAST") && "vp8" === this.store.codec && !Ln2(t3 = e3._hints).call(t3, xD.LOW_STREAM) && null !== (i2 = e3._encoderConfig) && void 0 !== i2 && i2.bitrateMax && (null === (n3 = e3._encoderConfig) || void 0 === n3 ? void 0 : n3.bitrateMax) > 200 && null !== (r2 = e3._scalabilityMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = e3._scalabilityMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t3, i2, n3) {
          if (wN("SDP_LOGGING")) return sD.upload("[".concat(this.store.clientId, "] exchanging ").concat(i2, " ").concat(t3, " SDP during P2PConnection.").concat(n3, "\n"), e3), "offer" === t3 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i2 ? "remote" : "local", n3);
          } : void 0;
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map((e4) => {
              e4.direction = "inactive";
            });
            const i2 = await this.peerConnection.createOffer(), n3 = this.logSDPExchange(i2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.muteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n3 || n3(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => t4.mid && -1 !== e3.indexOf(t4.mid));
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length.");
            t3.map(async (e4) => {
              e4.direction = "sendonly";
            });
            const i2 = await this.peerConnection.createOffer(), n3 = this.logSDPExchange(i2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.unmuteRemote(e3);
            const r2 = this.remoteSDP.toString();
            null == n3 || n3(r2), await this.setRemoteDescription({ type: "answer", sdp: r2 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3, t3) {
          var i2;
          if (t3 = null != t3 ? t3 : null === (i2 = this.currentRemoteDescription) || void 0 === i2 ? void 0 : i2.sdp) {
            var n3;
            const i3 = null === (n3 = FN(t3).mediaDescriptions.find((t4) => t4.attributes.mid === e3)) || void 0 === n3 ? void 0 : n3.attributes.ssrcs;
            return null == i3 ? void 0 : i3[0].ssrcId;
          }
        }
        async setRemoteDescription(e3) {
          var t3;
          await this.peerConnection.setRemoteDescription(e3), Ln2(t3 = ["connected", "completed"]).call(t3, this.peerConnection.iceConnectionState) || (this.isReady = true, this.addRemoteCandidate());
        }
        mungReceiveAnswerSDP(e3, t3, i2) {
          const n3 = FN(e3), r2 = n3.mediaDescriptions.find((e4) => e4.attributes.mid === t3);
          return r2 && i2 === EV.AUDIO && "audio" === r2.media.mediaType && Vx2(r2), BN(n3);
        }
      }, OU(Qz2.prototype, "establish", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "establish"), Qz2.prototype), OU(Qz2.prototype, "connect", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "connect"), Qz2.prototype), OU(Qz2.prototype, "receive", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "receive"), Qz2.prototype), OU(Qz2.prototype, "mockReceive", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "mockReceive"), Qz2.prototype), OU(Qz2.prototype, "stopReceiving", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "stopReceiving"), Qz2.prototype), OU(Qz2.prototype, "restartICE", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "restartICE"), Qz2.prototype), OU(Qz2.prototype, "close", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "close"), Qz2.prototype), OU(Qz2.prototype, "updateEncoderConfig", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "updateEncoderConfig"), Qz2.prototype), OU(Qz2.prototype, "updateSendParameters", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "updateSendParameters"), Qz2.prototype), OU(Qz2.prototype, "replaceTrack", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "replaceTrack"), Qz2.prototype), OU(Qz2.prototype, "muteLocal", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "muteLocal"), Qz2.prototype), OU(Qz2.prototype, "unmuteLocal", [iq2], Object.getOwnPropertyDescriptor(Qz2.prototype, "unmuteLocal"), Qz2.prototype), Qz2);
      function iq2(e2, t3, i2) {
        const n3 = e2[t3];
        if ("function" != typeof n3) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("From P2PConnection.".concat(t3));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n3.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      let nq2 = function(e2) {
        return e2.SEND_ONLY = "SEND_ONLY", e2.RECEIVE_ONLY = "RECEIVE_ONLY", e2;
      }({});
      var rq2, oq2, sq2, aq2, cq2, dq2, lq2, uq2, hq2, pq2, _q, Eq2;
      function mq2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function fq2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? mq2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : mq2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      let Sq2 = (rq2 = gq2(nq2.SEND_ONLY), oq2 = gq2(nq2.SEND_ONLY), sq2 = gq2(), aq2 = gq2(nq2.RECEIVE_ONLY), cq2 = gq2(nq2.RECEIVE_ONLY), dq2 = gq2(nq2.RECEIVE_ONLY), lq2 = gq2(nq2.RECEIVE_ONLY), uq2 = gq2(nq2.RECEIVE_ONLY), hq2 = gq2(nq2.RECEIVE_ONLY), pq2 = gq2(), _q = gq2(nq2.RECEIVE_ONLY), Eq2 = class extends Hw2 {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t3 = this._state;
          this._state = e2, this.emit(RV.StateChange, t3, this._state);
        }
        constructor(e2, t3) {
          super(), uI(this, "isPlanB", false), uI(this, "store", void 0), uI(this, "statsUploader", void 0), uI(this, "sendConnection", void 0), uI(this, "recvConnection", void 0), uI(this, "localTrackMap", /* @__PURE__ */ new Map()), uI(this, "remoteUserMap", /* @__PURE__ */ new Map()), uI(this, "localDataChannels", []), uI(this, "pendingLocalTracks", []), uI(this, "pendingRemoteTracks", []), uI(this, "statsCollector", void 0), uI(this, "dtlsFailedCount", 0), uI(this, "sendMutex", void 0), uI(this, "recvMutex", void 0), uI(this, "_state", TV.Disconnected), uI(this, "_restartStates", ["disconnected", "failed"]), uI(this, "reconnectInterval", void 0), uI(this, "uploadUnplinkStarted", false), uI(this, "uploadDownlinkStarted", false), uI(this, "uplinkStateUploadInterval", void 0), uI(this, "downlinkStatsUploadInterval", void 0), uI(this, "handleMuteLocalTrack", async (e3, t4, i2) => {
            const n3 = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== TV.Connected) return void i2(new Ow2(ww2.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
              const s2 = this.filterTobeMutedTracks(e3);
              if (0 === s2.length) return void t4();
              const a3 = s2.find((e4) => "videoLowTrack" === e4[0]);
              if (a3) {
                a3[1].track._originMediaStreamTrack.stop();
              }
              await this.sendConnection.muteLocal(s2.map((e4) => {
                let [, { id: t5 }] = e4;
                return t5;
              }));
              let c3 = false;
              var r2, o2;
              if ("video" === e3.trackMediaType) c3 = !(null === (r2 = this.localTrackMap.get(gV.LocalAudioTrack)) || void 0 === r2 || !r2.track._muted);
              else c3 = void 0 === (null === (o2 = this.localTrackMap.get(gV.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.id);
              const d2 = this.createMuteMessage(s2);
              await sO(this, RV.RequestMuteLocal, d2);
              const l2 = "video" === e3.trackMediaType ? PV.MUTE_LOCAL_VIDEO : PV.MUTE_LOCAL_AUDIO;
              await sO(this, RV.RequestP2PMuteLocal, { action: l2, message: d2, isMuteAll: c3 }), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              n3();
            }
          }), uI(this, "handleUnmuteLocalTrack", async (e3, t4, i2) => {
            const n3 = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
            try {
              if (!this.sendConnection || this.state !== TV.Connected) return void i2(new Ow2(ww2.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
              const r2 = this.filterTobeUnmutedTracks(e3);
              if (0 === r2.length) return void t4();
              await this.sendConnection.unmuteLocal(r2.map((e4) => {
                let [, { id: t5 }] = e4;
                return t5;
              }));
              const o2 = this.createUnmuteMessage(r2), s2 = "video" === e3.trackMediaType ? PV.UNMUTE_LOCAL_VIDEO : PV.UNMUTE_LOCAL_AUDIO;
              await sO(this, RV.RequestP2PMuteLocal, { action: s2, message: o2 }), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              n3();
            }
          }), uI(this, "handleUpdateVideoEncoder", async (e3, t4, i2, n3) => {
            let r2;
            "boolean" == typeof n3 && n3 || (r2 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoEncoder"));
            try {
              const i3 = this.localTrackMap.get(gV.LocalVideoTrack);
              if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== TV.Connected) return void t4();
              const { id: n4, track: s2 } = i3;
              n4 && (await this.sendConnection.updateSendParameters(n4, s2), await this.sendConnection.updateEncoderConfig(n4, s2), this.emit(RV.UpdateVideoEncoder, s2)), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              var o2;
              null === (o2 = r2) || void 0 === o2 || o2();
            }
          }), uI(this, "handleUpdateVideoSendParameters", async (e3, t4, i2) => {
            const n3 = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoSendParameters");
            try {
              const i3 = this.localTrackMap.get(gV.LocalVideoTrack);
              if (!this.sendConnection || !i3 || i3.track !== e3 || this.state !== TV.Connected) return void t4();
              const { id: r2, track: o2 } = i3;
              r2 && await this.sendConnection.updateSendParameters(r2, o2), t4();
            } catch (e4) {
              i2(e4);
            } finally {
              n3();
            }
          }), uI(this, "handleReplaceTrack", async (e3, t4, i2, n3) => {
            let r2;
            sD.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n3 && n3 || (r2 = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
            try {
              var o2;
              const i3 = Array.from(this.localTrackMap.entries()).find((t5) => {
                let [, { track: i4 }] = t5;
                return e3 === i4;
              });
              if (!this.sendConnection || !i3 || void 0 === i3[1].id || this.state !== TV.Connected) return void t4();
              if (await (null === (o2 = this.sendConnection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i3[1].id)), i3[0] === gV.LocalVideoTrack && fD2().supportDualStreamEncoding) {
                const t5 = this.localTrackMap.get(gV.LocalVideoLowTrack);
                if (t5) {
                  const i4 = e3._mediaStreamTrack.clone();
                  t5.track._originMediaStreamTrack.stop(), t5.track._mediaStreamTrack = i4, t5.track._originMediaStreamTrack = i4, await new ip2((e4, i5) => {
                    this.handleReplaceTrack(t5.track, e4, i5, true);
                  });
                }
              }
              t4();
            } catch (e4) {
              i2(e4);
            } finally {
              var s2;
              null === (s2 = r2) || void 0 === s2 || s2();
            }
          }), uI(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), uI(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), uI(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), uI(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t3, this.statsCollector.addP2PChannel(this), this.statsUploader = new GB2(e2), this.bindStatsUploaderEvents(), this.sendMutex = new xO("P2PChannel2-send-mutex", e2.clientId), this.recvMutex = new xO("P2PChannel2-recv-mutex", e2.clientId), this.reconnectInterval = window.setInterval(() => {
            [this.sendConnection, this.recvConnection].forEach((e3) => {
              e3 && ("disconnected" !== e3.iceConnectionState && "failed" !== e3.iceConnectionState || this.handleDisconnect(e3.direction));
            });
          }, wN("ICE_RESTART_INTERVAL"));
        }
        async startP2PConnection(e2, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
        }
        async connect(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support connect.");
        }
        async startP2P(e2, t3) {
          let i2;
          try {
            if (t3) {
              this.recvConnection && (sD.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset recvConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), i2 = await this.recvMutex.lock("From P2PChannel.startP2P"), this.recvConnection = new tq2(e2, this.store, BU.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);
              const n3 = await this.recvConnection.establish(t3);
              return { iceParameters: n3.iceParameters, dtlsParameters: n3.dtlsParameters, sdp: n3.sdp };
            }
            {
              this.state = TV.New, this.sendConnection && (sD.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset sendConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), i2 = await this.sendMutex.lock("From P2PChannel.startP2P"), this.sendConnection = new tq2(e2, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);
              const t4 = await this.sendConnection.establish();
              return { iceParameters: t4.iceParameters, dtlsParameters: t4.dtlsParameters, sdp: t4.sdp };
            }
          } finally {
            i2 && i2();
          }
        }
        async p2pConnect(e2) {
          if (!this.sendConnection) throw new Ow2(ww2.UNEXPECTED_ERROR, "Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .");
          this.store.peerConnectionStart(), await this.sendConnection.connect(e2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = TV.Connected;
        }
        async addRemoteCandidate(e2, t3) {
          if (t3 === BU.RECEIVE_ONLY) {
            if (!this.sendConnection) throw new Ow2(ww2.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.sendConnection.addRemoteCandidate(e2);
          } else {
            if (!this.recvConnection) throw new Ow2(ww2.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
            await this.recvConnection.addRemoteCandidate(e2);
          }
        }
        publish(e2, t3, i2) {
          var n3 = this;
          return qb2(function* () {
            const r2 = yield Jb2(n3.sendMutex.lock("From P2PChannel.publish"));
            try {
              if (!n3.sendConnection || n3.state !== TV.Connected) {
                n3.throwIfTrackTypeNotMatch(e2);
                const t4 = e2.filter((e3) => -1 === n3.pendingLocalTracks.indexOf(e3));
                return void (n3.pendingLocalTracks = n3.pendingLocalTracks.concat(t4));
              }
              n3.store.pubId = n3.store.pubId + 1, YF.markPublishStart(n3.store.clientId, n3.store.pubId);
              const o2 = n3.filterTobePublishedTracks(e2, t3, i2);
              if (0 === o2.length) return void (yield Jb2(n3.tryToUnmuteAudio(e2)));
              o2.forEach((e3) => {
                let { track: t4, type: i3 } = e3;
                const r3 = Date.now();
                n3.store.publish(t4.getTrackId(), i3 === gV.LocalAudioTrack ? "audio" : "video", r3);
              }), n3.bindLocalTrackEvents(o2);
              const s2 = yield Jb2(n3.sendConnection.send(o2.map((e3) => {
                let { track: t4 } = e3;
                return t4;
              }), n3.store.codec, n3.store.audioCodec)), a3 = (yield Jb2(s2.next())).value, c3 = n3.createGatewayPublishMessage(o2, a3);
              try {
                yield c3;
              } catch (e3) {
                throw s2.throw(e3), (null == e3 ? void 0 : e3.code) === ww2.WS_ABORT && o2.forEach((e4) => {
                  let { track: t4 } = e4;
                  -1 === n3.pendingLocalTracks.indexOf(t4) && n3.pendingLocalTracks.push(t4);
                }), n3.unbindLocalTrackEvents(o2), e3;
              }
              yield Jb2(s2.next()), o2.forEach((e3) => {
                let { type: t4 } = e3;
                n3.statsCollector.addLocalStats(t4);
              }), n3.statsUploader.startUploadOutboundStats(), n3.assignLocalTracks(o2, a3), o2.forEach((e3) => {
                let { track: t4, type: i3 } = e3;
                const r3 = Date.now();
                n3.store.publish(t4.getTrackId(), i3 === gV.LocalAudioTrack ? "audio" : "video", void 0, r3);
              }), n3.startUploadUplinkState();
            } finally {
              r2();
            }
          })();
        }
        async unpublish(e2) {
          if (!this.sendConnection || this.state !== TV.Connected) return void (0 === e2.length ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter((t4) => !Ln2(e2).call(e2, t4)));
          const t3 = this.filterTobeUnpublishedTracks(e2);
          if (0 === t3.length) return;
          const i2 = t3.find((e3) => "videoLowTrack" === e3[0]);
          if (i2) {
            i2[1].track.close();
          }
          const n3 = this.createGatewayUnpublishMessage(t3);
          if (await this.sendConnection.stopSending(t3.map((e3) => {
            let [, { id: t4 }] = e3;
            return t4;
          })), this.withdrawLocalTracks(t3), this.unbindLocalTrackEvents(t3.map((e3) => {
            let [t4, { track: i3 }] = e3;
            return { type: t4, track: i3 };
          })), t3.forEach((e3) => {
            let [t4] = e3;
            this.statsCollector.removeLocalStats(t4);
          }), 0 === this.localTrackMap.size && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === TV.Connected) {
            if (i2) {
              i2[1].track.close();
            }
            return n3;
          }
          e2.forEach((e3) => {
            const t4 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t4 && this.pendingLocalTracks.splice(t4, 1);
          });
        }
        startUploadUplinkState() {
          if (this.uploadUnplinkStarted) return;
          this.uploadUnplinkStarted = true, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);
          const e2 = () => {
            const e3 = [], t3 = [];
            Array.from(this.localTrackMap.entries()).forEach((i2) => {
              let [n3, { track: r2, ssrcs: o2 }] = i2;
              const s2 = { stream_type: mB2(r2, n3), ssrcs: o2 };
              r2._muted || !r2._enabled ? e3.push(s2) : t3.push(s2);
            }), e3.length > 0 && e3.forEach((e4) => {
              sO(this, RV.RequestMuteLocal, [e4]);
            }), t3.length > 0 && t3.forEach((e4) => {
              sO(this, RV.RequestUnmuteLocal, [e4]);
            });
          };
          e2(), this.uplinkStateUploadInterval = window.setInterval(() => {
            e2();
          }, 3e3);
        }
        stopUploadUplinkState() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));
        }
        publishLowStream(e2) {
          return qb2(function* () {
            throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (sD.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await oO(this, RV.RequestRePublish, this.pendingLocalTracks), this.emit(RV.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async unpublishLowStream() {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
        }
        async subscribe(e2, t3, i2, n3) {
          var r2;
          if (!this.recvConnection) throw new Ow2(ww2.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          if (null !== (r2 = this.remoteUserMap.get(e2)) && void 0 !== r2 && r2.has(t3)) return;
          const { track: o2, mid: s2, transceiver: a3 } = await this.recvConnection.receive(t3, [{ ssrcId: i2 }], String(e2.uid), n3);
          t3 === EV.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(o2) : (e2._audioTrack = new Zk2(o2, e2.uid, e2._uintid, this.store), sD.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), a3 && e2._audioTrack._updateRtpTransceiver(a3), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoSSRC = i2, e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(o2) : (e2._videoTrack = new Jk2(o2, e2.uid, e2._uintid, this.store), sD.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), a3 && e2._videoTrack._updateRtpTransceiver(a3), this.bindRemoteTrackEvents(e2, e2._videoTrack));
          const c3 = this.remoteUserMap.get(e2);
          c3 ? c3.set(t3, s2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t3, s2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();
          const d2 = this.pendingRemoteTracks.findIndex((i3) => {
            let { user: n4, kind: r3 } = i3;
            return n4.uid === e2.uid && t3 === r3;
          });
          -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(RV.MediaReconnectEnd, e2.uid));
        }
        async mockSubscribe(e2, t3, i2, n3) {
          if (!this.recvConnection) throw new Ow2(ww2.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
          await this.recvConnection.mockReceive(t3, [{ ssrcId: i2 }], String(e2.uid), n3);
        }
        async unsubscribe(e2, t3, i2) {
          const n3 = this.pendingRemoteTracks.filter((i3) => {
            let { user: n4, kind: r3 } = i3;
            return void 0 !== t3 ? n4.uid === e2.uid && t3 === r3 : n4.uid === e2.uid;
          });
          if (n3.forEach((e3) => {
            const t4 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t4, 1);
          }), this.recvConnection || i2 || n3.forEach((t4) => {
            let { kind: i3 } = t4;
            var n4;
            if (i3 === EV.AUDIO) null === (n4 = e2._audioTrack) || void 0 === n4 || n4._destroy(), e2._audioTrack = void 0;
            else if (i3 === EV.VIDEO) {
              var r3;
              null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
            }
          }), !this.recvConnection) return;
          const r2 = this.filterTobeUnSubscribedTracks(e2, t3);
          0 !== r2.length && (await this.recvConnection.stopReceiving(r2.map((e3) => {
            let [, { id: t4 }] = e3;
            return t4;
          })), this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r2.forEach((e3) => {
            let [t4, { kind: n4 }] = e3;
            var r3, o2;
            n4 === EV.VIDEO && t4._videoSSRC && (null === (r3 = this.recvConnection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t4._videoSSRC, false));
            if (n4 === EV.VIDEO) this.unbindRemoteTrackEvents(t4._videoTrack), i2 || (null === (o2 = t4._videoTrack) || void 0 === o2 || o2._destroy(), t4._videoTrack = void 0);
            else if (n4 === EV.AUDIO) {
              var s2;
              if (this.unbindRemoteTrackEvents(t4._audioTrack), !i2) null === (s2 = t4._audioTrack) || void 0 === s2 || s2._destroy(), t4._audioTrack = void 0;
            }
          }), r2.forEach((e3) => {
            let [, { kind: t4 }] = e3;
            sO(this, RV.RequestP2PMuteRemote, t4);
          }));
        }
        startUploadDownlinkState() {
          if (this.uploadDownlinkStarted) return;
          this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
          const e2 = () => Array.from(this.remoteUserMap.entries()).forEach((e3) => {
            let [, t3] = e3;
            [EV.VIDEO, EV.AUDIO].forEach((e4) => {
              t3.has(e4) ? sO(this, RV.RequestP2PUnmuteRemote, e4) : sO(this, RV.RequestP2PMuteRemote, e4);
            });
          });
          e2(), this.downlinkStatsUploadInterval = window.setInterval(() => {
            e2();
          }, 3e3);
        }
        stopUploadDownlinkState() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));
        }
        getAllDataChannels() {
          return this.localDataChannels;
        }
        async massSubscribe(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
        }
        async massSubscribeNoLock(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
        }
        async massUnsubscribe(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
        }
        async massUnsubscribeNoLock(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
        }
        async muteRemote(e2, t3) {
          if (!this.recvConnection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void sD.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, "."));
          if (!i2.get(t3)) return void sD.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t3, "."));
          const n3 = t3 === EV.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          void 0 !== n3 && this.recvConnection.setStatsRemoteVideoIsReady(n3, false);
        }
        async unmuteRemote(e2, t3) {
          return this.unmuteRemoteNoLock(e2, t3);
        }
        async unmuteRemoteNoLock(e2, t3) {
          if (!this.recvConnection) return;
          const i2 = this.remoteUserMap.get(e2);
          if (!i2) return void sD.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, "."));
          i2.get(t3) || sD.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t3, "."));
        }
        getAllTracks(e2) {
          const t3 = this.localTrackMap.get(gV.LocalAudioTrack);
          if ((null == t3 ? void 0 : t3.track) instanceof WL) {
            const i2 = t3.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t4] = e3;
              return t4 !== gV.LocalAudioTrack;
            }).filter((t4) => {
              let [i3] = t4;
              return !(e2 && i3 === gV.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t4 }] = e3;
              return t4;
            }).concat(i2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t4) => {
            let [i2] = t4;
            return !(e2 && i2 === gV.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t4 }] = e3;
            return t4;
          });
        }
        reportPublishEvent(e2, t3, i2, n3, r2) {
          if (e2) {
            const i3 = this.localTrackMap.get(gV.LocalAudioTrack), o3 = n3 ? this.localTrackMap.get(gV.LocalVideoLowTrack) : this.localTrackMap.get(gV.LocalVideoTrack);
            _D.publish(this.store.sessionId, { eventElapse: YF.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t3, audioName: null == i3 ? void 0 : i3.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(xD.SCREEN_TRACK)), audio: !!i3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          } else {
            var o2;
            i2 || (i2 = []);
            const s2 = i2.find((e3) => e3 instanceof BL), a3 = n3 ? null === (o2 = this.localTrackMap.get(gV.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i2.find((e3) => e3 instanceof kk2);
            _D.publish(this.store.sessionId, { eventElapse: YF.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t3, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a3 ? void 0 : a3.getTrackLabel(), screenshare: -1 !== (null == a3 ? void 0 : a3._hints.indexOf(xD.SCREEN_TRACK)), audio: !!s2, video: !!a3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
          }
        }
        reportSubscribeEvent(e2, t3, i2, n3) {
          const r2 = n3 === EV.VIDEO ? i2._videoSSRC : i2._audioSSRC;
          r2 && _D.subscribe(this.store.sessionId, { succ: e2, ec: t3, video: n3 === EV.VIDEO, audio: n3 === EV.AUDIO, peerid: i2.uid, subscribeRequestid: n3 === EV.VIDEO ? i2._videoSSRC : i2._audioSSRC, p2pid: this.store.p2pId, eventElapse: YF.measureFromSubscribeStart(this.store.clientId, r2) });
        }
        reset() {
          sD.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new xO("P2PChannel2-send-mutex", this.store.clientId), this.sendMutex = new xO("P2PChannel2-recv-mutex", this.store.clientId), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
          const e2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if ((null == e2 ? void 0 : e2.track) instanceof WL) {
            if (e2.track.trackList.length > 0) {
              const t3 = e2.track;
              e2.track.trackList.forEach((e3) => {
                t3.removeAudioTrack(e3);
              });
            }
            e2.track.close();
          }
          this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = TV.Disconnected;
        }
        getStats(e2) {
          var t3, i2;
          return e2 ? null === (i2 = this.recvConnection) || void 0 === i2 ? void 0 : i2.getStats() : null === (t3 = this.sendConnection) || void 0 === t3 ? void 0 : t3.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t3;
          return (null === (t3 = this.recvConnection) || void 0 === t3 ? void 0 : t3.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if (e2) return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(gV.LocalVideoTrack);
          if (e2) return { width: e2.track.videoWidth || 0, height: e2.track.videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t3 = this.localTrackMap.get(e2);
          return t3 && t3.track instanceof kk2 || t3 && t3.track instanceof BL ? t3.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t3) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t3 || i2.has(t3));
        }
        async hasRemoteMediaWithLock(e2, t3) {
          if (!e2) return this.remoteUserMap.size > 0;
          const i2 = this.remoteUserMap.get(e2);
          return !!i2 && (!t3 || i2.has(t3));
        }
        getRemoteMedia(e2) {
          var t3;
          const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4.uid === e2);
          return i2 ? { audioTrack: i2.audioTrack, audioSSRC: i2._audioSSRC, videoTrack: i2.videoTrack, videoSSRC: i2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t4] = e3;
            return { uid: t4.uid, level: t4.audioTrack ? 100 * t4.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t3 = this.localTrackMap.get(gV.LocalAudioTrack);
          return t3 && e2.push({ level: 100 * t3.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Xp2(e2).call(e2, (e3, t4) => e3.level - t4.level), e2;
        }
        async disconnectForReconnect() {
          this.sendConnection && this.recvConnection && (sD.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = TV.Reconnecting, wN("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t3] = e2;
            var i2;
            t3._videoTrack && t3._videoTrack._player && (null === (i2 = t3._videoTrack._player.getVideoElement()) || void 0 === i2 || i2.pause(), t3._videoTrack._player.isKeepLastFrame = true, t3._videoTrack._originMediaStreamTrack.stop());
          }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            var t3;
            let [i2, { track: n3 }] = e2;
            switch (i2) {
              case gV.LocalVideoTrack:
                Ln2(t3 = n3._hints).call(t3, xD.LOW_STREAM) ? n3.close() : this.pendingLocalTracks.push(n3);
                break;
              case gV.LocalAudioTrack:
                n3 instanceof WL ? this.pendingLocalTracks = this.pendingLocalTracks.concat(n3.trackList) : this.pendingLocalTracks.push(n3);
              case gV.LocalVideoLowTrack:
            }
          }), this.emit(RV.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t3, i2] = e2;
            Array.from(XN(i2).call(i2)).forEach((e3) => {
              this.setPendingRemoteMedia(t3, e3);
            }), this.emit(RV.MediaReconnectStart, t3.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), sD.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
        }
        hasPendingRemoteMedia(e2, t3) {
          for (const i2 of this.pendingRemoteTracks) {
            const { user: n3, kind: r2 } = i2;
            if ((e2 instanceof QF ? e2.uid : e2) === n3.uid && t3 === r2) return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t3) {
          this.hasPendingRemoteMedia(e2, t3) || this.pendingRemoteTracks.push({ user: e2, kind: t3 });
        }
        async restartICE(e2, t3) {
          let i2, n3;
          if (e2 === BU.SEND_ONLY) {
            if (!this.sendConnection) throw new Ow2(ww2.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.");
            i2 = await this.sendMutex.lock("From P2PChannel.restartICE"), n3 = this.sendConnection;
          } else {
            if (!this.recvConnection) throw new Ow2(ww2.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.");
            i2 = await this.recvMutex.lock("From P2PChannel.restartICE"), n3 = this.recvConnection;
          }
          try {
            if (t3) {
              const e3 = await n3.restartICE(t3);
              return n3.isInRestartIce = false, e3;
            }
            {
              const e3 = await n3.restartICE();
              if (e3) {
                const t4 = await oO(this, RV.RequestP2PRestartICE, { direction: BU.RECEIVE_ONLY, iceParameter: e3 });
                await n3.restartICE(t4), n3.isInRestartIce = false;
              }
            }
          } finally {
            i2();
          }
        }
        getUplinkNetworkQuality() {
          if (!this.sendConnection) return 0;
          const e2 = this.sendConnection.getStats(), t3 = this.localTrackMap.get(gV.LocalVideoTrack), i2 = this.localTrackMap.get(gV.LocalAudioTrack), n3 = e2.videoSend.find((e3) => {
            var i3;
            return e3.ssrc === (null == t3 || null === (i3 = t3.ssrcs) || void 0 === i3 ? void 0 : i3[0].ssrcId);
          }), r2 = e2.audioSend.find((e3) => {
            var t4;
            return e3.ssrc === (null == i2 || null === (t4 = i2.ssrcs) || void 0 === t4 ? void 0 : t4[0].ssrcId);
          });
          if (!n3 || !r2) return 1;
          const o2 = aO(this, RV.NeedSignalRTT), s2 = n3 ? n3.rttMs : void 0, a3 = r2 ? r2.rttMs : void 0, c3 = s2 && a3 ? (s2 + a3) / 2 : s2 || a3, d2 = (c3 && o2 ? (c3 + o2) / 2 : c3 || o2) || 0, l2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, u3 = l2 < 0.17 ? 1 : l2 < 0.36 ? 2 : l2 < 0.59 ? 3 : l2 < 0.1 ? 4 : 5, h2 = null == t3 ? void 0 : t3.track;
          if (h2 && h2._encoderConfig && -1 === h2._hints.indexOf(xD.SCREEN_TRACK)) {
            const t4 = h2._encoderConfig.bitrateMax, i3 = e2.bitrate.actualEncoded;
            if (t4 && i3) {
              const e3 = (1e3 * t4 - i3) / (1e3 * t4);
              return GM[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][u3];
            }
          }
          return u3;
        }
        getDownlinkNetworkQuality() {
          if (!this.recvConnection) return 0;
          const e2 = this.recvConnection.getStats();
          let t3 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((i2) => {
            let [n3] = i2;
            const r2 = n3._audioSSRC, o2 = n3._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a3 = e2.videoRecv.find((e3) => e3.ssrc === o2);
            if (!s2 && !a3) return void (t3 += 1);
            const c3 = aO(this, RV.NeedSignalRTT), d2 = e2.rtt, l2 = (d2 && c3 ? (d2 + c3) / 2 : d2 || c3) || 0, u3 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let p2 = 0.7 * h2 * 100 / 50 + 0.3 * l2 / 1500;
            u3 && (p2 = 0.6 * h2 * 100 / 50 + 0.2 * l2 / 1500 + 0.2 * u3 / 400);
            t3 += p2 < 0.1 ? 1 : p2 < 0.17 ? 2 : p2 < 0.36 ? 3 : p2 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t3 / this.remoteUserMap.size) : t3;
        }
        async muteLocalTrack(e2) {
          return new ip2((t3, i2) => {
            this.handleMuteLocalTrack(e2, t3, i2);
          });
        }
        filterTobePublishedTracks(e2, t3, i2) {
          const n3 = [], r2 = fD2(), o2 = this.getAllTracks();
          e2 = uO(e2 = e2.filter((e3) => -1 === o2.indexOf(e3)));
          let s2 = false, a3 = false;
          for (const o3 of e2) {
            if (o3 instanceof kk2 && (this.localTrackMap.has(gV.LocalVideoTrack) || s2 ? new Ow2(ww2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n3.push({ track: o3, type: gV.LocalVideoTrack }), s2 = true), t3)) {
              const e3 = this.getLowVideoTrack(o3, i2);
              n3.push({ track: e3, type: gV.LocalVideoLowTrack });
            }
            if (o3 instanceof BL) {
              const e3 = this.localTrackMap.get(gV.LocalAudioTrack);
              if (e3) {
                if (!(e3.track instanceof WL)) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e3.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
              } else if (a3) {
                const e4 = n3.find((e5) => {
                  let { type: t4 } = e5;
                  return t4 === gV.LocalAudioTrack;
                });
                if (!(e4.track instanceof WL)) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(o3);
              } else {
                if (!r2.webAudioMediaStreamDest || o3 instanceof WL || o3._bypassWebAudio) n3.push({ track: o3, type: gV.LocalAudioTrack });
                else {
                  const e4 = new WL();
                  e4.addAudioTrack(o3), n3.push({ track: e4, type: gV.LocalAudioTrack });
                }
                a3 = true;
              }
            }
          }
          return n3;
        }
        filterTobeUnpublishedTracks(e2) {
          const t3 = [], i2 = this.getAllTracks();
          e2 = uO(e2 = e2.filter((e3) => -1 !== i2.indexOf(e3)));
          for (const i3 of e2) {
            if (i3 instanceof BL) {
              const e3 = this.localTrackMap.get(gV.LocalAudioTrack);
              if (!e3) continue;
              e3.track instanceof WL ? (e3.track.removeAudioTrack(i3), this.unbindLocalAudioTrackEvents(i3), 0 === e3.track.trackList.length && (t3.push([gV.LocalAudioTrack, e3]), e3.track.close())) : t3.push([gV.LocalAudioTrack, e3]);
            }
            if (i3 instanceof kk2) {
              const e3 = this.localTrackMap.get(gV.LocalVideoTrack);
              if (!e3) continue;
              t3.push([gV.LocalVideoTrack, e3]);
              const i4 = this.localTrackMap.get(gV.LocalVideoLowTrack);
              i4 && t3.push([gV.LocalVideoLowTrack, i4]);
            }
          }
          return t3;
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t3, type: i2 } = e3;
            switch (i2) {
              case gV.LocalVideoTrack:
                t3.addListener(VD.GET_STATS, this.handleGetLocalVideoStats), t3.addListener(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t3.addListener(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t3.addListener(VD.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t3.addListener(VD.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t3.addListener(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), t3.addListener(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t3.addListener(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case gV.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t3);
              case gV.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t3) {
          e2 instanceof WL ? e2.trackList.forEach((e3) => {
            e3.addListener(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(VD.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(VD.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t3 || e2.addListener(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t3, { track: i2 }] = e3;
            return { track: i2, type: t3 };
          })), e2.forEach((e3) => {
            let { track: t3, type: i2 } = e3;
            switch (i2) {
              case gV.LocalVideoTrack:
                t3.off(VD.GET_STATS, this.handleGetLocalVideoStats), t3.off(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t3.off(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t3.off(VD.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t3.off(VD.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), t3.off(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), t3.off(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t3.off(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case gV.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t3);
              case gV.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof WL ? e2.trackList.forEach((e3) => {
            e3.off(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(VD.GET_STATS, this.handleGetLocalAudioStats), e3.off(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(VD.GET_STATS, this.handleGetLocalAudioStats), e2.off(VD.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(VD.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(VD.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(VD.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(VD.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t3) {
          t3 instanceof Jk2 && t3.addListener(VD.GET_STATS, (t4) => {
            t4(this.handleGetRemoteVideoStats(e2));
          }), t3 instanceof Zk2 && t3.addListener(VD.GET_STATS, (t4) => {
            t4(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(VD.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t3, i2] = e2;
            i2.has(EV.AUDIO) && this.unbindRemoteTrackEvents(t3._audioTrack), i2.has(EV.VIDEO) && this.unbindRemoteTrackEvents(t3._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t3) {
          return e2.map((e3, i2) => {
            var n3;
            let r2, { track: o2, type: s2 } = e3;
            switch (s2) {
              case gV.LocalAudioTrack:
                r2 = nV.Audio;
                break;
              case gV.LocalVideoTrack:
                r2 = Ln2(n3 = o2._hints).call(n3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalVideoLowTrack:
                r2 = nV.Low;
            }
            return { kind: s2 === gV.LocalAudioTrack ? EV.AUDIO : EV.VIDEO, stream_type: r2, mid: t3[i2].id, ssrcs: t3[i2].localSSRC, isMuted: o2.muted || !o2.enabled };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            var t3;
            let i2, [n3, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n3) {
              case gV.LocalVideoTrack:
                i2 = Ln2(t3 = r2._hints).call(t3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalAudioTrack:
                i2 = nV.Audio;
                break;
              case gV.LocalVideoLowTrack:
                i2 = nV.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          });
        }
        assignLocalTracks(e2, t3) {
          e2.forEach((e3, i2) => {
            let { track: n3, type: r2 } = e3;
            this.localTrackMap.set(r2, { track: n3, id: t3[i2].id, ssrcs: t3[i2].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t3] = e3;
            this.localTrackMap.delete(t3);
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t3) => {
            var i2;
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: ").concat(e2.name, ".onConnectionStateChange(").concat(t3, ")")), this.emit(RV.PeerConnectionStateChange, t3), "connected" !== t3 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t3 && (e2.isInRestartIce = false), Ln2(i2 = this._restartStates).call(i2, t3) && !e2.isInRestartIce && ("disconnected" === t3 && await yO(800), "disconnected" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || this.handleDisconnect(e2.direction));
          }, e2.onICEConnectionStateChange = (e3) => {
            "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), _D.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: qw2.TRACER }).onSuccess(), this.emit(RV.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportStateChange = (e3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
          }, e2.onDTLSTransportError = (e3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
          }, e2.onFirstAudioDecoded = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._audioSSRC === e3);
            var n3;
            i2 && (this.store.subscribe(i2.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n3 = i2.audioTrack) || void 0 === n3 || n3.emit(HD.FIRST_FRAME_DECODED), _D.firstRemoteFrame(this.store.sessionId, lD2.FIRST_AUDIO_DECODE, uD.FIRST_AUDIO_DECODE, { peer: i2._uintid, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._audioSSRC === e3);
            i2 && _D.firstRemoteFrame(this.store.sessionId, lD2.FIRST_AUDIO_RECEIVED, uD.FIRST_AUDIO_RECEIVED, { peer: i2._uintid, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t3, i2) => {
            this.reportVideoFirstFrameDecoded(e3, t3, i2);
          }, e2.onFirstVideoReceived = (e3) => {
            var t3;
            const i2 = Array.from(XN(t3 = this.remoteUserMap).call(t3)).find((t4) => t4._videoSSRC === e3);
            i2 && _D.firstRemoteFrame(this.store.sessionId, lD2.FIRST_VIDEO_RECEIVED, uD.FIRST_VIDEO_RECEIVED, { peer: i2._uintid, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t3) => {
            const i2 = "relay" === e3.candidateType, n3 = "relay" === t3.candidateType;
            "unknown" !== t3.candidateType && i2 === n3 || this.emit(RV.ConnectionTypeChange, i2), sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(ux2(t3)), " -> ").concat(JSON.stringify(ux2(e3)), ")"));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t3) => {
            sD.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(ux2(t3)), " -> ").concat(JSON.stringify(ux2(e3)), ")"));
          }, e2.onFirstVideoDecodedTimeout = (e3) => {
            this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
          }, e2.onLocalCandidate = (t3) => {
            this.emit(RV.LocalCandidate, { candidate: t3, direction: e2.direction });
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0, e2.onLocalCandidate = void 0;
        }
        async handleDisconnect(e2) {
          const t3 = e2 === BU.SEND_ONLY ? this.sendConnection : this.recvConnection;
          t3 && !t3.isInRestartIce && (t3.isInRestartIce = true, sD.debug("[".concat(this.store.clientId, "] [P2PChannel-").concat(t3.name, "] start use restartICE")), e2 === BU.SEND_ONLY ? this.restartICE(e2) : oO(this, RV.RequestP2PRestartICE, { direction: BU.SEND_ONLY }));
        }
        filterTobeMutedTracks(e2) {
          const t3 = [];
          if (-1 === this.getAllTracks().indexOf(e2)) return t3;
          const i2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if (e2 instanceof BL && (null == i2 ? void 0 : i2.track) instanceof WL) return i2.track.isActive || t3.push([gV.LocalAudioTrack, i2]), t3;
          const n3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i3 }] = t4;
            return e2 === i3;
          });
          if (n3 && (t3.push(n3), n3[0] === gV.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(gV.LocalVideoLowTrack);
            e3 && t3.push([gV.LocalVideoLowTrack, e3]);
          }
          return t3;
        }
        filterTobeUnmutedTracks(e2) {
          const t3 = [], i2 = this.localTrackMap.get(gV.LocalAudioTrack);
          if (e2 instanceof BL && (null == i2 ? void 0 : i2.track) instanceof WL) return i2.track.isActive && t3.push([gV.LocalAudioTrack, i2]), t3;
          const n3 = Array.from(this.localTrackMap.entries()).find((t4) => {
            let [, { track: i3 }] = t4;
            return e2 === i3;
          });
          if (n3) if (n3[0] === gV.LocalVideoTrack) {
            t3.push(n3);
            const e3 = this.localTrackMap.get(gV.LocalVideoLowTrack);
            e3 && t3.push([gV.LocalVideoLowTrack, e3]);
          } else t3.push(n3);
          return t3;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            var t3;
            let i2, [n3, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n3) {
              case gV.LocalAudioTrack:
                i2 = nV.Audio;
                break;
              case gV.LocalVideoTrack:
                i2 = Ln2(t3 = r2._hints).call(t3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalVideoLowTrack:
                i2 = nV.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            var t3;
            let i2, [n3, { track: r2, ssrcs: o2, id: s2 }] = e3;
            switch (n3) {
              case gV.LocalAudioTrack:
                i2 = nV.Audio;
                break;
              case gV.LocalVideoTrack:
                i2 = Ln2(t3 = r2._hints).call(t3, xD.SCREEN_TRACK) ? nV.Screen : nV.High;
                break;
              case gV.LocalVideoLowTrack:
                i2 = nV.Low;
            }
            return { stream_type: i2, ssrcs: o2, mid: s2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t3) {
          const i2 = [], n3 = this.remoteUserMap.get(e2);
          if (!n3) return i2;
          if (t3) {
            const r2 = n3.get(t3);
            if (!r2) return i2;
            i2.push([e2, { kind: t3, id: r2 }]);
          } else Array.from(n3.entries()).forEach((t4) => {
            let [n4, r2] = t4;
            i2.push([e2, { kind: n4, id: r2 }]);
          });
          return i2;
        }
        createUnsubscribeMessage(e2) {
          const t3 = [];
          return e2.forEach((e3) => {
            let [i2, { kind: n3, id: r2 }] = e3;
            switch (n3) {
              case EV.VIDEO:
                return void (i2._videoSSRC && t3.push({ stream_type: EV.VIDEO, ssrcId: i2._videoSSRC }));
              case EV.AUDIO:
                return void (i2._audioSSRC && t3.push({ stream_type: EV.AUDIO, ssrcId: i2._audioSSRC }));
            }
          }), t3;
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t3, { kind: i2 }] = e3;
            const n3 = this.remoteUserMap.get(t3);
            n3 && (n3.delete(i2), 0 === Array.from(n3.entries()).length && this.remoteUserMap.delete(t3));
          });
        }
        async updateBitrateLimit(e2) {
          const t3 = this.localTrackMap.get(gV.LocalVideoTrack), i2 = this.localTrackMap.get(gV.LocalVideoLowTrack);
          t3 && (await t3.track.setBitrateLimit(e2.uplink), await new ip2((e3, i3) => {
            this.handleUpdateVideoEncoder(t3.track, e3, i3, true);
          })), i2 && e2.low_stream_uplink && (await i2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 }), await new ip2((e3, t4) => {
            this.handleUpdateVideoEncoder(i2.track, e3, t4, true);
          }));
        }
        isP2PDisconnected() {
          if (this.sendConnection && this.recvConnection) {
            const e2 = this.sendConnection.peerConnectionState, t3 = this.recvConnection.peerConnectionState;
            return "connected" !== e2 && "connected" !== t3;
          }
          return true;
        }
        async tryToUnmuteAudio(e2) {
          for (let t3 = 0; t3 < e2.length; t3++) if (e2[t3] instanceof BL) {
            const i2 = this.filterTobeUnmutedTracks(e2[t3]);
            if (0 === i2.length) continue;
            const n3 = this.createUnmuteMessage(i2);
            return void await sO(this, RV.RequestUnmuteLocal, n3);
          }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = (e2) => this.getStats(e2), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter((e2) => {
            let [, { ssrcs: t3 }] = e2;
            return !!t3;
          }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t3;
            return !(null === (t3 = this.recvConnection) || void 0 === t3 || !t3.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t3) => this.emit(RV.RequestUpload, e2, t3), this.statsUploader.requestUploadStats = (e2) => this.emit(RV.RequestUploadStats, e2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await yO(jO(this.dtlsFailedCount, BO)), this.emit(RV.RequestReconnect);
        }
        async reconnectP2P() {
        }
        canPublishLowStream() {
          return this.localTrackMap.has(gV.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof kk2);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof kk2).length > 1) throw new Ow2(ww2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof BL).length > 1 && (e2.some((e3) => e3 instanceof BL && e3._bypassWebAudio) || !fD2().webAudioMediaStreamDest)) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t3 of e2) {
            if (t3 instanceof kk2 && this.pendingLocalTracks.some((e3) => e3 instanceof kk2)) throw new Ow2(ww2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t3 instanceof BL && this.pendingLocalTracks.some((e3) => e3 instanceof BL) && (!fD2().webAudioMediaStreamDest || t3._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof BL && e3._bypassWebAudio))) throw new Ow2(ww2.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t3) {
          const i2 = !wN("DISABLE_DUAL_STREAM_USE_ENCODING") && fD2().supportDualStreamEncoding, n3 = fq2(fq2({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t3);
          let r2;
          r2 = i2 ? e2._mediaStreamTrack.clone() : wB2(e2, n3);
          const o2 = IO(8, "track-low-"), s2 = new kk2(r2, fq2(fq2({}, i2 && { scaleResolutionDownBy: lx2(n3, e2) }), {}, { frameRate: n3.framerate, bitrateMax: n3.bitrate, bitrateMin: n3.bitrate }), void 0, void 0, o2);
          return s2.on(GD.TRANSCEIVER_UPDATED, (t4) => {
            e2._updateRtpTransceiver(t4, FD.LOW_STREAM);
          }), s2._hints.push(xD.LOW_STREAM), e2.addListener(VD.NEED_CLOSE, () => {
            s2.close();
          }), s2;
        }
        async globalLock() {
          return this.recvMutex.lock("From P2PChannel2.globalLock");
        }
        reportVideoFirstFrameDecoded(e2, t3, i2, n3) {
          var r2;
          const o2 = Array.from(XN(r2 = this.remoteUserMap).call(r2)).find((t4) => t4._videoSSRC === e2);
          if (o2) {
            n3 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
            const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e3) => e3.userId === o2.uid && "video" === e3.type);
            _D.firstRemoteVideoDecode(this.store.sessionId, lD2.FIRST_VIDEO_DECODE, uD.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t3, videoheight: i2, subscribeElapse: YF.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n3 ? 1 : 0 });
          }
        }
        async remoteMediaSsrcChanged(e2, t3, i2) {
          if (!this.recvConnection) return false;
          const n3 = this.remoteUserMap.get(e2);
          if (!n3) return false;
          const r2 = n3.get(t3);
          if (!r2) return false;
          const o2 = await this.recvConnection.getRemoteSSRC(r2);
          return void 0 !== o2 && o2 !== i2;
        }
        isPreSubScribe(e2) {
          return false;
        }
        async publishDataChannel(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        async unpublishDataChannel(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        async subscribeDataChannel(e2, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        async unsubscribeDataChannel(e2, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        hasPendingRemoteDataChannel(e2, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        setPendingRemoteDataChannel(e2, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        async preConnect(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        getEstablishParams() {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        async reSubscribe(e2) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        reportVideoFirstFrameRender(e2) {
        }
        async updateVideoStreamParameter(e2, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED);
        }
        unbindRtpTransceiver() {
          0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t3, { track: i2 }] = e2;
            t3 === gV.LocalVideoLowTrack ? i2._updateRtpTransceiver(void 0, FD.LOW_STREAM) : i2._updateRtpTransceiver(void 0);
          });
        }
      }, OU(Eq2.prototype, "p2pConnect", [rq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "p2pConnect"), Eq2.prototype), OU(Eq2.prototype, "unpublish", [oq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "unpublish"), Eq2.prototype), OU(Eq2.prototype, "unpublishLowStream", [sq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "unpublishLowStream"), Eq2.prototype), OU(Eq2.prototype, "subscribe", [aq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "subscribe"), Eq2.prototype), OU(Eq2.prototype, "mockSubscribe", [cq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "mockSubscribe"), Eq2.prototype), OU(Eq2.prototype, "unsubscribe", [dq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "unsubscribe"), Eq2.prototype), OU(Eq2.prototype, "muteRemote", [lq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "muteRemote"), Eq2.prototype), OU(Eq2.prototype, "unmuteRemote", [uq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "unmuteRemote"), Eq2.prototype), OU(Eq2.prototype, "hasRemoteMediaWithLock", [hq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "hasRemoteMediaWithLock"), Eq2.prototype), OU(Eq2.prototype, "disconnectForReconnect", [pq2], Object.getOwnPropertyDescriptor(Eq2.prototype, "disconnectForReconnect"), Eq2.prototype), OU(Eq2.prototype, "remoteMediaSsrcChanged", [_q], Object.getOwnPropertyDescriptor(Eq2.prototype, "remoteMediaSsrcChanged"), Eq2.prototype), Eq2);
      function gq2(e2) {
        return function(t3, i2, n3) {
          const r2 = t3[i2];
          if ("function" != typeof r2) throw new Error("Cannot use mutex on object property.");
          return n3.value = async function() {
            for (var t4 = arguments.length, n4 = new Array(t4), o2 = 0; o2 < t4; o2++) n4[o2] = arguments[o2];
            switch (e2) {
              case nq2.SEND_ONLY: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n4);
                } finally {
                  e3();
                }
              }
              case nq2.RECEIVE_ONLY: {
                const e3 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n4);
                } finally {
                  e3();
                }
              }
              default: {
                const e3 = await this.sendMutex.lock("From P2PChannel2.".concat(i2)), t5 = await this.recvMutex.lock("From P2PChannel2.".concat(i2));
                try {
                  return await r2.apply(this, n4);
                } finally {
                  e3(), t5();
                }
              }
            }
          }, n3;
        };
      }
      class Tq2 extends Hw2 {
        constructor(e2, t3) {
          super(), uI(this, "signal", void 0), uI(this, "token", void 0), uI(this, "tokenTimeout", void 0), uI(this, "tokenInterval", void 0), uI(this, "_sequence", 0), uI(this, "userMap", /* @__PURE__ */ new Map()), uI(this, "encoder", new TextEncoder()), this.signal = e2, this.token = t3;
          const i2 = () => {
            this.signal.connectionState === MU.CONNECTED && this.check(), 0 === this.userMap.size ? this.tokenInterval = window.setTimeout(i2, 1e3) : this.tokenInterval = window.setTimeout(i2, 3 * wN("P2P_TOKEN_INTERVAL"));
          };
          i2();
        }
        async send(e2, t3, i2, n3, r2) {
          var o2;
          if (0 === this.userMap.size) return;
          const s2 = Array.from(up2(o2 = this.userMap).call(o2))[0].token;
          "string" != typeof t3 && (t3 = JSON.stringify(t3)), n3 = null != n3 ? n3 : IO(6, ""), r2 = null != r2 ? r2 : this._sequence++;
          const a3 = { _id: n3, _type: e2, _seq: r2, _message: t3, token: "".concat(this.token, "_").concat(s2) };
          wN("SHOW_P2P_LOG") && sD.debug("send message", a3, "noNeedResponse : ".concat(i2));
          this.splitMessage(JSON.stringify(a3)).forEach((e3) => {
            this.signal.request(VU.DATA_STREAM, { payload: SO(this.encoder.encode(e3)) });
          });
          const c3 = new ip2((t4, r3) => {
            const o3 = window.setTimeout(() => {
              this.off("res-@".concat(n3, "_ack"), s3), this.off("res-@".concat(n3), d2), this.off(DV.ABORT, c4), sD.debug("[external-signal] request timeout, type: ".concat(e2, ", requestId: ").concat(n3)), 0 === this.userMap.size ? r3(new Ow2(ww2.INVALID_REMOTE_USER)) : r3(new Ow2(ww2.TIMEOUT));
            }, wN("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), s3 = () => {
              o3 && window.clearTimeout(o3), this.off(DV.ABORT, c4), i2 && t4();
            }, c4 = () => {
              o3 && window.clearTimeout(o3), this.off("res-@".concat(n3, "_ack"), s3), this.off("res-@".concat(n3), d2), r3(new Ow2(ww2.EXTERNAL_SIGNAL_ABORT, "type: ".concat(e2, ", requestId: ").concat(n3)));
            };
            this.once(DV.ABORT, c4), this.once("res-@".concat(n3, "_ack"), s3);
            const d2 = (i3, a4) => {
              l2 = true, o3 && window.clearTimeout(o3), this.off("res-@".concat(n3, "_ack"), s3), this.off(DV.ABORT, c4), "success" === i3 ? t4(a4) : r3(new Ow2(ww2.P2P_MESSAGE_FAILED, "request ".concat(e2, " failed, requestId: ").concat(n3)));
            };
            let l2 = false;
            i2 || (this.once("res-@".concat(n3), d2), yO(wN("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              l2 || sD.warning("external_signal request timeout, type: ".concat(e2, ", requestId: ").concat(n3, ", ").concat(a3));
            }));
          });
          try {
            return await c3;
          } catch (o3) {
            if (o3.code === ww2.TIMEOUT) return await this.send(e2, t3, i2, n3, r2);
            throw o3;
          }
        }
        onMessage(e2) {
          var t3;
          const { _uid: i2 } = e2;
          let n3, r2 = this.userMap.get(i2);
          if (r2) n3 = r2.splitMessageMap;
          else {
            if (this.userMap.size > 0 || !("_type" in e2) || e2._type !== NV.CHECK) return;
            const { token: t4 } = e2;
            n3 = /* @__PURE__ */ new Map(), r2 = { uid: i2, isStart: true, token: t4, splitMessageMap: n3, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }, this.userMap.set(i2, r2), this.signal.emit(FU.ON_USER_ONLINE, { uid: i2 }), this.handleUserOnline();
          }
          if ("id" in e2 && "total" in e2) {
            var o2;
            const { id: t4, total: r3 } = e2, s3 = null !== (o2 = n3.get(t4)) && void 0 !== o2 ? o2 : [];
            if (s3.push(e2), n3.has(t4) || n3.set(t4, s3), s3.length !== r3) return;
            {
              const r4 = Xp2(s3).call(s3, (e3, t5) => e3.index - t5.index).map((e3) => e3.payload).join("");
              n3.delete(t4), (e2 = JSON.parse(r4))._uid = i2;
            }
          }
          const { _type: s2, token: a3 } = e2;
          if (Ln2(t3 = [NV.ACK, NV.CHECK]).call(t3, s2)) return s2 === NV.CHECK && this.handleCheckToken(r2, a3), void this.receiveMessage(e2);
          a3 === "".concat(r2.token, "_").concat(this.token) ? this.handleReceivedMessage(e2) : sD.debug('Receive unexpected message", '.concat(a3, ", cur_token: ").concat(r2.token, "_").concat(this.token), e2);
        }
        check() {
          const e2 = { _id: IO(6, ""), token: this.token, _type: NV.CHECK };
          wN("SHOW_P2P_LOG") && sD.debug("send message", e2), this.signal.request(VU.DATA_STREAM, { payload: SO(this.encoder.encode(JSON.stringify(e2))) });
        }
        ack(e2) {
          const t3 = { _id: e2, _type: NV.ACK, token: this.token };
          wN("SHOW_P2P_LOG") && sD.debug("send message", t3), this.signal.request(VU.DATA_STREAM, { payload: SO(this.encoder.encode(JSON.stringify(t3))) });
        }
        response(e2, t3, i2) {
          this.send(NV.RESPONSE, JSON.stringify({ success: !i2, message: t3 }), true, e2);
        }
        handleReceivedMessage(e2) {
          const t3 = () => {
            this.userMap.forEach((e3) => {
              const { receivedMessagesMap: t4, nextExpectedSequenceNumber: i3 } = e3;
              for (; t4.has(i3); ) {
                const n4 = t4.get(i3);
                t4.delete(i3), this.receiveMessage(n4), e3.nextExpectedSequenceNumber++;
              }
            });
          };
          if (!e2) return void t3();
          const { _uid: i2, _seq: n3 } = e2, r2 = this.userMap.get(i2), { receivedMessagesMap: o2, isStart: s2, nextExpectedSequenceNumber: a3 } = r2;
          if (n3 < a3) return this.ack(e2._id), void sD.debug("[external-signal] receive old message, seq: ".concat(n3, ", ").concat(e2._message));
          o2.set(n3, e2), s2 && n3 === a3 && (this.receiveMessage(e2), o2.delete(a3), r2.nextExpectedSequenceNumber++, t3());
        }
        receiveMessage(e2) {
          const { _id: t3, _type: i2, _message: n3, _uid: r2 } = e2;
          if (wN("SHOW_P2P_LOG") && sD.debug("receive message", e2), t3) {
            let o2;
            switch (e2._type !== NV.ACK && (n3 && (o2 = JSON.parse(n3)), this.ack(e2._id)), e2._type) {
              case NV.CANDIDATE:
              case NV.CONTROL:
                this.signal.emit(i2, o2, r2);
                break;
              case NV.PUBLISH:
              case NV.UNPUBLISH:
              case NV.RESTART_ICE:
              case NV.CALL:
                o2.uid = r2, oO(this.signal, i2, o2).then((t4) => {
                  this.response(e2._id, t4);
                }).catch(() => {
                  this.response(e2._id, void 0, true);
                });
                break;
              case NV.ACK:
                this.getListeners("res-@".concat(t3, "_ack")).length > 0 && this.emit("res-@".concat(t3, "_ack"));
                break;
              case NV.RESPONSE: {
                const { success: e3, message: i3 } = o2;
                this.emit("res-@".concat(t3), e3 ? "success" : "failed", i3);
                break;
              }
            }
          }
        }
        splitMessage(e2) {
          if (e2.length < Tq2.MAX_MESSAGE_SIZE) return [e2];
          const t3 = [], { remoteToken: i2 } = JSON.parse(e2), n3 = IO(6, "");
          let r2 = 0, o2 = 800;
          const s2 = Math.ceil(e2.length / o2);
          for (; e2.length > 0; ) {
            r2++;
            const a3 = { id: n3, index: r2, total: s2, payload: e2.slice(0, o2), token: "".concat(this.token, "_").concat(i2) };
            JSON.stringify(a3).length > Tq2.MAX_MESSAGE_SIZE ? o2 -= 50 : (t3.push(a3), e2 = e2.slice(o2));
          }
          return t3.map((e3) => JSON.stringify(e3));
        }
        handleCheckToken(e2, t3) {
          return e2.token !== t3 ? (sD.debug("token changed, from ".concat(e2.token, " to ").concat(t3)), this.reset(e2.uid, t3), false) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout(() => {
            sD.debug("token timeout, ".concat(t3)), this.reset(e2.uid);
          }, wN("MAX_P2P_TIMEOUT")), true);
        }
        async handleUserOnline() {
          const e2 = await oO(this.signal, NV.CALL, void 0), t3 = await this.send(NV.CALL, e2);
          this.signal.emit(UU.P2P_CONNECTION, t3, true);
        }
        async reset(e2, t3) {
          const i2 = this.userMap.get(e2);
          i2 && (this.emit(DV.ABORT), this.signal.emit(FU.ON_USER_OFFLINE, { uid: i2.uid, reason: LV.P2P_TOKEN_CHANGED }), this._sequence = 0, this.userMap.clear(), t3 || (sD.debug("change local token from ".concat(t3, " to ").concat(t3)), this.token = IO(6, "")));
        }
        clear() {
          this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(DV.ABORT);
        }
      }
      uI(Tq2, "MAX_SIZE", 1), uI(Tq2, "MAX_MESSAGE_SIZE", 1024);
      class Rq2 extends Hw2 {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === MU.CONNECTED ? this.emit(UU.WS_CONNECTED) : e2 === MU.RECONNECTING ? this.emit(UU.WS_RECONNECTING, this._websocketReconnectReason) : e2 === MU.CLOSED && this.emit(UU.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket && this.websocket.url || null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t3) {
          super(), uI(this, "_disconnectedReason", void 0), uI(this, "_websocketReconnectReason", void 0), uI(this, "_connectionState", MU.CLOSED), uI(this, "reconnectToken", void 0), uI(this, "p2pToken", void 0), uI(this, "websocket", void 0), uI(this, "openConnectionTime", void 0), uI(this, "clientId", void 0), uI(this, "lastMsgTime", Date.now()), uI(this, "uploadCache", []), uI(this, "uploadCacheInterval", void 0), uI(this, "rttRolling", new HO(5)), uI(this, "pingpongTimer", void 0), uI(this, "pingpongTimeoutCount", 0), uI(this, "joinResponse", void 0), uI(this, "multiIpOption", void 0), uI(this, "initError", void 0), uI(this, "spec", void 0), uI(this, "store", void 0), uI(this, "_external_signal", void 0), uI(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer) return void this.emit(UU.ON_BINARY_DATA, e3.data);
            const t4 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t4, "_id")) {
              const e4 = "res-@".concat(t4._id);
              this.emit(e4, t4._result, t4._message);
            } else if (Object.prototype.hasOwnProperty.call(t4, "_type")) {
              switch (t4._type) {
                case FU.ON_DATA_STREAM:
                  return void this.handleDataStream(t4._message);
                case FU.MUTE_AUDIO:
                case FU.MUTE_VIDEO:
                case FU.ON_P2P_LOST:
                case FU.ON_USER_ONLINE:
                  return;
                case FU.ON_USER_OFFLINE:
                  const { uid: e4 } = t4._message;
                  return sD.debug("[".concat(this.clientId, "] user-offline uid: ").concat(e4)), void this._external_signal.reset(e4);
              }
              if (this.emit(t4._type, t4._message), t4._type === FU.ON_NOTIFICATION && this.handleNotification(t4._message), t4._type === FU.ON_USER_BANNED) switch (t4._message.error_code) {
                case 14:
                  this.close(Zw2.UID_BANNED);
                  break;
                case 15:
                  this.close(Zw2.IP_BANNED);
                  break;
                case 16:
                  this.close(Zw2.CHANNEL_BANNED);
              }
              if (t4._type === FU.ON_USER_LICENSE_BANNED) switch (t4._message.error_code) {
                case kU.ERR_LICENSE_MISSING:
                  this.close(Zw2.LICENSE_MISSING);
                  break;
                case kU.ERR_LICENSE_EXPIRED:
                  this.close(Zw2.LICENSE_EXPIRED);
                  break;
                case kU.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(Zw2.LICENSE_MINUTES_EXCEEDED);
                  break;
                case kU.ERR_LICENSE_PERIOD_INVALID:
                  this.close(Zw2.LICENSE_PERIOD_INVALID);
                  break;
                case kU.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(Zw2.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case kU.ERR_LICENSE_ILLEGAL:
                  this.close(Zw2.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
            }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t3, this.websocket = new XV("gateway-".concat(this.clientId), this.spec.retryConfig, true, wN("JOIN_GATEWAY_USE_DUAL_DOMAIN"), wN("JOIN_GATEWAY_USE_443PORT_ONLY"), t3), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === MU.CONNECTED && this.reconnect("retry", iO.OFFLINE);
          }), this.p2pToken = IO(6, ""), this._external_signal = new Tq2(this, this.p2pToken);
        }
        async request(e2, t3, i2, n3) {
          const r2 = IO(6, ""), o2 = { _id: r2, _type: e2, _message: t3 }, s2 = this.websocket.connectionID, a3 = () => new ip2((e3, t4) => {
            if (this.connectionState === MU.CONNECTED) return e3();
            const i3 = () => {
              this.off(UU.WS_CLOSED, n4), e3();
            }, n4 = () => {
              this.off(UU.WS_CONNECTED, i3), t4(new Ow2(ww2.WS_ABORT));
            };
            this.once(UU.WS_CONNECTED, i3), this.once(UU.WS_CLOSED, n4);
          });
          if (this.connectionState !== MU.CONNECTING && this.connectionState !== MU.RECONNECTING || e2 === VU.JOIN || e2 === VU.REJOIN || await a3(), this.websocket.sendMessage(o2, true), n3) return;
          const c3 = new ip2((i3, n4) => {
            let o3 = false;
            const a4 = (n5, r3) => {
              o3 = true, i3({ isSuccess: "success" === n5, message: r3 || {} }), this.off(UU.WS_CLOSED, c4), this.off(UU.WS_RECONNECTING, c4), this.emit(UU.REQUEST_SUCCESS, e2, t3);
            };
            this.once("res-@".concat(r2), a4);
            const c4 = () => {
              n4(new Ow2(ww2.WS_ABORT, "type: ".concat(e2))), this.off(UU.WS_CLOSED, c4), this.off(UU.WS_RECONNECTING, c4), this.off("res-@".concat(r2), a4);
            };
            this.once(UU.WS_CLOSED, c4), this.once(UU.WS_RECONNECTING, c4), yO(wN("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (sD.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(UU.REQUEST_TIMEOUT, e2, t3));
            });
          });
          let d2 = null;
          try {
            d2 = await c3;
          } catch (n4) {
            if (this.connectionState === MU.CLOSED || e2 === VU.LEAVE) throw new Ow2(ww2.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || i2 ? n4.throw() : e2 === VU.JOIN || e2 === VU.REJOIN ? null : (await a3(), await this.request(e2, t3));
          }
          if (d2.isSuccess) return d2.message;
          const l2 = Number(d2.message.error_code || d2.message.code), u3 = VV(l2), h2 = new Ow2(ww2.UNEXPECTED_RESPONSE, "".concat(u3.desc, ": ").concat(d2.message.error_str), { code: l2, data: d2.message, desc: u3.desc });
          return "success" === u3.action ? d2.message : (sD.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(l2, ", message: ").concat(u3.desc, ", action: ").concat(u3.action)), l2 === kU.ERR_TOO_MANY_BROADCASTERS ? e2 === VU.JOIN || e2 === VU.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : "failed" === u3.action ? h2.throw() : "quit" === u3.action ? (this.initError = h2, this.close(), h2.throw()) : (l2 === kU.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, sD.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", iO.MULTI_IP)) : this.reconnect(u3.action, iO.SERVER_ERROR), e2 === VU.JOIN || e2 === VU.REJOIN ? null : await this.request(e2, t3)));
        }
        waitMessage(e2, t3) {
          return new ip2((i2) => {
            const n3 = (r2) => {
              (!t3 || t3(r2)) && (this.off(e2, n3), i2(r2));
            };
            this.on(e2, n3);
          });
        }
        uploadWRTCStats(e2) {
          if (!this.store.sessionId) return void sD.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
          const t3 = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e2 };
          this.upload(xU.WRTC_STATS, t3);
        }
        upload(e2, t3) {
          const i2 = { _type: e2, _message: t3 };
          try {
            this.websocket.sendMessage(i2);
          } catch (e3) {
            const t4 = wN("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(i2), this.uploadCache.length > t4 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== MU.CONNECTED) return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, wN("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t3) {
          const i2 = { _type: e2, _message: t3 };
          this.websocket.sendMessage(i2);
        }
        async sendExtensionMessage(e2, t3, i2) {
          return await this._external_signal.send(e2, t3, i2);
        }
        init(e2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new ip2((t3, i2) => {
            this.once(UU.WS_CONNECTED, () => t3(this.joinResponse)), this.once(UU.WS_CLOSED, () => i2(this.initError || new Ow2(ww2.WS_ABORT))), this.connectionState = MU.CONNECTING, this.websocket.init(e2).catch(i2);
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e2 || Zw2.LEAVE, this.connectionState = MU.CLOSED, sD.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), this.p2pToken = IO(6, ""), this._external_signal.clear(), this._external_signal = new Tq2(this, this.p2pToken);
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(UU.ABORT_P2P_EXECUTION);
            const e2 = await oO(this, UU.REQUEST_JOIN_INFO), t3 = await this.request(VU.JOIN, e2);
            if (!t3) return this.emit(UU.REPORT_JOIN_GATEWAY, ww2.TIMEOUT, this.url || ""), false;
            this.joinResponse = t3, this.emit(UU.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = MU.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        reconnect(e2, t3) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t3);
        }
        async downgradeCodec(e2) {
          return false;
        }
        handleDataStream(e2) {
          try {
            var t3;
            const i2 = fO(e2.payload), n3 = new TextDecoder().decode(i2), r2 = JSON.parse(n3);
            "total" in r2 && "id" in r2 || Ln2(t3 = Object.values(NV)).call(t3, r2._type) ? (r2._uid = e2.uid, this._external_signal.onMessage(r2)) : this.emit(FU.ON_DATA_STREAM, e2);
          } catch (t4) {
            this.emit(FU.ON_DATA_STREAM, e2);
          }
        }
        handleNotification(e2) {
          sD.debug("[".concat(this.clientId, "] receive notification: "), e2);
          const t3 = VV(e2.code);
          if ("success" !== t3.action) {
            if ("failed" !== t3.action) return "quit" === t3.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t3.desc && this.close(Zw2.UID_BANNED), void this.close()) : void this.reconnect(t3.action, iO.SERVER_ERROR);
            sD.error("[".concat(this.clientId, "] ignore error: "), t3.desc);
          }
        }
        handlePingPong() {
          if (!this.websocket || "connected" !== this.websocket.state) return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = wN("PING_PONG_TIME_OUT"), t3 = Date.now();
          this.pingpongTimeoutCount >= e2 && (sD.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t3 - this.lastMsgTime, "ms")), t3 - this.lastMsgTime > wN("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", iO.TIMEOUT) : this.request(VU.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t3;
            this.rttRolling.add(e3), wN("REPORT_STATS") && this.send(VU.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWebsocketEvents() {
          this.websocket.on(jU.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(UU.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(jU.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(jU.CLOSED, () => {
            this.connectionState = MU.CLOSED;
          }), this.websocket.on(jU.FAILED, () => {
            this._disconnectedReason = Zw2.NETWORK_ERROR, this.connectionState = MU.CLOSED;
          }), this.websocket.on(jU.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === MU.CONNECTED ? this.connectionState = MU.RECONNECTING : this.connectionState = MU.CONNECTING;
          }), this.websocket.on(jU.WILL_RECONNECT, (e2, t3, i2) => {
            "retry" !== e2 ? (sD.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0) : sD.debug("".concat(this.clientId, " reconnect mode is retry, no need to renew session")), i2(e2);
          }), this.websocket.on(jU.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.join().catch((e2) => {
              if (this.emit(UU.REPORT_JOIN_GATEWAY, e2, this.url || ""), e2 instanceof Ow2 && e2.code === ww2.UNEXPECTED_RESPONSE && e2.data.code === kU.ERR_NO_AUTHORIZED) return sD.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", iO.SERVER_ERROR);
              sD.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", iO.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(jU.REQUEST_NEW_URLS, (e2, t3) => {
            oO(this, UU.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t3);
          }), this.websocket.on(jU.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            this.emit(FU.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
          });
        }
      }
      const vq2 = { name: "P2PChannel", create: function(e2) {
        let { store: t3, statsCollector: i2 } = e2;
        return new Sq2(t3, i2);
      }, createSubmodule: function(e2) {
        let { store: t3, spec: i2 } = e2;
        return new Rq2(i2, t3);
      } };
      function Cq2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function yq2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? Cq2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Cq2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      class Iq2 {
        constructor(e2) {
          uI(this, "sessionDesc", void 0), uI(this, "localCapabilities", void 0), uI(this, "rtpCapabilities", void 0), uI(this, "candidates", void 0), uI(this, "_originCandidates", void 0), uI(this, "iceParameters", void 0), uI(this, "dtlsParameters", void 0), uI(this, "setup", void 0), uI(this, "currentMidIndex", void 0), uI(this, "cname", void 0), e2 = pO(e2);
          const { iceParameters: t3, dtlsParameters: i2, candidates: n3, rtpCapabilities: r2, setup: o2, localCapabilities: s2, sdkCodec: a3, cname: c3 } = e2, d2 = FN("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = r2, this.candidates = n3, this._originCandidates = pO(n3), this.iceParameters = t3, this.dtlsParameters = i2, this.setup = o2, this.localCapabilities = s2, this.cname = c3;
          for (let e3 = 0; e3 < d2.mediaDescriptions.length; e3++) {
            const s3 = d2.mediaDescriptions[e3];
            if (s3.attributes.iceUfrag = t3.iceUfrag, s3.attributes.icePwd = t3.icePwd, s3.attributes.fingerprints = i2.fingerprints, s3.attributes.candidates = n3, s3.attributes.setup = o2, "video" === s3.media.mediaType) {
              s3.media.fmts = r2.videoCodecs.map((e5) => e5.payloadType.toString(10));
              const e4 = r2.videoCodecs.filter((e5) => {
                var t5, i3;
                return null === (t5 = e5.rtpMap) || void 0 === t5 ? void 0 : Ln2(i3 = t5.encodingName.toLowerCase()).call(i3, a3);
              }), t4 = r2.videoCodecs.filter((t5) => !Ln2(e4).call(e4, t5));
              s3.attributes.payloads = [...e4, ...t4], s3.attributes.extmaps = r2.videoExtensions;
            }
            "audio" === s3.media.mediaType && (s3.media.fmts = r2.audioCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = r2.audioCodecs, s3.attributes.extmaps = r2.audioExtensions), d2.mediaDescriptions[e3] = this.mungMediaDesc(s3);
          }
          this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
        }
        toString() {
          return BN(this.sessionDesc);
        }
        send(e2, t3, i2) {
          const { ssrcs: n3, ssrcGroups: r2 } = bx2(t3, this.cname), o2 = this.sessionDesc.mediaDescriptions.find((t4) => e2 === EV.VIDEO ? "video" === t4.media.mediaType : "audio" === t4.media.mediaType), s2 = n3[0].attributes.label, a3 = n3[0].attributes.mslabel;
          return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(n3), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(r2), { id: s2, mslabel: a3 };
        }
        batchSend(e2) {
          return e2.map((e3) => {
            let { kind: t3, ssrcMsg: i2 } = e3;
            return this.send(t3, i2, void 0);
          });
        }
        stopSending(e2) {
          this.sessionDesc.mediaDescriptions.forEach((t3) => {
            const i2 = [], n3 = [], r2 = [];
            t3.attributes.ssrcs.forEach((t4) => {
              Ln2(e2).call(e2, t4.attributes.label || "") ? r2.push(t4) : i2.push(t4);
            }), t3.attributes.ssrcGroups.forEach((e3) => {
              var t4;
              Ln2(t4 = r2.map((e4) => e4.ssrcId)).call(t4, e3.ssrcIds[0]) || n3.push(e3);
            }), t3.attributes.ssrcs = i2, t3.attributes.ssrcGroups = n3;
          });
        }
        mute(e2) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e2);
          if (!t3) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t3.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t3 = this.sessionDesc.mediaDescriptions.find((t4) => t4.attributes.mid === e2);
          if (!t3) throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t3.attributes.direction = "sendonly";
        }
        receive(e2, t3, i2) {
          e2.forEach((e3, t4) => {
            const i3 = e3._mediaStreamTrack, n3 = this.sessionDesc.mediaDescriptions.findIndex((e4) => e4.attributes.mid === i3.kind), r2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n3], e3);
            this.sessionDesc.mediaDescriptions[n3] = r2;
          });
        }
        stopReceiving(e2) {
        }
        updateCandidates(e2) {
          const t3 = this._originCandidates.filter((e3) => "udp" === e3.transport), i2 = [];
          if (t3.forEach((e3) => {
            i2.push(yq2(yq2({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
          }), 0 !== t3.length) {
            switch (e2) {
              case mV.TCP_RELAY:
                this.candidates = i2;
                break;
              case mV.UDP_TCP_RELAY:
              case mV.RELAY:
                this.candidates = [...t3, ...i2];
                break;
              default:
                this.candidates = t3;
            }
            for (const e3 of this.sessionDesc.mediaDescriptions) e3.attributes.candidates = this.candidates;
          }
        }
        restartICE(e2) {
          e2 = pO(e2), this.iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e2.iceUfrag, t3.attributes.icePwd = e2.icePwd;
          });
        }
        predictReceivingMids(e2) {
          const t3 = [];
          for (let i2 = 0; i2 < e2; i2++) t3.push((this.currentMidIndex + i2 + 1).toString(10));
          return t3;
        }
        mungRecvMediaDsec(e2, t3) {
          const i2 = pO(e2);
          return Ax2(i2, t3), Ox2(i2, t3), i2;
        }
        updateRecvMedia(e2, t3) {
          const i2 = this.sessionDesc.mediaDescriptions.findIndex((t4) => t4.attributes.mid === e2);
          if (-1 !== i2) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], t3);
            this.sessionDesc.mediaDescriptions[i2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        updateTrackLabel(e2, t3, i2) {
          const n3 = this.sessionDesc.mediaDescriptions.find((t4) => e2 === EV.VIDEO ? "video" === t4.attributes.mid : "audio" === t4.attributes.mid);
          if (n3) {
            const e3 = n3.attributes.ssrcs.find((e4) => e4.attributes.label === t3);
            var r2;
            if (e3) e3.attributes.label = i2, null === (r2 = e3.attributes.msid) || void 0 === r2 || r2.replace(t3, i2);
          }
        }
        mungMediaDesc(e2) {
          const t3 = pO(e2);
          return wx2(t3), function(e3) {
            const t4 = e3.attributes.extmaps.find((e4) => Sx2(e4.extensionName));
            t4 && e3.attributes.extmaps.splice(e3.attributes.extmaps.indexOf(t4), 1), e3.attributes.payloads.forEach((e4) => {
              const t5 = e4.rtcpFeedbacks.findIndex((e5) => "transport-cc" === e5.type);
              -1 !== t5 && e4.rtcpFeedbacks.splice(t5, 1);
            });
          }(t3), t3;
        }
        getSSRC(e2) {
          for (const t3 of this.sessionDesc.mediaDescriptions) for (const i2 of t3.attributes.ssrcs) if (i2.attributes.label === e2) return [i2];
        }
      }
      var bq2;
      function Aq2(e2, t3) {
        var i2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var n3 = Object.getOwnPropertySymbols(e2);
          t3 && (n3 = n3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
          })), i2.push.apply(i2, n3);
        }
        return i2;
      }
      function wq2(e2) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var i2 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? Aq2(Object(i2), true).forEach(function(t4) {
            uI(e2, t4, i2[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : Aq2(Object(i2)).forEach(function(t4) {
            Object.defineProperty(e2, t4, Object.getOwnPropertyDescriptor(i2, t4));
          });
        }
        return e2;
      }
      let Oq2 = (bq2 = class e2 extends _V {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get localCodecs() {
          return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map((e3) => e3.rtpMap && e3.rtpMap.encodingName.toLowerCase() || "").filter((e3) => {
            var t3;
            return Ln2(t3 = Object.keys(PN)).call(t3, e3);
          }))];
        }
        constructor(t3, i2) {
          super(t3, i2), uI(this, "store", void 0), uI(this, "peerConnection", void 0), uI(this, "remoteSDP", void 0), uI(this, "initialOffer", void 0), uI(this, "statsFilter", void 0), uI(this, "useRTX", false), uI(this, "localCapabilities", void 0), uI(this, "localCandidateCount", 0), uI(this, "allCandidatesReceived", false), uI(this, "establishPromise", void 0), uI(this, "mutex", void 0), this.store = i2, this.mutex = new xO("P2PConnection-mutex", i2.clientId), this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t3), { optional: [{ googDscp: true }] }), this.statsFilter = EN(this.peerConnection, wN("STATS_UPDATE_INTERVAL"), void 0, iw2() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
        }
        async establish() {
          try {
            const e3 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e3.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t3 = vx2(e3.sdp), i2 = Rx2(e3.sdp, { filterRTX: !this.useRTX, filterVideoFec: wN("FILTER_VIDEO_FEC"), filterAudioFec: wN("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
            return this.localCapabilities = i2, this.initialOffer = e3, wq2(wq2({}, t3), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i2 }, offerSDP: e3.sdp });
          } catch (e3) {
            throw new Ow2(ww2.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async updateRemoteConnect() {
        }
        async connect(e3) {
          try {
            if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new Iq2(wq2(wq2({}, e3), {}, { rtpCapabilities: e3.rtpCapabilities.send, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec }));
            const t3 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: t3 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        async updateRemoteRTPCapabilities(e3, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        getPreMedia(e3) {
        }
        send(e3, t3) {
          var i2 = this;
          return qb2(function* () {
            const n3 = yield Jb2(i2.mutex.lock());
            try {
              if (!i2.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const r2 = e3.map((e4) => i2.peerConnection.addTrack(e4._mediaStreamTrack)), o2 = yield Jb2(i2.peerConnection.createOffer()), s2 = FN(o2.sdp), a3 = e3.map((e4) => {
                const t4 = e4._mediaStreamTrack, n4 = s2.mediaDescriptions.find((e5) => e5.attributes.mid === t4.kind);
                if (!n4) throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e5, t5, i3) {
                  const n5 = e5.attributes.ssrcs.filter((e6) => e6.attributes.label === t5), r3 = e5.attributes.ssrcGroups;
                  if (0 === n5.length) throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (r3 && n5.length > 1) {
                    const e6 = r3.find((e7) => -1 !== e7.ssrcIds.indexOf(n5[0].ssrcId));
                    return e6 ? [{ ssrcId: e6.ssrcIds[0], rtx: i3 ? e6.ssrcIds[1] : void 0 }] : [{ ssrcId: n5[0].ssrcId }];
                  }
                  return [{ ssrcId: n5[0].ssrcId }];
                }(n4, t4.id, i2.useRTX);
              });
              let c3;
              try {
                c3 = yield a3;
              } catch (e4) {
                throw r2.forEach((e5) => {
                  $A2() && e5.replaceTrack(null), i2.peerConnection.removeTrack(e5);
                }), e4;
              }
              const d2 = i2.mungSendOfferSDP(o2.sdp, e3);
              i2.remoteSDP.receive(e3, t3, c3);
              const l2 = i2.remoteSDP.toString();
              return yield Jb2(i2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield Jb2(i2.applySendEncodings(r2, e3)), yield Jb2(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: l2 })), e3.map((e4, t4) => {
                const i3 = e4._mediaStreamTrack.id;
                return { localSSRC: a3[t4], id: i3 };
              });
            } catch (e4) {
              throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              n3();
            }
          })();
        }
        async stopSending(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getSenders().filter((t4) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t4.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t3.length !== e3.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map((e4) => {
              $A2() && e4.replaceTrack(null), this.peerConnection.removeTrack(e4);
            });
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e3);
            const n3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          }
        }
        async receive(e3, t3, i2, n3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { id: i3, mslabel: r2 } = this.remoteSDP.send(e3, t3, n3), o2 = new ip2((t4, n4) => {
              const o3 = setTimeout(() => {
                n4(new Error("Cannot receive track, id: ".concat(i3)));
              }, 1e4), s3 = (n5) => {
                const a4 = zA2();
                if (("Safari" === a4.name && 11 === Number(a4.version) || nw2()) && n5.track.id !== i3 && n5.streams[0].id === r2) {
                  var c3;
                  const r3 = n5.streams[0].getTracks()[0];
                  return null === (c3 = this.remoteSDP) || void 0 === c3 || c3.updateTrackLabel(e3, i3, n5.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t4(r3);
                }
                if (n5.track.id === i3) return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t4(n5.track);
              };
              this.peerConnection.addEventListener("track", s3);
            }), s2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
            const a3 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a3);
            return { track: await o2, id: i3 };
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const i2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(i2);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
        }
        async unmuteRemote(e3) {
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t3 = this.peerConnection.getSenders().filter((t4) => {
              var i2;
              return -1 !== e3.indexOf((null === (i2 = t4.track) || void 0 === i2 ? void 0 : i2.id) || "");
            });
            if (t3.length !== e3.length) throw new Error("sender' length doesn't match mids' length.");
            t3.map((e4) => {
              if ($A2() && e4.track) e4.track.enabled = false;
              else {
                const t4 = e4.getParameters();
                t4.encodings.forEach((e5) => e5.active = false), e4.setParameters(t4);
              }
            });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t3 = this.peerConnection.getSenders().filter((t4) => {
              var i3;
              return -1 !== e3.indexOf((null === (i3 = t4.track) || void 0 === i3 ? void 0 : i3.id) || "");
            });
            if (t3.length !== e3.length) throw new Error("Senders' length doesn't match mids' length.");
            t3.map(async (e4) => {
              if ($A2() && e4.track) e4.track.enabled = true;
              else {
                const t4 = e4.getParameters();
                t4.encodings.forEach((e5) => e5.active = true), await e4.setParameters(t4);
              }
            });
            const i2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(i2);
            const n3 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        restartICE(e3) {
          var t3 = this;
          return qb2(function* () {
            const i2 = yield Jb2(t3.mutex.lock("From P2PConnection.restartICE"));
            try {
              if (!t3.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
              const n3 = fD2().supportPCSetConfiguration;
              if (e3 === mV.RELAY && !n3) return;
              if (n3) {
                const i3 = t3.peerConnection.getConfiguration(), n4 = e3 === mV.RELAY ? "relay" : "all";
                i3.iceTransportPolicy !== n4 && (sD.debug("[".concat(t3.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i3.iceTransportPolicy, "] to [").concat(n4, "]")), i3.iceTransportPolicy = n4, t3.peerConnection.setConfiguration(i3));
              }
              e3 !== mV.RELAY && t3.remoteSDP.updateCandidates(e3);
              const r2 = yield Jb2(t3.peerConnection.createOffer({ iceRestart: true }));
              if (!r2.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
              const o2 = vx2(r2.sdp), { remoteIceParameters: s2 } = yield o2.iceParameters;
              t3.remoteSDP.restartICE(s2);
              const a3 = t3.remoteSDP.toString();
              yield Jb2(t3.peerConnection.setLocalDescription(r2)), yield Jb2(t3.peerConnection.setRemoteDescription({ type: "answer", sdp: a3 }));
            } catch (e4) {
              sD.warning("[".concat(t3.store.clientId, "] restart ICE failed, abort operation"), e4);
            } finally {
              i2();
            }
          })();
        }
        close() {
          var e3;
          this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e4 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(e4.sdp, [t3]);
            this.remoteSDP.updateRecvMedia(t3._mediaStreamTrack.kind, t3);
            const n3 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n3 });
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t3) {
          const i2 = this.peerConnection.getSenders().filter((t4) => {
            var i3;
            return (null === (i3 = t4.track) || void 0 === i3 ? void 0 : i3.id) === e3;
          });
          1 === i2.length && await this.applySendEncodings(i2, [t3]);
        }
        setStatsRemoteVideoIsReady(e3, t3) {
          this.statsFilter.setVideoIsReady2(e3, t3);
        }
        async replaceTrack(e3, t3) {
          const i2 = this.peerConnection.getSenders().find((e4) => {
            var i3;
            return (null === (i3 = e4.track) || void 0 === i3 ? void 0 : i3.id) === t3;
          });
          i2 && await i2.replaceTrack(e3._mediaStreamTrack);
        }
        createDataChannels(e3, t3) {
          throw new Ow2(ww2.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
        }
        stopDataChannels(e3) {
          throw new Ow2(ww2.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, sD.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, sD.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, wN("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t3) {
          const i2 = { iceServers: [], sdpSemantics: "plan-b" };
          return t3.iceServers ? i2.iceServers = t3.iceServers : t3.turnServer && "off" !== t3.turnServer.mode && (Qw2(t3.turnServer.servers) ? i2.iceServers = t3.turnServer.servers : (i2.iceServers && i2.iceServers.push(...e2.turnServerConfigToIceServers(t3.turnServer.servers)), wN("USE_TURN_SERVER_OF_GATEWAY") && i2.iceServers && t3.turnServer.serversFromGateway && i2.iceServers.push(...e2.turnServerConfigToIceServers(t3.turnServer.serversFromGateway)), t3.turnServer.servers.concat(t3.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (i2.iceTransportPolicy = "relay");
          }))), i2;
        }
        static turnServerConfigToIceServers(e3) {
          const t3 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t3.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t3;
        }
        async updateRtpSenderEncodings(e3, t3) {
          var i2;
          if (!t3) {
            t3 = this.peerConnection.getSenders().find((t4) => {
              var i3;
              return (null === (i3 = t4.track) || void 0 === i3 ? void 0 : i3.id) === e3._mediaStreamTrack.id;
            });
          }
          if (!t3) return sD.warn("[".concat(e3.getTrackId(), "] no rtpSender found}"));
          if (!fD2().supportSetRtpSenderParameters) return sD.warn("Browser not support set rtp-sender parameters");
          const n3 = {}, r2 = {};
          if (e3 instanceof kk2) switch (e3._optimizationMode) {
            case "motion":
              n3.degradationPreference = "maintain-framerate";
              break;
            case "detail":
              n3.degradationPreference = "maintain-resolution";
              break;
            default:
              n3.degradationPreference = "balanced";
          }
          if (wN("DSCP_TYPE") && vw2()) {
            var o2;
            const e4 = wN("DSCP_TYPE");
            Ln2(o2 = ["very-low", "low", "medium", "high"]).call(o2, e4) && (r2.networkPriority = e4);
          }
          const s2 = t3.getParameters(), a3 = null === (i2 = s2.encodings) || void 0 === i2 ? void 0 : i2[0];
          a3 && Object.assign(a3, r2), Object.assign(s2, n3), sD.debug("[".concat(e3.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(s2.encodings))), await t3.setParameters(s2);
        }
        async applySendEncodings(e3, t3) {
          try {
            if (!fD2().supportSetRtpSenderParameters) return;
            if (e3.length !== t3.length) return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              const n3 = e3[i2], r2 = t3[i2];
              n3 && r2 && await this.updateRtpSenderEncodings(r2, n3);
            }
          } catch (e4) {
            sD.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
          }
        }
        mungSendOfferSDP(e3, t3) {
          const i2 = FN(e3);
          return t3.forEach((e4, t4) => {
            const n3 = e4._mediaStreamTrack, r2 = i2.mediaDescriptions.find((e5) => e5.attributes.mid === n3.kind);
            r2 && Ax2(r2, e4);
          }), BN(i2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t3;
            null === (t3 = this.onFirstAudioReceived) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t3;
            null === (t3 = this.onFirstVideoReceived) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t3;
            null === (t3 = this.onFirstAudioDecoded) || void 0 === t3 || t3.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t3, i2) => {
            var n3;
            null === (n3 = this.onFirstVideoDecoded) || void 0 === n3 || n3.call(this, e3, t3, i2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t3) => {
            var i2;
            null === (i2 = this.onSelectedLocalCandidateChanged) || void 0 === i2 || i2.call(this, e3, t3);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t3) => {
            var i2;
            null === (i2 = this.onSelectedRemoteCandidateChanged) || void 0 === i2 || i2.call(this, e3, t3);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t3 = this.remoteSDP.batchSend(e3).map((t4, i3) => {
              let { id: n4, mslabel: r2 } = t4;
              const { kind: o2 } = e3[i3];
              return new ip2((e4, t5) => {
                const i4 = setTimeout(() => {
                  t5(new Error("Cannot receive track, id: ".concat(n4)));
                }, 1e4), s2 = (t6) => {
                  const a3 = zA2();
                  if ("Safari" === a3.name && 11 === Number(a3.version) && t6.track.id !== n4 && t6.streams[0].id === r2) {
                    var c3;
                    const r3 = t6.streams[0].getTracks()[0];
                    return null === (c3 = this.remoteSDP) || void 0 === c3 || c3.updateTrackLabel(o2, n4, t6.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e4({ track: r3, id: n4 });
                  }
                  if (t6.track.id === n4) return this.peerConnection.removeEventListener("track", s2), clearTimeout(i4), void e4({ track: t6.track, id: n4 });
                };
                this.peerConnection.addEventListener("track", s2);
              });
            }), i2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i2 });
            const n3 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(n3), await ip2.all(t3);
          } catch (e4) {
            throw new Ow2(ww2.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async getRemoteSSRC(e3) {
          if (!this.remoteSDP) return;
          const t3 = this.remoteSDP.getSSRC(e3);
          return null == t3 ? void 0 : t3[0].ssrcId;
        }
        setConfiguration(t3) {
          if (fD2().supportPCSetConfiguration) {
            const i2 = e2.resolvePCConfiguration(t3);
            this.peerConnection.setConfiguration(i2);
          }
        }
      }, OU(bq2.prototype, "connect", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "connect"), bq2.prototype), OU(bq2.prototype, "stopSending", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "stopSending"), bq2.prototype), OU(bq2.prototype, "receive", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "receive"), bq2.prototype), OU(bq2.prototype, "stopReceiving", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "stopReceiving"), bq2.prototype), OU(bq2.prototype, "muteRemote", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "muteRemote"), bq2.prototype), OU(bq2.prototype, "unmuteRemote", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "unmuteRemote"), bq2.prototype), OU(bq2.prototype, "muteLocal", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "muteLocal"), bq2.prototype), OU(bq2.prototype, "unmuteLocal", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "unmuteLocal"), bq2.prototype), OU(bq2.prototype, "close", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "close"), bq2.prototype), OU(bq2.prototype, "updateEncoderConfig", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "updateEncoderConfig"), bq2.prototype), OU(bq2.prototype, "updateSendParameters", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "updateSendParameters"), bq2.prototype), OU(bq2.prototype, "replaceTrack", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "replaceTrack"), bq2.prototype), OU(bq2.prototype, "getRemoteSSRC", [Nq2], Object.getOwnPropertyDescriptor(bq2.prototype, "getRemoteSSRC"), bq2.prototype), bq2);
      function Nq2(e2, t3, i2) {
        const n3 = e2[t3];
        if ("function" != typeof n3) throw new Error("Cannot use mutex on object property.");
        return i2.value = async function() {
          const e3 = this.mutex, i3 = await e3.lock("Locking from P2PConnection.".concat(t3));
          try {
            for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++) o2[s2] = arguments[s2];
            return await n3.apply(this, o2);
          } finally {
            i3();
          }
        }, i2;
      }
      const Dq2 = { name: "PlanBConnection", create: function(e2) {
        let { store: t3, spec: i2 } = e2;
        return new Oq2(i2, t3);
      } }, Pq2 = { interceptLocalAudioFrame: async function(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!fD2().supportWebRTCEncodedTransform) return void sD.warning("browser not support audio encoded transform");
        if (lM.has(e2)) return;
        if (!e2.track) return;
        const i2 = { track: e2.track };
        if (QA2()) {
          if (!e2.createEncodedStreams) return void sD.warning("browser not support createEncodedStreams() API");
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void sD.error("create audio-encoded-streams error", e3 && e3.message);
          }
          const o2 = new TransformStream({ transform(r3, o3) {
            i2.controller || (i2.controller = o3), e2.track && e2.track.id !== i2.track.id && (sD.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3));
            const s2 = t3.metadata && t3.metadata();
            s2 ? function(e3, t4) {
              const { chunk: i3, controller: n4 } = t4, r4 = cM.METADATA;
              i3.data = function(e4, t5, i4) {
                const n5 = i4.byteLength, r5 = n5 + sM + aM, o4 = rM + oM + r5, s3 = new ArrayBuffer(e4.byteLength + o4), a3 = new DataView(s3);
                a3.setUint8(0, nM), a3.setUint16(1, r5), a3.setUint8(3, t5), a3.setUint16(4, n5);
                for (let e5 = 0; e5 < n5; e5++) a3.setUint8(6 + e5, i4[e5]);
                const c3 = new Uint8Array(a3.buffer);
                return c3.set(new Uint8Array(e4), o4), c3.buffer;
              }(i3.data, r4, e3), n4.enqueue(i3);
            }(s2, { sender: e2, chunk: r3, controller: o3 }) : o3.enqueue(r3);
          } });
          r2.readable.pipeThrough(o2).pipeTo(r2.writable);
        } else if ($A2()) {
          if ("undefined" == typeof RTCRtpScriptTransform) return void sD.warning("browser not support RTCRtpScriptTransform");
          const r2 = iM(), o2 = new MessageChannel();
          await new ip2((e3) => r2.onmessage = (t4) => {
            "registered" === t4.data && e3(void 0);
          });
          const s2 = new RTCRtpScriptTransform(r2, { name: "audio-metadata-tx", port: o2.port2 }, [o2.port2]);
          e2.transform = s2, await new ip2((e3) => r2.onmessage = (t4) => {
            "started" === t4.data && e3(void 0);
          }), o2.port1.onmessage = (r3) => {
            var s3;
            if (r3.data.transformed && e2.track && (null === (s3 = e2.track) || void 0 === s3 ? void 0 : s3.id) !== i2.track.id) sD.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3);
            else if (r3.data.getMetadata) {
              const e3 = t3.metadata && t3.metadata();
              e3 && o2.port1.postMessage({ metadata: e3 });
            }
          }, i2.worker = r2;
        }
        function n3() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n3);
          }
          const t4 = lM.get(e2);
          if (t4) {
            lM.delete(e2);
            try {
              var i3, r2;
              null === (i3 = t4.controller) || void 0 === i3 || i3.terminate(), null === (r2 = t4.worker) || void 0 === r2 || r2.terminate();
            } catch (e3) {
              sD.warning(e3 && e3.message);
            }
          }
        }
        lM.set(e2, i2), e2.track.addEventListener("ended", n3);
      }, interceptRemoteAudioFrame: async function(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!fD2().supportWebRTCEncodedTransform) return void sD.warning("browser not support audio encoded transform");
        if (PM.has(e2)) return;
        const i2 = { track: e2.track, onMetadata: t3.onMetadata, onPts: t3.onPts };
        if (QA2() && !nw2()) {
          if (!e2.createEncodedStreams) return void sD.warning("browser not support createEncodedStreams() API");
          sw2(WA2.CHROME, 87, 116) || (t3.enableTopn = false);
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void sD.error("create audio-encoded-streams error", e3 && e3.message);
          }
          const o2 = new TransformStream({ transform(r3, o3) {
            i2.controller || (i2.controller = o3), e2.track && e2.track.id !== i2.track.id && (sD.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3)), t3.enableTopn ? function(e3, t4, i3) {
              var n4;
              const r4 = dM(new DataView(t4.data));
              if (!r4) return i3.enqueue(t4);
              const o4 = e3.track.id;
              LM.set(o4, e3.track);
              const s2 = null === (n4 = r4.tlv.find((e4) => e4.tag === cM.AUDIO_LEVEL)) || void 0 === n4 ? void 0 : n4.value;
              let a3 = 0;
              "number" == typeof s2 && (a3 = 127 - s2);
              const c3 = Math.round(Math.pow(10, a3 / 60) - 1), { selected: d2, speaker: l2 } = function(e4, t5) {
                let i4 = vM.get(e4);
                if (i4 || (i4 = function(e5) {
                  const t6 = new SM();
                  return vM.set(e5, t6), CM || (CM = new RM(wN("TOPN_SILENCE_THRESHOLD") || 500), CM.on("ActiveSpeakerChanged", (e6) => {
                    null != e6 && (yM = e6);
                  })), CM.addSpeakers([t6]), t6;
                }(e4)), vM.size <= IM) return { selected: true, speaker: i4 };
                if (!CM) throw new Error("no active speaker detector");
                return CM.levelChanged(i4.id, t5), bM = CM.loudest.map((e5) => e5.id), yM && !Ln2(bM).call(bM, yM) && bM.length >= IM && bM.pop(), { selected: Ln2(bM).call(bM, i4.id) || i4.id === yM, speaker: i4 };
              }(e3, c3), u3 = function(e4, t5, i4) {
                const n5 = AM.get(e4) || new OM(e4, t5);
                return n5.score = i4, AM.set(e4, n5), function(e5) {
                  if (wM.set(e5, true), !NM) return void (NM = Date.now());
                  const t6 = Date.now();
                  t6 - NM > 1e3 && (wM.get(e5) ? wM.set(e5, false) : (DM(e5), wM.delete(e5)), NM = t6);
                }(e4), n5;
              }(o4, e3.track, l2.energyScore);
              u3.addSample(d2), u3.active && (t4.data = r4.frame.buffer, i3.enqueue(t4));
            }(e2, r3, o3) : t3.enableMetadata || t3.enablePts ? function(e3, t4, i3, n4) {
              const r4 = new DataView(e3.data), o4 = r4.getUint8(0);
              let s2;
              if (0 != (128 & o4) && 71 !== o4) {
                const t5 = function(e4) {
                  if (e4.byteLength <= 0) return [];
                  const t6 = [];
                  let i4 = 0;
                  for (; i4 < e4.byteLength; ) {
                    const n6 = (128 & e4.getUint8(i4)) >> 7, r5 = 127 & e4.getUint8(i4);
                    if (!(n6 && i4 + 4 <= e4.byteLength)) {
                      i4++;
                      break;
                    }
                    {
                      const n7 = e4.getUint32(i4, false), o5 = (16776192 & n7) >> 10, s3 = 1023 & n7;
                      t6.push({ pt: r5, ts_offset: o5, length: s3, data: new Uint8Array() }), i4 += 4;
                    }
                  }
                  let n5 = e4.byteLength - i4;
                  for (const r5 of t6) {
                    if (r5.length > n5) return console.warn("Broken red payload"), [];
                    r5.length > 0 && (r5.data = new Uint8Array(e4.buffer, e4.byteOffset + i4, r5.length), i4 += r5.length, n5 -= r5.length);
                  }
                  if (n5 > 0) {
                    const r5 = { pt: t6.length > 0 ? t6[t6.length - 1].pt : 0, ts_offset: 0, length: n5, data: new Uint8Array(e4.buffer, e4.byteOffset + i4, n5) };
                    t6.push(r5);
                  }
                  return t6;
                }(r4);
                if (t5.length > 0) {
                  const i4 = function(e4) {
                    let t6 = 0;
                    for (let i6 = 0; i6 < e4.length; i6++) t6 += i6 < e4.length - 1 ? 4 : 1, t6 += e4[i6].length;
                    const i5 = new Uint8Array(t6);
                    let n5 = 0;
                    for (let t7 = 0; t7 < e4.length; t7++) if (t7 < e4.length - 1) {
                      const r5 = (2147483648 | (127 & e4[t7].pt) << 24 | (262143 & e4[t7].ts_offset) << 10 | 1023 & e4[t7].length) >>> 0;
                      i5[n5++] = r5 >> 24 & 255, i5[n5++] = r5 >> 16 & 255, i5[n5++] = r5 >> 8 & 255, i5[n5++] = 255 & r5;
                    } else i5[n5++] = 127 & e4[t7].pt;
                    for (const t7 of e4) i5.set(t7.data, n5), n5 += t7.length;
                    return i5;
                  }(t5.map((e4) => {
                    const t6 = new Uint8Array(e4.length);
                    t6.set(e4.data);
                    const i5 = dM(new DataView(t6.buffer));
                    return null != i5 && i5.frame && (e4.data = null == i5 ? void 0 : i5.frame), s2 = i5, e4;
                  }));
                  e3.data = i4.buffer;
                }
              } else s2 = dM(r4), s2 && (e3.data = s2.frame.buffer);
              if (t4.enqueue(e3), !s2) return;
              const a3 = s2.tlv.find((e4) => e4.tag === cM.METADATA);
              a3 && i3 && a3.value instanceof Uint8Array && i3(a3.value);
              const c3 = s2.tlv.find((e4) => e4.tag === cM.AUDIO_64_BIT_PTS);
              c3 && n4 && c3.value instanceof Uint8Array && 8 == c3.value.length && n4(new DataView(c3.value.buffer).getBigUint64(0, true));
            }(r3, o3, t3.onMetadata, t3.onPts) : o3.enqueue(r3);
          } });
          r2.readable.pipeThrough(o2).pipeTo(r2.writable);
        } else {
          if ("undefined" == typeof RTCRtpScriptTransform) return void sD.warning("browser not support RTCRtpScriptTransform");
          const t4 = iM(), r2 = new MessageChannel();
          await new ip2((e3) => t4.onmessage = (t5) => {
            "registered" === t5.data && e3(void 0);
          });
          const o2 = new RTCRtpScriptTransform(t4, { name: "audio-metadata-rx", port: r2.port2 }, [r2.port2]);
          e2.transform = o2, await new ip2((e3) => t4.onmessage = (t5) => {
            "started" === t5.data && e3(void 0);
          }), r2.port1.onmessage = (t5) => {
            var r3;
            t5.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id ? (sD.debug("audio track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3)) : t5.data.metadata && i2.onMetadata ? i2.onMetadata(t5.data.metadata) : t5.data.pts && i2.onPts && i2.onPts(t5.data.pts);
          }, i2.worker = t4;
        }
        function n3() {
          e2.track.removeEventListener("ended", n3), function(e3) {
            const t4 = PM.get(e3);
            if (t4) {
              !function(e4) {
                const t5 = vM.get(e4);
                t5 && (vM.delete(e4), CM && (CM.removeSpeakers([t5]), 0 === vM.size && (CM.destroy(), CM = null)));
              }(e3), DM(e3.track.id), PM.delete(e3);
              try {
                var i3, n4;
                null === (i3 = t4.controller) || void 0 === i3 || i3.terminate(), null === (n4 = t4.worker) || void 0 === n4 || n4.terminate();
              } catch (e4) {
                sD.warning(e4 && e4.message);
              }
            }
          }(e2);
        }
        PM.set(e2, i2), e2.track.addEventListener("ended", n3);
      }, interceptLocalVideoFrame: async function(e2, t3) {
        if (!fD2().supportWebRTCEncodedTransform) return void sD.warning("browser not support video encoded transform");
        if (FM.has(e2)) return;
        if (!e2.track) return;
        const i2 = { track: e2.track };
        if (QA2()) {
          if (!e2.createEncodedStreams) return void sD.warning("browser not support createEncodedStreams() API");
          let r2 = null;
          try {
            r2 = e2.createEncodedStreams();
          } catch (e3) {
            return void sD.error("create video-encoded-streams error", e3 && e3.message);
          }
          const o2 = [];
          t3.on("sei-to-send", (e3) => {
            o2.push(e3);
          });
          const s2 = new TransformStream({ transform(t4, r3) {
            i2.controller || (i2.controller = r3), e2.track && e2.track.id !== i2.track.id && (sD.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3));
            const s3 = xM(new Uint8Array(t4.data)), a3 = o2.shift();
            if (a3) {
              const e3 = function(e4, t5, i3) {
                switch (i3) {
                  case kM:
                    return function(e5, t6) {
                      const i4 = VM(t6), n4 = i4.length, r4 = Math.floor(n4 / 255), o3 = n4 % 255, s4 = new Uint8Array(6 + r4 + 1 + n4 + e5.byteLength);
                      s4[0] = 0, s4[1] = 0, s4[2] = 0, s4[3] = 1, s4[4] = 6, s4[5] = 101;
                      let a4 = 0;
                      for (; a4 < r4; ) s4[6 + a4] = 255, a4++;
                      return s4[6 + a4] = o3, a4++, s4.set(i4, 6 + a4), s4.set(new Uint8Array(e5), 6 + a4 + n4), s4.buffer;
                    }(e4, t5);
                  case MM:
                    return function(e5, t6) {
                      const i4 = VM(t6), n4 = i4.length, r4 = Math.floor(n4 / 255), o3 = n4 % 255, s4 = new Uint8Array(7 + r4 + 1 + n4 + 1 + e5.byteLength);
                      s4[0] = 0, s4[1] = 0, s4[2] = 0, s4[3] = 1, s4[4] = 78, s4[5] = 1, s4[6] = 101;
                      let a4 = 0;
                      for (; a4 < r4; ) s4[7 + a4] = 255, a4++;
                      return s4[7 + a4] = o3, a4++, s4.set(i4, 7 + a4), a4 += n4, s4[7 + a4] = 128, a4++, s4.set(new Uint8Array(e5), 7 + a4), s4.buffer;
                    }(e4, t5);
                  default:
                    return null;
                }
              }(t4.data, a3, s3);
              e3 && (t4.data = e3);
            }
            r3.enqueue(t4);
          } });
          r2.readable.pipeThrough(s2).pipeTo(r2.writable);
        } else {
          if (!$A2()) return;
          {
            if ("undefined" == typeof RTCRtpScriptTransform) return void sD.warning("browser not support RTCRtpScriptTransform");
            const r2 = iM(), o2 = new MessageChannel();
            await new ip2((e3) => r2.onmessage = (t4) => {
              "registered" === t4.data && e3(void 0);
            });
            const s2 = new RTCRtpScriptTransform(r2, { name: "sei-tx", port: o2.port2 }, [o2.port2]);
            e2.transform = s2, await new ip2((e3) => r2.onmessage = (t4) => {
              "started" === t4.data && e3(void 0);
            }), t3.on("sei-to-send", (e3) => {
              o2.port1.postMessage({ sei: e3 });
            }), o2.port1.onmessage = (t4) => {
              var r3;
              t4.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id && (sD.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3));
            }, i2.worker = r2;
          }
        }
        function n3() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n3);
          }
          const t4 = FM.get(e2);
          if (t4) {
            FM.delete(e2);
            try {
              var i3, r2;
              null === (i3 = t4.controller) || void 0 === i3 || i3.terminate(), null === (r2 = t4.worker) || void 0 === r2 || r2.terminate();
            } catch (e3) {
              sD.warning(e3 && e3.message);
            }
          }
        }
        FM.set(e2, i2), e2.track.addEventListener("ended", n3);
      }, interceptRemoteVideoFrame: async function(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!fD2().supportWebRTCEncodedTransform) return void sD.warning("browser not support video encoded transform");
        if (!e2.track) return;
        if (BM.has(e2)) {
          const i3 = BM.get(e2);
          return void (i3 && (i3.onSei = t3.onSei));
        }
        const i2 = { track: e2.track, onSei: t3.onSei };
        if (QA2()) {
          if (!e2.createEncodedStreams) return void sD.warning("browser not support createEncodedStreams() API");
          let t4 = null;
          try {
            t4 = e2.createEncodedStreams();
          } catch (e3) {
            return void sD.error("create video-encoded-streams error", e3 && e3.message);
          }
          const r2 = new TransformStream({ transform(t5, r3) {
            i2.controller || (i2.controller = r3), e2.track && e2.track.id !== i2.track.id && (sD.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3));
            const o2 = function(e3, t6) {
              switch (t6) {
                case kM:
                  return function(e4) {
                    const t7 = new DataView(e4.data);
                    let i3 = 0;
                    for (; i3 + 4 < e4.data.byteLength; ) {
                      if (0 === t7.getUint8(i3 + 0) && 0 === t7.getUint8(i3 + 1) && 0 === t7.getUint8(i3 + 2) && 1 === t7.getUint8(i3 + 3) && 6 === t7.getUint8(i3 + 4)) {
                        let n4 = i3 + 6, r4 = 0, o3 = 0;
                        for (; 255 === (o3 = t7.getUint8(n4++)); ) r4 += 255;
                        r4 += o3;
                        const s2 = UM(e4.data, n4, r4);
                        return new Uint8Array(s2);
                      }
                      i3++;
                    }
                    return null;
                  }(e3);
                case MM:
                  return function(e4) {
                    const t7 = new DataView(e4.data);
                    let i3 = 0;
                    for (; i3 + 5 < e4.data.byteLength; ) {
                      if (0 === t7.getUint8(i3 + 0) && 0 === t7.getUint8(i3 + 1) && 0 === t7.getUint8(i3 + 2) && 1 === t7.getUint8(i3 + 3) && 78 === t7.getUint8(i3 + 4) && 1 === t7.getUint8(i3 + 5) && 101 === t7.getUint8(i3 + 6)) {
                        let n4 = i3 + 7, r4 = 0, o3 = 0;
                        for (; 255 === (o3 = t7.getUint8(n4++)); ) r4 += 255;
                        r4 += o3;
                        const s2 = UM(e4.data, n4, r4);
                        return new Uint8Array(s2);
                      }
                      i3++;
                    }
                    return null;
                  }(e3);
                default:
                  return null;
              }
            }(t5, xM(new Uint8Array(t5.data)));
            o2 && i2.onSei && i2.onSei(o2), r3.enqueue(t5);
          } });
          t4.readable.pipeThrough(r2).pipeTo(t4.writable);
        } else if ($A2()) {
          if ("undefined" == typeof RTCRtpScriptTransform) return void sD.warning("browser not support RTCRtpScriptTransform");
          const t4 = iM(), r2 = new MessageChannel();
          await new ip2((e3) => t4.onmessage = (t5) => {
            "registered" === t5.data && e3(void 0);
          });
          const o2 = new RTCRtpScriptTransform(t4, { name: "sei-rx", port: r2.port2 }, [r2.port2]);
          e2.transform = o2, await new ip2((e3) => t4.onmessage = (t5) => {
            "started" === t5.data && e3(void 0);
          }), r2.port1.onmessage = (t5) => {
            var r3;
            t5.data.transformed && e2.track && (null === (r3 = e2.track) || void 0 === r3 ? void 0 : r3.id) !== i2.track.id ? (sD.debug("video track changed: ".concat(i2.track.id, " => ").concat(e2.track.id)), i2.track.removeEventListener("ended", n3), i2.track = e2.track, i2.track.addEventListener("ended", n3)) : t5.data.sei && i2.onSei && i2.onSei(t5.data.sei);
          }, i2.worker = t4;
        }
        function n3() {
          if (e2.track) {
            if (this.id !== e2.track.id) return;
            e2.track.removeEventListener("ended", n3);
          }
          !function(e3) {
            const t4 = BM.get(e3);
            if (t4) {
              BM.delete(e3);
              try {
                var i3, n4;
                null === (i3 = t4.controller) || void 0 === i3 || i3.terminate(), null === (n4 = t4.worker) || void 0 === n4 || n4.terminate();
              } catch (e4) {
                sD.warning(e4 && e4.message);
              }
            }
          }(e2);
        }
        BM.set(e2, i2), e2.track.addEventListener("ended", n3);
      } }, Lq2 = { name: "InterceptFrame", create: () => Pq2 };
      fN(), AN("PROCESS_ID", "process-".concat(IO(8, ""), "-").concat(IO(4, ""), "-").concat(IO(4, ""), "-").concat(IO(4, ""), "-").concat(IO(12, ""))), function() {
        let e2;
        try {
          e2 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e3) {
          return void sD.error("Error loading sdk config", e3.message);
        }
        if (e2) try {
          const t3 = JSON.parse(window.atob(e2)), i2 = Date.now();
          sD.debug("Loading global parameters from cache", t3), Object.keys(t3).forEach((e3) => {
            if (Object.prototype.hasOwnProperty.call(bN, e3)) {
              const { value: n3, expires: r2 } = t3[e3];
              if (r2 && r2 <= i2) return;
              NN[e3] = n3, bN[e3] = n3;
            }
          });
        } catch (t3) {
          sD.error("Error loading mutableParamsCache: ".concat(e2), t3.message);
        }
      }(), Array.isArray(NN.AREAS) && NN.AREAS.length > 0 && _F(NN.AREAS, true);
      const kq2 = (e2, t3, i2) => {
        sD.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t3))), AN(e2, t3, i2);
      };
      Xx2(QY, false), Xx2(oz2, false), Xx2(EG, false), Xx2(Uz2, false), Xx2(XY, false), Xx2(vq2, false), Xx2(Dq2, false), Xx2(Lq2, false);
      const Mq2 = function(e2) {
        const t3 = new Hw2(), i2 = e2, n3 = { getListeners: t3.getListeners.bind(t3), on: (e3, i3) => (function(e4, t4) {
          e4 === bV.SECURITY_POLICY_VIOLATION && EW(t4, true);
        }(e3, i3), t3.on.bind(t3)(e3, i3)), addListener: t3.addListener.bind(t3), once: t3.once.bind(t3), off: t3.off.bind(t3), removeAllListeners: t3.removeAllListeners.bind(t3), emit: t3.emit.bind(t3), safeEmit: t3.safeEmit.bind(t3) };
        return pW(pW({}, i2), n3);
      }({ __TRACK_LIST__: MD, VERSION: SN, BUILD: yN, ESM_BUNDLER: false, ESM: false, UMD: true, DEV: false, setParameter: kq2, getParameter: wN, getSupportedCodec: async function() {
        let e2 = { audio: [], video: [] };
        try {
          let t3 = new RTCPeerConnection();
          const i2 = await async function(e3) {
            let t4;
            return fD2().supportUnifiedPlan ? (e3.addTransceiver("video", { direction: "recvonly" }), e3.addTransceiver("audio", { direction: "recvonly" }), t4 = (await e3.createOffer()).sdp) : t4 = (await e3.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })).sdp, t4;
          }(t3);
          if (!i2) return e2;
          t3.close(), t3 = null, e2 = function(e3) {
            const t4 = { video: [], audio: [] };
            return e3.match(/ VP8/i) && t4.video.push("VP8"), e3.match(/ VP9/i) && t4.video.push("VP9"), e3.match(/ AV1/i) && t4.video.push("AV1"), e3.match(/ H264/i) && t4.video.push("H264"), e3.match(/ H265/i) && t4.video.push("H265"), e3.match(/ opus/i) && t4.audio.push("OPUS"), e3.match(/ PCMU/i) && t4.audio.push("PCMU"), e3.match(/ PCMA/i) && t4.audio.push("PCMA"), e3.match(/ G722/i) && t4.audio.push("G722"), t4;
          }(i2);
        } catch (e3) {
          throw new ED(ww2.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
        }
        return e2;
      }, checkSystemRequirements: function() {
        const e2 = _D.reportApiInvoke(null, { name: zw2.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: qw2.TRACER });
        let t3 = false;
        try {
          const e3 = window.RTCPeerConnection, i3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n4 = window.WebSocket;
          t3 = !!(e3 && i3 && n4), t3 && Rw2() && ow2(75) && new e3().close();
        } catch (e3) {
          return sD.error("check system requirement failed: ", e3), false;
        }
        let i2 = false;
        const n3 = zA2();
        n3.name === WA2.CHROME && Number(n3.version) >= 58 && ("WebKit" !== KA2.engine.name || function() {
          const e3 = zA2();
          if (ZA2()) {
            if (e3.os === GA2.MAC_OS) return true;
            if (e3.os === GA2.IOS) {
              const e4 = KA2.os.version && KA2.os.version.split(".");
              if (e4 && 14 === Number(e4[0]) && e4[1] && Number(e4[1]) >= 3) return true;
              if (e4 && Number(e4[0]) > 14) return true;
            }
          }
          return false;
        }()) && (i2 = true), (n3.name === WA2.FIREFOX && Number(n3.version) >= 56 || n3.name === WA2.OPERA && Number(n3.version) >= 45 || n3.name === WA2.SAFARI && Number(n3.version) >= 11 || "WebKit" === n3.name && (nw2() || Sw2()) && n3.osVersion && Number(n3.osVersion.split(".")[0]) >= 11 || gw2() || zA2().name === WA2.QQ) && (i2 = true), sD.debug("checkSystemRequirements, api:", t3, "browser", i2);
        const r2 = t3 && i2;
        return e2.onSuccess(r2), r2;
      }, getDevices: function(e2) {
        return PP.enumerateDevices(true, true, e2);
      }, getMicrophones: function(e2) {
        return PP.getRecordingDevices(e2);
      }, getCameras: function(e2) {
        return PP.getCamerasDevices(e2);
      }, getElectronScreenSources: yP, getPlaybackDevices: function(e2) {
        return PP.getSpeakers(e2);
      }, createClient: function() {
        var e2;
        let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const i2 = IO(5, "client-"), n3 = _D.reportApiInvoke(null, { id: i2, name: zw2.CREATE_CLIENT, options: [t3], tag: qw2.TRACER });
        try {
          !function(e3) {
            Dw2(e3.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), Dw2(e3.mode, "config.mode", ["rtc", "live", "p2p"]), void 0 !== e3.audioCodec && Dw2(e3.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e3.proxyServer && kw2(e3.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e3.turnServer && $w2(e3.turnServer), void 0 !== e3.httpRetryConfig && Xw2(e3.httpRetryConfig), void 0 !== e3.websocketRetryConfig && Xw2(e3.websocketRetryConfig);
          }(t3);
        } catch (e3) {
          throw n3.onError(e3), e3;
        }
        return (uw2(16, 0, true) || hw2(16, 0, true)) && ("vp9" === t3.codec && (t3.codec = "vp8", sD.debug("browser not support vp9, force use vp8")), AN("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), void 0 === t3.audioCodec && (t3.audioCodec = "opus"), n3.onSuccess(), new sW(oW(oW({ forceWaitGatewayResponse: true }, t3), {}, { role: Ln2(e2 = ["rtc", "p2p"]).call(e2, t3.mode) ? "host" : t3.role || "audience" }), i2);
      }, createCameraVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t3 = wN("CAMERA_CAPTURE_CONFIG"), i2 = IO(8, "track-cam-"), n3 = _D.reportApiInvoke(null, { id: i2, tag: qw2.TRACER, name: zw2.CREATE_CAM_VIDEO_TRACK, options: [dP({}, e2), t3] });
        t3 && (e2.encoderConfig = t3);
        const r2 = zP(e2);
        let o2 = null;
        sD.info("start create camera video track with config", JSON.stringify(e2), "trackId", i2);
        try {
          o2 = (await wP({ video: r2 }, i2)).getVideoTracks()[0] || null;
        } catch (e3) {
          throw n3.onError(e3), e3;
        }
        if (!o2) {
          const e3 = new Ow2(ww2.UNEXPECTED_ERROR, "can not find track in media stream");
          return n3.onError(e3), e3.throw(sD);
        }
        if (e2.optimizationMode && Uk2(i2, o2, e2, ND(e2.encoderConfig)), wN("USE_STANDARD_BITRATE_DEFAULT")) {
          const t4 = ND(e2.encoderConfig);
          e2.encoderConfig = t4, delete t4.bitrateMax, delete t4.bitrateMin;
        }
        const s2 = new Mk2(o2, e2, r2, e2.scalabiltyMode ? PD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, i2);
        return n3.onSuccess(s2.getTrackId()), sD.info("create camera video success, trackId:", i2), s2;
      }, createCustomVideoTrack: function(e2) {
        const t3 = IO(8, "track-cus-"), i2 = _D.reportApiInvoke(null, { id: t3, tag: qw2.TRACER, name: zw2.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] });
        wN("USE_STANDARD_BITRATE_DEFAULT") && (delete e2.bitrateMax, delete e2.bitrateMin);
        const n3 = new kk2(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? PD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, t3, [xD.CUSTOM_TRACK]);
        return i2.onSuccess(n3.getTrackId()), sD.info("create custom video track success with config", e2, "trackId", n3.getTrackId()), n3;
      }, createScreenVideoTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
        const i2 = "object" == typeof t3 ? function(e3) {
          return qP(e3);
        }(t3) : void 0;
        i2 && (t3 = "auto");
        const n3 = IO(8, "track-scr-v-"), r2 = _D.reportApiInvoke(null, { id: n3, tag: qw2.TRACER, name: zw2.CREATE_SCREEN_VIDEO_TRACK, options: [dP({}, e2), t3] });
        e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
        const o2 = function(e3) {
          const t4 = {};
          e3.screenSourceType && (t4.mediaSource = e3.screenSourceType), e3.extensionId && QA2() && (t4.extensionId = e3.extensionId);
          const { displaySurface: i3, selfBrowserSurface: n4, surfaceSwitching: r3, systemAudio: o3, preferCurrentTab: s3 } = e3;
          (rw2(107) || aw2(107) || pw2(93)) && (i3 && (Dw2(i3, "displaySurface", ["browser", "window", "monitor"]), t4.displaySurface = i3), n4 ? (Dw2(n4, "selfBrowserSurface", ["exclude", "include"]), t4.selfBrowserSurface = n4) : t4.selfBrowserSurface = "include", r3 && (Dw2(r3, "surfaceSwitching", ["exclude", "include"]), t4.surfaceSwitching = r3)), (rw2(105) || aw2(105) || pw2(91)) && o3 && (Dw2(o3, "systemAudio", ["exclude", "include"]), t4.systemAudio = o3), (rw2(94) || aw2(94) || pw2(80)) && s3 && (t4.preferCurrentTab = true), e3.electronScreenSourceId && (t4.sourceId = e3.electronScreenSourceId);
          const a4 = e3.encoderConfig ? DD(e3.encoderConfig) : null;
          return t4.mandatory = { chromeMediaSource: "desktop", maxWidth: a4 ? a4.width : void 0, maxHeight: a4 ? a4.height : void 0 }, a4 && (a4.frameRate && ("number" == typeof a4.frameRate ? (t4.mandatory.maxFrameRate = a4.frameRate, t4.mandatory.minFrameRate = a4.frameRate) : (t4.mandatory.maxFrameRate = a4.frameRate.max || a4.frameRate.ideal || a4.frameRate.exact || void 0, t4.mandatory.minFrameRate = a4.frameRate.min || a4.frameRate.ideal || a4.frameRate.exact || void 0), t4.frameRate = a4.frameRate), a4.width && (t4.width = a4.width), a4.height && (t4.height = a4.height)), t4;
        }(e2);
        let s2 = null, a3 = null;
        const c3 = fD2();
        if (!c3.supportShareAudio && "enable" === t3) {
          const e3 = new Ow2(ww2.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return r2.onError(e3), e3.throw(sD);
        }
        sD.info("start create screen video track with config", e2, "withAudio", t3, "trackId", n3);
        const d2 = c3.supportShareAudio && "disable" !== t3;
        try {
          const e3 = await wP({ screen: o2, screenAudio: d2 ? i2 || true : void 0 }, n3);
          s2 = e3.getVideoTracks()[0] || null, a3 = e3.getAudioTracks()[0] || null;
        } catch (e3) {
          throw r2.onError(e3), e3;
        }
        if (!s2) {
          const e3 = new Ow2(ww2.UNEXPECTED_ERROR, "can not find track in media stream");
          return r2.onError(e3), e3.throw(sD);
        }
        if (!a3 && "enable" === t3) {
          s2 && s2.stop();
          const e3 = new Ow2(ww2.SHARE_AUDIO_NOT_ALLOWED);
          return r2.onError(e3), e3.throw(sD);
        }
        e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode && (Uk2(n3, s2, e2, e2.encoderConfig && DD(e2.encoderConfig) || void 0), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax));
        const l2 = new kk2(s2, e2.encoderConfig ? DD(e2.encoderConfig) : {}, e2.scalabiltyMode ? PD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n3, [xD.SCREEN_TRACK]);
        if (!a3) return r2.onSuccess(l2.getTrackId()), sD.info("create screen video track success", "video:", l2.getTrackId()), l2;
        const u3 = new BL(a3, void 0, IO(8, "track-scr-a-"), false);
        return r2.onSuccess([l2.getTrackId(), u3.getTrackId()]), sD.info("create screen video track success", "video:", l2.getTrackId(), "audio:", u3.getTrackId()), [l2, u3];
      }, createMicrophoneAndCameraTracks: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const i2 = wN("CAMERA_CAPTURE_CONFIG"), n3 = IO(8, "track-mic-"), r2 = IO(8, "track-cam-"), o2 = _D.reportApiInvoke(null, { id: "".concat(n3, "-").concat(r2), tag: qw2.TRACER, name: zw2.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t3, i2] });
        i2 && (t3.encoderConfig = i2);
        const s2 = zP(t3), a3 = XP(e2);
        let c3 = null, d2 = null;
        sD.info("start create camera video track(".concat(r2, ") and microphone audio track(").concat(n3, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t3)));
        try {
          const e3 = await wP({ audio: a3, video: s2 }, "".concat(n3, "-").concat(r2));
          c3 = e3.getAudioTracks()[0], d2 = e3.getVideoTracks()[0];
        } catch (e3) {
          throw o2.onError(e3), e3;
        }
        if (!c3 || !d2) {
          const e3 = new Ow2(ww2.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return o2.onError(e3), e3.throw(sD);
        }
        if (t3.optimizationMode && Uk2(r2, d2, t3, ND(t3.encoderConfig)), wN("USE_STANDARD_BITRATE_DEFAULT")) {
          const e3 = ND(t3.encoderConfig);
          t3.encoderConfig = e3, delete e3.bitrateMax, delete e3.bitrateMin;
        }
        const l2 = new jL(c3, e2, a3, n3), u3 = new Mk2(d2, t3, s2, t3.scalabiltyMode ? PD(t3.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t3.optimizationMode, r2);
        return o2.onSuccess([l2.getTrackId(), u3.getTrackId()]), sD.info("create camera video track(".concat(r2, ") and microphone audio track(").concat(n3, ") success")), [l2, u3];
      }, createMicrophoneAudioTrack: async function() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const t3 = IO(8, "track-mic-"), i2 = _D.reportApiInvoke(null, { id: t3, tag: qw2.TRACER, name: zw2.CREATE_MIC_AUDIO_TRACK, options: [e2] }), n3 = XP(e2);
        let r2 = null;
        sD.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", t3);
        try {
          r2 = (await wP({ audio: n3 }, t3)).getAudioTracks()[0] || null;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        if (!r2) {
          const e3 = new Ow2(ww2.UNEXPECTED_ERROR, "can not find track in media stream");
          return i2.onError(e3), e3.throw(sD);
        }
        const o2 = new jL(r2, e2, n3, t3);
        return i2.onSuccess(o2.getTrackId()), sD.info("create microphone audio track success, trackId:", t3), o2;
      }, createCustomAudioTrack: function(e2) {
        const t3 = IO(8, "track-cus-"), i2 = _D.reportApiInvoke(null, { id: t3, tag: qw2.TRACER, name: zw2.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), n3 = new BL(e2.mediaStreamTrack, e2.encoderConfig ? kD2(e2.encoderConfig) : {}, t3, false);
        return sD.info("create custom audio track success with config", e2, "trackId", n3.getTrackId()), i2.onSuccess(n3.getTrackId()), n3;
      }, createBufferSourceAudioTrack: async function(e2) {
        var t3;
        const { cacheOnlineFile: i2, encoderConfig: n3 } = e2;
        let { source: r2 } = e2;
        const o2 = { source: r2 instanceof AudioBuffer ? "AudioBuffer" : r2 instanceof File ? null !== (t3 = File.name) && void 0 !== t3 ? t3 : "File" : r2, cacheOnlineFile: i2, encoderConfig: n3 }, s2 = IO(8, "track-buf-"), a3 = _D.reportApiInvoke(null, { id: s2, tag: qw2.TRACER, name: zw2.CREATE_BUFFER_AUDIO_TRACK, options: [o2] });
        if (wN("DISABLE_WEBAUDIO")) throw new Ow2(ww2.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
        sD.info("start create buffer source audio track with config", JSON.stringify(o2), "trackId", s2);
        const c3 = r2;
        if (!(r2 instanceof AudioBuffer)) try {
          r2 = await async function(e3, t4) {
            let i3 = null;
            if ("string" == typeof e3) {
              const t5 = KL.get(e3);
              if (t5) return sD.debug("use cached audio resource: ", e3), t5;
              try {
                i3 = (await GO(() => UA2.get(e3, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
              } catch (e4) {
                throw new Ow2(ww2.FETCH_AUDIO_FILE_FAILED, e4.toString());
              }
            } else {
              const t5 = new ip2((t6, i4) => {
                const n5 = new FileReader();
                n5.onload = (e4) => {
                  e4.target ? t6(e4.target.result) : i4(new Ow2(ww2.READ_LOCAL_AUDIO_FILE_ERROR));
                }, n5.onerror = () => {
                  i4(new Ow2(ww2.READ_LOCAL_AUDIO_FILE_ERROR));
                }, n5.readAsArrayBuffer(e3);
              });
              i3 = await t5;
            }
            const n4 = await function(e4) {
              const t5 = EP();
              return new ip2((i4, n5) => {
                t5.decodeAudioData(e4, (e5) => {
                  i4(e5);
                }, (e5) => {
                  n5(new Ow2(ww2.DECODE_AUDIO_FILE_FAILED, e5.toString()));
                });
              });
            }(i3);
            return "string" == typeof e3 && t4 && KL.set(e3, n4), n4;
          }(r2, i2);
        } catch (e3) {
          return a3.onError(e3), e3.throw(sD);
        }
        const d2 = new HL(r2), l2 = new GL(c3, d2, n3 ? kD2(n3) : {}, s2);
        return sD.info("create buffer source audio track success, trackId:", s2), a3.onSuccess(l2.getTrackId()), l2;
      }, setAppType: function(e2) {
        if (sD.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0)) throw sD.debug("Invalid appType"), new ED(ww2.INVALID_PARAMS, "invalid app type", e2);
        AN("APP_TYPE", Math.floor(e2));
      }, setLogLevel: function(e2) {
        sD.setLogLevel(e2);
      }, enableLogUpload: function() {
        wN("USE_NEW_LOG") ? AN("UPLOAD_LOG", true) : sD.enableLogUpload();
      }, disableLogUpload: function() {
        wN("USE_NEW_LOG") ? AN("UPLOAD_LOG", false) : sD.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new JF();
      }, checkAudioTrackIsActive: async function(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = _D.reportApiInvoke(null, { tag: qw2.TRACER, name: zw2.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t3] });
        if (!(e2 instanceof BL || e2 instanceof Zk2)) {
          const e3 = new ED(ww2.INVALID_TRACK, "the parameter is not a audio track");
          return i2.onError(e3), e3.throw();
        }
        t3 && t3 < 1e3 && (t3 = 1e3);
        const n3 = e2 instanceof BL ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
        let o2 = r2, s2 = r2;
        const a3 = Date.now();
        return new ip2((r3) => {
          const c3 = setInterval(() => {
            const d2 = e2.getVolumeLevel();
            o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
            const l2 = o2 - s2 > 1e-4, u3 = Date.now() - a3;
            if (l2 || u3 > t3) {
              clearInterval(c3);
              const t4 = l2, s3 = { duration: u3, deviceLabel: n3, maxVolumeLevel: o2, result: t4 };
              sD.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), i2.onSuccess(s3), r3(t4);
            }
          }, 200);
        });
      }, checkVideoTrackIsActive: async function(e2) {
        let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        const i2 = _D.reportApiInvoke(null, { tag: qw2.TRACER, name: zw2.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t3] });
        if (!(e2 instanceof kk2 || e2 instanceof Jk2)) {
          const e3 = new ED(ww2.INVALID_TRACK, "the parameter is not a video track");
          return i2.onError(e3), e3.throw();
        }
        t3 && t3 < 1e3 && (t3 = 1e3);
        const n3 = e2 instanceof kk2 ? e2.getTrackLabel() : "remote_track", r2 = e2.getMediaStreamTrack(true), o2 = document.createElement("video");
        o2.style.width = "1px", o2.style.height = "1px", o2.setAttribute("muted", ""), o2.muted = true, o2.setAttribute("playsinline", ""), o2.controls = false, ($A2() || ZA2()) && (o2.style.opacity = "0.01", o2.style.position = "fixed", o2.style.left = "0", o2.style.top = "0", document.body.appendChild(o2)), o2.srcObject = new MediaStream([r2]), o2.play();
        const s2 = document.createElement("canvas");
        s2.width = 160, s2.height = 120;
        let a3 = 0, c3 = 0;
        try {
          const e3 = Date.now();
          a3 = await function(e4, t4, i3, n4) {
            let r3, o3 = 0, s3 = null;
            return new ip2((a4, c4) => {
              function d3() {
                o3 > n4 && r3 && (r3(), a4(o3));
                const t5 = i3.getContext("2d");
                if (!t5) {
                  const e5 = new ED(ww2.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                  return sD.error(e5.toString()), void c4(e5);
                }
                t5.drawImage(e4, 0, 0, 160, 120);
                const d4 = t5.getImageData(0, 0, i3.width, i3.height), l3 = Math.floor(d4.data.length / 3);
                if (s3) {
                  for (let e5 = 0; e5 < l3; e5 += 3) if (d4.data[e5] !== s3[e5]) return o3 += 1, void (s3 = d4.data);
                  s3 = d4.data;
                } else s3 = d4.data;
              }
              setTimeout(() => {
                r3 && (r3(), a4(o3));
              }, t4), r3 = SP(() => {
                d3();
              }, 30);
            });
          }(o2, t3, s2, 4), c3 = Date.now() - e3;
        } catch (e3) {
          throw i2.onError(e3), e3;
        }
        hj2 === WA2.SAFARI && (o2.pause(), o2.remove()), o2.srcObject = null;
        const d2 = a3 > 4, l2 = { duration: c3, changedPicNum: a3, deviceLabel: n3, result: d2 };
        return sD.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i2.onSuccess(l2), d2;
      }, setArea: _F, audioElementPlayCenter: xP, resumeAudioContext: function() {
        xP.autoResumeAfterInterruption(true);
      }, processExternalMediaAEC: function(e2) {
        uW.processExternalMediaAEC(e2);
      }, registerExtensions: function(e2) {
        const t3 = wN("PLUGIN_INFO") || [];
        e2.forEach((e3) => {
          "name" in e3 && !Ln2(t3).call(t3, e3.name) && t3.push(e3.name);
          const i2 = e3;
          i2.__registered__ = true, i2.logger.hookLog = sD.extLog, i2.reporter.hookApiInvoke = _D.extApiInvoke, i2.parameters && Object.keys(i2.parameters).forEach((e4) => {
            i2.parameters[e4] = wN(e4);
          });
        }), kq2("PLUGIN_INFO", t3);
      }, ChannelMediaRelayError: iV, ChannelMediaRelayEvent: eV, ChannelMediaRelayState: tV, RemoteStreamFallbackType: jD2, RemoteStreamType: BD, ConnectionDisconnectedReason: Zw2, AudienceLatencyLevelType: Jw2, AREAS: aV, preload: async function(e2, t3, i2, n3) {
        return bj2(e2, t3, i2, n3);
      } });
      return Object.defineProperties(Mq2, { onAudioAutoplayFailed: { get: () => kP.onAudioAutoplayFailed, set: (e2) => {
        kP.onAudioAutoplayFailed = e2;
      } }, onAutoplayFailed: { get: () => kP.onAutoplayFailed, set: (e2) => {
        kP.onAutoplayFailed = e2;
      } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => Mq2._onSecurityPolicyViolation, set(e2) {
        Mq2._onSecurityPolicyViolation = e2, EW(e2);
      } }, __CLIENT_LIST__: { get: () => wN("SHOW_GLOBAL_CLIENT_LIST") ? WM : [] } }), PP.on(tP.CAMERA_DEVICE_CHANGED, (e2) => {
        sD.info("camera device changed", JSON.stringify(e2)), Mq2.onCameraChanged && Mq2.onCameraChanged(e2), Mq2.safeEmit(bV.CAMERA_CHANGED, e2);
      }), PP.on(tP.RECORDING_DEVICE_CHANGED, (e2) => {
        sD.info("microphone device changed", JSON.stringify(e2)), Mq2.onMicrophoneChanged && Mq2.onMicrophoneChanged(e2), Mq2.safeEmit(bV.MICROPHONE_CHANGED, e2);
      }), PP.on(tP.PLAYOUT_DEVICE_CHANGED, (e2) => {
        sD.debug("playout device changed", JSON.stringify(e2)), Mq2.onPlaybackDeviceChanged && Mq2.onPlaybackDeviceChanged(e2), Mq2.safeEmit(bV.PLAYBACK_DEVICE_CHANGED, e2);
      }), xP.onAutoplayFailed = () => {
        sD.info("detect audio element autoplay failed"), kP.onAudioAutoplayFailed && kP.onAudioAutoplayFailed();
      }, _P.on("autoplay-failed", () => {
        sD.info("detect webaudio autoplay failed"), kP.onAudioAutoplayFailed && kP.onAudioAutoplayFailed(), Mq2.safeEmit(bV.AUTOPLAY_FAILED);
      }), _P.on(vD.STATE_CHANGE, (e2, t3) => {
        sD.info("audio context state changed: ".concat(t3, " => ").concat(e2)), Mq2.onAudioContextStateChanged && Mq2.onAudioContextStateChanged(e2, t3), Mq2.safeEmit(bV.AUDIO_CONTEXT_STATE_CHANGED, e2, t3);
      }), dO.on(rO.NETWORK_STATE_CHANGE, (e2, t3) => {
        sD.info("[network-indicator] network state changed, ".concat(t3, " => ").concat(e2));
      }), window && (window.__ARTC__ = Mq2), Mq2;
    });
  }
});

// node_modules/agora-rtm-sdk/index.js
var require_agora_rtm_sdk = __commonJS({
  "node_modules/agora-rtm-sdk/index.js"(exports, module) {
    "use strict";
    !function(e, t2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e = "undefined" != typeof globalThis ? globalThis : e || self).AgoraRTM = t2();
    }(exports, function() {
      function be(e, t2) {
        var n2 = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(e);
          t2 && (r = r.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e, t3).enumerable;
          })), n2.push.apply(n2, r);
        }
        return n2;
      }
      function ua(e) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var n2 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? be(Object(n2), true).forEach(function(t3) {
            m(e, t3, n2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n2)) : be(Object(n2)).forEach(function(t3) {
            Object.defineProperty(e, t3, Object.getOwnPropertyDescriptor(n2, t3));
          });
        }
        return e;
      }
      function X(e) {
        return (X = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
          return typeof e2;
        } : function(e2) {
          return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
        })(e);
      }
      function sl(e, t2, n2, r, i, o, a2) {
        try {
          var s = e[o](a2), u2 = s.value;
        } catch (e2) {
          return void n2(e2);
        }
        s.done ? t2(u2) : Promise.resolve(u2).then(r, i);
      }
      function J(e) {
        return function() {
          var t2 = this, n2 = arguments;
          return new Promise(function(r, i) {
            function o(e2) {
              sl(s, r, i, o, a2, "next", e2);
            }
            function a2(e2) {
              sl(s, r, i, o, a2, "throw", e2);
            }
            var s = e.apply(t2, n2);
            o(void 0);
          });
        };
      }
      function W(e, t2) {
        if (!(e instanceof t2)) throw new TypeError("Cannot call a class as a function");
      }
      function tl(e, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var r = t2[n2];
          r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(e, r.key, r);
        }
      }
      function Ha(e, t2, n2) {
        return t2 && tl(e.prototype, t2), n2 && tl(e, n2), e;
      }
      function m(e, t2, n2) {
        return t2 in e ? Object.defineProperty(e, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e[t2] = n2, e;
      }
      function la(e, t2) {
        if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e, writable: true, configurable: true } }), t2 && df(e, t2);
      }
      function wd(e) {
        return (wd = Object.setPrototypeOf ? Object.getPrototypeOf : function(e2) {
          return e2.__proto__ || Object.getPrototypeOf(e2);
        })(e);
      }
      function df(e, t2) {
        return (df = Object.setPrototypeOf || function(e2, t3) {
          return e2.__proto__ = t3, e2;
        })(e, t2);
      }
      function ul() {
        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (e) {
          return false;
        }
      }
      function Sh(e, t2, n2) {
        return (Sh = ul() ? Reflect.construct : function(e2, t3, n3) {
          var r = [null];
          return r.push.apply(r, t3), e2 = new (Function.bind.apply(e2, r))(), n3 && df(e2, n3.prototype), e2;
        }).apply(null, arguments);
      }
      function ef(e) {
        var t2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return (ef = function(e2) {
          function n2() {
            return Sh(e2, arguments, wd(this).constructor);
          }
          if (null === e2 || -1 === Function.toString.call(e2).indexOf("[native code]")) return e2;
          if ("function" != typeof e2) throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== t2) {
            if (t2.has(e2)) return t2.get(e2);
            t2.set(e2, n2);
          }
          return n2.prototype = Object.create(e2.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), df(n2, e2);
        })(e);
      }
      function ff(e, t2) {
        if (null == e) return {};
        if (null == e) var n2 = {};
        else {
          n2 = {};
          var r, i = Object.keys(e);
          for (r = 0; r < i.length; r++) {
            var o = i[r];
            0 <= t2.indexOf(o) || (n2[o] = e[o]);
          }
        }
        if (Object.getOwnPropertySymbols) for (r = Object.getOwnPropertySymbols(e), o = 0; o < r.length; o++) i = r[o], 0 <= t2.indexOf(i) || Object.prototype.propertyIsEnumerable.call(e, i) && (n2[i] = e[i]);
        return n2;
      }
      function n(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }
      function ma(e) {
        var t2 = ul();
        return function() {
          var r = wd(e);
          if (t2) {
            var i = wd(this).constructor;
            r = Reflect.construct(r, arguments, i);
          } else r = r.apply(this, arguments);
          return r = !r || "object" != typeof r && "function" != typeof r ? n(this) : r;
        };
      }
      function Th(e, t2, n2) {
        return (Th = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e2, t3, n3) {
          for (; !Object.prototype.hasOwnProperty.call(e2, t3) && null !== (e2 = wd(e2)); ) ;
          if (e2) return (t3 = Object.getOwnPropertyDescriptor(e2, t3)).get ? t3.get.call(n3) : t3.value;
        })(e, t2, n2 || e);
      }
      function ra(e, t2) {
        var n2 = Array.isArray(e) ? e : void 0;
        if (!n2) if (null == (n2 = e && ("undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]))) n2 = void 0;
        else {
          var r, i = [], o = true, a2 = false;
          try {
            for (n2 = n2.call(e); !(o = (r = n2.next()).done) && (i.push(r.value), !t2 || i.length !== t2); o = true) ;
          } catch (e2) {
            a2 = true;
            var s = e2;
          } finally {
            try {
              o || null == n2.return || n2.return();
            } finally {
              if (a2) throw s;
            }
          }
          n2 = i;
        }
        if (!(e = n2 || vl(e, t2))) throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return e;
      }
      function G(e) {
        var t2 = Array.isArray(e) ? Uh(e) : void 0;
        if (t2 || (t2 = "undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"] ? Array.from(e) : void 0), !(e = t2 || vl(e))) throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        return e;
      }
      function vl(e, t2) {
        if (e) {
          if ("string" == typeof e) return Uh(e, t2);
          var n2 = Object.prototype.toString.call(e).slice(8, -1);
          if ("Object" === n2 && e.constructor && (n2 = e.constructor.name), "Map" === n2 || "Set" === n2) return Array.from(e);
          if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return Uh(e, t2);
        }
      }
      function Uh(e, t2) {
        (null == t2 || t2 > e.length) && (t2 = e.length);
        for (var n2 = 0, r = Array(t2); n2 < t2; n2++) r[n2] = e[n2];
        return r;
      }
      function fa(e, t2, n2, r, i) {
        var o = {};
        return Object.keys(r).forEach(function(e2) {
          o[e2] = r[e2];
        }), o.enumerable = !!o.enumerable, o.configurable = !!o.configurable, ("value" in o || o.initializer) && (o.writable = true), o = n2.slice().reverse().reduce(function(n3, r2) {
          return r2(e, t2, n3) || n3;
        }, o), i && void 0 !== o.initializer && (o.value = o.initializer ? o.initializer.call(i) : void 0, o.initializer = void 0), void 0 === o.initializer && (Object.defineProperty(e, t2, o), o = null), o;
      }
      function $a(e) {
        var t2 = { exports: {} };
        return e(t2, t2.exports), t2.exports;
      }
      function wl(e, t2) {
        var n2, r = 3 > arguments.length ? e : arguments[2];
        return va(e) === r ? e[t2] : (n2 = Fb.f(e, t2)) ? Q(n2, "value") ? n2.value : void 0 === n2.get ? void 0 : n2.get.call(r) : ha(n2 = Vb(e)) ? wl(n2, t2, r) : void 0;
      }
      function rs(e) {
        var t2 = e.charCodeAt(0) << 24, n2 = 0 | ss(~t2), r = 0, i = 0 | e.length, o = "";
        if (5 > n2 && i >= n2) {
          for (t2 = t2 << n2 >>> 24 + n2, r = 1; r < n2; r = r + 1 | 0) t2 = t2 << 6 | 63 & e.charCodeAt(r);
          65535 >= t2 ? o += xd(t2) : 1114111 >= t2 ? o += xd(55296 + ((t2 = t2 - 65536 | 0) >> 10) | 0, 56320 + (1023 & t2) | 0) : r = 0;
        }
        for (; r < i; r = r + 1 | 0) o += "ï¿½";
        return o;
      }
      function xl() {
      }
      function ts(e) {
        var t2 = 0 | e.charCodeAt(0);
        if (55296 <= t2 && 56319 >= t2) {
          var n2 = 0 | e.charCodeAt(1);
          if (!(n2 == n2 && 56320 <= n2 && 57343 >= n2)) return xd(239, 191, 189);
          if (65535 < (t2 = (t2 - 55296 << 10) + n2 - 56320 + 65536 | 0)) return xd(240 | t2 >>> 18, 128 | t2 >>> 12 & 63, 128 | t2 >>> 6 & 63, 128 | 63 & t2);
        }
        return 127 >= t2 ? e : 2047 >= t2 ? xd(192 | t2 >>> 6, 128 | 63 & t2) : xd(224 | t2 >>> 12, 128 | t2 >>> 6 & 63, 128 | 63 & t2);
      }
      function yl() {
      }
      function ea() {
        ea.init.call(this);
      }
      function ng(e) {
        if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + X(e));
      }
      function zl(e, t2, n2, r) {
        ng(n2);
        var i = e._events;
        if (void 0 === i) i = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0;
        else {
          void 0 !== i.newListener && (e.emit("newListener", t2, n2.listener ? n2.listener : n2), i = e._events);
          var o = i[t2];
        }
        return void 0 === o ? (i[t2] = n2, ++e._eventsCount) : ("function" == typeof o ? o = i[t2] = r ? [n2, o] : [o, n2] : r ? o.unshift(n2) : o.push(n2), 0 < (n2 = void 0 === e._maxListeners ? ea.defaultMaxListeners : e._maxListeners) && o.length > n2 && !o.warned && (o.warned = true, (n2 = Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit")).name = "MaxListenersExceededWarning", n2.emitter = e, n2.type = t2, n2.count = o.length, console && console.warn && console.warn(n2))), e;
      }
      function us() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function Al(e, t2, n2) {
        return e = { fired: false, wrapFn: void 0, target: e, type: t2, listener: n2 }, (t2 = us.bind(e)).listener = n2, e.wrapFn = t2;
      }
      function Bl(e, t2, n2) {
        if (void 0 === (e = e._events)) return [];
        if (void 0 === (t2 = e[t2])) return [];
        if ("function" == typeof t2) return n2 ? [t2.listener || t2] : [t2];
        if (n2) for (n2 = Array(t2.length), e = 0; e < n2.length; ++e) n2[e] = t2[e].listener || t2[e];
        else n2 = Cl(t2, t2.length);
        return n2;
      }
      function Dl(e) {
        var t2 = this._events;
        if (void 0 !== t2) {
          if ("function" == typeof (e = t2[e])) return 1;
          if (void 0 !== e) return e.length;
        }
        return 0;
      }
      function Cl(e, t2) {
        for (var n2 = Array(t2), r = 0; r < t2; ++r) n2[r] = e[r];
        return n2;
      }
      function vs(e, t2, n2) {
        "function" == typeof e.on && El(e, "error", t2, n2);
      }
      function El(e, t2, n2, r) {
        if ("function" == typeof e.on) r.once ? e.once(t2, n2) : e.on(t2, n2);
        else {
          if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + X(e));
          e.addEventListener(t2, function i(o) {
            r.once && e.removeEventListener(t2, i), n2(o);
          });
        }
      }
      function ws(e) {
        return e ? G(e) : xs(function() {
          return [];
        }, function(e2, t2) {
          return e2.push(t2), e2;
        });
      }
      function Fl(e, t2) {
        var n2, r, i, o;
        return w.wrap(function(a2) {
          for (; ; ) switch (a2.prev = a2.next) {
            case 0:
              n2 = Gl(e)([Hl, Hl, function(e2, t3) {
                return t3;
              }])[2], r = 0;
            case 2:
              if (!(r < t2.length)) {
                a2.next = 17;
                break;
              }
              if (i = t2[r], !((o = n2(Vh, i)) instanceof og)) {
                a2.next = 11;
                break;
              }
              if ((o = Wh(o.deref())) === Vh) {
                a2.next = 10;
                break;
              }
              return a2.next = 10, o;
            case 10:
              return a2.abrupt("return");
            case 11:
              if (o === Vh) {
                a2.next = 14;
                break;
              }
              return a2.next = 14, o;
            case 14:
              r++, a2.next = 2;
              break;
            case 17:
            case "end":
              return a2.stop();
          }
        }, ys);
      }
      function pg(e, t2) {
        return null != t2 && "function" == typeof t2[Symbol.iterator] ? Fl(pg(e), t2) : function(t3) {
          var n2 = t3[2];
          return zs(t3, function(t4, r) {
            return n2(t4, e(r));
          });
        };
      }
      function Ac(e) {
        return Object.prototype.toString.call(e).slice(8, -1);
      }
      function yd(e) {
        return "Object" === Ac(e) && (e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype);
      }
      function Il(e) {
        var t2;
        return (t2 = "Boolean" === Ac(e) || "Null" === Ac(e) || "Undefined" === Ac(e)) || (t2 = "Number" === Ac(e) && !isNaN(e)), t2 || "String" === Ac(e) || "Symbol" === Ac(e);
      }
      function zd(e) {
        var t2 = -1, n2 = null == e ? 0 : e.length;
        for (this.clear(); ++t2 < n2; ) {
          var r = e[t2];
          this.set(r[0], r[1]);
        }
      }
      function ce(e) {
        var t2 = -1, n2 = null == e ? 0 : e.length;
        for (this.clear(); ++t2 < n2; ) {
          var r = e[t2];
          this.set(r[0], r[1]);
        }
      }
      function de(e) {
        var t2 = -1, n2 = null == e ? 0 : e.length;
        for (this.clear(); ++t2 < n2; ) {
          var r = e[t2];
          this.set(r[0], r[1]);
        }
      }
      function gf(e) {
        var t2 = -1, n2 = null == e ? 0 : e.length;
        for (this.__data__ = new qg(); ++t2 < n2; ) this.add(e[t2]);
      }
      function ee(e) {
        this.size = (this.__data__ = new rg(e)).size;
      }
      function fe(e, t2, n2, r, i, o) {
        var a2, s = 1 & t2, u2 = 2 & t2, c2 = 4 & t2;
        if (n2 && (a2 = i ? n2(e, r, i, o) : n2(e)), void 0 !== a2) return a2;
        if (!lb(e)) return e;
        if (r = Va(e)) {
          if (a2 = As(e), !s) return Xh(e, a2);
        } else {
          var l = hf(e), f = "[object Function]" == l || "[object GeneratorFunction]" == l;
          if (jf(e)) return Jl(e, s);
          if ("[object Object]" == l || "[object Arguments]" == l || f && !i) {
            if (a2 = u2 || f ? {} : Kl(e), !s) return u2 ? Bs(e, Cs(a2, e)) : Ds(e, Es(a2, e));
          } else {
            if (!wa[l]) return i ? e : {};
            a2 = Fs(e, l, s);
          }
        }
        if (o || (o = new ge()), i = o.get(e)) return i;
        o.set(e, a2), Gs(e) ? e.forEach(function(r2) {
          a2.add(fe(r2, t2, n2, r2, e, o));
        }) : Hs(e) && e.forEach(function(r2, i2) {
          a2.set(i2, fe(r2, t2, n2, i2, e, o));
        }), u2 = c2 ? u2 ? Ll : Yh : u2 ? kf : Ad;
        var h = r ? void 0 : u2(e);
        return Is(h || e, function(r2, i2) {
          h && (r2 = e[i2 = r2]), Ml(a2, i2, fe(r2, t2, n2, i2, e, o));
        }), a2;
      }
      function Zh(e, t2) {
        if ("function" != typeof e || null != t2 && "function" != typeof t2) throw new TypeError("Expected a function");
        var n2 = function n3() {
          var r = arguments, i = t2 ? t2.apply(this, r) : r[0], o = n3.cache;
          return o.has(i) ? o.get(i) : (r = e.apply(this, r), n3.cache = o.set(i, r) || o, r);
        };
        return n2.cache = new (Zh.Cache || qg)(), n2;
      }
      function Nl(e) {
        if ("string" == typeof e) return e;
        if (Va(e)) return he(e, Nl) + "";
        if (ie(e)) return Ol ? Ol.call(e) : "";
        var t2 = e + "";
        return "0" == t2 && 1 / e == -Js ? "-0" : t2;
      }
      function $h(e, t2, n2, r, i) {
        var o = -1, a2 = e.length;
        for (n2 || (n2 = Ks), i || (i = []); ++o < a2; ) {
          var s = e[o];
          0 < t2 && n2(s) ? 1 < t2 ? $h(s, t2 - 1, n2, r, i) : ai(i, s) : r || (i[i.length] = s);
        }
        return i;
      }
      function je(e, t2, n2, r, i) {
        if (e === t2) t2 = true;
        else if (null == e || null == t2 || !gc(e) && !gc(t2)) t2 = e != e && t2 != t2;
        else e: {
          var o = Va(e), a2 = Va(t2), s = o ? "[object Array]" : hf(e), u2 = a2 ? "[object Array]" : hf(t2), c2 = "[object Object]" == (s = "[object Arguments]" == s ? "[object Object]" : s);
          if (a2 = "[object Object]" == (u2 = "[object Arguments]" == u2 ? "[object Object]" : u2), (u2 = s == u2) && jf(e)) {
            if (!jf(t2)) {
              t2 = false;
              break e;
            }
            o = true, c2 = false;
          }
          if (u2 && !c2) i || (i = new ge()), t2 = o || bi(e) ? Pl(e, t2, n2, r, je, i) : Ls(e, t2, s, n2, r, je, i);
          else {
            if (!(1 & n2) && (o = c2 && Ql.call(e, "__wrapped__"), s = a2 && Ql.call(t2, "__wrapped__"), o || s)) {
              e = o ? e.value() : e, t2 = s ? t2.value() : t2, i || (i = new ge()), t2 = je(e, t2, n2, r, i);
              break e;
            }
            if (u2) t: if (i || (i = new ge()), o = 1 & n2, s = Yh(e), a2 = s.length, u2 = Yh(t2).length, a2 == u2 || o) {
              for (u2 = a2; u2--; ) {
                var l = s[u2];
                if (!(o ? l in t2 : Ms.call(t2, l))) {
                  t2 = false;
                  break t;
                }
              }
              if (c2 = i.get(e), l = i.get(t2), c2 && l) t2 = c2 == t2 && l == e;
              else {
                c2 = true, i.set(e, t2), i.set(t2, e);
                for (var f = o; ++u2 < a2; ) {
                  var h = e[l = s[u2]], p = t2[l];
                  if (r) var d = o ? r(p, h, l, t2, e, i) : r(h, p, l, e, t2, i);
                  if (void 0 === d ? h !== p && !je(h, p, n2, r, i) : !d) {
                    c2 = false;
                    break;
                  }
                  f || (f = "constructor" == l);
                }
                c2 && !f && ((n2 = e.constructor) != (r = t2.constructor) && "constructor" in e && "constructor" in t2 && !("function" == typeof n2 && n2 instanceof n2 && "function" == typeof r && r instanceof r) && (c2 = false)), i.delete(e), i.delete(t2), t2 = c2;
              }
            } else t2 = false;
            else t2 = false;
          }
        }
        return t2;
      }
      function xa(e, t2, n2) {
        this.low = 0 | e, this.high = 0 | t2, this.unsigned = !!n2;
      }
      function mb(e) {
        return true === (e && e.__isLong__);
      }
      function Bd(e, t2) {
        var n2;
        if (t2) {
          if ((t2 = 0 <= (e >>>= 0) && 256 > e) && (n2 = Rl[e])) return n2;
          n2 = ya(e, 0 > (0 | e) ? -1 : 0, true), t2 && (Rl[e] = n2);
        } else {
          if ((t2 = -128 <= (e |= 0) && 128 > e) && (n2 = Sl[e])) return n2;
          n2 = ya(e, 0 > e ? -1 : 0, false), t2 && (Sl[e] = n2);
        }
        return n2;
      }
      function Gb(e, t2) {
        if (isNaN(e)) return t2 ? Cd : Hb;
        if (t2) {
          if (0 > e) return Cd;
          if (e >= Tl) return Ul;
        } else {
          if (e <= -Vl) return nb;
          if (e + 1 >= Vl) return Wl;
        }
        return 0 > e ? Gb(-e, t2).neg() : ya(e % ke | 0, e / ke | 0, t2);
      }
      function ya(e, t2, n2) {
        return new xa(e, t2, n2);
      }
      function ci(e, t2, n2) {
        if (0 === e.length) throw Error("empty string");
        if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return Hb;
        if ("number" == typeof t2 ? (n2 = t2, t2 = false) : t2 = !!t2, 2 > (n2 = n2 || 10) || 36 < n2) throw RangeError("radix");
        var r;
        if (0 < (r = e.indexOf("-"))) throw Error("interior hyphen");
        if (0 === r) return ci(e.substring(1), t2, n2).neg();
        r = Gb(sg(n2, 8));
        for (var i = Hb, o = 0; o < e.length; o += 8) {
          var a2 = Math.min(8, e.length - o), s = parseInt(e.substring(o, o + a2), n2);
          8 > a2 ? (a2 = Gb(sg(n2, a2)), i = i.mul(a2).add(Gb(s))) : i = (i = i.mul(r)).add(Gb(s));
        }
        return i.unsigned = t2, i;
      }
      function Wb(e, t2) {
        return "number" == typeof e ? Gb(e, t2) : "string" == typeof e ? ci(e, t2) : ya(e.low, e.high, "boolean" == typeof t2 ? t2 : e.unsigned);
      }
      function O(e, t2) {
        function n2() {
          this.constructor = e;
        }
        di(e, t2), e.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
      }
      function le(e) {
        return "function" == typeof e;
      }
      function me(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function ei(e) {
        return null !== e && "object" === X(e);
      }
      function Xl(e) {
        return e.reduce(function(e2, t2) {
          return e2.concat(t2 instanceof lf ? t2.errors : t2);
        }, []);
      }
      function fi(e) {
        for (; e; ) {
          var t2 = e.destination, n2 = e.isStopped;
          if (e.closed || n2) return false;
          e = t2 && t2 instanceof ia ? t2 : null;
        }
        return true;
      }
      function Yc(e) {
        return e;
      }
      function gi() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        return Yl(e);
      }
      function Yl(e) {
        return 0 === e.length ? Yc : 1 === e.length ? e[0] : function(t2) {
          return e.reduce(function(e2, t3) {
            return t3(e2);
          }, t2);
        };
      }
      function Zl(e) {
        if (e || (e = Ib.Promise || Promise), !e) throw Error("no Promise impl found");
        return e;
      }
      function $l() {
        return function(e) {
          return e.lift(new Ns(e));
        };
      }
      function mf(e) {
        return e ? Os(e) : vb;
      }
      function Os(e) {
        return new Y(function(t2) {
          return e.schedule(function() {
            return t2.complete();
          });
        });
      }
      function Zc(e) {
        return e && "function" == typeof e.schedule;
      }
      function hi(e, t2) {
        return new Y(function(n2) {
          var r = new Oa(), i = 0;
          return r.add(t2.schedule(function() {
            i === e.length ? n2.complete() : (n2.next(e[i++]), n2.closed || r.add(this.schedule()));
          })), r;
        });
      }
      function nf(e, t2) {
        return t2 ? hi(e, t2) : new Y(am(e));
      }
      function bb() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        return Zc(t2 = e[e.length - 1]) ? (e.pop(), hi(e, t2)) : nf(e);
      }
      function Z(e, t2) {
        return new Y(t2 ? function(n2) {
          return t2.schedule(Ps, 0, { error: e, subscriber: n2 });
        } : function(t3) {
          return t3.error(e);
        });
      }
      function Ps(e) {
        e.subscriber.error(e.error);
      }
      function Qs(e, t2) {
        return void 0 === t2 && (t2 = 0), function(n2) {
          return n2.lift(new Rs(e, t2));
        };
      }
      function bm(e) {
        return e in ii && (delete ii[e], true);
      }
      function hc() {
      }
      function ba(e, t2) {
        return function(n2) {
          if ("function" != typeof e) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
          return n2.lift(new Ss(e, t2));
        };
      }
      function cm(e, t2, n2) {
        if (t2) {
          if (!Zc(t2)) return function() {
            for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
            return cm(e, n2).apply(void 0, r).pipe(ba(function(e2) {
              return Jb(e2) ? t2.apply(void 0, e2) : t2(e2);
            }));
          };
          n2 = t2;
        }
        return function() {
          for (var t3 = [], r = 0; r < arguments.length; r++) t3[r] = arguments[r];
          var i, o = this, a2 = { context: o, subject: i, callbackFunc: e, scheduler: n2 };
          return new Y(function(r2) {
            if (n2) return n2.schedule(Ts, 0, { args: t3, subscriber: r2, params: a2 });
            if (!i) {
              i = new of();
              try {
                e.apply(o, t3.concat([function() {
                  for (var e2 = [], t4 = 0; t4 < arguments.length; t4++) e2[t4] = arguments[t4];
                  i.next(1 >= e2.length ? e2[0] : e2), i.complete();
                }]));
              } catch (e2) {
                fi(i) ? i.error(e2) : console.warn(e2);
              }
            }
            return i.subscribe(r2);
          });
        };
      }
      function Ts(e) {
        var t2 = this, n2 = e.args, r = e.subscriber, i = e.params;
        e = i.callbackFunc;
        var o = i.context, a2 = i.scheduler, s = i.subject;
        if (!s) {
          s = i.subject = new of(), i = function() {
            for (var e2 = [], n3 = 0; n3 < arguments.length; n3++) e2[n3] = arguments[n3];
            t2.add(a2.schedule(Us, 0, { value: 1 >= e2.length ? e2[0] : e2, subject: s }));
          };
          try {
            e.apply(o, n2.concat([i]));
          } catch (e2) {
            s.error(e2);
          }
        }
        this.add(s.subscribe(r));
      }
      function Us(e) {
        var t2 = e.subject;
        t2.next(e.value), t2.complete();
      }
      function dm(e, t2, n2) {
        if (t2) {
          if (!Zc(t2)) return function() {
            for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
            return dm(e, n2).apply(void 0, r).pipe(ba(function(e2) {
              return Jb(e2) ? t2.apply(void 0, e2) : t2(e2);
            }));
          };
          n2 = t2;
        }
        return function() {
          for (var t3 = [], r = 0; r < arguments.length; r++) t3[r] = arguments[r];
          var i = { subject: void 0, args: t3, callbackFunc: e, scheduler: n2, context: this };
          return new Y(function(r2) {
            var o = i.context, a2 = i.subject;
            if (n2) return n2.schedule(Vs, 0, { params: i, subscriber: r2, context: o });
            if (!a2) {
              a2 = i.subject = new of();
              try {
                e.apply(o, t3.concat([function() {
                  for (var e2 = [], t4 = 0; t4 < arguments.length; t4++) e2[t4] = arguments[t4];
                  (t4 = e2.shift()) ? a2.error(t4) : (a2.next(1 >= e2.length ? e2[0] : e2), a2.complete());
                }]));
              } catch (e2) {
                fi(a2) ? a2.error(e2) : console.warn(e2);
              }
            }
            return a2.subscribe(r2);
          });
        };
      }
      function Vs(e) {
        var t2 = this, n2 = e.params, r = e.subscriber;
        e = e.context;
        var i = n2.callbackFunc, o = n2.args, a2 = n2.scheduler, s = n2.subject;
        if (!s) {
          s = n2.subject = new of(), n2 = function() {
            for (var e2 = [], n3 = 0; n3 < arguments.length; n3++) e2[n3] = arguments[n3];
            (n3 = e2.shift()) ? t2.add(a2.schedule(em, 0, { err: n3, subject: s })) : t2.add(a2.schedule(Ws, 0, { value: 1 >= e2.length ? e2[0] : e2, subject: s }));
          };
          try {
            i.apply(e, o.concat([n2]));
          } catch (e2) {
            this.add(a2.schedule(em, 0, { err: e2, subject: s }));
          }
        }
        this.add(s.subscribe(r));
      }
      function Ws(e) {
        var t2 = e.subject;
        t2.next(e.value), t2.complete();
      }
      function em(e) {
        e.subject.error(e.err);
      }
      function fm(e) {
        return !!e && "function" != typeof e.subscribe && "function" == typeof e.then;
      }
      function ji(e, t2, n2, r, i) {
        if (void 0 === i && (i = new Xs(e, n2, r)), !i.closed) return t2 instanceof Y ? t2.subscribe(i) : pf(t2)(i);
      }
      function Ys(e, t2) {
        return new Y(function(n2) {
          var r = new Oa();
          return r.add(t2.schedule(function() {
            var i = e[ne]();
            r.add(i.subscribe({ next: function(e2) {
              r.add(t2.schedule(function() {
                return n2.next(e2);
              }));
            }, error: function(e2) {
              r.add(t2.schedule(function() {
                return n2.error(e2);
              }));
            }, complete: function() {
              r.add(t2.schedule(function() {
                return n2.complete();
              }));
            } }));
          })), r;
        });
      }
      function Zs(e, t2) {
        return new Y(function(n2) {
          var r = new Oa();
          return r.add(t2.schedule(function() {
            return e.then(function(e2) {
              r.add(t2.schedule(function() {
                n2.next(e2), r.add(t2.schedule(function() {
                  return n2.complete();
                }));
              }));
            }, function(e2) {
              r.add(t2.schedule(function() {
                return n2.error(e2);
              }));
            });
          })), r;
        });
      }
      function $s(e, t2) {
        if (!e) throw Error("Iterable cannot be null");
        return new Y(function(n2) {
          var r, i = new Oa();
          return i.add(function() {
            r && "function" == typeof r.return && r.return();
          }), i.add(t2.schedule(function() {
            r = e[$c](), i.add(t2.schedule(function() {
              if (!n2.closed) {
                try {
                  var e2 = r.next(), t3 = e2.value, i2 = e2.done;
                } catch (e3) {
                  return void n2.error(e3);
                }
                i2 ? n2.complete() : (n2.next(t3), this.schedule());
              }
            }));
          })), i;
        });
      }
      function gm(e, t2) {
        if (null != e) {
          if (e && "function" == typeof e[ne]) return Ys(e, t2);
          if (fm(e)) return Zs(e, t2);
          if (hm(e)) return hi(e, t2);
          if (e && "function" == typeof e[$c] || "string" == typeof e) return $s(e, t2);
        }
        throw new TypeError((null !== e && X(e) || e) + " is not observable");
      }
      function Kb(e, t2) {
        return t2 ? gm(e, t2) : e instanceof Y ? e : new Y(pf(e));
      }
      function ic(e, t2) {
        if (!t2.closed) {
          if (e instanceof Y) return e.subscribe(t2);
          try {
            var n2 = pf(e)(t2);
          } catch (e2) {
            t2.error(e2);
          }
          return n2;
        }
      }
      function cb(e, t2, n2) {
        return void 0 === n2 && (n2 = Number.POSITIVE_INFINITY), "function" == typeof t2 ? function(r) {
          return r.pipe(cb(function(n3, r2) {
            return Kb(e(n3, r2)).pipe(ba(function(e2, i) {
              return t2(n3, e2, r2, i);
            }));
          }, n2));
        } : ("number" == typeof t2 && (n2 = t2), function(t3) {
          return t3.lift(new at(e, n2));
        });
      }
      function tg(e) {
        return void 0 === e && (e = Number.POSITIVE_INFINITY), cb(Yc, e);
      }
      function im() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        return tg(1)(bb.apply(void 0, e));
      }
      function ad(e) {
        return new Y(function(t2) {
          try {
            var n2 = e();
          } catch (e2) {
            return void t2.error(e2);
          }
          return (n2 ? Kb(n2) : mf()).subscribe(t2);
        });
      }
      function jm() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        if (1 === e.length) {
          var n2 = e[0];
          if (Jb(n2)) return ug(n2, null);
          if (ei(n2) && Object.getPrototypeOf(n2) === Object.prototype) return ug((e = Object.keys(n2)).map(function(e2) {
            return n2[e2];
          }), e);
        }
        if ("function" == typeof e[e.length - 1]) {
          var r = e.pop();
          return ug(e = 1 === e.length && Jb(e[0]) ? e[0] : e, null).pipe(ba(function(e2) {
            return r.apply(void 0, e2);
          }));
        }
        return ug(e, null);
      }
      function ug(e, t2) {
        return new Y(function(n2) {
          var r = e.length;
          if (0 === r) n2.complete();
          else for (var i = Array(r), o = 0, a2 = 0, s = function(s2) {
            var u3 = Kb(e[s2]), c2 = false;
            n2.add(u3.subscribe({ next: function(e2) {
              c2 || (c2 = true, a2++), i[s2] = e2;
            }, error: function(e2) {
              return n2.error(e2);
            }, complete: function() {
              ++o !== r && c2 || (a2 === r && n2.next(t2 ? t2.reduce(function(e2, t3, n3) {
                return e2[t3] = i[n3], e2;
              }, {}) : i), n2.complete());
            } }));
          }, u2 = 0; u2 < r; u2++) s(u2);
        });
      }
      function gb(e, t2, n2, r) {
        return le(n2) && (r = n2, n2 = void 0), r ? gb(e, t2, n2).pipe(ba(function(e2) {
          return Jb(e2) ? r.apply(void 0, e2) : r(e2);
        })) : new Y(function(r2) {
          km(e, t2, function(e2) {
            1 < arguments.length ? r2.next(Array.prototype.slice.call(arguments)) : r2.next(e2);
          }, r2, n2);
        });
      }
      function km(e, t2, n2, r, i) {
        if (e && "function" == typeof e.addEventListener && "function" == typeof e.removeEventListener) {
          e.addEventListener(t2, n2, i);
          var o = function() {
            return e.removeEventListener(t2, n2, i);
          };
        } else if (e && "function" == typeof e.on && "function" == typeof e.off) e.on(t2, n2), o = function() {
          return e.off(t2, n2);
        };
        else if (e && "function" == typeof e.addListener && "function" == typeof e.removeListener) e.addListener(t2, n2), o = function() {
          return e.removeListener(t2, n2);
        };
        else {
          if (!e || !e.length) throw new TypeError("Invalid event target");
          for (var a2 = 0, s = e.length; a2 < s; a2++) km(e[a2], t2, n2, r, i);
        }
        r.add(o);
      }
      function lm(e, t2, n2) {
        return n2 ? lm(e, t2).pipe(ba(function(e2) {
          return Jb(e2) ? n2.apply(void 0, e2) : n2(e2);
        })) : new Y(function(n3) {
          var r = function() {
            for (var e2 = [], t3 = 0; t3 < arguments.length; t3++) e2[t3] = arguments[t3];
            return n3.next(1 === e2.length ? e2[0] : e2);
          };
          try {
            var i = e(r);
          } catch (e2) {
            return void n3.error(e2);
          }
          if (le(t2)) return function() {
            return t2(r, i);
          };
        });
      }
      function bt(e) {
        var t2 = e.subscriber, n2 = e.condition;
        if (!t2.closed) {
          if (e.needIterate) try {
            e.state = e.iterate(e.state);
          } catch (e2) {
            return void t2.error(e2);
          }
          else e.needIterate = true;
          if (n2) {
            var r = void 0;
            try {
              r = n2(e.state);
            } catch (e2) {
              return void t2.error(e2);
            }
            if (!r) return void t2.complete();
            if (t2.closed) return;
          }
          try {
            var i = e.resultSelector(e.state);
          } catch (e2) {
            return void t2.error(e2);
          }
          if (!t2.closed && (t2.next(i), !t2.closed)) return this.schedule(e);
        }
      }
      function ki(e) {
        return !Jb(e) && 0 <= e - parseFloat(e) + 1;
      }
      function mm(e, t2) {
        return void 0 === e && (e = 0), void 0 === t2 && (t2 = bd), (!ki(e) || 0 > e) && (e = 0), t2 && "function" == typeof t2.schedule || (t2 = bd), new Y(function(n2) {
          return n2.add(t2.schedule(ct, e, { subscriber: n2, counter: 0, period: e })), n2;
        });
      }
      function ct(e) {
        var t2 = e.subscriber, n2 = e.counter;
        e = e.period, t2.next(n2), this.schedule({ subscriber: t2, counter: n2 + 1, period: e }, e);
      }
      function Xb() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        t2 = Number.POSITIVE_INFINITY;
        var n2 = null, r = e[e.length - 1];
        return Zc(r) ? (n2 = e.pop(), 1 < e.length && "number" == typeof e[e.length - 1] && (t2 = e.pop())) : "number" == typeof r && (t2 = e.pop()), null === n2 && 1 === e.length && e[0] instanceof Y ? e[0] : tg(t2)(nf(e, n2));
      }
      function li() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        if (0 === e.length) return vb;
        var n2 = e[0], r = e.slice(1);
        return 1 === e.length && Jb(n2) ? li.apply(void 0, n2) : new Y(function(e2) {
          var t3 = function() {
            return e2.add(li.apply(void 0, r).subscribe(e2));
          };
          return Kb(n2).subscribe({ next: function(t4) {
            e2.next(t4);
          }, error: t3, complete: t3 });
        });
      }
      function dt(e) {
        var t2 = e.keys, n2 = e.index, r = e.subscriber, i = e.subscription;
        if (e = e.obj, !r.closed) if (n2 < t2.length) {
          var o = t2[n2];
          r.next([o, e[o]]), i.add(this.schedule({ keys: t2, index: n2 + 1, subscriber: r, subscription: i, obj: e }));
        } else r.complete();
      }
      function et(e, t2) {
        function n2() {
          return !n2.pred.apply(n2.thisArg, arguments);
        }
        return n2.pred = e, n2.thisArg = t2, n2;
      }
      function wb(e, t2) {
        return function(n2) {
          return n2.lift(new ft(e, t2));
        };
      }
      function Ca() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        if (1 === e.length) {
          if (!Jb(e[0])) return e[0];
          e = e[0];
        }
        return nf(e, void 0).lift(new gt());
      }
      function ht(e) {
        var t2 = e.start, n2 = e.index, r = e.subscriber;
        n2 >= e.count ? r.complete() : (r.next(t2), r.closed || (e.index = n2 + 1, e.start = t2 + 1, this.schedule(e)));
      }
      function Bc(e, t2, n2) {
        void 0 === e && (e = 0);
        var r = -1;
        return ki(t2) ? r = 1 > Number(t2) ? 1 : Number(t2) : Zc(t2) && (n2 = t2), Zc(n2) || (n2 = bd), new Y(function(t3) {
          var i = ki(e) ? e : +e - n2.now();
          return n2.schedule(it, i, { index: 0, period: r, subscriber: t3 });
        });
      }
      function it(e) {
        var t2 = e.index, n2 = e.period, r = e.subscriber;
        if (r.next(t2), !r.closed) {
          if (-1 === n2) return r.complete();
          e.index = t2 + 1, this.schedule(e, n2);
        }
      }
      function mi() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        return "function" == typeof (t2 = e[e.length - 1]) && e.pop(), nf(e, void 0).lift(new jt(t2));
      }
      function Ga(e) {
        return function(t2) {
          var n2 = new kt(e);
          return t2 = t2.lift(n2), n2.caught = t2;
        };
      }
      function ni(e, t2) {
        return cb(e, t2, 1);
      }
      function nm(e) {
        return void 0 === e && (e = null), function(t2) {
          return t2.lift(new lt(e));
        };
      }
      function cd(e, t2) {
        void 0 === t2 && (t2 = bd);
        var n2 = e instanceof Date && !isNaN(+e) ? +e - t2.now() : Math.abs(e);
        return function(e2) {
          return e2.lift(new mt(n2, t2));
        };
      }
      function om(e, t2) {
        return function(n2) {
          return n2.lift(new nt(e, t2));
        };
      }
      function Dd(e) {
        return void 0 === e && (e = ot), function(t2) {
          return t2.lift(new pt(e));
        };
      }
      function ot() {
        return new vg();
      }
      function Ka(e) {
        return function(t2) {
          return 0 === e ? mf() : t2.lift(new qt(e));
        };
      }
      function pm(e, t2) {
        return t2 ? function(n2) {
          return n2.pipe(pm(function(n3, r) {
            return Kb(e(n3, r)).pipe(ba(function(e2, i) {
              return t2(n3, e2, r, i);
            }));
          }));
        } : function(t3) {
          return t3.lift(new rt(e));
        };
      }
      function wg(e) {
        return function(t2) {
          return t2.lift(new st(e));
        };
      }
      function aa(e, t2) {
        var n2 = 2 <= arguments.length;
        return function(r) {
          return r.pipe(e ? wb(function(t3, n3) {
            return e(t3, n3, r);
          }) : Yc, Ka(1), n2 ? nm(t2) : Dd(function() {
            return new vg();
          }));
        };
      }
      function tt() {
        return function(e) {
          return e.lift(new ut());
        };
      }
      function qm(e) {
        return function(t2) {
          return 0 === e ? mf() : t2.lift(new vt(e));
        };
      }
      function qf(e) {
        return function(t2) {
          return t2.lift(new wt(e));
        };
      }
      function xg(e, t2) {
        var n2 = false;
        return 2 <= arguments.length && (n2 = true), function(r) {
          return r.lift(new xt(e, t2, n2));
        };
      }
      function rm(e, t2) {
        return 2 <= arguments.length ? function(n2) {
          return gi(xg(e, t2), qm(1), nm(t2))(n2);
        } : function(t3) {
          return gi(xg(function(t4, n2, r) {
            return e(t4, n2, r + 1);
          }), qm(1))(t3);
        };
      }
      function yt(e, t2) {
        return function(n2) {
          var r = "function" == typeof e ? e : function() {
            return e;
          };
          if ("function" == typeof t2) return n2.lift(new zt(r, t2));
          var i = Object.create(n2, At);
          return i.source = n2, i.subjectFactory = r, i;
        };
      }
      function oe(e) {
        return function(t2) {
          return t2.lift(new Bt(e, t2));
        };
      }
      function Ct() {
        return new Pa();
      }
      function pe() {
        return function(e) {
          return $l()(yt(Ct)(e));
        };
      }
      function sm(e, t2, n2) {
        var r = e && "object" === X(e) ? e : { bufferSize: e, windowTime: t2, refCount: false, scheduler: n2 };
        return function(e2) {
          return e2.lift(Dt(r));
        };
      }
      function Dt(e) {
        var t2, n2, r = e.bufferSize, i = void 0 === r ? Number.POSITIVE_INFINITY : r, o = void 0 === (r = e.windowTime) ? Number.POSITIVE_INFINITY : r, a2 = e.refCount, s = e.scheduler, u2 = 0, c2 = false, l = false;
        return function(e2) {
          if (u2++, !t2 || c2) {
            c2 = false;
            var r2 = (t2 = new qe(i, o, s)).subscribe(this);
            n2 = e2.subscribe({ next: function(e3) {
              t2.next(e3);
            }, error: function(e3) {
              c2 = true, t2.error(e3);
            }, complete: function() {
              l = true, n2 = void 0, t2.complete();
            } }), l && (n2 = void 0);
          } else r2 = t2.subscribe(this);
          this.add(function() {
            u2--, r2.unsubscribe(), r2 = void 0, n2 && !l && a2 && 0 === u2 && (n2.unsubscribe(), t2 = n2 = void 0);
          });
        };
      }
      function Cc(e, t2) {
        return "function" == typeof t2 ? function(n2) {
          return n2.pipe(Cc(function(n3, r) {
            return Kb(e(n3, r)).pipe(ba(function(e2, i) {
              return t2(n3, e2, r, i);
            }));
          }));
        } : function(t3) {
          return t3.lift(new Et(e));
        };
      }
      function ob(e) {
        return function(t2) {
          return t2.lift(new Ft(e));
        };
      }
      function Gt(e, t2) {
        return void 0 === t2 && (t2 = false), function(n2) {
          return n2.lift(new Ht(e, t2));
        };
      }
      function ca(e, t2, n2) {
        return function(r) {
          return r.lift(new It(e, t2, n2));
        };
      }
      function Jt(e, t2, n2) {
        return void 0 === t2 && (t2 = bd), void 0 === n2 && (n2 = Kt), function(r) {
          return r.lift(new Lt(e, t2, n2.leading, n2.trailing));
        };
      }
      function Mt(e) {
        e.subscriber.clearThrottle();
      }
      function Nt(e, t2, n2) {
        return void 0 === n2 && (n2 = bd), function(r) {
          var i = e instanceof Date && !isNaN(+e), o = i ? +e - n2.now() : Math.abs(e);
          return r.lift(new Ot(o, i, t2, n2));
        };
      }
      function hb(e, t2) {
        return void 0 === t2 && (t2 = bd), Nt(e, Z(new pb()), t2);
      }
      function Pt() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        return function(t3) {
          var n2;
          return "function" == typeof e[e.length - 1] && (n2 = e.pop()), t3.lift(new Qt(e, n2));
        };
      }
      function tm(e, t2, n2, r, i) {
        e !== t2 && um(t2, function(o, a2) {
          if (i || (i = new ge()), lb(o)) {
            o = i;
            var s = oi(e, a2), u2 = oi(t2, a2), c2 = o.get(u2);
            if (c2) pi(e, a2, c2);
            else {
              var l = void 0 === (c2 = r ? r(s, u2, a2 + "", e, t2, o) : void 0);
              if (l) {
                var f = Va(u2), h = !f && jf(u2), p = !f && !h && bi(u2);
                c2 = u2, f || h || p ? Va(s) ? c2 = s : gc(s) && Ed(s) ? c2 = Xh(s) : h ? (l = false, c2 = Jl(u2, true)) : p ? (l = false, c2 = vm(u2, true)) : c2 = [] : wm(u2) || rf(u2) ? (c2 = s, rf(s) ? c2 = re(s, kf(s)) : lb(s) && !qi(s) || (c2 = Kl(u2))) : l = false;
              }
              l && (o.set(u2, c2), tm(c2, u2, n2, r, o), o.delete(u2)), pi(e, a2, c2);
            }
          } else void 0 === (s = r ? r(oi(e, a2), o, a2 + "", e, t2, i) : void 0) && (s = o), pi(e, a2, s);
        }, kf);
      }
      function Rt(e) {
        var t2 = 1, n2 = ri;
        1 == (1 >= arguments.length ? 0 : arguments.length - 1) ? "number" == typeof (1 >= arguments.length ? void 0 : arguments[1]) ? t2 = 1 >= arguments.length ? void 0 : arguments[1] : n2 = 1 >= arguments.length ? void 0 : arguments[1] : 2 == (1 >= arguments.length ? 0 : arguments.length - 1) && (t2 = 1 >= arguments.length ? void 0 : arguments[1], n2 = 2 >= arguments.length ? void 0 : arguments[2]);
        var r = t2 || 1;
        return function(t3) {
          return t3.pipe(xg(function(t4, i) {
            var o = n2.now(), a2 = o - e;
            if ((t4 = t4.filter(function(e2) {
              return e2.until > a2;
            })).length >= r) {
              var s = t4[t4.length - 1], u2 = t4[0].until + e * Math.floor(t4.length / r);
              t4.push({ delay: s.until < o ? u2 - o : u2 - s.until, until: u2, value: i });
            } else t4.push({ delay: 0, until: o, value: i });
            return t4;
          }, []), ba(function(e2) {
            return e2[e2.length - 1];
          }), ni(function(e2) {
            var t4 = bb(e2.value);
            return e2.delay ? t4.pipe(cd(e2.delay, n2)) : t4;
          }));
        };
      }
      function St(e, t2) {
        var n2 = (t2 = void 0 === t2 ? { protocols: xm, makeWebSocket: ym } : t2).protocols, r = void 0 === n2 ? xm : n2, i = void 0 === (t2 = t2.makeWebSocket) ? ym : t2;
        return new Y(function(t3) {
          var n3, o = new Pa(), a2 = i(e, r), s = false, u2 = false, c2 = function(e2) {
            if (n3) throw s = true, e2 = Error("Web socket message factory function called more than once"), t3.error(e2), e2;
            return n3 = e2.subscribe(function(e3) {
              a2.send(e3);
            }), o;
          };
          return a2.onopen = function() {
            u2 ? (s = true, a2.close()) : t3.next(c2);
          }, a2.onmessage = function(e2) {
            o.next(e2.data);
          }, a2.onerror = function(e2) {
            s = true, t3.error(Error(e2.message));
          }, a2.onclose = function(e2) {
            s || (s = true, u2 ? (t3.complete(), o.complete()) : t3.error(Error(1e3 === e2.code ? "Normal closure" : e2.reason)));
          }, function() {
            u2 = true, n3 && n3.unsubscribe(), s || (s = true, a2.close());
          };
        });
      }
      function yg() {
        this._listeners = {};
      }
      function zm(e) {
        return "undefined" != typeof Float32Array ? function() {
          function t2(e2, t3, n3) {
            o[0] = e2, t3[n3] = a2[0], t3[n3 + 1] = a2[1], t3[n3 + 2] = a2[2], t3[n3 + 3] = a2[3];
          }
          function n2(e2, t3, n3) {
            o[0] = e2, t3[n3] = a2[3], t3[n3 + 1] = a2[2], t3[n3 + 2] = a2[1], t3[n3 + 3] = a2[0];
          }
          function r(e2, t3) {
            return a2[0] = e2[t3], a2[1] = e2[t3 + 1], a2[2] = e2[t3 + 2], a2[3] = e2[t3 + 3], o[0];
          }
          function i(e2, t3) {
            return a2[3] = e2[t3], a2[2] = e2[t3 + 1], a2[1] = e2[t3 + 2], a2[0] = e2[t3 + 3], o[0];
          }
          var o = new Float32Array([-0]), a2 = new Uint8Array(o.buffer), s = 128 === a2[3];
          e.writeFloatLE = s ? t2 : n2, e.writeFloatBE = s ? n2 : t2, e.readFloatLE = s ? r : i, e.readFloatBE = s ? i : r;
        }() : function() {
          function t2(e2, t3, n3, r) {
            var i = 0 > t3 ? 1 : 0;
            if (i && (t3 = -t3), 0 === t3) e2(0 < 1 / t3 ? 0 : 2147483648, n3, r);
            else if (isNaN(t3)) e2(2143289344, n3, r);
            else if (34028234663852886e22 < t3) e2((i << 31 | 2139095040) >>> 0, n3, r);
            else if (11754943508222875e-54 > t3) e2((i << 31 | Math.round(t3 / 1401298464324817e-60)) >>> 0, n3, r);
            else {
              var o = Math.floor(Math.log(t3) / Math.LN2);
              e2((i << 31 | o + 127 << 23 | 8388607 & Math.round(t3 * Math.pow(2, -o) * 8388608)) >>> 0, n3, r);
            }
          }
          function n2(e2, t3, n3) {
            return n3 = e2(t3, n3), e2 = 2 * (n3 >> 31) + 1, t3 = n3 >>> 23 & 255, n3 &= 8388607, 255 === t3 ? n3 ? NaN : 1 / 0 * e2 : 0 === t3 ? 1401298464324817e-60 * e2 * n3 : e2 * Math.pow(2, t3 - 150) * (n3 + 8388608);
          }
          e.writeFloatLE = t2.bind(null, Am), e.writeFloatBE = t2.bind(null, Bm), e.readFloatLE = n2.bind(null, Cm), e.readFloatBE = n2.bind(null, Dm);
        }(), "undefined" != typeof Float64Array ? function() {
          function t2(e2, t3, n3) {
            o[0] = e2, t3[n3] = a2[0], t3[n3 + 1] = a2[1], t3[n3 + 2] = a2[2], t3[n3 + 3] = a2[3], t3[n3 + 4] = a2[4], t3[n3 + 5] = a2[5], t3[n3 + 6] = a2[6], t3[n3 + 7] = a2[7];
          }
          function n2(e2, t3, n3) {
            o[0] = e2, t3[n3] = a2[7], t3[n3 + 1] = a2[6], t3[n3 + 2] = a2[5], t3[n3 + 3] = a2[4], t3[n3 + 4] = a2[3], t3[n3 + 5] = a2[2], t3[n3 + 6] = a2[1], t3[n3 + 7] = a2[0];
          }
          function r(e2, t3) {
            return a2[0] = e2[t3], a2[1] = e2[t3 + 1], a2[2] = e2[t3 + 2], a2[3] = e2[t3 + 3], a2[4] = e2[t3 + 4], a2[5] = e2[t3 + 5], a2[6] = e2[t3 + 6], a2[7] = e2[t3 + 7], o[0];
          }
          function i(e2, t3) {
            return a2[7] = e2[t3], a2[6] = e2[t3 + 1], a2[5] = e2[t3 + 2], a2[4] = e2[t3 + 3], a2[3] = e2[t3 + 4], a2[2] = e2[t3 + 5], a2[1] = e2[t3 + 6], a2[0] = e2[t3 + 7], o[0];
          }
          var o = new Float64Array([-0]), a2 = new Uint8Array(o.buffer), s = 128 === a2[7];
          e.writeDoubleLE = s ? t2 : n2, e.writeDoubleBE = s ? n2 : t2, e.readDoubleLE = s ? r : i, e.readDoubleBE = s ? i : r;
        }() : function() {
          function t2(e2, t3, n3, r, i, o) {
            var a2 = 0 > r ? 1 : 0;
            if (a2 && (r = -r), 0 === r) e2(0, i, o + t3), e2(0 < 1 / r ? 0 : 2147483648, i, o + n3);
            else if (isNaN(r)) e2(0, i, o + t3), e2(2146959360, i, o + n3);
            else if (17976931348623157e292 < r) e2(0, i, o + t3), e2((a2 << 31 | 2146435072) >>> 0, i, o + n3);
            else if (22250738585072014e-324 > r) e2((r /= 5e-324) >>> 0, i, o + t3), e2((a2 << 31 | r / 4294967296) >>> 0, i, o + n3);
            else {
              var s = Math.floor(Math.log(r) / Math.LN2);
              1024 === s && (s = 1023), e2(4503599627370496 * (r *= Math.pow(2, -s)) >>> 0, i, o + t3), e2((a2 << 31 | s + 1023 << 20 | 1048576 * r & 1048575) >>> 0, i, o + n3);
            }
          }
          function n2(e2, t3, n3, r, i) {
            return t3 = e2(r, i + t3), r = e2(r, i + n3), e2 = 2 * (r >> 31) + 1, t3 = 4294967296 * (1048575 & r) + t3, 2047 === (n3 = r >>> 20 & 2047) ? t3 ? NaN : 1 / 0 * e2 : 0 === n3 ? 5e-324 * e2 * t3 : e2 * Math.pow(2, n3 - 1075) * (t3 + 4503599627370496);
          }
          e.writeDoubleLE = t2.bind(null, Am, 0, 4), e.writeDoubleBE = t2.bind(null, Bm, 4, 0), e.readDoubleLE = n2.bind(null, Cm, 0, 4), e.readDoubleBE = n2.bind(null, Dm, 4, 0);
        }(), e;
      }
      function Am(e, t2, n2) {
        t2[n2] = 255 & e, t2[n2 + 1] = e >>> 8 & 255, t2[n2 + 2] = e >>> 16 & 255, t2[n2 + 3] = e >>> 24;
      }
      function Bm(e, t2, n2) {
        t2[n2] = e >>> 24, t2[n2 + 1] = e >>> 16 & 255, t2[n2 + 2] = e >>> 8 & 255, t2[n2 + 3] = 255 & e;
      }
      function Cm(e, t2) {
        return (e[t2] | e[t2 + 1] << 8 | e[t2 + 2] << 16 | e[t2 + 3] << 24) >>> 0;
      }
      function Dm(e, t2) {
        return (e[t2] << 24 | e[t2 + 1] << 16 | e[t2 + 2] << 8 | e[t2 + 3]) >>> 0;
      }
      function Wa(e, t2) {
        this.lo = e >>> 0, this.hi = t2 >>> 0;
      }
      function sf(e, t2, n2) {
        this.fn = e, this.len = t2, this.next = void 0, this.val = n2;
      }
      function si() {
      }
      function Tt(e) {
        this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;
      }
      function ja() {
        this.len = 0, this.tail = this.head = new sf(si, 0, 0), this.states = null;
      }
      function ti(e, t2, n2) {
        t2[n2] = 255 & e;
      }
      function ui(e, t2) {
        this.len = e, this.next = void 0, this.val = t2;
      }
      function vi(e, t2, n2) {
        for (; e.hi; ) t2[n2++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;
        for (; 127 < e.lo; ) t2[n2++] = 127 & e.lo | 128, e.lo >>>= 7;
        t2[n2++] = e.lo;
      }
      function wi(e, t2, n2) {
        t2[n2] = 255 & e, t2[n2 + 1] = e >>> 8 & 255, t2[n2 + 2] = e >>> 16 & 255, t2[n2 + 3] = e >>> 24;
      }
      function jc() {
        xi.call(this);
      }
      function Ut(e, t2, n2) {
        40 > e.length ? V.utf8.write(e, t2, n2) : t2.utf8Write ? t2.utf8Write(e, n2) : t2.write(e, n2);
      }
      function Yb(e, t2) {
        return RangeError("index out of range: " + e.pos + " + " + (t2 || 1) + " > " + e.len);
      }
      function La(e) {
        this.buf = e, this.pos = 0, this.len = e.length;
      }
      function yi() {
        var e = new Em(0, 0), t2 = 0;
        if (!(4 < this.len - this.pos)) {
          for (; 3 > t2; ++t2) {
            if (this.pos >= this.len) throw Yb(this);
            if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, 128 > this.buf[this.pos++]) return e;
          }
          return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t2) >>> 0, e;
        }
        for (; 4 > t2; ++t2) if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, 128 > this.buf[this.pos++]) return e;
        if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, 128 > this.buf[this.pos++]) return e;
        if (t2 = 0, 4 < this.len - this.pos) {
          for (; 5 > t2; ++t2) if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, 128 > this.buf[this.pos++]) return e;
        } else for (; 5 > t2; ++t2) {
          if (this.pos >= this.len) throw Yb(this);
          if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, 128 > this.buf[this.pos++]) return e;
        }
        throw Error("invalid varint encoding");
      }
      function zg(e, t2) {
        return (e[t2 - 4] | e[t2 - 3] << 8 | e[t2 - 2] << 16 | e[t2 - 1] << 24) >>> 0;
      }
      function Fm() {
        if (this.pos + 8 > this.len) throw Yb(this, 8);
        return new Em(zg(this.buf, this.pos += 4), zg(this.buf, this.pos += 4));
      }
      function Fd(e) {
        zi.call(this, e);
      }
      function tf(e, t2, n2) {
        if ("function" != typeof e) throw TypeError("rpcImpl must be a function");
        V.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = !!t2, this.responseDelimited = !!n2;
      }
      function za(e) {
        return "string" == typeof e && /^[\s\w!#$%&()+,.:;<=>?@[\]^{|}~-]{1,64}$/.test(e) && "null" !== e;
      }
      function Gm(e) {
        try {
          var t2 = e.split(".").map(function(e2) {
            return Number(e2);
          });
        } catch (e2) {
          return false;
        }
        if (4 !== t2.length || 0 === t2[0]) return false;
        for (e = 0; e < t2.length; e++) {
          var n2 = t2[e];
          if (!Number.isInteger(n2) || 0 > n2 || 255 < n2) return false;
        }
        return true;
      }
      function Hm(e, t2) {
        if (!Array.isArray(t2) || 0 === t2.length || 32 < t2.length || t2.some(function(e2) {
          return 0 === e2.length || 32 < e2.length;
        })) throw new I("arguments is not valid", Ja);
        if (!za(e)) throw new I("ID is invalid", Ja);
      }
      function uf(e) {
        var t2 = e.attributes, n2 = e.attrSizeMap, r = e.maxAttrsCount, i = e.maxAttrValueSize;
        if (e = e.maxTotalSize, !yd(t2)) throw new I("attributes must be an object", Ja);
        if (Object.keys(t2).length > r) throw new ib("Exceed the limit of ".concat(r, " attributes"), se);
        if (0 === Object.keys(t2).length) throw new I("The attributes is an empty object", Ja);
        var o = 0, a2 = 0;
        for (t2 = Object.entries(t2); a2 < t2.length; a2++) {
          var s = ra(t2[a2], 2), u2 = s[1];
          s = new Blob([s[0]]).size;
          var c2 = new Blob([u2]).size;
          if (0 === s || 32 < s) throw new I("Invalid attribute key", Ja);
          if (c2 > i) throw new ib("Invalid attribute value, over the limit of ".concat(i, " bytes"), se);
          if ("string" != typeof u2 || 0 === u2.length) throw new I("Invalid attribute value", Ja);
          o += s, o += c2;
        }
        if (o > e) throw new ib("The attributes size overflow", se);
        if (void 0 !== n2) {
          if (Object.keys(n2).length > r) throw new ib("Exceed the limit of ".concat(r, " attributes"), se);
          for (o = r = 0, n2 = Object.entries(n2); o < n2.length; o++) {
            if (a2 = (t2 = ra(n2[o], 2))[1], 0 === (t2 = new Blob([t2[0]]).size)) throw new I("Invalid attribute key", Ja);
            if (a2 > i) throw new ib("Invalid attribute value, over the limit of ".concat(i, " bytes"), se);
            r += t2, r += a2;
          }
          if (r > e) throw new ib("The attributes size overflow", se);
        }
      }
      function Ag(e, t2) {
        return Math.floor(Math.random() * (Math.floor(t2) - Math.ceil(e) + 1)) + e;
      }
      function Bg() {
        var e = Ag(0, 4294967295), t2 = Ag(1, 4294967295);
        return new U(e, t2, true);
      }
      function Xa(e) {
        return e.toString().padEnd(32, "0");
      }
      function Im(e, t2) {
        return new TypeError("Unexpected ".concat(e, ": ").concat(t2));
      }
      function Jm(e, t2) {
        return e = e.split(".").map(function(e2) {
          return Number(e2);
        }), t2 = t2.split(".").map(function(e2) {
          return Number(e2);
        }), Math.sqrt(1e3 * Math.pow(e[0] - t2[0], 2) + 100 * Math.pow(e[1] - t2[1], 2) + 10 * Math.pow(e[2] - t2[2], 2) + 1 * Math.pow(e[3] - t2[3], 2));
      }
      function Km(e) {
        return e.lessThanOrEqual(Number.MAX_SAFE_INTEGER) ? e.toNumber() : e.toString();
      }
      function Ai(e, t2) {
        t2 = "".concat(e).concat(t2 || "");
        var n2 = Lm.get(t2) || 1;
        return Lm.set(t2, n2 + 1), "".concat(e).concat(n2);
      }
      function Mm(e, t2) {
        var n2 = "number" == typeof t2 ? t2 : void 0 !== t2 && "string" != typeof t2 ? t2.code : void 0;
        return t2 = "number" != typeof t2 && "string" != typeof t2 && void 0 !== t2 && void 0 !== t2.serverCode ? t2.serverCode : void 0, n2 = "".concat(void 0 !== n2 ? " Error Code ".concat(n2) : "").concat(void 0 !== t2 ? ", server Code ".concat(t2) : ""), e = "string" == typeof e && e ? Cg(e) : Array.isArray(e) && "string" == typeof e[0] && e[0] ? Cg(Nm.apply(void 0, [e[0]].concat(G(e.slice(1))))) : "", "".concat("" === n2 ? "" : "".concat(n2, " - ")).concat(e);
      }
      function Om(e) {
        return Bi.apply(this, arguments);
      }
      function Bi() {
        return (Bi = J(w.mark(function e(t2) {
          return w.wrap(function(e2) {
            for (; ; ) switch (e2.prev = e2.next) {
              case 0:
                return e2.abrupt("return", new Promise(function(e3) {
                  setTimeout(function() {
                    e3();
                  }, t2);
                }));
              case 1:
              case "end":
                return e2.stop();
            }
          }, e);
        }))).apply(this, arguments);
      }
      function Pm(e) {
        return e instanceof Blob || "[object Blob]" === Object.prototype.toString.call(e);
      }
      function Dg(e) {
        var t2 = 255 & e, n2 = e >> 8 & 255, r = e >> 16 & 255;
        return "".concat(e >> 24 & 255, ".").concat(r, ".").concat(n2, ".").concat(t2);
      }
      function te(e, t2, n2) {
        return Ci.apply(this, arguments);
      }
      function Ci() {
        return (Ci = J(w.mark(function e(t2, n2, r) {
          var i, o, a2, s, u2, c2, l, f, h, p, d, v2, b, g, y2, m2, E2, _, O2, I2, A, k, R2, T2, N2, S2;
          return w.wrap(function(e2) {
            for (; ; ) switch (e2.prev = e2.next) {
              case 0:
                if (i = n2.body, o = n2.headers, a2 = void 0 === o ? {} : o, s = n2.timeout, u2 = void 0 === s ? 1e4 : s, c2 = n2.signal, l = n2.withCredentials, f = void 0 !== l && l, h = (r || {}).useBinaryResponse, p = void 0 !== h && h, (d = new XMLHttpRequest()).open("POST", t2, true), d.responseType = p ? "arraybuffer" : "text", d.withCredentials = f, d.timeout = u2, v2 = i instanceof FormData, b = i instanceof Uint8Array, !(1 < (g = Object.keys(a2).filter(function(e3) {
                  return "content-type" === e3.toLowerCase();
                })).length)) {
                  e2.next = 14;
                  break;
                }
                throw new RangeError("multiple content-type");
              case 14:
                0 === g.length && (b ? a2["Content-Type"] = "application/octet-stream" : v2 || (a2["Content-Type"] = "application/json"));
              case 15:
                if ("setRequestHeader" in d) {
                  e2.next = 46;
                  break;
                }
                return d.abort(), e2.next = 19, fetch(t2, { body: v2 || b ? i : JSON.stringify(i), cache: "no-cache", credentials: f ? "include" : "same-origin", headers: a2, method: "POST", mode: "cors", referrer: "no-referrer", signal: c2 });
              case 19:
                if (y2 = e2.sent, !(200 <= (m2 = y2.status) && 300 > m2 || 304 === m2)) {
                  e2.next = 31;
                  break;
                }
                if (!p) {
                  e2.next = 27;
                  break;
                }
                return e2.next = 25, y2.arrayBuffer();
              case 25:
                return E2 = e2.sent, e2.abrupt("return", { status: m2, responseData: E2 });
              case 27:
                return e2.next = 29, y2.text();
              case 29:
                return _ = e2.sent, e2.abrupt("return", { status: m2, responseText: _ });
              case 31:
                return O2 = new da(["Post XHR failure, status %d", m2]), e2.prev = 32, e2.next = 35, y2.text();
              case 35:
                throw I2 = e2.sent, O2.statusCode = m2, O2.message = I2 || "Request failed, status ".concat(m2), O2;
              case 41:
                throw e2.prev = 41, e2.t0 = e2.catch(32), O2.statusCode = m2, O2.message = "Request failed, status ".concat(m2), O2;
              case 46:
                if (0 !== Object.keys(a2).length) for (A = 0, k = Object.entries(a2); A < k.length; A++) R2 = ra(k[A], 2), T2 = R2[0], N2 = R2[1], d.setRequestHeader(T2, N2);
                return void 0 !== c2 && (S2 = function e3() {
                  d.abort(), c2.removeEventListener("abort", e3);
                }, c2.addEventListener("abort", S2)), v2 || b ? d.send(i) : d.send(JSON.stringify(i)), e2.abrupt("return", new Promise(function(e3, t3) {
                  d.onload = function() {
                    var n3 = d.status;
                    if (200 <= n3 && 300 > n3 || 304 === n3) e3(p ? { status: n3, responseData: d.response } : { status: n3, responseText: d.responseText });
                    else {
                      var r2 = new da(["Post XHR failure, status %d", n3]);
                      r2.statusCode = n3, r2.message = d.response || "Request failed, status ".concat(d.status), t3(r2);
                    }
                  }, d.ontimeout = function(e4) {
                    t3(new db(["XHR request timed out after %d ms", u2], { originalError: e4 }));
                  }, d.onerror = function() {
                    var e4 = new da(["Post XHR failure, status %d", d.status]);
                    e4.statusCode = d.status, e4.message = d.response || "Request failed, status ".concat(d.status), t3(e4);
                  }, d.onabort = function() {
                    try {
                      t3(new DOMException("The request aborted.", "AbortError"));
                    } catch (n3) {
                      var e4 = Error("The request aborted.");
                      e4.name = "AbortError", t3(e4);
                    }
                  };
                }));
              case 50:
              case "end":
                return e2.stop();
            }
          }, e, null, [[32, 41]]);
        }))).apply(this, arguments);
      }
      function Rm(e) {
        return Hi.apply(this, arguments);
      }
      function Hi() {
        return (Hi = J(w.mark(function e(t2) {
          var n2;
          return w.wrap(function(e2) {
            for (; ; ) switch (e2.prev = e2.next) {
              case 0:
                return (n2 = new Image()).src = t2, e2.abrupt("return", new Promise(function(e3, t3) {
                  n2.onload = function() {
                    e3({ width: n2.width, height: n2.height });
                  }, n2.onerror = t3;
                }));
              case 3:
              case "end":
                return e2.stop();
            }
          }, e);
        }))).apply(this, arguments);
      }
      function Xt(e, t2) {
        return Ii.apply(this, arguments);
      }
      function Ii() {
        return (Ii = J(w.mark(function e(t2, n2) {
          var r, i, o, a2, s, u2, c2, l, f, h;
          return w.wrap(function(e2) {
            for (; ; ) switch (e2.prev = e2.next) {
              case 0:
                if (r = t2.thumbnailHeight, i = void 0 === r ? 0 : r, o = t2.thumbnailWidth, a2 = void 0 === o ? 0 : o, s = t2.width, u2 = void 0 === s ? 0 : s, c2 = t2.height, l = void 0 === c2 ? 0 : c2, f = t2.thumbnail, h = [], "number" == typeof i && "number" == typeof a2 && "number" == typeof u2 && "number" == typeof l) {
                  e2.next = 5;
                  break;
                }
                throw new I("Invalid message params", wf);
              case 5:
                return 0 >= u2 && 0 >= l && h.push(Rm(Sm(n2)).then(function(e3) {
                  u2 = e3.width, l = e3.height;
                })), 0 >= a2 && 0 >= i && void 0 !== f && h.push(Ji(f).then(function() {
                  var e3 = J(w.mark(function e4(t3) {
                    var n3;
                    return w.wrap(function(e5) {
                      for (; ; ) switch (e5.prev = e5.next) {
                        case 0:
                          return e5.next = 2, Rm(Sm(t3));
                        case 2:
                          n3 = e5.sent, a2 = n3.width, i = n3.height;
                        case 5:
                        case "end":
                          return e5.stop();
                      }
                    }, e4);
                  }));
                  return function(t3) {
                    return e3.apply(this, arguments);
                  };
                }())), e2.next = 9, Promise.all(h).catch(function() {
                });
              case 9:
                return e2.abrupt("return", { width: u2, height: l, thumbnailWidth: a2, thumbnailHeight: i });
              case 10:
              case "end":
                return e2.stop();
            }
          }, e);
        }))).apply(this, arguments);
      }
      function Tm(e, t2) {
        if (!yd(e)) throw new I("message object is not a plain object", t2);
        if (void 0 === e.messageType) if (e.rawMessage instanceof Uint8Array) {
          if (e.messageType = "RAW", void 0 !== e.text) throw new I("Raw messages cannot have text property. Use description instead", t2);
        } else {
          if ("string" != typeof e.text) throw new I("messageType is undefined", t2);
          if (e.messageType = "TEXT", void 0 !== e.rawMessage) throw new I("Text messages cannot have rawMessage property", t2);
        }
      }
      function Gg(e) {
        return Ki.apply(this, arguments);
      }
      function Ki() {
        return (Ki = J(w.mark(function e(t2) {
          var n2, r, i, o, a2, s, u2, c2, l, f, h, p, d, v2, b, g, y2, m2, E2, _, O2;
          return w.wrap(function(e2) {
            for (; ; ) switch (e2.prev = e2.next) {
              case 0:
                if (n2 = t2.message, r = t2.peerId, i = t2.toPeer, o = t2.session, a2 = t2.errorCodes, s = t2.diff, u2 = t2.logger, c2 = t2.options, void 0 !== o) {
                  e2.next = 3;
                  break;
                }
                throw new K("The client is not logged in. Cannot do the operation", a2.NOT_LOGGED_IN);
              case 3:
                if (l = false, "TEXT" !== n2.messageType || !n2.text.startsWith("AgoraRTMLegacyEndcallCompatibleMessagePrefix") || !i) {
                  e2.next = 11;
                  break;
                }
                if (f = n2.text.split("_"), h = ra(f, 3), p = h[0], d = h[1], void 0 !== h[2] && za(d) && "AgoraRTMLegacyEndcallCompatibleMessagePrefix" === p) {
                  e2.next = 10;
                  break;
                }
                throw new I("Message is not valid", ve);
              case 10:
                l = true;
              case 11:
                if (v2 = Date.now(), b = o.messageSentTimes.length - 1, !((g = o.messageSentTimes[b]) && g + 3e3 < v2)) {
                  e2.next = 18;
                  break;
                }
                o.messageSentTimes = [v2], e2.next = 29;
                break;
              case 18:
                y2 = b;
              case 19:
                if (!(0 <= y2)) {
                  e2.next = 28;
                  break;
                }
                if (!(o.messageSentTimes[y2] + 3e3 < v2)) {
                  e2.next = 23;
                  break;
                }
                return o.messageSentTimes = o.messageSentTimes.slice(y2 + 1, b + 1), e2.abrupt("break", 28);
              case 23:
                if (!(180 <= b - y2 + 1)) {
                  e2.next = 25;
                  break;
                }
                throw new ib("Message sent failed, exceeded the 180 message in 3 seconds", a2.TOO_OFTEN);
              case 25:
                y2--, e2.next = 19;
                break;
              case 28:
                o.messageSentTimes.push(v2);
              case 29:
                e2.t0 = n2.messageType, e2.next = "TEXT" === e2.t0 ? 32 : "RAW" === e2.t0 ? 37 : "FILE" === e2.t0 || "IMAGE" === e2.t0 ? 39 : 40;
                break;
              case 32:
                if (!l) {
                  e2.next = 36;
                  break;
                }
                return m2 = n2.text.split("_"), E2 = ra(m2, 3), _ = E2[1], O2 = E2[2], u2.info("[rtm-API] EndCall message send api is called"), e2.abrupt("return", o.sendInvitationMessage({ peerId: r, type: "CallCancel", extra: O2, channelId: _, callId: "0" }));
              case 36:
                return e2.abrupt("return", o.sendTextMessage(n2.text, r, i, c2, 1e4 - s));
              case 37:
                return void 0 === n2.description && (n2.description = ""), e2.abrupt("return", o.sendRawMessage(n2.rawMessage, n2.description, r, i, c2, 1e4 - s));
              case 39:
                return e2.abrupt("return", o.sendMediaMessage(n2.messageType, n2, r, i, c2, 1e4 - s));
              case 40:
                throw new I("Invalid message type", ve);
              case 41:
              case "end":
                return e2.stop();
            }
          }, e);
        }))).apply(this, arguments);
      }
      function Yt(e) {
        var t2 = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1], n2 = e.replace(/(https?:\/\/)?(www.)?/i, "");
        return t2 || (n2 = n2.split(".").slice(e.length - 2).join(".")), -1 !== n2.indexOf("/") ? n2.split("/")[0] : n2;
      }
      function oa(e) {
        if ("string" != typeof e) return "[Sensitive Info]";
        var t2 = Math.floor(0.7 * e.length), n2 = e.length;
        return Um(e, t2, n2, "*".repeat(n2 - t2));
      }
      function Vm(e, t2, n2) {
        function r(i) {
          if (void 0 === e) return e;
          if (Il(i)) return i;
          if (Array.isArray(i)) return i.map(r);
          var o = {}, a2 = 0;
          for (i = Hg(i); a2 < i.length; a2++) {
            var s = ra(i[a2], 2), u2 = s[0];
            if ("string" == typeof (s = s[1]) && n2.includes(u2)) {
              o[u2] = "string" == typeof s ? oa(s) : "[Sensitive Info]";
              break;
            }
            t2.includes(u2) ? o[u2] = "[Hidden Info]" : o[u2] = null == s ? s : n2.includes(u2) ? "[Sensitive Info]" : r(s);
          }
          return o;
        }
        return Array.isArray(e) ? e.map(r) : r(e);
      }
      function Wm(e) {
        return Object.getOwnPropertyNames(e).forEach(function(t2) {
          "object" == X(t2 = e[t2]) && null !== t2 && Wm(t2);
        }), Object.freeze(e);
      }
      function pa(e) {
        return new TextDecoder("utf-8").decode(e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength));
      }
      function Ig(e) {
        return new TextEncoder().encode(e).length;
      }
      function Xm() {
        for (var e = 0, t2 = arguments.length, n2 = Array(t2), r = 0; r < t2; r++) n2[r] = arguments[r];
        for (t2 = 0; t2 < n2.length; t2++) e += n2[t2].length;
        for (e = new Uint8Array(e), r = t2 = 0; r < n2.length; r++) {
          var i = n2[r];
          e.set(i, t2), t2 += i.length;
        }
        return e;
      }
      function we(e, t2, n2) {
        var r = e.match(/([^?#]+)(\?[^#]*)?(#.*)?/);
        if (e = null == r ? void 0 : r[1], r = null == r ? void 0 : r[2]) {
          var i;
          for (r = r.substr(1).split("&"), i = 0; i < r.length; i++) if (r[i].split("=")[0] == t2) {
            r[i] = t2 + "=" + encodeURIComponent(n2);
            break;
          }
          return i == r.length && r.push(t2 + "=" + encodeURIComponent(n2)), e + "?" + r.join("&");
        }
        return e + "?" + t2 + "=" + encodeURIComponent(n2);
      }
      function Ji(e) {
        return new Promise(function(t2, n2) {
          var r = new FileReader();
          r.onloadend = function() {
            var e2 = r.result || new ArrayBuffer(0);
            t2(e2);
          }, r.onerror = n2, r.readAsArrayBuffer(e);
        });
      }
      function Zt(e, t2) {
        e = e = [e], "string" == typeof (t2 = t2 || {}) && (t2 = { type: t2 });
        try {
          var n2 = new Blob(e, t2);
        } catch (i) {
          if ("TypeError" !== i.name) throw i;
          n2 = new ("undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder)();
          for (var r = 0; r < e.length; r += 1) n2.append(e[r]);
          n2 = n2.getBlob(t2.type);
        }
        return n2;
      }
      function Um(e, t2, n2, r) {
        return "string" != typeof e ? "[Sensitive Info]" : e.substring(0, t2) + r + e.substring(n2);
      }
      function Ym(e) {
        var t2 = [];
        return function e2(n2) {
          if (null === n2 || "object" !== X(n2)) return n2;
          if (-1 !== t2.indexOf(n2)) return "[Circular]";
          if (t2.push(n2), "function" == typeof n2.toJSON) try {
            var r = e2(n2.toJSON());
            return t2.pop(), r;
          } catch (e3) {
            return "[Throws: " + (e3 ? e3.message : "?") + "]";
          }
          return Array.isArray(n2) ? (r = n2.map(e2), t2.pop(), r) : (r = Object.keys(n2).reduce(function(t3, r2) {
            e: {
              if ($t.call(n2, r2)) try {
                var i = n2[r2];
                break e;
              } catch (e3) {
                i = "[Throws: " + (e3 ? e3.message : "?") + "]";
                break e;
              }
              i = n2[r2];
            }
            return t3[r2] = e2(i), t3;
          }, {}), t2.pop(), r);
        }(e);
      }
      function au(e) {
        if (!(100 < (e = String(e)).length) && (e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e))) {
          var t2 = parseFloat(e[1]);
          switch ((e[2] || "ms").toLowerCase()) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return 315576e5 * t2;
            case "weeks":
            case "week":
            case "w":
              return 6048e5 * t2;
            case "days":
            case "day":
            case "d":
              return 864e5 * t2;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return 36e5 * t2;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return 6e4 * t2;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return 1e3 * t2;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return t2;
          }
        }
      }
      function Jg(e, t2, n2, r) {
        return Math.round(e / n2) + " " + r + (t2 >= 1.5 * n2 ? "s" : "");
      }
      function bu(e) {
        var t2 = e.areas, n2 = e.excludedArea;
        if (1 === t2.length && t2[0] === F.GLOBAL && n2 === F.CHINA) return xe([F.OVERSEA]);
        if (t2.includes(F.GLOBAL)) {
          if (e = xf(Kg).filter(function(e2) {
            return e2 !== F.GLOBAL && e2 !== F.OVERSEA;
          }), n2 in yf) {
            t2 = yf[n2];
            var r = [].concat(G(null != t2 ? t2 : []), [n2]);
            return xe(e.filter(function(e2) {
              return !r.includes(e2);
            }));
          }
          if (Zm(n2)) {
            var i = cu(n2);
            return xe(e.filter(function(e2) {
              return e2 !== n2 && e2 !== i;
            }));
          }
        }
        if (Zm(n2) || n2 in yf) return xe(t2);
        throw new I("Invalid excludedArea area config");
      }
      function Ma(e, t2, n2) {
        void 0 === n2 && (n2 = Object.getOwnPropertyDescriptor(e, t2));
        var r = n2.value;
        return n2.value = function() {
          for (var e2 = this, n3 = arguments.length, i = Array(n3), o = 0; o < n3; o++) i[o] = arguments[o];
          this.invokeTracker.apply(this, ["%s: ".concat(0 < i.length ? "%s with args: ".concat(i.map(function() {
            return "%o";
          })) : "%s"), this.name, t2].concat(G(i.map(ye))));
          try {
            var a2 = r.apply(this, i);
          } catch (e3) {
            throw this.logError.apply(this, ["".concat(void 0 !== e3.code ? "Error Code ".concat(e3.code, ": ") : "", "%s failed").concat(0 < i.length ? " with args: ".concat(i.map(function() {
              return "%o";
            })) : ""), t2].concat(G(i.map(ye)))), e3.originalError && this.logError(e3.originalError), this.errorTracker(e3), e3;
          }
          var s = Date.now();
          return J(w.mark(function n4() {
            var r2, o2;
            return w.wrap(function(n5) {
              for (; ; ) switch (n5.prev = n5.next) {
                case 0:
                  return n5.prev = 0, n5.next = 3, a2;
                case 3:
                  r2 = n5.sent, n5.next = 12;
                  break;
                case 6:
                  return n5.prev = 6, n5.t0 = n5.catch(0), e2.logError.apply(e2, ["".concat(void 0 !== n5.t0.code ? "Error Code ".concat(n5.t0.code, ": ") : "", "%s failed").concat(0 < i.length ? " with args: ".concat(i.map(function() {
                    return "%o";
                  })) : ""), t2].concat(G(i.map(ye)))), n5.t0.originalError && e2.logError(n5.t0.originalError), e2.errorTracker(n5.t0), n5.abrupt("return");
                case 12:
                  r2 !== a2 ? void 0 === r2 ? e2.resultTracker("%s promise resolves after %dms", t2, Date.now() - s) : e2.resultTracker("%s promise resolves after %dms, result is %o", t2, Date.now() - s, ye(r2)) : "Object" !== Ac(r2) || yd(r2) ? e2.resultTracker("%s result is %o", t2, ye(r2)) : e2.resultTracker("%s result is %s", t2, r2.name || (null === (o2 = r2.constructor) || void 0 === o2 ? void 0 : o2.name));
                case 13:
                case "end":
                  return n5.stop();
              }
            }, n4, null, [[0, 6]]);
          }))(), a2;
        }, n2;
      }
      function Nb(e, t2, n2) {
        void 0 === n2 && (n2 = Object.getOwnPropertyDescriptor(e, t2));
        var r = n2.value;
        return n2.value = function() {
          for (var e2 = this, n3 = arguments.length, i = Array(n3), o = 0; o < n3; o++) i[o] = arguments[o];
          this.invokeTracker.apply(this, ["%s: ".concat(0 < i.length ? "%s with args: ".concat(i.map(function() {
            return "%o";
          })) : "%s"), this.name, t2].concat(i));
          try {
            var a2 = r.apply(this, i);
          } catch (e3) {
            throw this.logError.apply(this, ["".concat(void 0 !== e3.code ? "Error Code ".concat(e3.code, ": ") : "", "%s failed").concat(0 < i.length ? " with args: ".concat(i.map(function() {
              return "%o";
            })) : ""), t2].concat(i)), e3.originalError && this.logError(e3.originalError), this.errorTracker(e3), e3;
          }
          var s = Date.now();
          return J(w.mark(function n4() {
            var r2, o2;
            return w.wrap(function(n5) {
              for (; ; ) switch (n5.prev = n5.next) {
                case 0:
                  return n5.prev = 0, n5.next = 3, a2;
                case 3:
                  r2 = n5.sent, n5.next = 12;
                  break;
                case 6:
                  return n5.prev = 6, n5.t0 = n5.catch(0), e2.logError.apply(e2, ["".concat(void 0 !== n5.t0.code ? "Error Code ".concat(n5.t0.code, ": ") : "", "%s failed").concat(0 < i.length ? " with args: ".concat(i.map(function() {
                    return "%o";
                  })) : ""), t2].concat(i)), n5.t0.originalError && e2.logError(n5.t0.originalError), e2.errorTracker(n5.t0), n5.abrupt("return");
                case 12:
                  r2 !== a2 ? void 0 === r2 ? e2.resultTracker("%s promise resolves after %dms", t2, Date.now() - s) : e2.resultTracker("%s promise resolves after %dms, result is %o", t2, Date.now() - s, r2) : "Object" !== Ac(r2) || yd(r2) ? e2.resultTracker("%s result is %o", t2, r2) : e2.resultTracker("%s result is %s", t2, r2.name || (null === (o2 = r2.constructor) || void 0 === o2 ? void 0 : o2.name));
                case 13:
                case "end":
                  return n5.stop();
              }
            }, n4, null, [[0, 6]]);
          }))(), a2;
        }, n2;
      }
      function du(e, t2) {
        var n2 = "".concat(e, "Uri");
        if ("number" != typeof (n2 = Li[n2]) || 0 === n2) throw new TypeError("Got Unknown URI Name");
        return t2 = new (e = $m[e])(t2), t2 = e.encode(t2).finish(), new eu({ uri: n2, data: t2 });
      }
      function an(e, t2) {
        return "".concat(e.split(".").join("-"), ".edge.").concat(t2 ? "sd-rtn.com" : "agora.io");
      }
      function eb(e, t2, n2) {
        return Mi.apply(this, arguments);
      }
      function Mi() {
        return (Mi = J(w.mark(function e(t2, n2, r) {
          var i, o;
          return w.wrap(function(e2) {
            for (; ; ) switch (e2.prev = e2.next) {
              case 0:
                e2.next = 2;
                break;
              case 2:
                return i = fu[t2].encode(n2).finish(), o = function() {
                  var e3 = J(w.mark(function e4(n3) {
                    var a2, s, u2, c2 = arguments;
                    return w.wrap(function(e5) {
                      for (; ; ) switch (e5.prev = e5.next) {
                        case 0:
                          if (!(3 < (s = 1 < c2.length && void 0 !== c2[1] ? c2[1] : 0))) {
                            e5.next = 3;
                            break;
                          }
                          return e5.abrupt("return");
                        case 3:
                          return u2 = we(u2 = r ? "https://".concat(null !== (a2 = null == M ? void 0 : M.PROXY_NGINX[0]) && void 0 !== a2 ? a2 : "webrtc-cloud-proxy.sd-rtn.com", "/rs/?h=").concat(n3, "&p=6443&d=events/proto-raw") : "https://".concat(n3, ":6443/events/proto-raw"), "sentTs", Math.ceil(Date.now() / 1e3).toString()), u2 = we(u2, "id", gu[t2].toString()), e5.next = 8, te(u2, { body: i, timeout: 2e4, headers: { "Content-Type": "application/octet-stream" } }).catch(function(e6) {
                            return o(n3, s + 1);
                          });
                        case 8:
                        case "end":
                          return e5.stop();
                      }
                    }, e4);
                  }));
                  return function(t3) {
                    return e3.apply(this, arguments);
                  };
                }(), e2.prev = 4, e2.next = 7, o((null == M ? void 0 : M.EVENT_REPORT_DOMAIN[0]) || "webcollector-rtm.agora.io");
              case 7:
                e2.next = 13;
                break;
              case 9:
                return e2.prev = 9, e2.t0 = e2.catch(4), e2.next = 13, o(M && bn(1 < (null == M ? void 0 : M.EVENT_REPORT_DOMAIN.length) ? null == M ? void 0 : M.EVENT_REPORT_DOMAIN.slice(1) : null == M ? void 0 : M.EVENT_REPORT_DOMAIN) || "rtm.statscollector.sd-rtn.com");
              case 13:
              case "end":
                return e2.stop();
            }
          }, e, null, [[4, 9]]);
        }))).apply(this, arguments);
      }
      function fb(e) {
        return void 0 === e ? U.fromNumber(0) : U.fromNumber(Date.now() - e);
      }
      function hu(e) {
        return btoa(String.fromCharCode.apply({}, e.replace(/\r|\n/g, "").replace(/([\dA-Fa-f]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ").map(function(e2) {
          return parseInt(e2, 16);
        }))).replace(/={1,2}$/, "");
      }
      function Lg(e, t2) {
        return U.fromValue(e).eq(t2);
      }
      function Mg(e, t2) {
        var n2 = void 0 === t2 ? e.val : t2, r = e.isBoolean;
        t2 = e.isNumber;
        var i = e.oneof, o = e.len;
        if (2 !== [r, t2, i].filter(function(e2) {
          return !e2;
        }).length) throw new TypeError("invalid field type");
        if (void 0 !== n2 && (e = false, void 0 !== i && (i = Ni(i), iu(i, Lg).length === i.length && void 0 !== ju(i, function(e2) {
          return Lg(n2, e2);
        }) && (e = true)), r = void 0 !== r && (0 === n2 || 1 === n2) && 1 === o, t2 = void 0 !== t2 && n2.toString(2).length <= o, !(e || r || t2))) throw Error("invalid field value");
      }
      function cn(e) {
        return function() {
          var t2 = e();
          if (!t2) throw new K("Client is not logged in. Cannot do the operation");
          return t2;
        };
      }
      var Ya = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, Ng = function(e) {
        return e && e.Math == Math && e;
      }, y = Ng("object" == typeof globalThis && globalThis) || Ng("object" == typeof window && window) || Ng("object" == typeof self && self) || Ng("object" == typeof Ya && Ya) || /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")(), R = function(e) {
        try {
          return !!e();
        } catch (e2) {
          return true;
        }
      }, ka = !R(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), dn = {}.propertyIsEnumerable, en = Object.getOwnPropertyDescriptor, zf = en && !dn.call({ 1: 2 }, 1) ? function(e) {
        return !!(e = en(this, e)) && e.enumerable;
      } : dn, dd = function(e, t2) {
        return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t2 };
      }, ku = {}.toString, Zb = function(e) {
        return ku.call(e).slice(8, -1);
      }, lu = "".split, Af = R(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(e) {
        return "String" == Zb(e) ? lu.call(e, "") : Object(e);
      } : Object, jb = function(e) {
        if (null == e) throw TypeError("Can't call method on " + e);
        return e;
      }, qb = function(e) {
        return Af(jb(e));
      }, ha = function(e) {
        return "object" == typeof e ? null !== e : "function" == typeof e;
      }, lc = function(e, t2) {
        if (!ha(e)) return e;
        var n2, r;
        if (t2 && "function" == typeof (n2 = e.toString) && !ha(r = n2.call(e)) || "function" == typeof (n2 = e.valueOf) && !ha(r = n2.call(e)) || !t2 && "function" == typeof (n2 = e.toString) && !ha(r = n2.call(e))) return r;
        throw TypeError("Can't convert object to primitive value");
      }, Qa = function(e) {
        return Object(jb(e));
      }, mu = {}.hasOwnProperty, Q = function(e, t2) {
        return mu.call(Qa(e), t2);
      }, ze = y.document, Og = ha(ze) && ha(ze.createElement), fn = !ka && !R(function() {
        return 7 != Object.defineProperty(Og ? ze.createElement("div") : {}, "a", { get: function() {
          return 7;
        } }).a;
      }), gn = Object.getOwnPropertyDescriptor, Fb = { f: ka ? gn : function(e, t2) {
        if (e = qb(e), t2 = lc(t2, true), fn) try {
          return gn(e, t2);
        } catch (e2) {
        }
        if (Q(e, t2)) return dd(!zf.call(e, t2), e[t2]);
      } }, va = function(e) {
        if (!ha(e)) throw TypeError(String(e) + " is not an object");
        return e;
      }, hn = Object.defineProperty, Ra = { f: ka ? hn : function(e, t2, n2) {
        if (va(e), t2 = lc(t2, true), va(n2), fn) try {
          return hn(e, t2, n2);
        } catch (e2) {
        }
        if ("get" in n2 || "set" in n2) throw TypeError("Accessors not supported");
        return "value" in n2 && (e[t2] = n2.value), e;
      } }, Na = ka ? function(e, t2, n2) {
        return Ra.f(e, t2, dd(1, n2));
      } : function(e, t2, n2) {
        return e[t2] = n2, e;
      }, Oi = function(e, t2) {
        try {
          Na(y, e, t2);
        } catch (n2) {
          y[e] = t2;
        }
        return t2;
      }, ed = y["__core-js_shared__"] || Oi("__core-js_shared__", {}), nu = Function.toString;
      "function" != typeof ed.inspectSource && (ed.inspectSource = function(e) {
        return nu.call(e);
      });
      var Pi = ed.inspectSource, jn = y.WeakMap, ou = "function" == typeof jn && /native code/.test(Pi(jn)), fd = $a(function(e) {
        (e.exports = function(e2, t2) {
          return ed[e2] || (ed[e2] = void 0 !== t2 ? t2 : {});
        })("versions", []).push({ version: "3.12.1", mode: "global", copyright: "Â© 2021 Denis Pushkarev (zloirock.ru)" });
      }), pu = 0, qu = Math.random(), Ae = function(e) {
        return "Symbol(" + String(void 0 === e ? "" : e) + ")_" + (++pu + qu).toString(36);
      }, kn = fd("keys"), Pg = function(e) {
        return kn[e] || (kn[e] = Ae(e));
      }, Be = {}, ru = y.WeakMap;
      if (ou || ed.state) var Gd = ed.state || (ed.state = new ru()), su = Gd.get, ln = Gd.has, tu = Gd.set, Qi = function(e, t2) {
        if (ln.call(Gd, e)) throw new TypeError("Object already initialized");
        return t2.facade = e, tu.call(Gd, e, t2), t2;
      }, Qg = function(e) {
        return su.call(Gd, e) || {};
      }, Ri = function(e) {
        return ln.call(Gd, e);
      };
      else {
        var Ce = Pg("state");
        Be[Ce] = true, Qi = function(e, t2) {
          if (Q(e, Ce)) throw new TypeError("Object already initialized");
          return t2.facade = e, Na(e, Ce, t2), t2;
        }, Qg = function(e) {
          return Q(e, Ce) ? e[Ce] : {};
        }, Ri = function(e) {
          return Q(e, Ce);
        };
      }
      var Za = { set: Qi, get: Qg, has: Ri, enforce: function(e) {
        return Ri(e) ? Qg(e) : Qi(e, {});
      }, getterFor: function(e) {
        return function(t2) {
          var n2;
          if (!ha(t2) || (n2 = Qg(t2)).type !== e) throw TypeError("Incompatible receiver, " + e + " required");
          return n2;
        };
      } }, Ta = $a(function(e) {
        var t2 = Za.get, n2 = Za.enforce, r = String(String).split("String");
        (e.exports = function(e2, t3, i, o) {
          var a2 = !!o && !!o.unsafe, s = !!o && !!o.enumerable;
          if (o = !!o && !!o.noTargetGet, "function" == typeof i) {
            "string" != typeof t3 || Q(i, "name") || Na(i, "name", t3);
            var u2 = n2(i);
            u2.source || (u2.source = r.join("string" == typeof t3 ? t3 : ""));
          }
          e2 === y ? s ? e2[t3] = i : Oi(t3, i) : (a2 ? !o && e2[t3] && (s = true) : delete e2[t3], s ? e2[t3] = i : Na(e2, t3, i));
        })(Function.prototype, "toString", function() {
          return "function" == typeof this && t2(this).source || Pi(this);
        });
      }), mn = function(e) {
        return "function" == typeof e ? e : void 0;
      }, mc = function(e, t2) {
        return 2 > arguments.length ? mn(y[e]) || mn(y[e]) : y[e] && y[e][t2] || y[e] && y[e][t2];
      }, uu = Math.ceil, vu = Math.floor, $b = function(e) {
        return isNaN(e = +e) ? 0 : (0 < e ? vu : uu)(e);
      }, wu = Math.min, ta = function(e) {
        return 0 < e ? wu($b(e), 9007199254740991) : 0;
      }, xu = Math.max, yu = Math.min, xb = function(e, t2) {
        return 0 > (e = $b(e)) ? xu(e + t2, 0) : yu(e, t2);
      }, nn = function(e) {
        return function(t2, n2, r) {
          t2 = qb(t2);
          var i = ta(t2.length);
          if (r = xb(r, i), e && n2 != n2) {
            for (; i > r; ) if ((n2 = t2[r++]) != n2) return true;
          } else for (; i > r; r++) if ((e || r in t2) && t2[r] === n2) return e || r || 0;
          return !e && -1;
        };
      }, on = nn(true), Si = nn(false), pn = function(e, t2) {
        e = qb(e);
        var n2, r = 0, i = [];
        for (n2 in e) !Q(Be, n2) && Q(e, n2) && i.push(n2);
        for (; t2.length > r; ) Q(e, n2 = t2[r++]) && (~Si(i, n2) || i.push(n2));
        return i;
      }, Rg = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), zu = Rg.concat("length", "prototype"), Hd = { f: Object.getOwnPropertyNames || function(e) {
        return pn(e, zu);
      } }, Bf = { f: Object.getOwnPropertySymbols }, qn = mc("Reflect", "ownKeys") || function(e) {
        var t2 = Hd.f(va(e)), n2 = Bf.f;
        return n2 ? t2.concat(n2(e)) : t2;
      }, rn = function(e, t2) {
        for (var n2 = qn(t2), r = Ra.f, i = Fb.f, o = 0; o < n2.length; o++) {
          var a2 = n2[o];
          Q(e, a2) || r(e, a2, i(t2, a2));
        }
      }, Au = /#|\.prototype\./, nc = function(e, t2) {
        return (e = Bu[Cu(e)]) == Du || e != Eu && ("function" == typeof t2 ? R(t2) : !!t2);
      }, Cu = nc.normalize = function(e) {
        return String(e).replace(Au, ".").toLowerCase();
      }, Bu = nc.data = {}, Eu = nc.NATIVE = "N", Du = nc.POLYFILL = "P", Fu = Fb.f, N = function(e, t2) {
        var n2, r, i, o = e.target, a2 = e.global, s = e.stat;
        if (r = a2 ? y : s ? y[o] || Oi(o, {}) : (y[o] || {}).prototype) for (i in t2) {
          var u2 = t2[i], c2 = e.noTargetGet ? (n2 = Fu(r, i)) && n2.value : r[i];
          if (!(n2 = nc(a2 ? i : o + (s ? "." : "#") + i, e.forced)) && void 0 !== c2) {
            if (typeof u2 == typeof c2) continue;
            rn(u2, c2);
          }
          (e.sham || c2 && c2.sham) && Na(u2, "sham", true);
          try {
            Ta(r, i, u2, e);
          } catch (e2) {
          }
        }
      }, yb = function(e) {
        if ("function" != typeof e) throw TypeError(String(e) + " is not a function");
        return e;
      }, Id = function(e, t2, n2) {
        if (yb(e), void 0 === t2) return e;
        switch (n2) {
          case 0:
            return function() {
              return e.call(t2);
            };
          case 1:
            return function(n3) {
              return e.call(t2, n3);
            };
          case 2:
            return function(n3, r) {
              return e.call(t2, n3, r);
            };
          case 3:
            return function(n3, r, i) {
              return e.call(t2, n3, r, i);
            };
        }
        return function() {
          return e.apply(t2, arguments);
        };
      }, gd = Array.isArray || function(e) {
        return "Array" == Zb(e);
      }, De = mc("navigator", "userAgent") || "", sn = y.process, tn = sn && sn.versions, un = tn && tn.v8;
      if (un) var hd = un.split("."), Ti = 4 > hd[0] ? 1 : hd[0] + hd[1];
      else De && (hd = De.match(/Edge\/(\d+)/), (!hd || 74 <= hd[1]) && (hd = De.match(/Chrome\/(\d+)/)) && (Ti = hd[1]));
      var id = Ti && +Ti, oc = !!Object.getOwnPropertySymbols && !R(function() {
        return !String(Symbol()) || !Symbol.sham && id && 41 > id;
      }), vn = oc && !Symbol.sham && "symbol" == typeof Symbol.iterator, Cf = fd("wks"), Df = y.Symbol, Gu = vn ? Df : Df && Df.withoutSetter || Ae, qa = function(e) {
        return Q(Cf, e) && (oc || "string" == typeof Cf[e]) || (oc && Q(Df, e) ? Cf[e] = Df[e] : Cf[e] = Gu("Symbol." + e)), Cf[e];
      }, Hu = qa("species"), Sg = function(e, t2) {
        if (gd(e)) {
          var n2 = e.constructor;
          "function" != typeof n2 || n2 !== Array && !gd(n2.prototype) ? ha(n2) && (null === (n2 = n2[Hu]) && (n2 = void 0)) : n2 = void 0;
        }
        return new (void 0 === n2 ? Array : n2)(0 === t2 ? 0 : t2);
      }, wn = [].push, jd = function(e) {
        var t2 = 1 == e, n2 = 2 == e, r = 3 == e, i = 4 == e, o = 6 == e, a2 = 7 == e, s = 5 == e || o;
        return function(u2, c2, l, f) {
          var h = Qa(u2), p = Af(h);
          c2 = Id(c2, l, 3), l = ta(p.length);
          var d, v2 = 0;
          for (f = f || Sg, u2 = t2 ? f(u2, l) : n2 || a2 ? f(u2, 0) : void 0; l > v2; v2++) if ((s || v2 in p) && (d = c2(f = p[v2], v2, h), e)) if (t2) u2[v2] = d;
          else if (d) switch (e) {
            case 3:
              return true;
            case 5:
              return f;
            case 6:
              return v2;
            case 2:
              wn.call(u2, f);
          }
          else switch (e) {
            case 4:
              return false;
            case 7:
              wn.call(u2, f);
          }
          return o ? -1 : r || i ? i : u2;
        };
      }, Jd = jd(0), xn = jd(1), yn = jd(2), Iu = jd(3), Ju = jd(4), zn = jd(5), An = jd(6);
      jd(7);
      var Ku = qa("species"), Ef = function(e) {
        return 51 <= id || !R(function() {
          var t2 = [];
          return (t2.constructor = {})[Ku] = function() {
            return { foo: 1 };
          }, 1 !== t2[e](Boolean).foo;
        });
      }, Lu = Ef("filter");
      N({ target: "Array", proto: true, forced: !Lu }, { filter: function(e) {
        return yn(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } });
      var Dc = Object.keys || function(e) {
        return pn(e, Rg);
      }, Mu = R(function() {
        Dc(1);
      });
      N({ target: "Object", stat: true, forced: Mu }, { keys: function(e) {
        return Dc(Qa(e));
      } });
      var Ee = function(e, t2) {
        var n2 = [][e];
        return !!n2 && R(function() {
          n2.call(null, t2 || function() {
            throw 1;
          }, 1);
        });
      }, Nu = [].join, Ou = Af != Object, Pu = Ee("join", ",");
      N({ target: "Array", proto: true, forced: Ou || !Pu }, { join: function(e) {
        return Nu.call(qb(this), void 0 === e ? "," : e);
      } });
      var Qu = Ef("map");
      N({ target: "Array", proto: true, forced: !Qu }, { map: function(e) {
        return xn(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } });
      var Ui = function(e) {
        var t2 = e.return;
        if (void 0 !== t2) return va(t2.call(e)).value;
      }, Fe = {}, Ru = qa("iterator"), Su = Array.prototype, Vi = function(e) {
        return void 0 !== e && (Fe.Array === e || Su[Ru] === e);
      }, Ge = function(e, t2, n2) {
        (t2 = lc(t2)) in e ? Ra.f(e, t2, dd(0, n2)) : e[t2] = n2;
      }, Tu = qa("toStringTag"), Bn = {};
      Bn[Tu] = "z";
      var Wi = "[object z]" === String(Bn), Uu = qa("toStringTag"), Vu = "Arguments" == Zb(/* @__PURE__ */ function() {
        return arguments;
      }()), Ff = Wi ? Zb : function(e) {
        var t2;
        if (void 0 === e) var n2 = "Undefined";
        else {
          if (null === e) var r = "Null";
          else {
            e: {
              var i = e = Object(e);
              try {
                r = i[Uu];
                break e;
              } catch (e2) {
              }
              r = void 0;
            }
            r = "string" == typeof (n2 = r) ? n2 : Vu ? Zb(e) : "Object" == (t2 = Zb(e)) && "function" == typeof e.callee ? "Arguments" : t2;
          }
          n2 = r;
        }
        return n2;
      }, Wu = qa("iterator"), Xi = function(e) {
        if (null != e) return e[Wu] || e["@@iterator"] || Fe[Ff(e)];
      }, Cn = qa("iterator"), Dn = false;
      try {
        var Xu = 0, En = { next: function() {
          return { done: !!Xu++ };
        }, return: function() {
          Dn = true;
        } };
        En[Cn] = function() {
          return this;
        }, Array.from(En, function() {
          throw 2;
        });
      } catch (c2) {
      }
      var Tg = function(e, t2) {
        if (!t2 && !Dn) return false;
        var n2 = false;
        try {
          (t2 = {})[Cn] = function() {
            return { next: function() {
              return { done: n2 = true };
            } };
          }, e(t2);
        } catch (e2) {
        }
        return n2;
      }, Yu = !Tg(function(e) {
        Array.from(e);
      });
      N({ target: "Array", stat: true, forced: Yu }, { from: function(e) {
        var t2, n2 = Qa(e), r = "function" == typeof this ? this : Array, i = arguments.length, o = 1 < i ? arguments[1] : void 0, a2 = void 0 !== o, s = Xi(n2), u2 = 0;
        if (a2 && (o = Id(o, 2 < i ? arguments[2] : void 0, 2)), null == s || r == Array && Vi(s)) {
          var c2 = ta(n2.length);
          for (r = new r(c2); c2 > u2; u2++) s = a2 ? o(n2[u2], u2) : n2[u2], Ge(r, u2, s);
        } else for (i = (n2 = s.call(n2)).next, r = new r(); !(t2 = i.call(n2)).done; u2++) {
          if (a2) {
            s = n2;
            var l = o;
            t2 = [t2.value, u2];
            try {
              c2 = l(va(t2)[0], t2[1]);
            } catch (e2) {
              throw Ui(s), e2;
            }
          } else c2 = t2.value;
          Ge(r, u2, s = c2);
        }
        return r.length = u2, r;
      } });
      var Fn = function(e) {
        return function(t2, n2) {
          t2 = String(jb(t2)), n2 = $b(n2);
          var r, i = t2.length;
          if (0 > n2 || n2 >= i) return e ? "" : void 0;
          var o = t2.charCodeAt(n2);
          return 55296 > o || 56319 < o || n2 + 1 === i || 56320 > (r = t2.charCodeAt(n2 + 1)) || 57343 < r ? e ? t2.charAt(n2) : o : e ? t2.slice(n2, n2 + 2) : r - 56320 + (o - 55296 << 10) + 65536;
        };
      };
      Fn(false);
      var Gn = Fn(true), Hn = !R(function() {
        function e() {
        }
        return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;
      }), In = Pg("IE_PROTO"), Zu = Object.prototype, Vb = Hn ? Object.getPrototypeOf : function(e) {
        return e = Qa(e), Q(e, In) ? e[In] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? Zu : null;
      }, Yi = qa("iterator"), Jn = false, $u = function() {
        return this;
      }, Kd;
      if ([].keys) {
        var Kn = [].keys();
        if ("next" in Kn) {
          var Ln = Vb(Vb(Kn));
          Ln !== Object.prototype && (Kd = Ln);
        } else Jn = true;
      }
      (null == Kd || R(function() {
        var e = {};
        return Kd[Yi].call(e) !== e;
      })) && (Kd = {}), Q(Kd, Yi) || Na(Kd, Yi, $u);
      var Ug = Kd, Vg = Jn, av = ka ? Object.defineProperties : function(e, t2) {
        va(e);
        for (var n2, r = Dc(t2), i = r.length, o = 0; i > o; ) Ra.f(e, n2 = r[o++], t2[n2]);
        return e;
      }, Zi = mc("document", "documentElement"), Mn = Pg("IE_PROTO"), $i = function() {
      }, aj, Wg = function() {
        try {
          aj = document.domain && new ActiveXObject("htmlfile");
        } catch (e2) {
        }
        if (aj) {
          var e = aj;
          e.write("<script><\/script>"), e.close(), e = e.parentWindow.Object;
        } else (e = Og ? ze.createElement("iframe") : {}).style.display = "none", Zi.appendChild(e), e.src = "javascript:", (e = e.contentWindow.document).open(), e.write("<script>document.F=Object<\/script>"), e.close(), e = e.F;
        for (Wg = e, e = Rg.length; e--; ) delete Wg.prototype[Rg[e]];
        return Wg();
      };
      Be[Mn] = true;
      var ac = Object.create || function(e, t2) {
        if (null !== e) {
          $i.prototype = va(e);
          var n2 = new $i();
          $i.prototype = null, n2[Mn] = e;
        } else n2 = Wg();
        return void 0 === t2 ? n2 : av(n2, t2);
      }, bv = Ra.f, Nn = qa("toStringTag"), Ec = function(e, t2, n2) {
        e && !Q(e = n2 ? e : e.prototype, Nn) && bv(e, Nn, { configurable: true, value: t2 });
      }, cv = function() {
        return this;
      }, dv = function(e, t2, n2) {
        return t2 += " Iterator", e.prototype = ac(Ug, { next: dd(1, n2) }), Ec(e, t2, false), Fe[t2] = cv, e;
      }, Ua = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e = false, t2 = {};
        try {
          var n2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
          n2.call(t2, []), e = t2 instanceof Array;
        } catch (e2) {
        }
        return function(t3, r) {
          if (va(t3), !ha(r) && null !== r) throw TypeError("Can't set " + String(r) + " as a prototype");
          return e ? n2.call(t3, r) : t3.__proto__ = r, t3;
        };
      }() : void 0), Gf = qa("iterator"), ev = function() {
        return this;
      }, bj = function(e, t2, n2, r, i, o, a2) {
        dv(n2, t2, r), r = function(e2) {
          if (e2 === i && h) return h;
          if (!Vg && e2 in l) return l[e2];
          switch (e2) {
            case "keys":
            case "values":
            case "entries":
              return function() {
                return new n2(this, e2);
              };
          }
          return function() {
            return new n2(this);
          };
        };
        var s, u2 = t2 + " Iterator", c2 = false, l = e.prototype, f = l[Gf] || l["@@iterator"] || i && l[i], h = !Vg && f || r(i), p = "Array" == t2 && l.entries || f;
        if (p && (e = Vb(p.call(new e())), Ug !== Object.prototype && e.next && (Vb(e) !== Ug && (Ua ? Ua(e, Ug) : "function" != typeof e[Gf] && Na(e, Gf, ev)), Ec(e, u2, true))), "values" == i && f && "values" !== f.name && (c2 = true, h = function() {
          return f.call(this);
        }), l[Gf] !== h && Na(l, Gf, h), Fe[t2] = h, i) {
          var d = { values: r("values"), keys: o ? h : r("keys"), entries: r("entries") };
          if (a2) for (s in d) !Vg && !c2 && s in l || Ta(l, s, d[s]);
          else N({ target: t2, proto: true, forced: Vg || c2 }, d);
        }
        return d;
      }, fv = Za.set, gv = Za.getterFor("String Iterator");
      bj(String, "String", function(e) {
        fv(this, { type: "String Iterator", string: String(e), index: 0 });
      }, function() {
        var e = gv(this), t2 = e.string, n2 = e.index;
        return n2 >= t2.length ? { value: void 0, done: true } : (t2 = Gn(t2, n2), e.index += t2.length, { value: t2, done: false });
      });
      var cj = qa("unscopables"), dj = Array.prototype;
      null == dj[cj] && Ra.f(dj, cj, { configurable: true, value: ac(null) });
      var Ld = function(e) {
        dj[cj][e] = true;
      }, On = true;
      "find" in [] && Array(1).find(function() {
        On = false;
      }), N({ target: "Array", proto: true, forced: On }, { find: function(e) {
        return zn(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } }), Ld("find");
      var Pn = function(e) {
        var t2 = String(jb(this)), n2 = "";
        if (0 > (e = $b(e)) || 1 / 0 == e) throw RangeError("Wrong number of repetitions");
        for (; 0 < e; (e >>>= 1) && (t2 += t2)) 1 & e && (n2 += t2);
        return n2;
      };
      N({ target: "String", proto: true }, { repeat: Pn }), N({ target: "Number", stat: true }, { MAX_SAFE_INTEGER: 9007199254740991 }), N({ target: "Number", stat: true }, { isNaN: function(e) {
        return e != e;
      } }), y.Number.isNaN;
      var hv = Wi ? {}.toString : function() {
        return "[object " + Ff(this) + "]";
      };
      Wi || Ta(Object.prototype, "toString", hv, { unsafe: true });
      var Fc = y.Promise, Hf = function(e, t2, n2) {
        for (var r in t2) Ta(e, r, t2[r], n2);
        return e;
      }, Qn = qa("species"), If = function(e) {
        e = mc(e);
        var t2 = Ra.f;
        ka && e && !e[Qn] && t2(e, Qn, { configurable: true, get: function() {
          return this;
        } });
      }, Gc = function(e, t2, n2) {
        if (!(e instanceof t2)) throw TypeError("Incorrect " + (n2 ? n2 + " " : "") + "invocation");
        return e;
      }, Jf = function(e, t2) {
        this.stopped = e, this.result = t2;
      }, Xg = function(e, t2, n2) {
        var r, i = !(!n2 || !n2.AS_ENTRIES), o = !(!n2 || !n2.IS_ITERATOR), a2 = !(!n2 || !n2.INTERRUPTED), s = Id(t2, n2 && n2.that, 1 + i + a2), u2 = function(e2) {
          return c2 && Ui(c2), new Jf(true, e2);
        };
        if (t2 = function(e2) {
          return i ? (va(e2), a2 ? s(e2[0], e2[1], u2) : s(e2[0], e2[1])) : a2 ? s(e2, u2) : s(e2);
        }, o) var c2 = e;
        else {
          if ("function" != typeof (o = Xi(e))) throw TypeError("Target is not iterable");
          if (Vi(o)) {
            for (o = 0, n2 = ta(e.length); n2 > o; o++) if ((r = t2(e[o])) && r instanceof Jf) return r;
            return new Jf(false);
          }
          c2 = o.call(e);
        }
        for (e = c2.next; !(o = e.call(c2)).done; ) {
          try {
            r = t2(o.value);
          } catch (e2) {
            throw Ui(c2), e2;
          }
          if ("object" == typeof r && r && r instanceof Jf) return r;
        }
        return new Jf(false);
      }, iv = qa("species"), kd = function(e, t2) {
        var n2;
        return void 0 === (e = va(e).constructor) || null == (n2 = va(e)[iv]) ? t2 : yb(n2);
      }, Rn = /(?:iphone|ipod|ipad).*applewebkit/i.test(De), Hc = "process" == Zb(y.process), Yg = y.location, ej = y.setImmediate, Sn = y.clearImmediate, jv = y.process, Tn = y.MessageChannel, fj = y.Dispatch, gj = 0, Kf = {}, hj = function(e) {
        if (Kf.hasOwnProperty(e)) {
          var t2 = Kf[e];
          delete Kf[e], t2();
        }
      }, ij = function(e) {
        return function() {
          hj(e);
        };
      }, Un = function(e) {
        hj(e.data);
      }, Vn = function(e) {
        y.postMessage(e + "", Yg.protocol + "//" + Yg.host);
      };
      if (!ej || !Sn) if (ej = function(e) {
        for (var t2 = [], n2 = 1; arguments.length > n2; ) t2.push(arguments[n2++]);
        return Kf[++gj] = function() {
          ("function" == typeof e ? e : Function(e)).apply(void 0, t2);
        }, Lf(gj), gj;
      }, Sn = function(e) {
        delete Kf[e];
      }, Hc) var Lf = function(e) {
        jv.nextTick(ij(e));
      };
      else if (fj && fj.now) Lf = function(e) {
        fj.now(ij(e));
      };
      else if (Tn && !Rn) {
        var Wn = new Tn(), Xn = Wn.port2;
        Wn.port1.onmessage = Un, Lf = Id(Xn.postMessage, Xn, 1);
      } else y.addEventListener && "function" == typeof postMessage && !y.importScripts && Yg && "file:" !== Yg.protocol && !R(Vn) ? (Lf = Vn, y.addEventListener("message", Un, false)) : Lf = "onreadystatechange" in (Og ? ze.createElement("script") : {}) ? function(e) {
        Zi.appendChild(Og ? ze.createElement("script") : {}).onreadystatechange = function() {
          Zi.removeChild(this), hj(e);
        };
      } : function(e) {
        setTimeout(ij(e), 0);
      };
      var jj = ej, kv = /web0s(?!.*chrome)/i.test(De), lv = Fb.f, Yn = y.MutationObserver || y.WebKitMutationObserver, Zn = y.document, $n = y.process, Zg = y.Promise, ao = lv(y, "queueMicrotask"), bo = ao && ao.value, Md, Mf;
      if (!bo) {
        var ah = function() {
          var e;
          for (Hc && (e = $n.domain) && e.exit(); Md; ) {
            var t2 = Md.fn;
            Md = Md.next;
            try {
              t2();
            } catch (e2) {
              throw Md ? $g() : Mf = void 0, e2;
            }
          }
          Mf = void 0, e && e.enter();
        };
        if (Rn || Hc || kv || !Yn || !Zn) if (Zg && Zg.resolve) {
          var kj = Zg.resolve(void 0);
          kj.constructor = Zg;
          var mv = kj.then, $g = function() {
            mv.call(kj, ah);
          };
        } else $g = Hc ? function() {
          $n.nextTick(ah);
        } : function() {
          jj.call(y, ah);
        };
        else {
          var co = true, eo = Zn.createTextNode("");
          new Yn(ah).observe(eo, { characterData: true }), $g = function() {
            eo.data = co = !co;
          };
        }
      }
      var fo = bo || function(e) {
        e = { fn: e, next: void 0 }, Mf && (Mf.next = e), Md || (Md = e, $g()), Mf = e;
      }, nv = function(e) {
        var t2, n2;
        this.promise = new e(function(e2, r) {
          if (void 0 !== t2 || void 0 !== n2) throw TypeError("Bad Promise constructor");
          t2 = e2, n2 = r;
        }), this.resolve = yb(t2), this.reject = yb(n2);
      }, lj = { f: function(e) {
        return new nv(e);
      } }, mj = function(e, t2) {
        return va(e), ha(t2) && t2.constructor === e ? t2 : ((0, (e = lj.f(e)).resolve)(t2), e.promise);
      }, ov = function(e, t2) {
        var n2 = y.console;
        n2 && n2.error && (1 === arguments.length ? n2.error(e) : n2.error(e, t2));
      }, nj = function(e) {
        try {
          return { error: false, value: e() };
        } catch (e2) {
          return { error: true, value: e2 };
        }
      }, pv = "object" == typeof window, qv = qa("species"), go = Za.get, rv = Za.set, sv = Za.getterFor("Promise"), Nd = Fc && Fc.prototype, zb = Fc, bh = Nd, ho = y.TypeError, oj = y.document, pj = y.process, He = lj.f, tv = He, uv = !!(oj && oj.createEvent && y.dispatchEvent), io = "function" == typeof PromiseRejectionEvent, jo = false, Nf = nc("Promise", function() {
        var e = Pi(zb) !== String(zb);
        if (!e && 66 === id) return true;
        if (51 <= id && /native code/.test(zb)) return false;
        var t2 = new zb(function(e2) {
          e2(1);
        }), n2 = function(e2) {
          e2(function() {
          }, function() {
          });
        };
        return (t2.constructor = {})[qv] = n2, !(jo = t2.then(function() {
        }) instanceof n2) || !e && pv && !io;
      }), vv = Nf || !Tg(function(e) {
        zb.all(e).catch(function() {
        });
      }), ko = function(e) {
        var t2;
        return !(!ha(e) || "function" != typeof (t2 = e.then)) && t2;
      }, qj = function(e, t2) {
        if (!e.notified) {
          e.notified = true;
          var n2 = e.reactions;
          fo(function() {
            for (var r = e.value, i = 1 == e.state, o = 0; n2.length > o; ) {
              var a2, s = n2[o++], u2 = i ? s.ok : s.fail, c2 = s.resolve, l = s.reject, f = s.domain;
              try {
                if (u2) {
                  if (i || (2 === e.rejection && wv(e), e.rejection = 1), true === u2) var h = r;
                  else if (f && f.enter(), h = u2(r), f) {
                    f.exit();
                    var p = true;
                  }
                  h === s.promise ? l(ho("Promise-chain cycle")) : (a2 = ko(h)) ? a2.call(h, c2, l) : c2(h);
                } else l(r);
              } catch (e2) {
                f && !p && f.exit(), l(e2);
              }
            }
            e.reactions = [], e.notified = false, t2 && !e.rejection && xv(e);
          });
        }
      }, lo = function(e, t2, n2) {
        var r;
        if (uv) {
          var i = oj.createEvent("Event");
          i.promise = t2, i.reason = n2, i.initEvent(e, false, true), y.dispatchEvent(i);
        } else i = { promise: t2, reason: n2 };
        !io && (r = y["on" + e]) ? r(i) : "unhandledrejection" === e && ov("Unhandled promise rejection", n2);
      }, xv = function(e) {
        jj.call(y, function() {
          var t2 = e.facade, n2 = e.value;
          if (1 !== e.rejection && !e.parent) {
            var r = nj(function() {
              Hc ? pj.emit("unhandledRejection", n2, t2) : lo("unhandledrejection", t2, n2);
            });
            if (e.rejection = Hc || 1 !== e.rejection && !e.parent ? 2 : 1, r.error) throw r.value;
          }
        });
      }, wv = function(e) {
        jj.call(y, function() {
          var t2 = e.facade;
          Hc ? pj.emit("rejectionHandled", t2) : lo("rejectionhandled", t2, e.value);
        });
      }, Ie = function(e, t2, n2) {
        return function(r) {
          e(t2, r, n2);
        };
      }, Je = function(e, t2, n2) {
        e.done || (e.done = true, n2 && (e = n2), e.value = t2, e.state = 2, qj(e, true));
      }, rj = function(e, t2, n2) {
        if (!e.done) {
          e.done = true, n2 && (e = n2);
          try {
            if (e.facade === t2) throw ho("Promise can't be resolved itself");
            var r = ko(t2);
            r ? fo(function() {
              var n3 = { done: false };
              try {
                r.call(t2, Ie(rj, n3, e), Ie(Je, n3, e));
              } catch (t3) {
                Je(n3, t3, e);
              }
            }) : (e.value = t2, e.state = 1, qj(e, false));
          } catch (t3) {
            Je({ done: false }, t3, e);
          }
        }
      };
      if (Nf) {
        zb = function(e) {
          Gc(this, zb, "Promise"), yb(e), sj.call(this);
          var t2 = go(this);
          try {
            e(Ie(rj, t2), Ie(Je, t2));
          } catch (e2) {
            Je(t2, e2);
          }
        }, bh = zb.prototype;
        var sj = function(e) {
          rv(this, { type: "Promise", done: false, notified: false, parent: false, reactions: [], rejection: false, state: 0, value: void 0 });
        };
        sj.prototype = Hf(bh, { then: function(e, t2) {
          var n2 = sv(this), r = He(kd(this, zb));
          return r.ok = "function" != typeof e || e, r.fail = "function" == typeof t2 && t2, r.domain = Hc ? pj.domain : void 0, n2.parent = true, n2.reactions.push(r), 0 != n2.state && qj(n2, false), r.promise;
        }, catch: function(e) {
          return this.then(void 0, e);
        } });
        var yv = function() {
          var e = new sj(), t2 = go(e);
          this.promise = e, this.resolve = Ie(rj, t2), this.reject = Ie(Je, t2);
        };
        if (lj.f = He = function(e) {
          return e === zb || e === zv ? new yv(e) : tv(e);
        }, "function" == typeof Fc && Nd !== Object.prototype) {
          var Av = Nd.then;
          jo || (Ta(Nd, "then", function(e, t2) {
            var n2 = this;
            return new zb(function(e2, t3) {
              Av.call(n2, e2, t3);
            }).then(e, t2);
          }, { unsafe: true }), Ta(Nd, "catch", bh.catch, { unsafe: true }));
          try {
            delete Nd.constructor;
          } catch (c2) {
          }
          Ua && Ua(Nd, bh);
        }
      }
      N({ global: true, wrap: true, forced: Nf }, { Promise: zb }), Ec(zb, "Promise", false), If("Promise");
      var zv = mc("Promise");
      N({ target: "Promise", stat: true, forced: Nf }, { reject: function(e) {
        var t2 = He(this);
        return t2.reject.call(void 0, e), t2.promise;
      } }), N({ target: "Promise", stat: true, forced: Nf }, { resolve: function(e) {
        return mj(this, e);
      } }), N({ target: "Promise", stat: true, forced: vv }, { all: function(e) {
        var t2 = this, n2 = He(t2), r = n2.resolve, i = n2.reject, o = nj(function() {
          var n3 = yb(t2.resolve), o2 = [], a2 = 0, s = 1;
          Xg(e, function(e2) {
            var u2 = a2++, c2 = false;
            o2.push(void 0), s++, n3.call(t2, e2).then(function(e3) {
              c2 || (c2 = true, o2[u2] = e3, --s || r(o2));
            }, i);
          }), --s || r(o2);
        });
        return o.error && i(o.value), n2.promise;
      }, race: function(e) {
        var t2 = this, n2 = He(t2), r = n2.reject, i = nj(function() {
          var i2 = yb(t2.resolve);
          Xg(e, function(e2) {
            i2.call(t2, e2).then(n2.resolve, r);
          });
        });
        return i.error && r(i.value), n2.promise;
      } });
      var mo = [].indexOf, no = !!mo && 0 > 1 / [1].indexOf(1, -0), Bv = Ee("indexOf");
      N({ target: "Array", proto: true, forced: no || !Bv }, { indexOf: function(e) {
        return no ? mo.apply(this, arguments) || 0 : Si(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } });
      var tj = function() {
        var e = va(this), t2 = "";
        return e.global && (t2 += "g"), e.ignoreCase && (t2 += "i"), e.multiline && (t2 += "m"), e.dotAll && (t2 += "s"), e.unicode && (t2 += "u"), e.sticky && (t2 += "y"), t2;
      }, pc = R(function() {
        var e = RegExp("a", "y");
        return e.lastIndex = 2, null != e.exec("abcd");
      }), Cv = R(function() {
        var e = RegExp("^r", "gy");
        return e.lastIndex = 2, null != e.exec("str");
      }), ch = RegExp.prototype.exec, Dv = fd("native-string-replace", String.prototype.replace), oo = ch, uj = (c = /a/, a = /b*/g, ch.call(c, "a"), ch.call(a, "a"), 0 !== c.lastIndex || 0 !== a.lastIndex), po = pc || Cv, vj = void 0 !== /()??/.exec("")[1], c, a;
      (uj || vj || po) && (oo = function(e) {
        var t2, n2 = po && this.sticky, r = tj.call(this), i = this.source, o = 0, a2 = e;
        if (n2) {
          -1 === (r = r.replace("y", "")).indexOf("g") && (r += "g"), a2 = String(e).slice(this.lastIndex), 0 < this.lastIndex && (!this.multiline || this.multiline && "\n" !== e[this.lastIndex - 1]) && (i = "(?: " + i + ")", a2 = " " + a2, o++);
          var s = new RegExp("^(?:" + i + ")", r);
        }
        if (vj && (s = new RegExp("^" + i + "$(?!\\s)", r)), uj) var u2 = this.lastIndex;
        var c2 = ch.call(n2 ? s : this, a2);
        return n2 ? c2 ? (c2.input = c2.input.slice(o), c2[0] = c2[0].slice(o), c2.index = this.lastIndex, this.lastIndex += c2[0].length) : this.lastIndex = 0 : uj && c2 && (this.lastIndex = this.global ? c2.index + c2[0].length : u2), vj && c2 && 1 < c2.length && Dv.call(c2[0], s, function() {
          for (t2 = 1; t2 < arguments.length - 2; t2++) void 0 === arguments[t2] && (c2[t2] = void 0);
        }), c2;
      });
      var Of = oo;
      N({ target: "RegExp", proto: true, forced: /./.exec !== Of }, { exec: Of });
      var Ev = qa("species"), wj = RegExp.prototype, Fv = !R(function() {
        var e = /./;
        return e.exec = function() {
          var e2 = [];
          return e2.groups = { a: "7" }, e2;
        }, "7" !== "".replace(e, "$<a>");
      }), qo = "$0" === "a".replace(/./, "$0"), ro = qa("replace"), so = !!/./[ro] && "" === /./[ro]("a", "$0"), Gv = !R(function() {
        var e = /(?:)/, t2 = e.exec;
        return e.exec = function() {
          return t2.apply(this, arguments);
        }, 2 !== (e = "ab".split(e)).length || "a" !== e[0] || "b" !== e[1];
      }), dh = function(e, t2, n2, r) {
        var i = qa(e), o = !R(function() {
          var t3 = {};
          return t3[i] = function() {
            return 7;
          }, 7 != ""[e](t3);
        }), a2 = o && !R(function() {
          var t3 = false, n3 = /a/;
          return "split" === e && ((n3 = { constructor: {} }).constructor[Ev] = function() {
            return n3;
          }, n3.flags = "", n3[i] = /./[i]), n3.exec = function() {
            return t3 = true, null;
          }, n3[i](""), !t3;
        });
        if (!o || !a2 || "replace" === e && (!Fv || !qo || so) || "split" === e && !Gv) {
          var s = /./[i], u2 = (n2 = n2(i, ""[e], function(e2, t3, n3, r2, i2) {
            var a3 = t3.exec;
            return a3 === Of || a3 === wj.exec ? o && !i2 ? { done: true, value: s.call(t3, n3, r2) } : { done: true, value: e2.call(n3, t3, r2) } : { done: false };
          }, { REPLACE_KEEPS_$0: qo, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: so }))[1];
          Ta(String.prototype, e, n2[0]), Ta(wj, i, 2 == t2 ? function(e2, t3) {
            return u2.call(e2, this, t3);
          } : function(e2) {
            return u2.call(e2, this);
          });
        }
        r && Na(wj[i], "sham", true);
      }, xj = function(e, t2, n2) {
        return t2 + (n2 ? Gn(e, t2).length : 1);
      }, Hv = Math.floor, Iv = "".replace, Jv = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Kv = /\$([$&'`]|\d{1,2})/g, Lv = function(e, t2, n2, r, i, o) {
        var a2 = n2 + e.length, s = r.length, u2 = Kv;
        return void 0 !== i && (i = Qa(i), u2 = Jv), Iv.call(o, u2, function(o2, u3) {
          switch (u3.charAt(0)) {
            case "$":
              return "$";
            case "&":
              return e;
            case "`":
              return t2.slice(0, n2);
            case "'":
              return t2.slice(a2);
            case "<":
              o2 = i[u3.slice(1, -1)];
              break;
            default:
              var c2 = +u3;
              if (0 === c2) return o2;
              if (c2 > s) return 0 === (c2 = Hv(c2 / 10)) ? o2 : c2 <= s ? void 0 === r[c2 - 1] ? u3.charAt(1) : r[c2 - 1] + u3.charAt(1) : o2;
              o2 = r[c2 - 1];
          }
          return void 0 === o2 ? "" : o2;
        });
      }, Ke = function(e, t2) {
        var n2 = e.exec;
        if ("function" == typeof n2) {
          if ("object" != typeof (e = n2.call(e, t2))) throw TypeError("RegExp exec method returned something other than an Object or null");
          return e;
        }
        if ("RegExp" !== Zb(e)) throw TypeError("RegExp#exec called on incompatible receiver");
        return Of.call(e, t2);
      }, Mv = Math.max, Nv = Math.min, Ov = function(e) {
        return void 0 === e ? e : String(e);
      };
      dh("replace", 2, function(e, t2, n2, r) {
        var i = r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, o = r.REPLACE_KEEPS_$0, a2 = i ? "$" : "$0";
        return [function(n3, r2) {
          var i2 = jb(this), o2 = null == n3 ? void 0 : n3[e];
          return void 0 !== o2 ? o2.call(n3, i2, r2) : t2.call(String(i2), n3, r2);
        }, function(e2, r2) {
          if (!i && o || "string" == typeof r2 && -1 === r2.indexOf(a2)) {
            var s = n2(t2, e2, this, r2);
            if (s.done) return s.value;
          }
          var u2 = va(e2);
          e2 = String(this), (s = "function" == typeof r2) || (r2 = String(r2));
          var c2 = u2.global;
          if (c2) {
            var l = u2.unicode;
            u2.lastIndex = 0;
          }
          for (var f = []; ; ) {
            var h = Ke(u2, e2);
            if (null === h) break;
            if (f.push(h), !c2) break;
            "" === String(h[0]) && (u2.lastIndex = xj(e2, ta(u2.lastIndex), l));
          }
          for (l = "", c2 = u2 = 0; c2 < f.length; c2++) {
            h = f[c2];
            for (var p = String(h[0]), d = Mv(Nv($b(h.index), e2.length), 0), v2 = [], b = 1; b < h.length; b++) v2.push(Ov(h[b]));
            h = h.groups, s ? (v2 = [p].concat(v2, d, e2), void 0 !== h && v2.push(h), h = String(r2.apply(void 0, v2))) : h = Lv(p, e2, d, v2, h, r2), d >= u2 && (l += e2.slice(u2, d) + h, u2 = d + p.length);
          }
          return l + e2.slice(u2);
        }];
      });
      var Pv = Ef("slice"), Qv = qa("species"), Rv = [].slice, Sv = Math.max;
      N({ target: "Array", proto: true, forced: !Pv }, { slice: function(e, t2) {
        var n2 = qb(this), r = ta(n2.length);
        if (e = xb(e, r), t2 = xb(void 0 === t2 ? r : t2, r), gd(n2)) {
          var i = n2.constructor;
          if ("function" != typeof i || i !== Array && !gd(i.prototype) ? ha(i) && (null === (i = i[Qv]) && (i = void 0)) : i = void 0, i === Array || void 0 === i) return Rv.call(n2, e, t2);
        }
        for (i = new (void 0 === i ? Array : i)(Sv(t2 - e, 0)), r = 0; e < t2; e++, r++) e in n2 && Ge(i, r, n2[e]);
        return i.length = r, i;
      } });
      var Tv = Za.set, Uv = Za.getterFor("Array Iterator"), ld = bj(Array, "Array", function(e, t2) {
        Tv(this, { type: "Array Iterator", target: qb(e), index: 0, kind: t2 });
      }, function() {
        var e = Uv(this), t2 = e.target, n2 = e.kind, r = e.index++;
        return !t2 || r >= t2.length ? (e.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r, done: false } : "values" == n2 ? { value: t2[r], done: false } : { value: [r, t2[r]], done: false };
      }, "values");
      Fe.Arguments = Fe.Array, Ld("keys"), Ld("values"), Ld("entries");
      var to = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView, Le = function(e) {
        if (void 0 === e) return 0;
        e = $b(e);
        var t2 = ta(e);
        if (e !== t2) throw RangeError("Wrong length or index");
        return t2;
      }, Vv = Math.abs, Ic = Math.pow, Wv = Math.floor, Xv = Math.log, Yv = Math.LN2, yj = function(e) {
        var t2 = Qa(this), n2 = ta(t2.length), r = arguments.length, i = xb(1 < r ? arguments[1] : void 0, n2);
        for (n2 = void 0 === (r = 2 < r ? arguments[2] : void 0) ? n2 : xb(r, n2); n2 > i; ) t2[i++] = e;
        return t2;
      }, Zv = Hd.f, $v = Ra.f, Me = Za.get, uo = Za.set, bc = y.ArrayBuffer, Ab = bc, cc = y.DataView, eh = cc && cc.prototype, vo = Object.prototype, fh = y.RangeError, wo = function(e, t2, n2) {
        var r, i = Array(n2), o = (1 << (n2 = 8 * n2 - t2 - 1)) - 1, a2 = o >> 1, s = 23 === t2 ? Ic(2, -24) - Ic(2, -77) : 0, u2 = 0 > e || 0 === e && 0 > 1 / e ? 1 : 0, c2 = 0;
        if ((e = Vv(e)) != e || 1 / 0 === e) {
          e = e != e ? 1 : 0;
          var l = o;
        } else l = Wv(Xv(e) / Yv), 1 > e * (r = Ic(2, -l)) && (l--, r *= 2), 2 <= (e = 1 <= l + a2 ? e + s / r : e + s * Ic(2, 1 - a2)) * r && (l++, r /= 2), l + a2 >= o ? (e = 0, l = o) : 1 <= l + a2 ? (e = (e * r - 1) * Ic(2, t2), l += a2) : (e = e * Ic(2, a2 - 1) * Ic(2, t2), l = 0);
        for (; 8 <= t2; i[c2++] = 255 & e, e /= 256, t2 -= 8) ;
        for (l = l << t2 | e, n2 += t2; 0 < n2; i[c2++] = 255 & l, l /= 256, n2 -= 8) ;
        return i[--c2] |= 128 * u2, i;
      }, xo = function(e, t2) {
        var n2 = e.length, r = 8 * n2 - t2 - 1, i = (1 << r) - 1, o = i >> 1;
        r -= 7, --n2;
        var a2 = e[n2--], s = 127 & a2;
        for (a2 >>= 7; 0 < r; s = 256 * s + e[n2], n2--, r -= 8) ;
        var u2 = s & (1 << -r) - 1;
        for (s >>= -r, r += t2; 0 < r; u2 = 256 * u2 + e[n2], n2--, r -= 8) ;
        if (0 === s) s = 1 - o;
        else {
          if (s === i) return u2 ? NaN : a2 ? -1 / 0 : 1 / 0;
          u2 += Ic(2, t2), s -= o;
        }
        return (a2 ? -1 : 1) * u2 * Ic(2, s - t2);
      }, yo = function(e) {
        return [255 & e];
      }, zo = function(e) {
        return [255 & e, e >> 8 & 255];
      }, Ao = function(e) {
        return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255];
      }, Bo = function(e) {
        return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0];
      }, aw = function(e) {
        return wo(e, 23, 4);
      }, bw = function(e) {
        return wo(e, 52, 8);
      }, gh = function(e, t2) {
        $v(e.prototype, t2, { get: function() {
          return Me(this)[t2];
        } });
      }, md = function(e, t2, n2, r) {
        n2 = Le(n2);
        var i = Me(e);
        if (n2 + t2 > i.byteLength) throw fh("Wrong index");
        return e = Me(i.buffer).bytes, n2 += i.byteOffset, t2 = e.slice(n2, n2 + t2), r ? t2 : t2.reverse();
      }, nd = function(e, t2, n2, r, i, o) {
        n2 = Le(n2);
        var a2 = Me(e);
        if (n2 + t2 > a2.byteLength) throw fh("Wrong index");
        for (e = Me(a2.buffer).bytes, n2 += a2.byteOffset, r = r(+i), i = 0; i < t2; i++) e[n2 + i] = r[o ? i : t2 - i - 1];
      };
      if (to) {
        if (!R(function() {
          bc(1);
        }) || !R(function() {
          new bc(-1);
        }) || R(function() {
          return new bc(), new bc(1.5), new bc(NaN), "ArrayBuffer" != bc.name;
        })) {
          Ab = function(e) {
            return Gc(this, Ab), new bc(Le(e));
          };
          for (var cw = Ab.prototype = bc.prototype, Co = Zv(bc), Do = 0, zj; Co.length > Do; ) (zj = Co[Do++]) in Ab || Na(Ab, zj, bc[zj]);
          cw.constructor = Ab;
        }
        Ua && Vb(eh) !== vo && Ua(eh, vo);
        var hh = new cc(new Ab(2)), Eo = eh.setInt8;
        hh.setInt8(0, 2147483648), hh.setInt8(1, 2147483649), !hh.getInt8(0) && hh.getInt8(1) || Hf(eh, { setInt8: function(e, t2) {
          Eo.call(this, e, t2 << 24 >> 24);
        }, setUint8: function(e, t2) {
          Eo.call(this, e, t2 << 24 >> 24);
        } }, { unsafe: true });
      } else Ab = function(e) {
        Gc(this, Ab, "ArrayBuffer"), e = Le(e), uo(this, { bytes: yj.call(Array(e), 0), byteLength: e }), ka || (this.byteLength = e);
      }, cc = function(e, t2, n2) {
        Gc(this, cc, "DataView"), Gc(e, Ab, "DataView");
        var r = Me(e).byteLength;
        if (0 > (t2 = $b(t2)) || t2 > r) throw fh("Wrong offset");
        if (t2 + (n2 = void 0 === n2 ? r - t2 : ta(n2)) > r) throw fh("Wrong length");
        uo(this, { buffer: e, byteLength: n2, byteOffset: t2 }), ka || (this.buffer = e, this.byteLength = n2, this.byteOffset = t2);
      }, ka && (gh(Ab, "byteLength"), gh(cc, "buffer"), gh(cc, "byteLength"), gh(cc, "byteOffset")), Hf(cc.prototype, { getInt8: function(e) {
        return md(this, 1, e)[0] << 24 >> 24;
      }, getUint8: function(e) {
        return md(this, 1, e)[0];
      }, getInt16: function(e) {
        var t2 = md(this, 2, e, 1 < arguments.length ? arguments[1] : void 0);
        return (t2[1] << 8 | t2[0]) << 16 >> 16;
      }, getUint16: function(e) {
        var t2 = md(this, 2, e, 1 < arguments.length ? arguments[1] : void 0);
        return t2[1] << 8 | t2[0];
      }, getInt32: function(e) {
        return Bo(md(this, 4, e, 1 < arguments.length ? arguments[1] : void 0));
      }, getUint32: function(e) {
        return Bo(md(this, 4, e, 1 < arguments.length ? arguments[1] : void 0)) >>> 0;
      }, getFloat32: function(e) {
        return xo(md(this, 4, e, 1 < arguments.length ? arguments[1] : void 0), 23);
      }, getFloat64: function(e) {
        return xo(md(this, 8, e, 1 < arguments.length ? arguments[1] : void 0), 52);
      }, setInt8: function(e, t2) {
        nd(this, 1, e, yo, t2);
      }, setUint8: function(e, t2) {
        nd(this, 1, e, yo, t2);
      }, setInt16: function(e, t2) {
        nd(this, 2, e, zo, t2, 2 < arguments.length ? arguments[2] : void 0);
      }, setUint16: function(e, t2) {
        nd(this, 2, e, zo, t2, 2 < arguments.length ? arguments[2] : void 0);
      }, setInt32: function(e, t2) {
        nd(this, 4, e, Ao, t2, 2 < arguments.length ? arguments[2] : void 0);
      }, setUint32: function(e, t2) {
        nd(this, 4, e, Ao, t2, 2 < arguments.length ? arguments[2] : void 0);
      }, setFloat32: function(e, t2) {
        nd(this, 4, e, aw, t2, 2 < arguments.length ? arguments[2] : void 0);
      }, setFloat64: function(e, t2) {
        nd(this, 8, e, bw, t2, 2 < arguments.length ? arguments[2] : void 0);
      } });
      Ec(Ab, "ArrayBuffer"), Ec(cc, "DataView");
      var Pf = { ArrayBuffer: Ab, DataView: cc }, Aj = Pf.ArrayBuffer, Fo = Pf.DataView, Go = Aj.prototype.slice, dw = R(function() {
        return !new Aj(2).slice(1, void 0).byteLength;
      });
      N({ target: "ArrayBuffer", proto: true, unsafe: true, forced: dw }, { slice: function(e, t2) {
        if (void 0 !== Go && void 0 === t2) return Go.call(va(this), e);
        var n2 = va(this).byteLength;
        e = xb(e, n2), t2 = xb(void 0 === t2 ? n2 : t2, n2), n2 = new (kd(this, Aj))(ta(t2 - e));
        for (var r = new Fo(this), i = new Fo(n2), o = 0; e < t2; ) i.setUint8(o++, r.getUint8(e++));
        return n2;
      } });
      var ew = Ra.f, ih = y.Int8Array, Bj = ih && ih.prototype, Ho = y.Uint8ClampedArray, Io = Ho && Ho.prototype, qc = ih && Vb(ih), dc = Bj && Vb(Bj), Jo = Object.prototype, Ko = Jo.isPrototypeOf, Lo = qa("toStringTag"), Cj = Ae("TYPED_ARRAY_TAG"), Jc = to && !!Ua && "Opera" !== Ff(y.opera), Mo = false, Bb, rc = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, fw = { BigInt64Array: 8, BigUint64Array: 8 }, jh = function(e) {
        return !!ha(e) && (e = Ff(e), Q(rc, e) || Q(fw, e));
      };
      for (Bb in rc) y[Bb] || (Jc = false);
      if ((!Jc || "function" != typeof qc || qc === Function.prototype) && (qc = function() {
        throw TypeError("Incorrect invocation");
      }, Jc)) for (Bb in rc) y[Bb] && Ua(y[Bb], qc);
      if ((!Jc || !dc || dc === Jo) && (dc = qc.prototype, Jc)) for (Bb in rc) y[Bb] && Ua(y[Bb].prototype, dc);
      if (Jc && Vb(Io) !== dc && Ua(Io, dc), ka && !Q(dc, Lo)) for (Bb in Mo = true, ew(dc, Lo, { get: function() {
        return ha(this) ? this[Cj] : void 0;
      } }), rc) y[Bb] && Na(y[Bb], Cj, Bb);
      var Qf = Jc, No = Mo && Cj, Da = function(e) {
        if (jh(e)) return e;
        throw TypeError("Target is not a typed array");
      }, Ne = function(e) {
        if (Ua) {
          if (Ko.call(qc, e)) return e;
        } else for (var t2 in rc) if (Q(rc, Bb)) {
          var n2 = y[t2];
          if (n2 && (e === n2 || Ko.call(n2, e))) return e;
        }
        throw TypeError("Target is not a typed array constructor");
      }, Aa = function(e, t2, n2) {
        if (ka) {
          if (n2) for (var r in rc) {
            var i = y[r];
            if (i && Q(i.prototype, e)) try {
              delete i.prototype[e];
            } catch (e2) {
            }
          }
          dc[e] && !n2 || Ta(dc, e, n2 ? t2 : Jc && Bj[e] || t2);
        }
      }, Oo = function(e, t2, n2) {
        var r, i;
        if (ka) {
          if (Ua) {
            if (n2) {
              for (r in rc) if ((i = y[r]) && Q(i, e)) try {
                delete i[e];
              } catch (e2) {
              }
            }
            if (qc[e] && !n2) return;
            try {
              return Ta(qc, e, n2 ? t2 : Jc && qc[e] || t2);
            } catch (e2) {
            }
          }
          for (r in rc) !(i = y[r]) || i[e] && !n2 || Ta(i, e, t2);
        }
      }, Po = qc, Rf = dc, gw = y.ArrayBuffer, Od = y.Int8Array, Dj = !Qf || !R(function() {
        Od(1);
      }) || !R(function() {
        new Od(-1);
      }) || !Tg(function(e) {
        new Od(), new Od(null), new Od(1.5), new Od(e);
      }, true) || R(function() {
        return 1 !== new Od(new gw(2), 1, void 0).length;
      }), kh = function(e, t2) {
        if (0 > (e = $b(e))) throw RangeError("The argument can't be less than 0");
        if (e % t2) throw RangeError("Wrong offset");
        return e;
      }, Ej = function(e) {
        var t2 = Qa(e), n2 = arguments.length, r = 1 < n2 ? arguments[1] : void 0, i = void 0 !== r, o = Xi(t2);
        if (null != o && !Vi(o)) {
          var a2 = o.call(t2), s = a2.next;
          for (t2 = []; !(o = s.call(a2)).done; ) t2.push(o.value);
        }
        for (i && 2 < n2 && (r = Id(r, arguments[2], 2)), o = ta(t2.length), a2 = new (Ne(this))(o), n2 = 0; o > n2; n2++) a2[n2] = i ? r(t2[n2], n2) : t2[n2];
        return a2;
      }, lh = function(e, t2, n2) {
        var r, i;
        return Ua && "function" == typeof (r = t2.constructor) && r !== n2 && ha(i = r.prototype) && i !== n2.prototype && Ua(e, i), e;
      }, Sf = $a(function(e) {
        var t2 = Hd.f, n2 = Za.get, r = Za.set, i = Ra.f, o = Fb.f, a2 = Math.round, s = y.RangeError, u2 = Pf.ArrayBuffer, c2 = Pf.DataView, l = function(e2, t3) {
          var n3 = 0, r2 = t3.length;
          for (e2 = new (Ne(e2))(r2); r2 > n3; ) e2[n3] = t3[n3++];
          return e2;
        }, f = function(e2, t3) {
          i(e2, t3, { get: function() {
            return n2(this)[t3];
          } });
        }, h = function(e2) {
          var t3;
          return e2 instanceof u2 || "ArrayBuffer" == (t3 = Ff(e2)) || "SharedArrayBuffer" == t3;
        }, p = function(e2, t3) {
          return jh(e2) && "symbol" != typeof t3 && t3 in e2 && String(+t3) == String(t3);
        }, d = function(e2, t3) {
          return p(e2, t3 = lc(t3, true)) ? dd(2, e2[t3]) : o(e2, t3);
        }, v2 = function(e2, t3, n3) {
          return !(p(e2, t3 = lc(t3, true)) && ha(n3) && Q(n3, "value")) || Q(n3, "get") || Q(n3, "set") || n3.configurable || Q(n3, "writable") && !n3.writable || Q(n3, "enumerable") && !n3.enumerable ? i(e2, t3, n3) : (e2[t3] = n3.value, e2);
        };
        ka ? (Qf || (Fb.f = d, Ra.f = v2, f(Rf, "buffer"), f(Rf, "byteOffset"), f(Rf, "byteLength"), f(Rf, "length")), N({ target: "Object", stat: true, forced: !Qf }, { getOwnPropertyDescriptor: d, defineProperty: v2 }), e.exports = function(e2, o2, f2) {
          var p2 = e2.match(/\d+$/)[0] / 8, d2 = e2 + (f2 ? "Clamped" : "") + "Array", v3 = "get" + e2, b = "set" + e2, g = y[d2], m2 = g;
          e2 = m2 && m2.prototype;
          var E2 = {}, w2 = function(e3, t3) {
            i(e3, t3, { get: function() {
              var e4 = n2(this);
              return e4.view[v3](t3 * p2 + e4.byteOffset, true);
            }, set: function(e4) {
              var r2 = n2(this);
              f2 && (e4 = 0 > (e4 = a2(e4)) ? 0 : 255 < e4 ? 255 : 255 & e4), r2.view[b](t3 * p2 + r2.byteOffset, e4, true);
            }, enumerable: true });
          };
          Qf ? Dj && (m2 = o2(function(e3, t3, n3, r2) {
            return Gc(e3, m2, d2), lh(ha(t3) ? h(t3) ? void 0 !== r2 ? new g(t3, kh(n3, p2), r2) : void 0 !== n3 ? new g(t3, kh(n3, p2)) : new g(t3) : jh(t3) ? l(m2, t3) : Ej.call(m2, t3) : new g(Le(t3)), e3, m2);
          }), Ua && Ua(m2, Po), Jd(t2(g), function(e3) {
            e3 in m2 || Na(m2, e3, g[e3]);
          }), m2.prototype = e2) : (m2 = o2(function(e3, t3, n3, i2) {
            Gc(e3, m2, d2);
            var o3 = 0, a3 = 0;
            if (ha(t3)) {
              if (!h(t3)) return jh(t3) ? l(m2, t3) : Ej.call(m2, t3);
              var f3 = t3;
              if (a3 = kh(n3, p2), t3 = t3.byteLength, void 0 === i2) {
                if (t3 % p2) throw s("Wrong length");
                if (0 > (i2 = t3 - a3)) throw s("Wrong length");
              } else if ((i2 = ta(i2) * p2) + a3 > t3) throw s("Wrong length");
              t3 = i2 / p2;
            } else t3 = Le(t3), f3 = new u2(i2 = t3 * p2);
            for (r(e3, { buffer: f3, byteOffset: a3, byteLength: i2, length: t3, view: new c2(f3) }); o3 < t3; ) w2(e3, o3++);
          }), Ua && Ua(m2, Po), e2 = m2.prototype = ac(Rf)), e2.constructor !== m2 && Na(e2, "constructor", m2), No && Na(e2, No, d2), E2[d2] = m2, N({ global: true, forced: m2 != g, sham: !Qf }, E2), "BYTES_PER_ELEMENT" in m2 || Na(m2, "BYTES_PER_ELEMENT", p2), "BYTES_PER_ELEMENT" in e2 || Na(e2, "BYTES_PER_ELEMENT", p2), If(d2);
        }) : e.exports = function() {
        };
      });
      Sf("Uint8", function(e) {
        return function(t2, n2, r) {
          return e(this, t2, n2, r);
        };
      });
      var hw = Math.min, iw = [].copyWithin || function(e, t2) {
        var n2 = Qa(this), r = ta(n2.length), i = xb(e, r), o = xb(t2, r), a2 = 2 < arguments.length ? arguments[2] : void 0;
        for (r = hw((void 0 === a2 ? r : xb(a2, r)) - o, r - i), a2 = 1, o < i && i < o + r && (a2 = -1, o += r - 1, i += r - 1); 0 < r--; ) o in n2 ? n2[i] = n2[o] : delete n2[i], i += a2, o += a2;
        return n2;
      };
      Aa("copyWithin", function(e, t2) {
        return iw.call(Da(this), e, t2, 2 < arguments.length ? arguments[2] : void 0);
      }), Aa("every", function(e) {
        return Ju(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      }), Aa("fill", function(e) {
        return yj.apply(Da(this), arguments);
      }), Aa("filter", function(e) {
        var t2 = yn(Da(this), e, 1 < arguments.length ? arguments[1] : void 0), n2 = kd(this, this.constructor), r = 0, i = t2.length;
        for (n2 = new (Ne(n2))(i); i > r; ) n2[r] = t2[r++];
        return n2;
      }), Aa("find", function(e) {
        return zn(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      }), Aa("findIndex", function(e) {
        return An(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      }), Aa("forEach", function(e) {
        Jd(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      }), Aa("includes", function(e) {
        return on(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      }), Aa("indexOf", function(e) {
        return Si(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      });
      var Qo = qa("iterator"), Ro = y.Uint8Array, jw = ld.values, kw = ld.keys, lw = ld.entries, Fj = Ro && Ro.prototype[Qo], So = !!Fj && ("values" == Fj.name || null == Fj.name), To = function() {
        return jw.call(Da(this));
      };
      Aa("entries", function() {
        return lw.call(Da(this));
      }), Aa("keys", function() {
        return kw.call(Da(this));
      }), Aa("values", To, !So), Aa(Qo, To, !So);
      var mw = [].join;
      Aa("join", function(e) {
        return mw.apply(Da(this), arguments);
      });
      var nw = Math.min, Gj = [].lastIndexOf, Uo = !!Gj && 0 > 1 / [1].lastIndexOf(1, -0), ow = Ee("lastIndexOf"), pw = Uo || !ow ? function(e) {
        if (Uo) return Gj.apply(this, arguments) || 0;
        var t2 = qb(this), n2 = ta(t2.length), r = n2 - 1;
        for (1 < arguments.length && (r = nw(r, $b(arguments[1]))), 0 > r && (r = n2 + r); 0 <= r; r--) if (r in t2 && t2[r] === e) return r || 0;
        return -1;
      } : Gj;
      Aa("lastIndexOf", function(e) {
        return pw.apply(Da(this), arguments);
      }), Aa("map", function(e) {
        return xn(Da(this), e, 1 < arguments.length ? arguments[1] : void 0, function(e2, t2) {
          return new (Ne(kd(e2, e2.constructor)))(t2);
        });
      });
      var Vo = function(e) {
        return function(t2, n2, r, i) {
          yb(n2), t2 = Qa(t2);
          var o = Af(t2), a2 = ta(t2.length), s = e ? a2 - 1 : 0, u2 = e ? -1 : 1;
          if (2 > r) for (; ; ) {
            if (s in o) {
              i = o[s], s += u2;
              break;
            }
            if (s += u2, e ? 0 > s : a2 <= s) throw TypeError("Reduce of empty array with no initial value");
          }
          for (; e ? 0 <= s : a2 > s; s += u2) s in o && (i = n2(i, o[s], s, t2));
          return i;
        };
      }, Wo = Vo(false), qw = Vo(true);
      Aa("reduce", function(e) {
        return Wo(Da(this), e, arguments.length, 1 < arguments.length ? arguments[1] : void 0);
      }), Aa("reduceRight", function(e) {
        return qw(Da(this), e, arguments.length, 1 < arguments.length ? arguments[1] : void 0);
      });
      var rw = Math.floor;
      Aa("reverse", function() {
        for (var e, t2 = Da(this).length, n2 = rw(t2 / 2), r = 0; r < n2; ) e = this[r], this[r++] = this[--t2], this[t2] = e;
        return this;
      });
      var sw = R(function() {
        new Int8Array(1).set({});
      });
      Aa("set", function(e) {
        Da(this);
        var t2 = kh(1 < arguments.length ? arguments[1] : void 0, 1), n2 = this.length, r = Qa(e), i = ta(r.length), o = 0;
        if (i + t2 > n2) throw RangeError("Wrong length");
        for (; o < i; ) this[t2 + o] = r[o++];
      }, sw);
      var tw = [].slice, uw = R(function() {
        new Int8Array(1).slice();
      });
      Aa("slice", function(e, t2) {
        e = tw.call(Da(this), e, t2);
        var n2 = kd(this, this.constructor);
        t2 = 0;
        var r = e.length;
        for (n2 = new (Ne(n2))(r); r > t2; ) n2[t2] = e[t2++];
        return n2;
      }, uw), Aa("some", function(e) {
        return Iu(Da(this), e, 1 < arguments.length ? arguments[1] : void 0);
      });
      var vw = [].sort;
      Aa("sort", function(e) {
        return vw.call(Da(this), e);
      }), Aa("subarray", function(e, t2) {
        var n2 = Da(this), r = n2.length;
        return e = xb(e, r), new (kd(n2, n2.constructor))(n2.buffer, n2.byteOffset + e * n2.BYTES_PER_ELEMENT, ta((void 0 === t2 ? r : xb(t2, r)) - e));
      });
      var mh = y.Int8Array, Xo = [].toLocaleString, ww = [].slice, xw = !!mh && R(function() {
        Xo.call(new mh(1));
      }), yw = R(function() {
        return [1, 2].toLocaleString() != new mh([1, 2]).toLocaleString();
      }) || !R(function() {
        mh.prototype.toLocaleString.call([1, 2]);
      });
      Aa("toLocaleString", function() {
        return Xo.apply(xw ? ww.call(Da(this)) : Da(this), arguments);
      }, yw);
      var Yo = y.Uint8Array, zw = Yo && Yo.prototype || {}, nh = [].toString, Aw = [].join;
      R(function() {
        nh.call({});
      }) && (nh = function() {
        return Aw.call(this);
      }), Aa("toString", nh, zw.toString != nh);
      var Zo = Pf.ArrayBuffer;
      N({ global: true, forced: y.ArrayBuffer !== Zo }, { ArrayBuffer: Zo }), If("ArrayBuffer");
      var Bw = Ra.f, Hj = Function.prototype, Cw = Hj.toString, Dw = /^\s*function ([^ (]*)/;
      !ka || "name" in Hj || Bw(Hj, "name", { configurable: true, get: function() {
        try {
          return Cw.call(this).match(Dw)[1];
        } catch (e) {
          return "";
        }
      } });
      var $o = RegExp.prototype, ap = $o.toString, Ew = R(function() {
        return "/a/b" != ap.call({ source: "a", flags: "b" });
      }), Fw = "toString" != ap.name;
      (Ew || Fw) && Ta(RegExp.prototype, "toString", function() {
        var e = va(this), t2 = String(e.source), n2 = e.flags;
        return "/" + t2 + "/" + (e = String(void 0 === n2 && e instanceof RegExp && !("flags" in $o) ? tj.call(e) : n2));
      }, { unsafe: true });
      var Gw = Ef("splice"), Hw = Math.max, Iw = Math.min;
      N({ target: "Array", proto: true, forced: !Gw }, { splice: function(e, t2) {
        var n2, r, i = Qa(this), o = ta(i.length), a2 = xb(e, o), s = arguments.length;
        if (0 === s ? s = n2 = 0 : 1 === s ? (s = 0, n2 = o - a2) : (s -= 2, n2 = Iw(Hw($b(t2), 0), o - a2)), 9007199254740991 < o + s - n2) throw TypeError("Maximum allowed length exceeded");
        var u2 = Sg(i, n2);
        for (r = 0; r < n2; r++) {
          var c2 = a2 + r;
          c2 in i && Ge(u2, r, i[c2]);
        }
        if (u2.length = n2, s < n2) {
          for (r = a2; r < o - n2; r++) {
            var l = r + s;
            (c2 = r + n2) in i ? i[l] = i[c2] : delete i[l];
          }
          for (r = o; r > o - n2 + s; r--) delete i[r - 1];
        } else if (s > n2) for (r = o - n2; r > a2; r--) l = r + s - 1, (c2 = r + n2 - 1) in i ? i[l] = i[c2] : delete i[l];
        for (r = 0; r < s; r++) i[r + a2] = arguments[r + 2];
        return i.length = o - n2 + s, u2;
      } });
      var Ij = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Jj = qa("iterator"), bp = qa("toStringTag"), Kj = ld.values, oh;
      for (oh in Ij) {
        var cp = y[oh], Kc = cp && cp.prototype;
        if (Kc) {
          if (Kc[Jj] !== Kj) try {
            Na(Kc, Jj, Kj);
          } catch (c2) {
            Kc[Jj] = Kj;
          }
          if (Kc[bp] || Na(Kc, bp, oh), Ij[oh]) {
            for (var Oe in ld) if (Kc[Oe] !== ld[Oe]) try {
              Na(Kc, Oe, ld[Oe]);
            } catch (c2) {
              Kc[Oe] = ld[Oe];
            }
          }
        }
      }
      var dp = Object.is || function(e, t2) {
        return e === t2 ? 0 !== e || 1 / e == 1 / t2 : e != e && t2 != t2;
      };
      dh("search", 1, function(e, t2, n2) {
        return [function(t3) {
          var n3 = jb(this), r = null == t3 ? void 0 : t3[e];
          return void 0 !== r ? r.call(t3, n3) : new RegExp(t3)[e](String(n3));
        }, function(e2) {
          var r = n2(t2, e2, this);
          if (r.done) return r.value;
          e2 = va(e2);
          var i = String(this);
          return r = e2.lastIndex, dp(r, 0) || (e2.lastIndex = 0), i = Ke(e2, i), dp(e2.lastIndex, r) || (e2.lastIndex = r), null === i ? -1 : i.index;
        }];
      }), $a(function(e) {
        !function(t2, n2) {
          e.exports ? e.exports = n2(t2) : n2(t2);
        }("undefined" != typeof self ? self : Ya, function(e2) {
          function t2(e3) {
            return btoa(e3).replace(/=+$/, "").replace(/\+/g, "-").replace(/\//g, "_");
          }
          function n2(e3) {
            return e3 = (e3 += "===").slice(0, -e3.length % 4), atob(e3.replace(/-/g, "+").replace(/_/g, "/"));
          }
          function r(e3) {
            for (var t3 = new Uint8Array(e3.length), n3 = 0; n3 < e3.length; n3++) t3[n3] = e3.charCodeAt(n3);
            return t3;
          }
          function i(e3) {
            return e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), String.fromCharCode.apply(String, e3);
          }
          function o(e3) {
            var t3 = { name: (e3.name || e3 || "").toUpperCase().replace("V", "v") };
            switch (t3.name) {
              case "SHA-1":
              case "SHA-256":
              case "SHA-384":
              case "SHA-512":
                break;
              case "AES-CBC":
              case "AES-GCM":
              case "AES-KW":
                e3.length && (t3.length = e3.length);
                break;
              case "HMAC":
                e3.hash && (t3.hash = o(e3.hash)), e3.length && (t3.length = e3.length);
                break;
              case "RSAES-PKCS1-v1_5":
                e3.publicExponent && (t3.publicExponent = new Uint8Array(e3.publicExponent)), e3.modulusLength && (t3.modulusLength = e3.modulusLength);
                break;
              case "RSASSA-PKCS1-v1_5":
              case "RSA-OAEP":
                e3.hash && (t3.hash = o(e3.hash)), e3.publicExponent && (t3.publicExponent = new Uint8Array(e3.publicExponent)), e3.modulusLength && (t3.modulusLength = e3.modulusLength);
                break;
              default:
                throw new SyntaxError("Bad algorithm name");
            }
            return t3;
          }
          function a2(e3) {
            return { HMAC: { "SHA-1": "HS1", "SHA-256": "HS256", "SHA-384": "HS384", "SHA-512": "HS512" }, "RSASSA-PKCS1-v1_5": { "SHA-1": "RS1", "SHA-256": "RS256", "SHA-384": "RS384", "SHA-512": "RS512" }, "RSAES-PKCS1-v1_5": { "": "RSA1_5" }, "RSA-OAEP": { "SHA-1": "RSA-OAEP", "SHA-256": "RSA-OAEP-256" }, "AES-KW": { 128: "A128KW", 192: "A192KW", 256: "A256KW" }, "AES-GCM": { 128: "A128GCM", 192: "A192GCM", 256: "A256GCM" }, "AES-CBC": { 128: "A128CBC", 192: "A192CBC", 256: "A256CBC" } }[e3.name][(e3.hash || {}).name || e3.length || ""];
          }
          function s(e3) {
            (e3 instanceof ArrayBuffer || e3 instanceof Uint8Array) && (e3 = JSON.parse(decodeURIComponent(escape(i(e3)))));
            var t3 = { kty: e3.kty, alg: e3.alg, ext: e3.ext || e3.extractable };
            switch (t3.kty) {
              case "oct":
                t3.k = e3.k;
              case "RSA":
                "n e d p q dp dq qi oth".split(" ").forEach(function(n3) {
                  n3 in e3 && (t3[n3] = e3[n3]);
                });
                break;
              default:
                throw new TypeError("Unsupported key type");
            }
            return t3;
          }
          function u2(e3) {
            return e3 = s(e3), E2 && (e3.extractable = e3.ext, delete e3.ext), r(unescape(encodeURIComponent(JSON.stringify(e3)))).buffer;
          }
          function c2(e3) {
            var n3 = l(e3), r2 = false;
            switch (2 < n3.length && (r2 = true, n3.shift()), e3 = { ext: true }, n3[0][0]) {
              case "1.2.840.113549.1.1.1":
                var o2 = "n e d p q dp dq qi".split(" ");
                for (n3 = l(n3[1]), r2 && n3.shift(), r2 = 0; r2 < n3.length; r2++) n3[r2][0] || (n3[r2] = n3[r2].subarray(1)), e3[o2[r2]] = t2(i(n3[r2]));
                e3.kty = "RSA";
                break;
              default:
                throw new TypeError("Unsupported key type");
            }
            return e3;
          }
          function l(e3, t3) {
            if (e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), t3 || (t3 = { pos: 0, end: e3.length }), 2 > t3.end - t3.pos || t3.end > e3.length) throw new RangeError("Malformed DER");
            var n3 = e3[t3.pos++], r2 = e3[t3.pos++];
            if (128 <= r2) {
              if (r2 &= 127, t3.end - t3.pos < r2) throw new RangeError("Malformed DER");
              for (var o2 = 0; r2--; ) o2 <<= 8, o2 |= e3[t3.pos++];
              r2 = o2;
            }
            if (t3.end - t3.pos < r2) throw new RangeError("Malformed DER");
            switch (n3) {
              case 2:
                n3 = e3.subarray(t3.pos, t3.pos += r2);
                break;
              case 3:
                if (e3[t3.pos++]) throw Error("Unsupported bit string");
                r2--;
              case 4:
                n3 = new Uint8Array(e3.subarray(t3.pos, t3.pos += r2)).buffer;
                break;
              case 5:
                n3 = null;
                break;
              case 6:
                if (!((e3 = btoa(i(e3.subarray(t3.pos, t3.pos += r2)))) in _)) throw Error("Unsupported OBJECT ID " + e3);
                n3 = _[e3];
                break;
              case 48:
                for (n3 = [], r2 = t3.pos + r2; t3.pos < r2; ) n3.push(l(e3, t3));
                break;
              default:
                throw Error("Unsupported DER tag 0x" + n3.toString(16));
            }
            return n3;
          }
          function f(e3, t3) {
            t3 || (t3 = []);
            var n3 = t3.length + 2;
            if (t3.push(0, 0), e3 instanceof Uint8Array) for (var i2 = 2, o2 = e3.length, a3 = 0; a3 < o2; a3++) t3.push(e3[a3]);
            else if (e3 instanceof ArrayBuffer) for (i2 = 4, o2 = e3.byteLength, e3 = new Uint8Array(e3), a3 = 0; a3 < o2; a3++) t3.push(e3[a3]);
            else if (null === e3) i2 = 5, o2 = 0;
            else if ("string" == typeof e3 && e3 in O2) for (i2 = 6, o2 = (e3 = r(atob(O2[e3]))).length, a3 = 0; a3 < o2; a3++) t3.push(e3[a3]);
            else if (e3 instanceof Array) {
              for (a3 = 0; a3 < e3.length; a3++) f(e3[a3], t3);
              i2 = 48, o2 = t3.length - n3;
            } else {
              if (!("object" === X(e3) && 3 === e3.tag && e3.value instanceof ArrayBuffer)) throw Error("Unsupported DER value " + e3);
              for (i2 = 3, o2 = (e3 = new Uint8Array(e3.value)).byteLength, t3.push(0), a3 = 0; a3 < o2; a3++) t3.push(e3[a3]);
              o2++;
            }
            if (128 <= o2) {
              for (a3 = o2, o2 = 4, t3.splice(n3, 0, a3 >> 24 & 255, a3 >> 16 & 255, a3 >> 8 & 255, 255 & a3); 1 < o2 && !(a3 >> 24); ) a3 <<= 8, o2--;
              4 > o2 && t3.splice(n3, 4 - o2), o2 |= 128;
            }
            return t3.splice(n3 - 2, 2, i2, o2), t3;
          }
          function h(e3, t3, n3, r2) {
            Object.defineProperties(this, { _key: { value: e3 }, type: { value: e3.type, enumerable: true }, extractable: { value: void 0 === n3 ? e3.extractable : n3, enumerable: true }, algorithm: { value: void 0 === t3 ? e3.algorithm : t3, enumerable: true }, usages: { value: void 0 === r2 ? e3.usages : r2, enumerable: true } });
          }
          function p(e3) {
            return "verify" === e3 || "encrypt" === e3 || "wrapKey" === e3;
          }
          function d(e3) {
            return "sign" === e3 || "decrypt" === e3 || "unwrapKey" === e3;
          }
          if ("function" != typeof Promise) throw "Promise support required";
          var v2 = e2.crypto || e2.msCrypto;
          if (v2) {
            var b = v2.subtle || v2.webkitSubtle;
            if (b) {
              var g = e2.Crypto || v2.constructor || Object, y2 = e2.SubtleCrypto || b.constructor || Object;
              e2.CryptoKey || e2.Key;
              var m2 = -1 < e2.navigator.userAgent.indexOf("Edge/"), E2 = !!e2.msCrypto && !m2, w2 = !v2.subtle && !!v2.webkitSubtle;
              if (E2 || w2) {
                var _ = { KoZIhvcNAQEB: "1.2.840.113549.1.1.1" }, O2 = { "1.2.840.113549.1.1.1": "KoZIhvcNAQEB" };
                if (["generateKey", "importKey", "unwrapKey"].forEach(function(e3) {
                  var t3 = b[e3];
                  b[e3] = function(i2, l2, f2) {
                    var g2 = [].slice.call(arguments);
                    switch (e3) {
                      case "generateKey":
                        var y3 = o(i2), m3 = l2, _2 = f2;
                        break;
                      case "importKey":
                        y3 = o(f2), m3 = g2[3], _2 = g2[4], "jwk" === i2 && ((l2 = s(l2)).alg || (l2.alg = a2(y3)), l2.key_ops || (l2.key_ops = "oct" !== l2.kty ? "d" in l2 ? _2.filter(d) : _2.filter(p) : _2.slice()), g2[1] = u2(l2));
                        break;
                      case "unwrapKey":
                        y3 = g2[4], m3 = g2[5], _2 = g2[6], g2[2] = f2._key;
                    }
                    if ("generateKey" === e3 && "HMAC" === y3.name && y3.hash) return y3.length = y3.length || { "SHA-1": 512, "SHA-256": 512, "SHA-384": 1024, "SHA-512": 1024 }[y3.hash.name], b.importKey("raw", v2.getRandomValues(new Uint8Array(y3.length + 7 >> 3)), y3, m3, _2);
                    if (w2 && "generateKey" === e3 && "RSASSA-PKCS1-v1_5" === y3.name && (!y3.modulusLength || 2048 <= y3.modulusLength)) return (i2 = o(i2)).name = "RSAES-PKCS1-v1_5", delete i2.hash, b.generateKey(i2, true, ["encrypt", "decrypt"]).then(function(e4) {
                      return Promise.all([b.exportKey("jwk", e4.publicKey), b.exportKey("jwk", e4.privateKey)]);
                    }).then(function(e4) {
                      return e4[0].alg = e4[1].alg = a2(y3), e4[0].key_ops = _2.filter(p), e4[1].key_ops = _2.filter(d), Promise.all([b.importKey("jwk", e4[0], y3, true, e4[0].key_ops), b.importKey("jwk", e4[1], y3, m3, e4[1].key_ops)]);
                    }).then(function(e4) {
                      return { publicKey: e4[0], privateKey: e4[1] };
                    });
                    if ((w2 || E2 && "SHA-1" === (y3.hash || {}).name) && "importKey" === e3 && "jwk" === i2 && "HMAC" === y3.name && "oct" === l2.kty) return b.importKey("raw", r(n2(l2.k)), f2, g2[3], g2[4]);
                    if (w2 && "importKey" === e3 && ("spki" === i2 || "pkcs8" === i2)) return b.importKey("jwk", c2(l2), f2, g2[3], g2[4]);
                    if (E2 && "unwrapKey" === e3) return b.decrypt(g2[3], f2, l2).then(function(e4) {
                      return b.importKey(i2, e4, g2[4], g2[5], g2[6]);
                    });
                    try {
                      var O3 = t3.apply(b, g2);
                    } catch (e4) {
                      return Promise.reject(e4);
                    }
                    return E2 && (O3 = new Promise(function(e4, t4) {
                      O3.onabort = O3.onerror = function(e5) {
                        t4(e5);
                      }, O3.oncomplete = function(t5) {
                        e4(t5.target.result);
                      };
                    })), O3 = O3.then(function(e4) {
                      return "HMAC" !== y3.name || y3.length || (y3.length = 8 * e4.algorithm.length), 0 == y3.name.search("RSA") && (y3.modulusLength || (y3.modulusLength = (e4.publicKey || e4).algorithm.modulusLength), y3.publicExponent || (y3.publicExponent = (e4.publicKey || e4).algorithm.publicExponent)), e4.publicKey && e4.privateKey ? { publicKey: new h(e4.publicKey, y3, m3, _2.filter(p)), privateKey: new h(e4.privateKey, y3, m3, _2.filter(d)) } : new h(e4, y3, m3, _2);
                    });
                  };
                }), ["exportKey", "wrapKey"].forEach(function(e3) {
                  var o2 = b[e3];
                  b[e3] = function(u3, c3, l2) {
                    var h2 = [].slice.call(arguments);
                    switch (e3) {
                      case "exportKey":
                        h2[1] = c3._key;
                        break;
                      case "wrapKey":
                        h2[1] = c3._key, h2[2] = l2._key;
                    }
                    if ((w2 || E2 && "SHA-1" === (c3.algorithm.hash || {}).name) && "exportKey" === e3 && "jwk" === u3 && "HMAC" === c3.algorithm.name && (h2[0] = "raw"), !w2 || "exportKey" !== e3 || "spki" !== u3 && "pkcs8" !== u3 || (h2[0] = "jwk"), E2 && "wrapKey" === e3) return b.exportKey(u3, c3).then(function(e4) {
                      return "jwk" === u3 && (e4 = r(unescape(encodeURIComponent(JSON.stringify(s(e4)))))), b.encrypt(h2[3], l2, e4);
                    });
                    try {
                      var v3 = o2.apply(b, h2);
                    } catch (e4) {
                      return Promise.reject(e4);
                    }
                    return E2 && (v3 = new Promise(function(e4, t3) {
                      v3.onabort = v3.onerror = function(e5) {
                        t3(e5);
                      }, v3.oncomplete = function(t4) {
                        e4(t4.target.result);
                      };
                    })), "exportKey" === e3 && "jwk" === u3 && (v3 = v3.then(function(e4) {
                      return (w2 || E2 && "SHA-1" === (c3.algorithm.hash || {}).name) && "HMAC" === c3.algorithm.name ? { kty: "oct", alg: a2(c3.algorithm), key_ops: c3.usages.slice(), ext: true, k: t2(i(e4)) } : ((e4 = s(e4)).alg || (e4.alg = a2(c3.algorithm)), e4.key_ops || (e4.key_ops = "public" === c3.type ? c3.usages.filter(p) : "private" === c3.type ? c3.usages.filter(d) : c3.usages.slice()), e4);
                    })), !w2 || "exportKey" !== e3 || "spki" !== u3 && "pkcs8" !== u3 || (v3 = v3.then(function(e4) {
                      var t3 = [["", null]], i2 = false;
                      switch ((e4 = s(e4)).kty) {
                        case "RSA":
                          for (var o3 = "n e d p q dp dq qi".split(" "), a3 = [], u4 = 0; u4 < o3.length && o3[u4] in e4; u4++) {
                            var c4 = a3[u4] = r(n2(e4[o3[u4]]));
                            128 & c4[0] && (a3[u4] = new Uint8Array(c4.length + 1), a3[u4].set(c4, 1));
                          }
                          2 < a3.length && (i2 = true, a3.unshift(new Uint8Array([0]))), t3[0][0] = "1.2.840.113549.1.1.1";
                          break;
                        default:
                          throw new TypeError("Unsupported key type");
                      }
                      return t3.push(new Uint8Array(f(a3)).buffer), i2 ? t3.unshift(new Uint8Array([0])) : t3[1] = { tag: 3, value: t3[1] }, new Uint8Array(f(t3)).buffer;
                    })), v3;
                  };
                }), ["encrypt", "decrypt", "sign", "verify"].forEach(function(e3) {
                  var t3 = b[e3];
                  b[e3] = function(n3, r2, i2, a3) {
                    if (E2 && (!i2.byteLength || a3 && !a3.byteLength)) throw Error("Empty input is not allowed");
                    var s2 = [].slice.call(arguments), u3 = o(n3);
                    if (!E2 || "sign" !== e3 && "verify" !== e3 || "RSASSA-PKCS1-v1_5" !== n3 && "HMAC" !== n3 || (s2[0] = { name: n3 }), E2 && r2.algorithm.hash && (s2[0].hash = s2[0].hash || r2.algorithm.hash), E2 && "decrypt" === e3 && "AES-GCM" === u3.name) {
                      var c3 = n3.tagLength >> 3;
                      s2[2] = (i2.buffer || i2).slice(0, i2.byteLength - c3), n3.tag = (i2.buffer || i2).slice(i2.byteLength - c3);
                    }
                    E2 && "AES-GCM" === u3.name && void 0 === s2[0].tagLength && (s2[0].tagLength = 128), s2[1] = r2._key;
                    try {
                      var l2 = t3.apply(b, s2);
                    } catch (e4) {
                      return Promise.reject(e4);
                    }
                    return E2 && (l2 = new Promise(function(t4, n4) {
                      l2.onabort = l2.onerror = function(e4) {
                        n4(e4);
                      }, l2.oncomplete = function(n5) {
                        if (n5 = n5.target.result, "encrypt" === e3 && n5 instanceof AesGcmEncryptResult) {
                          var r3 = n5.ciphertext, i3 = n5.tag;
                          (n5 = new Uint8Array(r3.byteLength + i3.byteLength)).set(new Uint8Array(r3), 0), n5.set(new Uint8Array(i3), r3.byteLength), n5 = n5.buffer;
                        }
                        t4(n5);
                      };
                    })), l2;
                  };
                }), E2) {
                  var I2 = b.digest;
                  b.digest = function(e3, t3) {
                    if (!t3.byteLength) throw Error("Empty input is not allowed");
                    try {
                      var n3 = I2.call(b, e3, t3);
                    } catch (e4) {
                      return Promise.reject(e4);
                    }
                    return n3 = new Promise(function(e4, t4) {
                      n3.onabort = n3.onerror = function(e5) {
                        t4(e5);
                      }, n3.oncomplete = function(t5) {
                        e4(t5.target.result);
                      };
                    });
                  }, e2.crypto = Object.create(v2, { getRandomValues: { value: function(e3) {
                    return v2.getRandomValues(e3);
                  } }, subtle: { value: b } }), e2.CryptoKey = h;
                }
                w2 && (v2.subtle = b, e2.Crypto = g, e2.SubtleCrypto = y2, e2.CryptoKey = h);
              }
            }
          }
        });
      });
      var Jw = qa("match"), Lj = function(e) {
        var t2;
        return ha(e) && (void 0 !== (t2 = e[Jw]) ? !!t2 : "RegExp" == Zb(e));
      }, Kw = [].push, Lw = Math.min;
      dh("split", 2, function(e, t2, n2) {
        var r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || 1 < ".".split(/()()/).length || "".split(/.?/).length ? function(e2, n3) {
          var r2 = String(jb(this));
          if (0 === (n3 = void 0 === n3 ? 4294967295 : n3 >>> 0)) return [];
          if (void 0 === e2) return [r2];
          if (!Lj(e2)) return t2.call(r2, e2, n3);
          var i, o, a2, s = [], u2 = 0;
          for (e2 = new RegExp(e2.source, (e2.ignoreCase ? "i" : "") + (e2.multiline ? "m" : "") + (e2.unicode ? "u" : "") + (e2.sticky ? "y" : "") + "g"); (i = Of.call(e2, r2)) && !((o = e2.lastIndex) > u2 && (s.push(r2.slice(u2, i.index)), 1 < i.length && i.index < r2.length && Kw.apply(s, i.slice(1)), a2 = i[0].length, u2 = o, s.length >= n3)); ) e2.lastIndex === i.index && e2.lastIndex++;
          return u2 === r2.length ? (a2 || !e2.test("")) && s.push("") : s.push(r2.slice(u2)), s.length > n3 ? s.slice(0, n3) : s;
        } : "0".split(void 0, 0).length ? function(e2, n3) {
          return void 0 === e2 && 0 === n3 ? [] : t2.call(this, e2, n3);
        } : t2;
        return [function(t3, n3) {
          var i = jb(this), o = null == t3 ? void 0 : t3[e];
          return void 0 !== o ? o.call(t3, i, n3) : r.call(String(i), t3, n3);
        }, function(e2, i) {
          var o = n2(r, e2, this, i, r !== t2);
          if (o.done) return o.value;
          var a2 = va(e2);
          e2 = String(this);
          var s = kd(a2, RegExp);
          if (o = a2.unicode, a2 = new s(pc ? "^(?:" + a2.source + ")" : a2, (a2.ignoreCase ? "i" : "") + (a2.multiline ? "m" : "") + (a2.unicode ? "u" : "") + (pc ? "g" : "y")), 0 === (i = void 0 === i ? 4294967295 : i >>> 0)) return [];
          if (0 === e2.length) return null === Ke(a2, e2) ? [e2] : [];
          var u2 = 0, c2 = 0;
          for (s = []; c2 < e2.length; ) {
            a2.lastIndex = pc ? 0 : c2;
            var l, f = Ke(a2, pc ? e2.slice(c2) : e2);
            if (null === f || (l = Lw(ta(a2.lastIndex + (pc ? c2 : 0)), e2.length)) === u2) c2 = xj(e2, c2, o);
            else {
              if (s.push(e2.slice(u2, c2)), s.length === i) return s;
              for (u2 = 1; u2 <= f.length - 1; u2++) if (s.push(f[u2]), s.length === i) return s;
              c2 = u2 = l;
            }
          }
          return s.push(e2.slice(u2)), s;
        }];
      }, pc), function(e) {
        e.console || (e.console = {}), e = e.console;
        for (var t2, n2 = function() {
        }, r = ["memory"], i = "assert clear count debug dir dirxml error exception group groupCollapsed groupEnd info log markTimeline profile profiles profileEnd show table time timeEnd timeline timelineEnd timeStamp trace warn".split(" "); t2 = r.pop(); ) e[t2] || (e[t2] = {});
        for (; t2 = i.pop(); ) e[t2] || (e[t2] = n2);
      }("undefined" == typeof window ? Ya : window), N({ target: "Object", stat: true }, { setPrototypeOf: Ua });
      var Mw = R(function() {
        Vb(1);
      });
      N({ target: "Object", stat: true, forced: Mw, sham: !Hn }, { getPrototypeOf: function(e) {
        return Vb(Qa(e));
      } });
      var ep = [].slice, Mj = {}, Nw = Function.bind || function(e) {
        var t2 = yb(this), n2 = ep.call(arguments, 1), r = function() {
          var i = n2.concat(ep.call(arguments));
          if (this instanceof r) {
            var o = i.length;
            if (!(o in Mj)) {
              for (var a2 = [], s = 0; s < o; s++) a2[s] = "a[" + s + "]";
              Mj[o] = Function("C,a", "return new C(" + a2.join(",") + ")");
            }
            i = Mj[o](t2, i);
          } else i = t2.apply(e, i);
          return i;
        };
        return ha(t2.prototype) && (r.prototype = t2.prototype), r;
      }, Nj = mc("Reflect", "construct"), fp = R(function() {
        function e() {
        }
        return !(Nj(function() {
        }, [], e) instanceof e);
      }), gp = !R(function() {
        Nj(function() {
        });
      }), hp = fp || gp;
      N({ target: "Reflect", stat: true, forced: hp, sham: hp }, { construct: function(e, t2) {
        yb(e), va(t2);
        var n2 = 3 > arguments.length ? e : yb(arguments[2]);
        if (gp && !fp) return Nj(e, t2, n2);
        if (e == n2) {
          switch (t2.length) {
            case 0:
              return new e();
            case 1:
              return new e(t2[0]);
            case 2:
              return new e(t2[0], t2[1]);
            case 3:
              return new e(t2[0], t2[1], t2[2]);
            case 4:
              return new e(t2[0], t2[1], t2[2], t2[3]);
          }
          return (n2 = [null]).push.apply(n2, t2), new (Nw.apply(e, n2))();
        }
        n2 = n2.prototype, n2 = ac(ha(n2) ? n2 : Object.prototype);
        var r = Function.apply.call(e, n2, t2);
        return ha(r) ? r : n2;
      } }), N({ target: "Reflect", stat: true }, { get: wl });
      var ip = Fb.f, Ow = R(function() {
        ip(1);
      });
      N({ target: "Object", stat: true, forced: !ka || Ow, sham: !ka }, { getOwnPropertyDescriptor: function(e, t2) {
        return ip(qb(e), t2);
      } });
      var jp = Hd.f, Pw = {}.toString, kp = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], Oj = function(e) {
        if (kp && "[object Window]" == Pw.call(e)) try {
          var t2 = jp(e);
        } catch (e2) {
          t2 = kp.slice();
        }
        else t2 = jp(qb(e));
        return t2;
      }, lp = { f: qa }, Qw = Ra.f, ph = function(e) {
        var t2 = y.Symbol || (y.Symbol = {});
        Q(t2, e) || Qw(t2, e, { value: lp.f(e) });
      }, rb = Pg("hidden"), mp = qa("toPrimitive"), Rw = Za.set, np = Za.getterFor("Symbol"), Ob = Object.prototype, sb = y.Symbol, Tf = mc("JSON", "stringify"), op = Fb.f, od = Ra.f, pp = Oj, Sw = zf, Lc = fd("symbols"), Uf = fd("op-symbols"), Pj = fd("string-to-symbol-registry"), Qj = fd("symbol-to-string-registry"), Tw = fd("wks"), Rj = y.QObject, Sj = !Rj || !Rj.prototype || !Rj.prototype.findChild, Tj = ka && R(function() {
        return 7 != ac(od({}, "a", { get: function() {
          return od(this, "a", { value: 7 }).a;
        } })).a;
      }) ? function(e, t2, n2) {
        var r = op(Ob, t2);
        r && delete Ob[t2], od(e, t2, n2), r && e !== Ob && od(Ob, t2, r);
      } : od, Uj = function(e, t2) {
        var n2 = Lc[e] = ac(sb.prototype);
        return Rw(n2, { type: "Symbol", tag: e, description: t2 }), ka || (n2.description = t2), n2;
      }, Vj = vn ? function(e) {
        return "symbol" == typeof e;
      } : function(e) {
        return Object(e) instanceof sb;
      }, qh = function(e, t2, n2) {
        return e === Ob && qh(Uf, t2, n2), va(e), t2 = lc(t2, true), va(n2), Q(Lc, t2) ? (n2.enumerable ? (Q(e, rb) && e[rb][t2] && (e[rb][t2] = false), n2 = ac(n2, { enumerable: dd(0, false) })) : (Q(e, rb) || od(e, rb, dd(1, {})), e[rb][t2] = true), Tj(e, t2, n2)) : od(e, t2, n2);
      }, qp = function(e, t2) {
        va(e);
        var n2 = qb(t2);
        return t2 = Dc(n2).concat(Wj(n2)), Jd(t2, function(t3) {
          ka && !Xj.call(n2, t3) || qh(e, t3, n2[t3]);
        }), e;
      }, Xj = function(e) {
        e = lc(e, true);
        var t2 = Sw.call(this, e);
        return !(this === Ob && Q(Lc, e) && !Q(Uf, e)) && (!(t2 || !Q(this, e) || !Q(Lc, e) || Q(this, rb) && this[rb][e]) || t2);
      }, rp = function(e, t2) {
        if (e = qb(e), t2 = lc(t2, true), e !== Ob || !Q(Lc, t2) || Q(Uf, t2)) {
          var n2 = op(e, t2);
          return !n2 || !Q(Lc, t2) || Q(e, rb) && e[rb][t2] || (n2.enumerable = true), n2;
        }
      }, sp = function(e) {
        e = pp(qb(e));
        var t2 = [];
        return Jd(e, function(e2) {
          Q(Lc, e2) || Q(Be, e2) || t2.push(e2);
        }), t2;
      }, Wj = function(e) {
        var t2 = e === Ob;
        e = pp(t2 ? Uf : qb(e));
        var n2 = [];
        return Jd(e, function(e2) {
          !Q(Lc, e2) || t2 && !Q(Ob, e2) || n2.push(Lc[e2]);
        }), n2;
      };
      if (oc || (sb = function() {
        if (this instanceof sb) throw TypeError("Symbol is not a constructor");
        var e = arguments.length && void 0 !== arguments[0] ? String(arguments[0]) : void 0, t2 = Ae(e), n2 = function(e2) {
          this === Ob && n2.call(Uf, e2), Q(this, rb) && Q(this[rb], t2) && (this[rb][t2] = false), Tj(this, t2, dd(1, e2));
        };
        return ka && Sj && Tj(Ob, t2, { configurable: true, set: n2 }), Uj(t2, e);
      }, Ta(sb.prototype, "toString", function() {
        return np(this).tag;
      }), Ta(sb, "withoutSetter", function(e) {
        return Uj(Ae(e), e);
      }), zf = Xj, Ra.f = qh, Fb.f = rp, Hd.f = Oj = sp, Bf.f = Wj, lp.f = function(e) {
        return Uj(qa(e), e);
      }, ka && (od(sb.prototype, "description", { configurable: true, get: function() {
        return np(this).description;
      } }), Ta(Ob, "propertyIsEnumerable", Xj, { unsafe: true }))), N({ global: true, wrap: true, forced: !oc, sham: !oc }, { Symbol: sb }), Jd(Dc(Tw), function(e) {
        ph(e);
      }), N({ target: "Symbol", stat: true, forced: !oc }, { for: function(e) {
        if (e = String(e), Q(Pj, e)) return Pj[e];
        var t2 = sb(e);
        return Pj[e] = t2, Qj[t2] = e, t2;
      }, keyFor: function(e) {
        if (!Vj(e)) throw TypeError(e + " is not a symbol");
        if (Q(Qj, e)) return Qj[e];
      }, useSetter: function() {
        Sj = true;
      }, useSimple: function() {
        Sj = false;
      } }), N({ target: "Object", stat: true, forced: !oc, sham: !ka }, { create: function(e, t2) {
        return void 0 === t2 ? ac(e) : qp(ac(e), t2);
      }, defineProperty: qh, defineProperties: qp, getOwnPropertyDescriptor: rp }), N({ target: "Object", stat: true, forced: !oc }, { getOwnPropertyNames: sp, getOwnPropertySymbols: Wj }), N({ target: "Object", stat: true, forced: R(function() {
        Bf.f(1);
      }) }, { getOwnPropertySymbols: function(e) {
        return Bf.f(Qa(e));
      } }), Tf) {
        var Uw = !oc || R(function() {
          var e = sb();
          return "[null]" != Tf([e]) || "{}" != Tf({ a: e }) || "{}" != Tf(Object(e));
        });
        N({ target: "JSON", stat: true, forced: Uw }, { stringify: function(e, t2, n2) {
          for (var r, i = [e], o = 1; arguments.length > o; ) i.push(arguments[o++]);
          if (r = t2, (ha(t2) || void 0 !== e) && !Vj(e)) return gd(t2) || (t2 = function(e2, t3) {
            if ("function" == typeof r && (t3 = r.call(this, e2, t3)), !Vj(t3)) return t3;
          }), i[1] = t2, Tf.apply(null, i);
        } });
      }
      sb.prototype[mp] || Na(sb.prototype, mp, sb.prototype.valueOf), Ec(sb, "Symbol"), Be[rb] = true;
      var Vw = Ra.f, Mc = y.Symbol;
      if (ka && "function" == typeof Mc && (!("description" in Mc.prototype) || void 0 !== Mc().description)) {
        var tp = {}, Vf = function() {
          var e = 1 > arguments.length || void 0 === arguments[0] ? void 0 : String(arguments[0]), t2 = this instanceof Vf ? new Mc(e) : void 0 === e ? Mc() : Mc(e);
          return "" === e && (tp[t2] = true), t2;
        };
        rn(Vf, Mc);
        var Yj = Vf.prototype = Mc.prototype;
        Yj.constructor = Vf;
        var Ww = Yj.toString, Xw = "Symbol(test)" == String(Mc("test")), Yw = /^Symbol\((.*)\)[^)]+$/;
        Vw(Yj, "description", { configurable: true, get: function() {
          var e = ha(this) ? this.valueOf() : this, t2 = Ww.call(e);
          return Q(tp, e) ? "" : "" === (e = Xw ? t2.slice(7, -1) : t2.replace(Yw, "$1")) ? void 0 : e;
        } }), N({ global: true, forced: true }, { Symbol: Vf });
      }
      ph("toStringTag"), Ec(y.JSON, "JSON", true), Ec(Math, "Math", true), function() {
        function e(e2, t3) {
          if (!(e2 instanceof t3)) throw new TypeError("Cannot call a class as a function");
        }
        function t2(e2, t3) {
          for (var n3 = 0; n3 < t3.length; n3++) {
            var r2 = t3[n3];
            r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
          }
        }
        function n2(e2, n3, r2) {
          return n3 && t2(e2.prototype, n3), r2 && t2(e2, r2), e2;
        }
        function r(e2, t3) {
          if ("function" != typeof t3 && null !== t3) throw new TypeError("Super expression must either be null or a function");
          e2.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e2, writable: true, configurable: true } }), t3 && o(e2, t3);
        }
        function i(e2) {
          return (i = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
            return e3.__proto__ || Object.getPrototypeOf(e3);
          })(e2);
        }
        function o(e2, t3) {
          return (o = Object.setPrototypeOf || function(e3, t4) {
            return e3.__proto__ = t4, e3;
          })(e2, t3);
        }
        function a2(e2) {
          if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e2;
        }
        function s(e2) {
          var t3 = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (e3) {
              return false;
            }
          }();
          return function() {
            var n3 = i(e2);
            if (t3) {
              var r2 = i(this).constructor;
              n3 = Reflect.construct(n3, arguments, r2);
            } else n3 = n3.apply(this, arguments);
            return n3 = !n3 || "object" !== X(n3) && "function" != typeof n3 ? a2(this) : n3;
          };
        }
        function u2(e2, t3, n3) {
          return (u2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e3, t4, n4) {
            for (; !Object.prototype.hasOwnProperty.call(e3, t4) && null !== (e3 = i(e3)); ) ;
            if (e3) return (t4 = Object.getOwnPropertyDescriptor(e3, t4)).get ? t4.get.call(n4) : t4.value;
          })(e2, t3, n3 || e2);
        }
        var c2 = function() {
          function t3() {
            e(this, t3), Object.defineProperty(this, "listeners", { value: {}, writable: true, configurable: true });
          }
          return n2(t3, [{ key: "addEventListener", value: function(e2, t4, n3) {
            e2 in this.listeners || (this.listeners[e2] = []), this.listeners[e2].push({ callback: t4, options: n3 });
          } }, { key: "removeEventListener", value: function(e2, t4) {
            if (e2 in this.listeners) {
              for (var n3 = 0, r2 = (e2 = this.listeners[e2]).length; n3 < r2; n3++) if (e2[n3].callback === t4) {
                e2.splice(n3, 1);
                break;
              }
            }
          } }, { key: "dispatchEvent", value: function(e2) {
            if (e2.type in this.listeners) {
              for (var t4 = this.listeners[e2.type].slice(), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
                var i2 = t4[n3];
                try {
                  i2.callback.call(this, e2);
                } catch (e3) {
                  Promise.resolve().then(function() {
                    throw e3;
                  });
                }
                i2.options && i2.options.once && this.removeEventListener(e2.type, i2.callback);
              }
              return !e2.defaultPrevented;
            }
          } }]), t3;
        }(), l = function(t3) {
          function o2() {
            e(this, o2);
            var t4 = l2.call(this);
            return t4.listeners || c2.call(a2(t4)), Object.defineProperty(a2(t4), "aborted", { value: false, writable: true, configurable: true }), Object.defineProperty(a2(t4), "onabort", { value: null, writable: true, configurable: true }), t4;
          }
          r(o2, t3);
          var l2 = s(o2);
          return n2(o2, [{ key: "toString", value: function() {
            return "[object AbortSignal]";
          } }, { key: "dispatchEvent", value: function(e2) {
            "abort" === e2.type && (this.aborted = true, "function" == typeof this.onabort && this.onabort.call(this, e2)), u2(i(o2.prototype), "dispatchEvent", this).call(this, e2);
          } }]), o2;
        }(c2), f = function() {
          function t3() {
            e(this, t3), Object.defineProperty(this, "signal", { value: new l(), writable: true, configurable: true });
          }
          return n2(t3, [{ key: "abort", value: function() {
            try {
              var e2 = new Event("abort");
            } catch (t4) {
              "undefined" != typeof document ? document.createEvent ? (e2 = document.createEvent("Event")).initEvent("abort", false, false) : (e2 = document.createEventObject()).type = "abort" : e2 = { type: "abort", bubbles: false, cancelable: false };
            }
            this.signal.dispatchEvent(e2);
          } }, { key: "toString", value: function() {
            return "[object AbortController]";
          } }]), t3;
        }();
        "undefined" != typeof Symbol && Symbol.toStringTag && (f.prototype[Symbol.toStringTag] = "AbortController", l.prototype[Symbol.toStringTag] = "AbortSignal"), function(e2) {
          if (e2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
            console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
            var t3 = true;
          } else t3 = "function" == typeof e2.Request && !e2.Request.prototype.hasOwnProperty("signal") || !e2.AbortController;
          t3 && (e2.AbortController = f, e2.AbortSignal = l);
        }("undefined" != typeof self ? self : Ya);
      }();
      var Zw = Math.floor, $w = Math.log, ax = Math.LOG2E;
      N({ target: "Math", stat: true }, { clz32: function(e) {
        return (e >>>= 0) ? 31 - Zw($w(e + 0.5) * ax) : 32;
      } });
      var bx = Math.log, cx = Math.LN2, ss = Math.clz32 || function(e) {
        return 31 - bx(e >>> 0) / cx | 0;
      }, xd = String.fromCharCode, up = {}.toString, Zj = window.Uint8Array, ak = Zj || Array, dx = up.call((window.ArrayBuffer || ak).prototype), bk;
      xl.prototype.decode = function(e) {
        if (e = e && e.buffer || e, up.call(e) !== dx) throw Error("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
        for (var t2 = "", n2 = 0, r = 0 | (e = Zj ? new ak(e) : e).length; n2 < r; n2 = n2 + 32768 | 0) t2 += xd.apply(0, e[Zj ? "slice" : "subarray"](n2, n2 + 32768 | 0));
        return t2.replace(/[\xc0-\xff][\x80-\xbf]*/g, rs);
      }, window.TextDecoder || (window.TextDecoder = xl), yl.prototype.encode = function(e) {
        for (var t2 = 0 | (e = void 0 === e ? "" : ("" + e).replace(/[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, ts)).length, n2 = new ak(t2), r = 0; r < t2; r = r + 1 | 0) n2[r] = e.charCodeAt(r);
        return n2;
      }, window.TextEncoder || (window.TextEncoder = yl), function(e) {
        var t2, n2, r, i, o, a2, s, u2, c2, l, f;
        !function(e2) {
          e2.LOGIN = "LOGIN", e2.LOGIN_SUCCESS = "LOGIN_SUCCESS", e2.LOGIN_FAILURE = "LOGIN_FAILURE", e2.LOGIN_TIMEOUT = "LOGIN_TIMEOUT", e2.INTERRUPTED = "INTERRUPTED", e2.LOGOUT = "LOGOUT", e2.BANNED_BY_SERVER = "BANNED_BY_SERVER", e2.REMOTE_LOGIN = "REMOTE_LOGIN";
        }(t2 || (t2 = {})), e.ConnectionChangeReason = t2, function(e2) {
          e2.DISCONNECTED = "DISCONNECTED", e2.CONNECTING = "CONNECTING", e2.CONNECTED = "CONNECTED", e2.RECONNECTING = "RECONNECTING", e2.ABORTED = "ABORTED";
        }(n2 || (n2 = {})), e.ConnectionState = n2, function(e2) {
          e2.IDLE = "IDLE", e2.SENT_TO_REMOTE = "SENT_TO_REMOTE", e2.RECEIVED_BY_REMOTE = "RECEIVED_BY_REMOTE", e2.ACCEPTED_BY_REMOTE = "ACCEPTED_BY_REMOTE", e2.REFUSED_BY_REMOTE = "REFUSED_BY_REMOTE", e2.CANCELED = "CANCELED", e2.FAILURE = "FAILURE";
        }(r || (r = {})), e.LocalInvitationState = r, function(e2) {
          e2.INVITATION_RECEIVED = "INVITATION_RECEIVED", e2.ACCEPT_SENT_TO_LOCAL = "ACCEPT_SENT_TO_LOCAL", e2.REFUSED = "REFUSED", e2.ACCEPTED = "ACCEPTED", e2.CANCELED = "CANCELED", e2.FAILURE = "FAILURE";
        }(i || (i = {})), e.RemoteInvitationState = i, function(e2) {
          e2.UNKNOWN = "UNKNOWN", e2.PEER_NO_RESPONSE = "PEER_NO_RESPONSE", e2.INVITATION_EXPIRE = "INVITATION_EXPIRE", e2.PEER_OFFLINE = "PEER_OFFLINE", e2.NOT_LOGGEDIN = "NOT_LOGGEDIN";
        }(o || (o = {})), e.LocalInvitationFailureReason = o, function(e2) {
          e2.UNKNOWN = "UNKNOWN", e2.PEER_OFFLINE = "PEER_OFFLINE", e2.ACCEPT_FAILURE = "ACCEPT_FAILURE", e2.INVITATION_EXPIRE = "INVITATION_EXPIRE";
        }(a2 || (a2 = {})), e.RemoteInvitationFailureReason = a2, function(e2) {
          e2.ONLINE = "ONLINE", e2.UNREACHABLE = "UNREACHABLE", e2.OFFLINE = "OFFLINE";
        }(s || (s = {})), e.PeerOnlineState = s, (u2 || (u2 = {})).ONLINE_STATUS = "ONLINE_STATUS", e.PeerSubscriptionOption = u2, function(e2) {
          e2.TEXT = "TEXT", e2.RAW = "RAW", e2.IMAGE = "IMAGE", e2.FILE = "FILE";
        }(c2 || (c2 = {})), e.MessageType = c2, function(e2) {
          e2.CN = "CN", e2.NA = "NA", e2.EU = "EU", e2.AS = "AS", e2.JP = "JP", e2.IN = "IN", e2.GLOB = "GLOB", e2.OC = "OC", e2.SA = "SA", e2.AF = "AF", e2.OVS = "OVS";
        }(l || (l = {})), e.LegacyAreaCode = l, function(e2) {
          e2.GLOBAL = "GLOBAL", e2.INDIA = "INDIA", e2.JAPAN = "JAPAN", e2.ASIA = "ASIA", e2.EUROPE = "EUROPE", e2.CHINA = "CHINA", e2.NORTH_AMERICA = "NORTH_AMERICA";
        }(f || (f = {})), e.AreaCode = f;
      }(bk || (bk = {}));
      var S = bk;
      N({ target: "Array", proto: true }, { includes: function(e) {
        return on(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } }), Ld("includes");
      var ck = function(e) {
        if (Lj(e)) throw TypeError("The method doesn't accept regular expressions");
        return e;
      }, ex = qa("match"), dk = function(e) {
        var t2 = /./;
        try {
          "/./"[e](t2);
        } catch (n2) {
          try {
            return t2[ex] = false, "/./"[e](t2);
          } catch (e2) {
          }
        }
        return false;
      };
      N({ target: "String", proto: true, forced: !dk("includes") }, { includes: function(e) {
        return !!~String(jb(this)).indexOf(ck(e), 1 < arguments.length ? arguments[1] : void 0);
      } });
      var Nc = { RECONNECTING_AP_INTERVAL: 2500, RECONNECTING_AP_NUM: 2, DISABLE_MESSAGE_COMPRESSION: false, LOG_UPLOAD_INTERVAL: 3e3, LOG_HANDLER: void 0 };
      ph("iterator"), ph("asyncIterator");
      var ek = Ee("forEach") ? [].forEach : function(e) {
        return Jd(this, e, 1 < arguments.length ? arguments[1] : void 0);
      }, vp;
      for (vp in Ij) {
        var wp = y[vp], rh = wp && wp.prototype;
        if (rh && rh.forEach !== ek) try {
          Na(rh, "forEach", ek);
        } catch (c2) {
          rh.forEach = ek;
        }
      }
      var fx = [].reverse, xp = [1, 2];
      N({ target: "Array", proto: true, forced: String(xp) === String(xp.reverse()) }, { reverse: function() {
        return gd(this) && (this.length = this.length), fx.call(this);
      } });
      var w = $a(function(e) {
        e = function(e2) {
          function t2(e3, t3, n3) {
            return Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }), e3[t3];
          }
          function n2(e3, t3, n3, o2) {
            return t3 = Object.create((t3 && t3.prototype instanceof i ? t3 : i).prototype), o2 = new h(o2 || []), t3._invoke = /* @__PURE__ */ function(e4, t4, n4) {
              var i2 = _;
              return function(o3, a3) {
                if (i2 === I2) throw Error("Generator is already running");
                if (i2 === A) {
                  if ("throw" === o3) throw a3;
                  return d();
                }
                for (n4.method = o3, n4.arg = a3; ; ) {
                  if ((o3 = n4.delegate) && (o3 = c2(o3, n4))) {
                    if (o3 === k) continue;
                    return o3;
                  }
                  if ("next" === n4.method) n4.sent = n4._sent = n4.arg;
                  else if ("throw" === n4.method) {
                    if (i2 === _) throw i2 = A, n4.arg;
                    n4.dispatchException(n4.arg);
                  } else "return" === n4.method && n4.abrupt("return", n4.arg);
                  if (i2 = I2, "normal" === (o3 = r(e4, t4, n4)).type) {
                    if (i2 = n4.done ? A : O2, o3.arg === k) continue;
                    return { value: o3.arg, done: n4.done };
                  }
                  "throw" === o3.type && (i2 = A, n4.method = "throw", n4.arg = o3.arg);
                }
              };
            }(e3, n3, o2), t3;
          }
          function r(e3, t3, n3) {
            try {
              return { type: "normal", arg: e3.call(t3, n3) };
            } catch (e4) {
              return { type: "throw", arg: e4 };
            }
          }
          function i() {
          }
          function o() {
          }
          function a2() {
          }
          function s(e3) {
            ["next", "throw", "return"].forEach(function(n3) {
              t2(e3, n3, function(e4) {
                return this._invoke(n3, e4);
              });
            });
          }
          function u2(e3, t3) {
            function n3(i3, o2, a3, s2) {
              if ("throw" !== (i3 = r(e3[i3], e3, o2)).type) {
                var u3 = i3.arg;
                return (i3 = u3.value) && "object" === X(i3) && g.call(i3, "__await") ? t3.resolve(i3.__await).then(function(e4) {
                  n3("next", e4, a3, s2);
                }, function(e4) {
                  n3("throw", e4, a3, s2);
                }) : t3.resolve(i3).then(function(e4) {
                  u3.value = e4, a3(u3);
                }, function(e4) {
                  return n3("throw", e4, a3, s2);
                });
              }
              s2(i3.arg);
            }
            var i2;
            this._invoke = function(e4, r2) {
              function o2() {
                return new t3(function(t4, i3) {
                  n3(e4, r2, t4, i3);
                });
              }
              return i2 = i2 ? i2.then(o2, o2) : o2();
            };
          }
          function c2(e3, t3) {
            var n3 = e3.iterator[t3.method];
            if (n3 === v2) {
              if (t3.delegate = null, "throw" === t3.method) {
                if (e3.iterator.return && (t3.method = "return", t3.arg = v2, c2(e3, t3), "throw" === t3.method)) return k;
                t3.method = "throw", t3.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return k;
            }
            return "throw" === (n3 = r(n3, e3.iterator, t3.arg)).type ? (t3.method = "throw", t3.arg = n3.arg, t3.delegate = null, k) : (n3 = n3.arg) ? n3.done ? (t3[e3.resultName] = n3.value, t3.next = e3.nextLoc, "return" !== t3.method && (t3.method = "next", t3.arg = v2), t3.delegate = null, k) : n3 : (t3.method = "throw", t3.arg = new TypeError("iterator result is not an object"), t3.delegate = null, k);
          }
          function l(e3) {
            var t3 = { tryLoc: e3[0] };
            1 in e3 && (t3.catchLoc = e3[1]), 2 in e3 && (t3.finallyLoc = e3[2], t3.afterLoc = e3[3]), this.tryEntries.push(t3);
          }
          function f(e3) {
            var t3 = e3.completion || {};
            t3.type = "normal", delete t3.arg, e3.completion = t3;
          }
          function h(e3) {
            this.tryEntries = [{ tryLoc: "root" }], e3.forEach(l, this), this.reset(true);
          }
          function p(e3) {
            if (e3) {
              var t3 = e3[m2];
              if (t3) return t3.call(e3);
              if ("function" == typeof e3.next) return e3;
              if (!isNaN(e3.length)) {
                var n3 = -1;
                return (t3 = function t4() {
                  for (; ++n3 < e3.length; ) if (g.call(e3, n3)) return t4.value = e3[n3], t4.done = false, t4;
                  return t4.value = v2, t4.done = true, t4;
                }).next = t3;
              }
            }
            return { next: d };
          }
          function d() {
            return { value: v2, done: true };
          }
          var v2, b = Object.prototype, g = b.hasOwnProperty, y2 = "function" == typeof Symbol ? Symbol : {}, m2 = y2.iterator || "@@iterator", E2 = y2.asyncIterator || "@@asyncIterator", w2 = y2.toStringTag || "@@toStringTag";
          try {
            t2({}, "");
          } catch (e3) {
            t2 = function(e4, t3, n3) {
              return e4[t3] = n3;
            };
          }
          e2.wrap = n2;
          var _ = "suspendedStart", O2 = "suspendedYield", I2 = "executing", A = "completed", k = {};
          t2(y2 = {}, m2, function() {
            return this;
          });
          var R2 = Object.getPrototypeOf;
          (R2 = R2 && R2(R2(p([])))) && R2 !== b && g.call(R2, m2) && (y2 = R2);
          var T2 = a2.prototype = i.prototype = Object.create(y2);
          return o.prototype = a2, t2(T2, "constructor", a2), t2(a2, "constructor", o), o.displayName = t2(a2, w2, "GeneratorFunction"), e2.isGeneratorFunction = function(e3) {
            return !!(e3 = "function" == typeof e3 && e3.constructor) && (e3 === o || "GeneratorFunction" === (e3.displayName || e3.name));
          }, e2.mark = function(e3) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e3, a2) : (e3.__proto__ = a2, t2(e3, w2, "GeneratorFunction")), e3.prototype = Object.create(T2), e3;
          }, e2.awrap = function(e3) {
            return { __await: e3 };
          }, s(u2.prototype), t2(u2.prototype, E2, function() {
            return this;
          }), e2.AsyncIterator = u2, e2.async = function(t3, r2, i2, o2, a3) {
            void 0 === a3 && (a3 = Promise);
            var s2 = new u2(n2(t3, r2, i2, o2), a3);
            return e2.isGeneratorFunction(r2) ? s2 : s2.next().then(function(e3) {
              return e3.done ? e3.value : s2.next();
            });
          }, s(T2), t2(T2, w2, "Generator"), t2(T2, m2, function() {
            return this;
          }), t2(T2, "toString", function() {
            return "[object Generator]";
          }), e2.keys = function(e3) {
            var t3, n3 = [];
            for (t3 in e3) n3.push(t3);
            return n3.reverse(), function t4() {
              for (; n3.length; ) {
                var r2 = n3.pop();
                if (r2 in e3) return t4.value = r2, t4.done = false, t4;
              }
              return t4.done = true, t4;
            };
          }, e2.values = p, h.prototype = { constructor: h, reset: function(e3) {
            if (this.next = this.prev = 0, this.sent = this._sent = v2, this.done = false, this.delegate = null, this.method = "next", this.arg = v2, this.tryEntries.forEach(f), !e3) for (var t3 in this) "t" === t3.charAt(0) && g.call(this, t3) && !isNaN(+t3.slice(1)) && (this[t3] = v2);
          }, stop: function() {
            this.done = true;
            var e3 = this.tryEntries[0].completion;
            if ("throw" === e3.type) throw e3.arg;
            return this.rval;
          }, dispatchException: function(e3) {
            function t3(t4, r3) {
              return o2.type = "throw", o2.arg = e3, n3.next = t4, r3 && (n3.method = "next", n3.arg = v2), !!r3;
            }
            if (this.done) throw e3;
            for (var n3 = this, r2 = this.tryEntries.length - 1; 0 <= r2; --r2) {
              var i2 = this.tryEntries[r2], o2 = i2.completion;
              if ("root" === i2.tryLoc) return t3("end");
              if (i2.tryLoc <= this.prev) {
                var a3 = g.call(i2, "catchLoc"), s2 = g.call(i2, "finallyLoc");
                if (a3 && s2) {
                  if (this.prev < i2.catchLoc) return t3(i2.catchLoc, true);
                  if (this.prev < i2.finallyLoc) return t3(i2.finallyLoc);
                } else if (a3) {
                  if (this.prev < i2.catchLoc) return t3(i2.catchLoc, true);
                } else {
                  if (!s2) throw Error("try statement without catch or finally");
                  if (this.prev < i2.finallyLoc) return t3(i2.finallyLoc);
                }
              }
            }
          }, abrupt: function(e3, t3) {
            for (var n3 = this.tryEntries.length - 1; 0 <= n3; --n3) {
              var r2 = this.tryEntries[n3];
              if (r2.tryLoc <= this.prev && g.call(r2, "finallyLoc") && this.prev < r2.finallyLoc) {
                var i2 = r2;
                break;
              }
            }
            return i2 && ("break" === e3 || "continue" === e3) && i2.tryLoc <= t3 && t3 <= i2.finallyLoc && (i2 = null), (n3 = i2 ? i2.completion : {}).type = e3, n3.arg = t3, i2 ? (this.method = "next", this.next = i2.finallyLoc, k) : this.complete(n3);
          }, complete: function(e3, t3) {
            if ("throw" === e3.type) throw e3.arg;
            return "break" === e3.type || "continue" === e3.type ? this.next = e3.arg : "return" === e3.type ? (this.rval = this.arg = e3.arg, this.method = "return", this.next = "end") : "normal" === e3.type && t3 && (this.next = t3), k;
          }, finish: function(e3) {
            for (var t3 = this.tryEntries.length - 1; 0 <= t3; --t3) {
              var n3 = this.tryEntries[t3];
              if (n3.finallyLoc === e3) return this.complete(n3.completion, n3.afterLoc), f(n3), k;
            }
          }, catch: function(e3) {
            for (var t3 = this.tryEntries.length - 1; 0 <= t3; --t3) {
              var n3 = this.tryEntries[t3];
              if (n3.tryLoc === e3) {
                if ("throw" === (e3 = n3.completion).type) {
                  var r2 = e3.arg;
                  f(n3);
                }
                return r2;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(e3, t3, n3) {
            return this.delegate = { iterator: p(e3), resultName: t3, nextLoc: n3 }, "next" === this.method && (this.arg = v2), k;
          } }, e2;
        }(e.exports);
        try {
          regeneratorRuntime = e;
        } catch (t2) {
          "object" === ("undefined" == typeof globalThis ? "undefined" : X(globalThis)) ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e);
        }
      }), yp = !R(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      }), fk = $a(function(e) {
        var t2 = Ra.f, n2 = Ae("meta"), r = 0, i = Object.isExtensible || function() {
          return true;
        }, o = function(e2) {
          t2(e2, n2, { value: { objectID: "O" + ++r, weakData: {} } });
        }, a2 = e.exports = { REQUIRED: false, fastKey: function(e2, t3) {
          if (!ha(e2)) return "symbol" == typeof e2 ? e2 : ("string" == typeof e2 ? "S" : "P") + e2;
          if (!Q(e2, n2)) {
            if (!i(e2)) return "F";
            if (!t3) return "E";
            o(e2);
          }
          return e2[n2].objectID;
        }, getWeakData: function(e2, t3) {
          if (!Q(e2, n2)) {
            if (!i(e2)) return true;
            if (!t3) return false;
            o(e2);
          }
          return e2[n2].weakData;
        }, onFreeze: function(e2) {
          return yp && a2.REQUIRED && i(e2) && !Q(e2, n2) && o(e2), e2;
        } };
        Be[n2] = true;
      }), zp = function(e, t2, n2) {
        var r = -1 !== e.indexOf("Map"), i = -1 !== e.indexOf("Weak"), o = r ? "set" : "add", a2 = y[e], s = a2 && a2.prototype, u2 = a2, c2 = {}, l = function(e2) {
          var t3 = s[e2];
          Ta(s, e2, "add" == e2 ? function(e3) {
            return t3.call(this, 0 === e3 ? 0 : e3), this;
          } : "delete" == e2 ? function(e3) {
            return !(i && !ha(e3)) && t3.call(this, 0 === e3 ? 0 : e3);
          } : "get" == e2 ? function(e3) {
            return i && !ha(e3) ? void 0 : t3.call(this, 0 === e3 ? 0 : e3);
          } : "has" == e2 ? function(e3) {
            return !(i && !ha(e3)) && t3.call(this, 0 === e3 ? 0 : e3);
          } : function(e3, n3) {
            return t3.call(this, 0 === e3 ? 0 : e3, n3), this;
          });
        };
        if (nc(e, "function" != typeof a2 || !(i || s.forEach && !R(function() {
          new a2().entries().next();
        })))) u2 = n2.getConstructor(t2, e, r, o), fk.REQUIRED = true;
        else if (nc(e, true)) {
          var f = new u2(), h = f[o](i ? {} : -0, 1) != f, p = R(function() {
            f.has(1);
          }), d = Tg(function(e2) {
            new a2(e2);
          }), v2 = !i && R(function() {
            for (var e2 = new a2(), t3 = 5; t3--; ) e2[o](t3, t3);
            return !e2.has(-0);
          });
          d || ((u2 = t2(function(t3, n3) {
            return Gc(t3, u2, e), t3 = lh(new a2(), t3, u2), null != n3 && Xg(n3, t3[o], { that: t3, AS_ENTRIES: r }), t3;
          })).prototype = s, s.constructor = u2), (p || v2) && (l("delete"), l("has"), r && l("get")), (v2 || h) && l(o), i && s.clear && delete s.clear;
        }
        return c2[e] = u2, N({ global: true, forced: u2 != a2 }, c2), Ec(u2, e), i || n2.setStrong(u2, e, r), u2;
      }, gx = Ra.f, Ap = fk.fastKey, Bp = Za.set, gk = Za.getterFor, Cp = { getConstructor: function(e, t2, n2, r) {
        var i = e(function(e2, o2) {
          Gc(e2, i, t2), Bp(e2, { type: t2, index: ac(null), first: void 0, last: void 0, size: 0 }), ka || (e2.size = 0), null != o2 && Xg(o2, e2[r], { that: e2, AS_ENTRIES: n2 });
        }), o = gk(t2), a2 = function(e2, t3, n3) {
          var r2, i2 = o(e2), a3 = s(e2, t3);
          return a3 ? a3.value = n3 : (i2.last = a3 = { index: r2 = Ap(t3, true), key: t3, value: n3, previous: t3 = i2.last, next: void 0, removed: false }, i2.first || (i2.first = a3), t3 && (t3.next = a3), ka ? i2.size++ : e2.size++, "F" !== r2 && (i2.index[r2] = a3)), e2;
        }, s = function(e2, t3) {
          e2 = o(e2);
          var n3 = Ap(t3);
          if ("F" !== n3) return e2.index[n3];
          for (e2 = e2.first; e2; e2 = e2.next) if (e2.key == t3) return e2;
        };
        return Hf(i.prototype, { clear: function() {
          for (var e2 = o(this), t3 = e2.index, n3 = e2.first; n3; ) n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete t3[n3.index], n3 = n3.next;
          e2.first = e2.last = void 0, ka ? e2.size = 0 : this.size = 0;
        }, delete: function(e2) {
          var t3 = o(this);
          if (e2 = s(this, e2)) {
            var n3 = e2.next, r2 = e2.previous;
            delete t3.index[e2.index], e2.removed = true, r2 && (r2.next = n3), n3 && (n3.previous = r2), t3.first == e2 && (t3.first = n3), t3.last == e2 && (t3.last = r2), ka ? t3.size-- : this.size--;
          }
          return !!e2;
        }, forEach: function(e2) {
          for (var t3, n3 = o(this), r2 = Id(e2, 1 < arguments.length ? arguments[1] : void 0, 3); t3 = t3 ? t3.next : n3.first; ) for (r2(t3.value, t3.key, this); t3 && t3.removed; ) t3 = t3.previous;
        }, has: function(e2) {
          return !!s(this, e2);
        } }), Hf(i.prototype, n2 ? { get: function(e2) {
          return (e2 = s(this, e2)) && e2.value;
        }, set: function(e2, t3) {
          return a2(this, 0 === e2 ? 0 : e2, t3);
        } } : { add: function(e2) {
          return a2(this, e2 = 0 === e2 ? 0 : e2, e2);
        } }), ka && gx(i.prototype, "size", { get: function() {
          return o(this).size;
        } }), i;
      }, setStrong: function(e, t2, n2) {
        var r = t2 + " Iterator", i = gk(t2), o = gk(r);
        bj(e, t2, function(e2, t3) {
          Bp(this, { type: r, target: e2, state: i(e2), kind: t3, last: void 0 });
        }, function() {
          for (var e2 = o(this), t3 = e2.kind, n3 = e2.last; n3 && n3.removed; ) n3 = n3.previous;
          return e2.target && (e2.last = n3 = n3 ? n3.next : e2.state.first) ? "keys" == t3 ? { value: n3.key, done: false } : "values" == t3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (e2.target = void 0, { value: void 0, done: true });
        }, n2 ? "entries" : "values", !n2, true), If(t2);
      } };
      zp("Set", function(e) {
        return function() {
          return e(this, arguments.length ? arguments[0] : void 0);
        };
      }, Cp);
      var hx = /^[\t\n\x0B\f\r \u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029\ufeff][\t\n\x0B\f\r \u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029\ufeff]*/, ix = /[\t\n\x0B\f\r \u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029\ufeff][\t\n\x0B\f\r \u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029\ufeff]*$/, hk = function(e) {
        return function(t2) {
          return t2 = String(jb(t2)), 1 & e && (t2 = t2.replace(hx, "")), 2 & e && (t2 = t2.replace(ix, "")), t2;
        };
      };
      hk(1), hk(2);
      var ik = hk(3), sh = y.parseInt, jx = /^[+-]?0[Xx]/, Dp = 8 !== sh("	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF08") || 22 !== sh("	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF0x16") ? function(e, t2) {
        return e = ik(String(e)), sh(e, t2 >>> 0 || (jx.test(e) ? 16 : 10));
      } : sh;
      N({ global: true, forced: parseInt != Dp }, { parseInt: Dp });
      var kx = Hd.f, lx = Fb.f, mx = Ra.f, pd = y.Number, th = pd.prototype, nx = "Number" == Zb(ac(th)), Ep = function(e) {
        var t2, n2 = lc(e, false);
        if ("string" == typeof n2 && 2 < n2.length) {
          if (43 === (e = (n2 = ik(n2)).charCodeAt(0)) || 45 === e) {
            if (88 === (e = n2.charCodeAt(2)) || 120 === e) return NaN;
          } else if (48 === e) {
            switch (n2.charCodeAt(1)) {
              case 66:
              case 98:
                e = 2;
                var r = 49;
                break;
              case 79:
              case 111:
                e = 8, r = 55;
                break;
              default:
                return +n2;
            }
            var i = (n2 = n2.slice(2)).length;
            for (t2 = 0; t2 < i; t2++) {
              var o = n2.charCodeAt(t2);
              if (48 > o || o > r) return NaN;
            }
            return parseInt(n2, e);
          }
        }
        return +n2;
      };
      if (nc("Number", !pd(" 0o1") || !pd("0b1") || pd("+0x1"))) {
        for (var Pd = function(e) {
          var t2 = 1 > arguments.length ? 0 : e, n2 = this;
          return n2 instanceof Pd && (nx ? R(function() {
            th.valueOf.call(n2);
          }) : "Number" != Zb(n2)) ? lh(new pd(Ep(t2)), n2, Pd) : Ep(t2);
        }, Fp = ka ? kx(pd) : "MAX_VALUE MIN_VALUE NaN NEGATIVE_INFINITY POSITIVE_INFINITY EPSILON isFinite isInteger isNaN isSafeInteger MAX_SAFE_INTEGER MIN_SAFE_INTEGER parseFloat parseInt isInteger fromString range".split(" "), jk = 0, uh; Fp.length > jk; jk++) Q(pd, uh = Fp[jk]) && !Q(Pd, uh) && mx(Pd, uh, lx(pd, uh));
        Pd.prototype = th, th.constructor = Pd, Ta(y, "Number", Pd);
      }
      var Gp = qa("isConcatSpreadable"), ox = 51 <= id || !R(function() {
        var e = [];
        return e[Gp] = false, e.concat()[0] !== e;
      }), px = Ef("concat");
      N({ target: "Array", proto: true, forced: !ox || !px }, { concat: function(e) {
        var t2, n2 = Qa(this), r = Sg(n2, 0), i = 0, o = -1;
        for (t2 = arguments.length; o < t2; o++) {
          var a2 = -1 === o ? n2 : arguments[o], s = a2;
          if (ha(s)) {
            var u2 = s[Gp];
            s = void 0 !== u2 ? !!u2 : gd(s);
          } else s = false;
          if (s) {
            if (9007199254740991 < i + (u2 = ta(a2.length))) throw TypeError("Maximum allowed index exceeded");
            for (s = 0; s < u2; s++, i++) s in a2 && Ge(r, i, a2[s]);
          } else {
            if (9007199254740991 <= i) throw TypeError("Maximum allowed index exceeded");
            Ge(r, i++, a2);
          }
        }
        return r.length = i, r;
      } });
      var kk = mc("Reflect", "apply"), qx = Function.apply, rx = !R(function() {
        kk(function() {
        });
      });
      N({ target: "Reflect", stat: true, forced: rx }, { apply: function(e, t2, n2) {
        return yb(e), va(n2), kk ? kk(e, t2, n2) : qx.call(e, t2, n2);
      } }), N({ target: "Reflect", stat: true }, { ownKeys: qn });
      var sx = Oj, tx = R(function() {
        return !Object.getOwnPropertyNames(1);
      });
      N({ target: "Object", stat: true, forced: tx }, { getOwnPropertyNames: sx });
      var Pe = "object" === ("undefined" == typeof Reflect ? "undefined" : X(Reflect)) ? Reflect : null, Hp = Pe && "function" == typeof Pe.apply ? Pe.apply : function(e, t2, n2) {
        return Function.prototype.apply.call(e, t2, n2);
      }, ux = Pe && "function" == typeof Pe.ownKeys ? Pe.ownKeys : Object.getOwnPropertySymbols ? function(e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
      } : function(e) {
        return Object.getOwnPropertyNames(e);
      }, Ip = Number.isNaN || function(e) {
        return e != e;
      };
      ea.EventEmitter = ea, ea.prototype._events = void 0, ea.prototype._eventsCount = 0, ea.prototype._maxListeners = void 0;
      var Jp = 10;
      Object.defineProperty(ea, "defaultMaxListeners", { enumerable: true, get: function() {
        return Jp;
      }, set: function(e) {
        if ("number" != typeof e || 0 > e || Ip(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
        Jp = e;
      } }), ea.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, ea.prototype.setMaxListeners = function(e) {
        if ("number" != typeof e || 0 > e || Ip(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this;
      }, ea.prototype.getMaxListeners = function() {
        return void 0 === this._maxListeners ? ea.defaultMaxListeners : this._maxListeners;
      }, ea.prototype.emit = function(e) {
        for (var t2 = [], n2 = 1; n2 < arguments.length; n2++) t2.push(arguments[n2]);
        n2 = "error" === e;
        var r = this._events;
        if (void 0 !== r) n2 = n2 && void 0 === r.error;
        else if (!n2) return false;
        if (n2) {
          var i;
          if (0 < t2.length && (i = t2[0]), i instanceof Error) throw i;
          throw (t2 = Error("Unhandled error." + (i ? " (" + i.message + ")" : ""))).context = i, t2;
        }
        if (void 0 === (n2 = r[e])) return false;
        if ("function" == typeof n2) Hp(n2, this, t2);
        else for (r = Cl(n2, i = n2.length), n2 = 0; n2 < i; ++n2) Hp(r[n2], this, t2);
        return true;
      }, ea.prototype.addListener = function(e, t2) {
        return zl(this, e, t2, false);
      }, ea.prototype.on = ea.prototype.addListener, ea.prototype.prependListener = function(e, t2) {
        return zl(this, e, t2, true);
      }, ea.prototype.once = function(e, t2) {
        return ng(t2), this.on(e, Al(this, e, t2)), this;
      }, ea.prototype.prependOnceListener = function(e, t2) {
        return ng(t2), this.prependListener(e, Al(this, e, t2)), this;
      }, ea.prototype.removeListener = function(e, t2) {
        var n2;
        ng(t2);
        var r = this._events;
        if (void 0 === r) return this;
        var i = r[e];
        if (void 0 === i) return this;
        if (i === t2 || i.listener === t2) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, i.listener || t2));
        else if ("function" != typeof i) {
          var o = -1;
          for (n2 = i.length - 1; 0 <= n2; n2--) if (i[n2] === t2 || i[n2].listener === t2) {
            var a2 = i[n2].listener;
            o = n2;
            break;
          }
          if (0 > o) return this;
          if (0 === o) i.shift();
          else {
            for (; o + 1 < i.length; o++) i[o] = i[o + 1];
            i.pop();
          }
          1 === i.length && (r[e] = i[0]), void 0 !== r.removeListener && this.emit("removeListener", e, a2 || t2);
        }
        return this;
      }, ea.prototype.off = ea.prototype.removeListener, ea.prototype.removeAllListeners = function(e) {
        var t2 = this._events;
        if (void 0 === t2) return this;
        if (void 0 === t2.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== t2[e] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete t2[e]), this;
        if (0 === arguments.length) {
          var n2 = Object.keys(t2);
          for (t2 = 0; t2 < n2.length; ++t2) {
            var r = n2[t2];
            "removeListener" !== r && this.removeAllListeners(r);
          }
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (n2 = t2[e])) this.removeListener(e, n2);
        else if (void 0 !== n2) for (t2 = n2.length - 1; 0 <= t2; t2--) this.removeListener(e, n2[t2]);
        return this;
      }, ea.prototype.listeners = function(e) {
        return Bl(this, e, true);
      }, ea.prototype.rawListeners = function(e) {
        return Bl(this, e, false);
      }, ea.listenerCount = function(e, t2) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t2) : Dl.call(e, t2);
      }, ea.prototype.listenerCount = Dl, ea.prototype.eventNames = function() {
        return 0 < this._eventsCount ? ux(this._events) : [];
      }, ea.once = function(e, t2) {
        return new Promise(function(n2, r) {
          function i(n3) {
            e.removeListener(t2, o), r(n3);
          }
          function o() {
            "function" == typeof e.removeListener && e.removeListener("error", i), n2([].slice.call(arguments));
          }
          El(e, t2, o, { once: true }), "error" !== t2 && vs(e, i, { once: true });
        });
      };
      var Qe = Object.assign, Kp = Object.defineProperty, Lp = !Qe || R(function() {
        if (ka && 1 !== Qe({ b: 1 }, Qe(Kp({}, "a", { enumerable: true, get: function() {
          Kp(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b) return true;
        var e = {}, t2 = {}, n2 = Symbol();
        return e[n2] = 7, "abcdefghijklmnopqrst".split("").forEach(function(e2) {
          t2[e2] = e2;
        }), 7 != Qe({}, e)[n2] || "abcdefghijklmnopqrst" != Dc(Qe({}, t2)).join("");
      }) ? function(e, t2) {
        for (var n2 = Qa(e), r = arguments.length, i = 1, o = Bf.f, a2 = zf; r > i; ) for (var s, u2 = Af(arguments[i++]), c2 = o ? Dc(u2).concat(o(u2)) : Dc(u2), l = c2.length, f = 0; l > f; ) s = c2[f++], (!ka || a2.call(u2, s)) && (n2[s] = u2[s]);
        return n2;
      } : Qe;
      N({ target: "Object", stat: true, forced: Object.assign !== Lp }, { assign: Lp }), zp("Map", function(e) {
        return function() {
          return e(this, arguments.length ? arguments[0] : void 0);
        };
      }, Cp);
      var vx = Math.log, wx = Math.LN2;
      N({ target: "Math", stat: true }, { log2: function(e) {
        return vx(e) / wx;
      } });
      var xx = Ra.f, yx = Hd.f, zx = Za.enforce, Ax = qa("match"), sc = y.RegExp, lk = sc.prototype, Wf = /a/g, mk = /a/g, nk = new sc(Wf) !== Wf;
      if (ka && nc("RegExp", !nk || pc || R(function() {
        return mk[Ax] = false, sc(Wf) != Wf || sc(mk) == mk || "/a/i" != sc(Wf, "i");
      }))) {
        for (var Oc = function(e, t2) {
          var n2, r = this instanceof Oc, i = Lj(e), o = void 0 === t2;
          return !r && i && e.constructor === Oc && o || (nk ? i && !o && (e = e.source) : e instanceof Oc && (o && (t2 = tj.call(e)), e = e.source), pc && (n2 = !!t2 && -1 < t2.indexOf("y")) && (t2 = t2.replace(/y/g, "")), e = lh(nk ? new sc(e, t2) : sc(e, t2), r ? this : lk, Oc), pc && n2 && (zx(e).sticky = true)), e;
        }, Bx = function(e) {
          e in Oc || xx(Oc, e, { configurable: true, get: function() {
            return sc[e];
          }, set: function(t2) {
            sc[e] = t2;
          } });
        }, Mp = yx(sc), Np = 0; Mp.length > Np; ) Bx(Mp[Np++]);
        lk.constructor = Oc, Oc.prototype = lk, Ta(y, "RegExp", Oc);
      }
      If("RegExp"), Sf("Float32", function(e) {
        return function(t2, n2, r) {
          return e(this, t2, n2, r);
        };
      }), Sf("Float64", function(e) {
        return function(t2, n2, r) {
          return e(this, t2, n2, r);
        };
      }), Sf("Uint32", function(e) {
        return function(t2, n2, r) {
          return e(this, t2, n2, r);
        };
      }), Sf("Uint16", function(e) {
        return function(t2, n2, r) {
          return e(this, t2, n2, r);
        };
      });
      var ok = function(e, t2) {
        return e === t2 ? 0 : null == e ? null == t2 ? 0 : -1 : null == t2 ? null == e ? 0 : 1 : "function" == typeof e.compare ? e.compare(t2) : "function" == typeof t2.compare ? -t2.compare(e) : e < t2 ? -1 : e > t2 ? 1 : 0;
      }, pk = [], Op = pk.sort, Cx = R(function() {
        pk.sort(void 0);
      }), Dx = R(function() {
        pk.sort(null);
      }), Ex = Ee("sort");
      N({ target: "Array", proto: true, forced: Cx || !Dx || !Ex }, { sort: function(e) {
        return void 0 === e ? Op.call(Qa(this)) : Op.call(Qa(this), yb(e));
      } });
      var Pp = Object.getPrototypeOf({}), Xf = function(e, t2) {
        var n2;
        return e === t2 || (null == e ? e == t2 : "function" === X(e.equiv) ? e.equiv(t2) : null == t2 ? e == t2 : "function" === X(t2.equiv) ? t2.equiv(e) : "string" !== X(e) && "string" !== X(t2) && (null != (n2 = Object.getPrototypeOf(e)) && n2 !== Pp || null != (n2 = Object.getPrototypeOf(t2)) && n2 !== Pp ? "function" !== X(e) && void 0 !== e.length && "function" !== X(t2) && void 0 !== t2.length ? Gx(e, t2) : e instanceof Set && t2 instanceof Set ? Hx(e, t2) : e instanceof Map && t2 instanceof Map ? Ix(e, t2) : e instanceof Date && t2 instanceof Date ? e.getTime() === t2.getTime() : e instanceof RegExp && t2 instanceof RegExp ? e.toString() === t2.toString() : e != e && t2 != t2 : Fx(e, t2)));
      }, Gx = function(e, t2) {
        var n2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : Xf, r = e.length;
        if (r === t2.length) for (; 0 <= --r && n2(e[r], t2[r]); ) ;
        return 0 > r;
      }, Hx = function(e, t2) {
        var n2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : Xf;
        return e.size === t2.size && n2(G(e.keys()).sort(), G(t2.keys()).sort());
      }, Ix = function(e, t2) {
        var n2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : Xf;
        return e.size === t2.size && n2(G(e).sort(), G(t2).sort());
      }, Fx = function(e, t2) {
        var n2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : Xf;
        if (Object.keys(e).length !== Object.keys(t2).length) return false;
        for (var r in e) if (!t2.hasOwnProperty(r) || !n2(e[r], t2[r])) return false;
        return true;
      }, Qp = function(e) {
        var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : function(e2) {
          return void 0 !== e2 ? ": " + e2 : "";
        };
        return function(n2) {
          function r(n3) {
            return W(this, r), i.call(this, e(n3) + t2(n3));
          }
          la(r, n2);
          var i = ma(r);
          return r;
        }(ef(Error));
      }, Jx = Qp(function() {
        return "illegal argument(s)";
      }), vh = function(e) {
        throw new Jx(e);
      }, qk = Qp(function() {
        return "index out of bounds";
      }), Rp = 1 / 4294967295, Kx = function() {
        function e() {
          W(this, e);
        }
        return Ha(e, [{ key: "float", value: function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
          return this.int() * Rp * e2;
        } }, { key: "norm", value: function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
          return 2 * (this.int() * Rp - 0.5) * e2;
        } }, { key: "minmax", value: function(e2, t2) {
          return this.float() * (t2 - e2) + e2;
        } }]), e;
      }(), rk = Math.random, Lx = new (function(e) {
        function t2() {
          return W(this, t2), n2.apply(this, arguments);
        }
        la(t2, e);
        var n2 = ma(t2);
        return Ha(t2, [{ key: "int", value: function() {
          return 4294967296 * rk() >>> 0;
        } }, { key: "float", value: function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
          return rk() * e2;
        } }, { key: "norm", value: function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 1;
          return 2 * (rk() - 0.5) * e2;
        } }]), t2;
      }(Kx))(), Vh = Symbol(), Hl = function() {
      }, Mx = fk.onFreeze, sk = Object.freeze, Nx = R(function() {
        sk(1);
      });
      N({ target: "Object", stat: true, forced: Nx, sham: !yp }, { freeze: function(e) {
        return sk && ha(e) ? sk(Mx(e)) : e;
      } });
      var Ox = Ee("reduce"), Px = !Hc && 79 < id && 83 > id;
      N({ target: "Array", proto: true, forced: !Ox || Px }, { reduce: function(e) {
        return Wo(this, e, arguments.length, 1 < arguments.length ? arguments[1] : void 0);
      } });
      var Gl = function(e) {
        return null != e && "function" == typeof e.xform ? e.xform() : e;
      }, og = function() {
        function e(t2) {
          W(this, e), this.value = t2;
        }
        return Ha(e, [{ key: "deref", value: function() {
          return this.value;
        } }]), e;
      }(), Wh = function(e) {
        return e instanceof og ? e.deref() : e;
      }, xs = function(e, t2) {
        return [e, function(e2) {
          return e2;
        }, t2];
      }, Qx = w.mark(function(e, t2) {
        var n2, r, i, o, a2, s;
        return w.wrap(function(u2) {
          for (; ; ) switch (u2.prev = u2.next) {
            case 0:
              n2 = Gl(e)(ws()), r = n2[1], i = n2[2], o = 0;
            case 4:
              if (!(o < t2.length)) {
                u2.next = 15;
                break;
              }
              if (a2 = t2[o], !((s = i([], a2)) instanceof og)) {
                u2.next = 10;
                break;
              }
              return u2.delegateYield(Wh(r(s.deref())), "t0", 9);
            case 9:
              return u2.abrupt("return");
            case 10:
              if (!s.length) {
                u2.next = 12;
                break;
              }
              return u2.delegateYield(s, "t1", 12);
            case 12:
              o++, u2.next = 4;
              break;
            case 15:
              return u2.delegateYield(Wh(r([])), "t2", 16);
            case 16:
            case "end":
              return u2.stop();
          }
        }, Qx);
      }), ys = w.mark(Fl), zs = function(e, t2) {
        return [e[0], e[1], t2];
      }, Sp = true;
      "findIndex" in [] && Array(1).findIndex(function() {
        Sp = false;
      }), N({ target: "Array", proto: true, forced: Sp }, { findIndex: function(e) {
        return An(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } }), Ld("findIndex"), N({ target: "Array", proto: true }, { fill: yj }), Ld("fill");
      var Rx = function() {
        function e(t2) {
          W(this, e), this._length = 0, t2 && this.into(t2);
        }
        return Ha(e, [{ key: "length", get: function() {
          return this._length;
        } }, { key: "copy", value: function() {
          return new e(this);
        } }, { key: "empty", value: function() {
          return new e();
        } }, { key: "clear", value: function() {
          this.release();
        } }, { key: "release", value: function() {
          for (var e2, t2 = this.head; t2; ) e2 = t2.next, delete t2.value, delete t2.prev, delete t2.next, t2 = e2;
          return delete this.head, delete this.tail, this._length = 0, true;
        } }, { key: "compare", value: function(e2) {
          var t2 = this._length;
          if (t2 < e2._length) return -1;
          if (t2 > e2._length) return 1;
          if (0 === t2) return 0;
          t2 = this.head, e2 = e2.head;
          for (var n2 = 0; t2 && 0 == n2; ) n2 = ok(t2.value, e2.value), t2 = t2.next, e2 = e2.next;
          return n2;
        } }, { key: "equiv", value: function(t2) {
          if (!(t2 instanceof e || null != t2 && "function" != typeof t2 && void 0 !== t2.length) || this._length !== t2.length) return false;
          if (!this._length || this === t2) return true;
          for (var n2 = this.head, r = 0; r < t2.length; r++) {
            if (!Xf(n2.value, t2[r])) return false;
            n2 = n2.next;
          }
          return true;
        } }, { key: Symbol.iterator, value: w.mark(function e2() {
          var t2;
          return w.wrap(function(e3) {
            for (; ; ) switch (e3.prev = e3.next) {
              case 0:
                t2 = this.head;
              case 1:
                if (!t2) {
                  e3.next = 7;
                  break;
                }
                return e3.next = 4, t2.value;
              case 4:
                t2 = t2.next, e3.next = 1;
                break;
              case 7:
              case "end":
                return e3.stop();
            }
          }, e2, this);
        }) }, { key: "seq", value: function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : this.length;
          if (!(e2 >= t2 || 0 > e2)) {
            e2 = this.nthCell(e2);
            var n2 = this.nthCell(t2 - 1);
            return t2 = function e3(t3) {
              return { first: function() {
                return t3.value;
              }, next: function() {
                return t3 !== n2 && t3.next ? e3(t3.next) : void 0;
              } };
            }, e2 ? t2(e2) : void 0;
          }
        } }, { key: "cycle", value: w.mark(function e2() {
          return w.wrap(function(e3) {
            for (; ; ) switch (e3.prev = e3.next) {
              case 0:
                return e3.delegateYield(this, "t0", 2);
              case 2:
                e3.next = 0;
                break;
              case 4:
              case "end":
                return e3.stop();
            }
          }, e2, this);
        }) }, { key: "$reduce", value: function(e2, t2) {
          for (var n2 = this.head; n2 && !(t2 instanceof og); ) t2 = e2(t2, n2.value), n2 = n2.next;
          return t2;
        } }, { key: "drop", value: function() {
          var e2 = this.head;
          if (e2) return (this.head = e2.next) ? delete this.head.prev : delete this.tail, this._length--, e2.value;
        } }, { key: "cons", value: function(e2) {
          return e2 = { value: e2, next: this.head }, this.head ? this.head.prev = e2 : this.tail = e2, this.head = e2, this._length++, this;
        } }, { key: "insertBefore", value: function(e2, t2) {
          return e2 || vh("cell is undefined"), t2 = { value: t2, next: e2, prev: e2.prev }, e2.prev ? e2.prev.next = t2 : this.head = t2, e2.prev = t2, this._length++, this;
        } }, { key: "insertAfter", value: function(e2, t2) {
          return e2 || vh("cell is undefined"), t2 = { value: t2, next: e2.next, prev: e2 }, e2.next ? e2.next.prev = t2 : this.tail = t2, e2.next = t2, this._length++, this;
        } }, { key: "insertBeforeNth", value: function(e2, t2) {
          if (0 > e2 && (e2 += this._length), 0 >= e2) return this.cons(t2);
          if (0 > e2 || e2 >= this._length) throw new qk(e2);
          return this.insertBefore(this.nthCellUnsafe(e2), t2);
        } }, { key: "insertAfterNth", value: function(e2, t2) {
          if (0 > e2 && (e2 += this._length), e2 >= this._length - 1) return this.push(t2);
          if (0 > e2 || e2 >= this._length) throw new qk(e2);
          return this.insertAfter(this.nthCellUnsafe(e2), t2);
        } }, { key: "insertSorted", value: function(e2, t2) {
          t2 = t2 || ok;
          for (var n2 = this.head; n2; ) {
            if (0 >= t2(e2, n2.value)) return this.insertBefore(n2, e2);
            n2 = n2.next;
          }
          return this.push(e2);
        } }, { key: "find", value: function(e2) {
          for (var t2 = this.head; t2; ) {
            if (t2.value === e2) return t2;
            t2 = t2.next;
          }
        } }, { key: "findWith", value: function(e2) {
          for (var t2 = this.head; t2; ) {
            if (e2(t2.value)) return t2;
            t2 = t2.next;
          }
        } }, { key: "concat", value: function() {
          for (var e2 = this.copy(), t2 = arguments.length, n2 = Array(t2), r = 0; r < t2; r++) n2[r] = arguments[r];
          for (t2 = 0; t2 < n2.length; t2++) e2.into(n2[t2]);
          return e2;
        } }, { key: "into", value: function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) this.push(e2[t2]);
        } }, { key: "slice", value: function() {
          var t2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, n2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : this.length;
          t2 = 0 > t2 ? t2 + this._length : t2, n2 = 0 > n2 ? n2 + this._length : n2, (0 > t2 || 0 > n2) && vh("invalid indices: ${from} / ${to}");
          for (var r = new e(), i = this.nthCell(t2); i && ++t2 <= n2; ) r.push(i.value), i = i.next;
          return r;
        } }, { key: "splice", value: function(t2) {
          var n2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, r = 2 < arguments.length ? arguments[2] : void 0;
          if ("number" == typeof t2) {
            if (0 > t2 && (t2 += this._length), 0 > t2 || t2 >= this._length) throw new qk(t2);
            var i = this.nthCellUnsafe(t2);
          } else i = t2;
          var o = new e();
          if (0 < n2) for (; i && 0 < n2--; ) this.remove(i), o.push(i.value), i = i.next;
          else i && (i = i.next);
          if (r) if (i) for (n2 = 0; n2 < r.length; n2++) this.insertBefore(i, r[n2]);
          else for (i = 0; i < r.length; i++) this.push(r[i]);
          return o;
        } }, { key: "remove", value: function(e2) {
          return e2.prev ? e2.prev.next = e2.next : this.head = e2.next, e2.next ? e2.next.prev = e2.prev : this.tail = e2.prev, this._length--, this;
        } }, { key: "swap", value: function(e2, t2) {
          if (e2 !== t2) {
            var n2 = e2.value;
            e2.value = t2.value, t2.value = n2;
          }
          return this;
        } }, { key: "push", value: function(e2) {
          return this.tail ? (e2 = { value: e2, prev: this.tail }, this.tail = this.tail.next = e2, this._length++, this) : this.cons(e2);
        } }, { key: "pop", value: function() {
          var e2 = this.tail;
          if (e2) return (this.tail = e2.prev) ? delete this.tail.next : delete this.head, this._length--, e2.value;
        } }, { key: "first", value: function() {
          return this.head && this.head.value;
        } }, { key: "peek", value: function() {
          return this.tail && this.tail.value;
        } }, { key: "setHead", value: function(e2) {
          return this.head ? (this.head.value = e2, this) : this.cons(e2);
        } }, { key: "setTail", value: function(e2) {
          return this.tail ? (this.tail.value = e2, this) : this.push(e2);
        } }, { key: "setNth", value: function(e2, t2) {
          var n2 = this.nthCell(e2);
          return !n2 && vh("index out of bounds: ".concat(e2)), n2.value = t2, this;
        } }, { key: "nth", value: function(e2, t2) {
          return (e2 = this.nthCell(e2)) ? e2.value : t2;
        } }, { key: "nthCell", value: function(e2) {
          if (0 > e2 && (e2 += this._length), !(0 > e2 || e2 >= this._length)) return this.nthCellUnsafe(e2);
        } }, { key: "rotateLeft", value: function() {
          switch (this._length) {
            case 0:
            case 1:
              return this;
            case 2:
              return this.swap(this.head, this.tail);
            default:
              return this.push(this.drop());
          }
        } }, { key: "rotateRight", value: function() {
          switch (this._length) {
            case 0:
            case 1:
              return this;
            case 2:
              return this.swap(this.head, this.tail);
            default:
              var e2 = this.peek();
              return this.pop(), this.cons(e2);
          }
        } }, { key: "map", value: function(t2) {
          for (var n2 = new e(), r = this.head; r; ) n2.push(t2(r.value)), r = r.next;
          return n2;
        } }, { key: "filter", value: function(t2) {
          for (var n2 = new e(), r = this.head; r; ) t2(r.value) && n2.push(r.value), r = r.next;
          return n2;
        } }, { key: "reduce", value: function(e2, t2) {
          for (var n2 = this.head; n2; ) t2 = e2(t2, n2.value), n2 = n2.next;
          return t2;
        } }, { key: "shuffle", value: function(e2) {
          var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : Lx;
          if (2 > this._length) return this;
          for (e2 = null != e2 ? e2 : Math.ceil(1.5 * Math.log2(this._length)); 0 < e2; e2--) for (var n2 = this.head; n2; ) {
            var r = n2.next;
            0.5 > t2.float() ? this.asHead(n2) : this.asTail(n2), n2 = r;
          }
          return this;
        } }, { key: "sort", value: function() {
          var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : ok;
          if (!this._length) return this;
          for (var t2 = 1; ; ) {
            var n2 = this.head;
            this.tail = this.head = void 0;
            for (var r = 0; n2; ) {
              r++;
              for (var i = n2, o = 0, a2 = 0; a2 < t2 && (o++, i = i.next); a2++) ;
              for (a2 = t2; 0 < o || 0 < a2 && i; ) {
                if (0 === o) {
                  var s = i;
                  i = i.next, a2--;
                } else i && 0 !== a2 ? 0 >= e2(n2.value, i.value) ? (s = n2, n2 = n2.next, o--) : (s = i, i = i.next, a2--) : (s = n2, n2 = n2.next, o--);
                this.tail ? this.tail.next = s : this.head = s, s.prev = this.tail, this.tail = s;
              }
              n2 = i;
            }
            if (this.tail.next = void 0, 1 >= r) return this;
            t2 *= 2;
          }
        } }, { key: "reverse", value: function() {
          for (var e2 = this.head, t2 = this.tail, n2 = (this._length >>> 1) + (1 & this._length); e2 && t2 && 0 < n2; ) {
            var r = e2.value;
            e2.value = t2.value, t2.value = r, e2 = e2.next, t2 = t2.prev, n2--;
          }
          return this;
        } }, { key: "asHead", value: function(e2) {
          return e2 === this.head || (this.remove(e2), this.head.prev = e2, e2.next = this.head, e2.prev = void 0, this.head = e2, this._length++), this;
        } }, { key: "asTail", value: function(e2) {
          return e2 === this.tail || (this.remove(e2), this.tail.next = e2, e2.prev = this.tail, e2.next = void 0, this.tail = e2, this._length++), this;
        } }, { key: "toString", value: function() {
          for (var e2 = [], t2 = this.head; t2; ) e2.push(String(t2.value)), t2 = t2.next;
          return e2.join(", ");
        } }, { key: "toJSON", value: function() {
          return G(this);
        } }, { key: "nthCellUnsafe", value: function(e2) {
          if (e2 <= this._length >> 1) var t2 = this.head, n2 = "next";
          else t2 = this.tail, n2 = "prev", e2 = this._length - e2 - 1;
          for (; 0 < e2-- && t2; ) t2 = t2[n2];
          return t2;
        } }]), e;
      }(), tc = function() {
        function e(t2, n2) {
          W(this, e), n2 = Object.assign({ maxlen: 1 / 0, maxsize: 1 / 0, map: function() {
            return /* @__PURE__ */ new Map();
          }, ksize: function() {
            return 0;
          }, vsize: function() {
            return 0;
          } }, n2), this.map = n2.map(), this.items = new Rx(), this._size = 0, this.opts = n2, t2 && this.into(t2);
        }
        return Ha(e, [{ key: "length", get: function() {
          return this.items.length;
        } }, { key: "size", get: function() {
          return this._size;
        } }, { key: Symbol.iterator, value: function() {
          return this.entries();
        } }, { key: "entries", value: function() {
          return pg(function(e2) {
            return [e2.k, e2];
          }, this.items);
        } }, { key: "keys", value: function() {
          return pg(function(e2) {
            return e2.k;
          }, this.items);
        } }, { key: "values", value: function() {
          return pg(function(e2) {
            return e2.v;
          }, this.items);
        } }, { key: "copy", value: function() {
          var e2 = this.empty();
          e2.items = this.items.copy();
          for (var t2 = e2.items.head; t2; ) e2.map.set(t2.value.k, t2), t2 = t2.next;
          return e2;
        } }, { key: "empty", value: function() {
          return new e(null, this.opts);
        } }, { key: "release", value: function() {
          this._size = 0, this.map.clear();
          var e2 = this.opts.release;
          if (e2) {
            for (var t2; t2 = this.items.drop(); ) e2(t2.k, t2.v);
            return true;
          }
          return this.items.release();
        } }, { key: "has", value: function(e2) {
          return this.map.has(e2);
        } }, { key: "get", value: function(e2, t2) {
          return (e2 = this.map.get(e2)) ? this.resetEntry(e2) : t2;
        } }, { key: "set", value: function(e2, t2) {
          var n2 = this.opts.ksize(e2) + this.opts.vsize(t2), r = this.map.get(e2);
          return this._size += Math.max(0, n2 - (r ? r.value.s : 0)), this.ensureSize() && this.doSetEntry(r, e2, t2, n2), t2;
        } }, { key: "into", value: function(e2) {
          for (var t2 = 0; t2 < e2.length; t2++) {
            var n2 = e2[t2];
            this.set(n2[0], n2[1]);
          }
          return this;
        } }, { key: "getSet", value: function(e2, t2) {
          var n2 = this, r = this.map.get(e2);
          return r ? Promise.resolve(this.resetEntry(r)) : t2().then(function(t3) {
            return n2.set(e2, t3);
          });
        } }, { key: "delete", value: function(e2) {
          return !!(e2 = this.map.get(e2)) && (this.removeEntry(e2), true);
        } }, { key: "resetEntry", value: function(e2) {
          return this.items.asTail(e2), e2.value.v;
        } }, { key: "ensureSize", value: function() {
          for (var e2 = this.opts.release, t2 = this.opts.maxsize, n2 = this.opts.maxlen; this._size > t2 || this.length >= n2; ) {
            var r = this.items.drop();
            if (!r) return false;
            this.map.delete(r.k), e2 && e2(r.k, r.v), this._size -= r.s;
          }
          return true;
        } }, { key: "removeEntry", value: function(e2) {
          var t2 = e2.value;
          this.map.delete(t2.k), this.items.remove(e2), this.opts.release && this.opts.release(t2.k, t2.v), this._size -= t2.s;
        } }, { key: "doSetEntry", value: function(e2, t2, n2, r) {
          e2 ? (e2.value.v = n2, e2.value.s = r, this.items.asTail(e2)) : (this.items.push({ k: t2, v: n2, s: r }), this.map.set(t2, this.items.tail));
        } }]), e;
      }(), Sx = function(e) {
        function t2(e2, r) {
          return W(this, t2), r = Object.assign({ ttl: 36e5 }, r), n2.call(this, e2, r);
        }
        la(t2, e);
        var n2 = ma(t2);
        return Ha(t2, [{ key: "empty", value: function() {
          return new t2(null, this.opts);
        } }, { key: "has", value: function(e2) {
          return void 0 !== this.get(e2);
        } }, { key: "get", value: function(e2, t3) {
          if (e2 = this.map.get(e2)) {
            if (e2.value.t >= Date.now()) return this.resetEntry(e2);
            this.removeEntry(e2);
          }
          return t3;
        } }, { key: "set", value: function(e2, t3) {
          var n3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : this.opts.ttl, r = this.opts.ksize(e2) + this.opts.vsize(t3), i = this.map.get(e2);
          return this._size += Math.max(0, r - (i ? i.value.s : 0)), this.ensureSize() && (n3 = Date.now() + n3, i ? (i.value.v = t3, i.value.s = r, i.value.t = n3, this.items.asTail(i)) : (this.items.push({ k: e2, v: t3, s: r, t: n3 }), this.map.set(e2, this.items.tail))), t3;
        } }, { key: "getSet", value: function(e2, t3) {
          var n3 = this, r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : this.opts.ttl, i = this.get(e2);
          return i ? Promise.resolve(i) : t3().then(function(t4) {
            return n3.set(e2, t4, r);
          });
        } }, { key: "prune", value: function() {
          for (var e2 = Date.now(), t3 = this.items.head; t3; ) t3.value.t < e2 && this.removeEntry(t3), t3 = t3.next;
        } }, { key: "ensureSize", value: function() {
          for (var e2 = this.opts.maxsize, n3 = this.opts.maxlen, r = Date.now(), i = this.items.head; i && (this._size > e2 || this.length >= n3); ) i.value.t < r && this.removeEntry(i), i = i.next;
          return Th(wd(t2.prototype), "ensureSize", this).call(this);
        } }]), t2;
      }(tc), Tp = "object" == X(Ya) && Ya && Ya.Object === Object && Ya, Tx = "object" == ("undefined" == typeof self ? "undefined" : X(self)) && self && self.Object === Object && self, Cb = Tp || Tx || Function("return this")(), Pb = Cb.Symbol, Up = Object.prototype, Ux = Up.hasOwnProperty, Vx = Up.toString, Yf = Pb ? Pb.toStringTag : void 0, Wx = Object.prototype.toString, Vp = Pb ? Pb.toStringTag : void 0, Qd = function(e) {
        if (null == e) e = void 0 === e ? "[object Undefined]" : "[object Null]";
        else if (Vp && Vp in Object(e)) {
          var t2 = Ux.call(e, Yf), n2 = e[Yf];
          try {
            e[Yf] = void 0;
            var r = true;
          } catch (e2) {
          }
          var i = Vx.call(e);
          r && (t2 ? e[Yf] = n2 : delete e[Yf]), e = i;
        } else e = Wx.call(e);
        return e;
      }, lb = function(e) {
        var t2 = X(e);
        return null != e && ("object" == t2 || "function" == t2);
      }, qi = function(e) {
        return !!lb(e) && ("[object Function]" == (e = Qd(e)) || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e);
      }, tk = Cb["__core-js_shared__"], Wp = function() {
        var e = /[^.]+$/.exec(tk && tk.keys && tk.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : "";
      }(), Xx = Function.prototype.toString, Rd = function(e) {
        if (null != e) {
          try {
            return Xx.call(e);
          } catch (e2) {
          }
          return e + "";
        }
        return "";
      }, Yx = /^\[object .+?Constructor\]$/, Zx = RegExp("^" + Function.prototype.toString.call(Object.prototype.hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Sd = function(e, t2) {
        return e = null == e ? void 0 : e[t2], !lb(e) || Wp && Wp in e || !(qi(e) ? Zx : Yx).test(Rd(e)) ? void 0 : e;
      }, Zf = Sd(Object, "create"), $x = Object.prototype.hasOwnProperty, ay = Object.prototype.hasOwnProperty;
      zd.prototype.clear = function() {
        this.__data__ = Zf ? Zf(null) : {}, this.size = 0;
      }, zd.prototype.delete = function(e) {
        return e = this.has(e) && delete this.__data__[e], this.size -= e ? 1 : 0, e;
      }, zd.prototype.get = function(e) {
        var t2 = this.__data__;
        return Zf ? "__lodash_hash_undefined__" === (e = t2[e]) ? void 0 : e : $x.call(t2, e) ? t2[e] : void 0;
      }, zd.prototype.has = function(e) {
        var t2 = this.__data__;
        return Zf ? void 0 !== t2[e] : ay.call(t2, e);
      }, zd.prototype.set = function(e, t2) {
        var n2 = this.__data__;
        return this.size += this.has(e) ? 0 : 1, n2[e] = Zf && void 0 === t2 ? "__lodash_hash_undefined__" : t2, this;
      };
      var $f = function(e, t2) {
        return e === t2 || e != e && t2 != t2;
      }, wh = function(e, t2) {
        for (var n2 = e.length; n2--; ) if ($f(e[n2][0], t2)) return n2;
        return -1;
      }, by = Array.prototype.splice;
      ce.prototype.clear = function() {
        this.__data__ = [], this.size = 0;
      }, ce.prototype.delete = function(e) {
        var t2 = this.__data__;
        return !(0 > (e = wh(t2, e))) && (e == t2.length - 1 ? t2.pop() : by.call(t2, e, 1), --this.size, true);
      }, ce.prototype.get = function(e) {
        var t2 = this.__data__;
        return 0 > (e = wh(t2, e)) ? void 0 : t2[e][1];
      }, ce.prototype.has = function(e) {
        return -1 < wh(this.__data__, e);
      }, ce.prototype.set = function(e, t2) {
        var n2 = this.__data__, r = wh(n2, e);
        return 0 > r ? (++this.size, n2.push([e, t2])) : n2[r][1] = t2, this;
      };
      var rg = ce, ag = Sd(Cb, "Map"), xh = function(e, t2) {
        e = e.__data__;
        var n2 = X(t2);
        return ("string" == n2 || "number" == n2 || "symbol" == n2 || "boolean" == n2 ? "__proto__" !== t2 : null === t2) ? e["string" == typeof t2 ? "string" : "hash"] : e.map;
      };
      de.prototype.clear = function() {
        this.size = 0, this.__data__ = { hash: new zd(), map: new (ag || rg)(), string: new zd() };
      }, de.prototype.delete = function(e) {
        return e = xh(this, e).delete(e), this.size -= e ? 1 : 0, e;
      }, de.prototype.get = function(e) {
        return xh(this, e).get(e);
      }, de.prototype.has = function(e) {
        return xh(this, e).has(e);
      }, de.prototype.set = function(e, t2) {
        var n2 = xh(this, e), r = n2.size;
        return n2.set(e, t2), this.size += n2.size == r ? 0 : 1, this;
      };
      var qg = de;
      gf.prototype.add = gf.prototype.push = function(e) {
        return this.__data__.set(e, "__lodash_hash_undefined__"), this;
      }, gf.prototype.has = function(e) {
        return this.__data__.has(e);
      };
      var Xp = function(e, t2, n2, r) {
        var i = e.length;
        for (n2 += r ? 1 : -1; r ? n2-- : ++n2 < i; ) if (t2(e[n2], n2, e)) return n2;
        return -1;
      }, cy = function(e) {
        return e != e;
      }, dy = function(e, t2) {
        var n2;
        if (n2 = !(null == e || !e.length)) {
          if (t2 == t2) e: {
            n2 = -1;
            for (var r = e.length; ++n2 < r; ) if (e[n2] === t2) {
              e = n2;
              break e;
            }
            e = -1;
          }
          else e = Xp(e, cy, 0);
          n2 = -1 < e;
        }
        return n2;
      }, ey = function(e, t2, n2) {
        for (var r = -1, i = null == e ? 0 : e.length; ++r < i; ) if (n2(t2, e[r])) return true;
        return false;
      }, fy = function(e, t2) {
        return e.has(t2);
      }, Re = Sd(Cb, "Set"), gy = function() {
      }, uk = function(e) {
        var t2 = -1, n2 = Array(e.size);
        return e.forEach(function(e2) {
          n2[++t2] = e2;
        }), n2;
      }, hy = 1 / 0, iy = Re && 1 / uk(new Re([, -0]))[1] == hy ? function(e) {
        return new Re(e);
      } : gy, vk = function(e, t2, n2) {
        var r = -1, i = dy, o = e.length, a2 = true, s = [], u2 = s;
        if (n2) a2 = false, i = ey;
        else if (200 <= o) {
          if (i = t2 ? null : iy(e)) return uk(i);
          a2 = false, i = fy, u2 = new gf();
        } else u2 = t2 ? [] : s;
        e: for (; ++r < o; ) {
          var c2 = e[r], l = t2 ? t2(c2) : c2;
          if (c2 = n2 || 0 !== c2 ? c2 : 0, a2 && l == l) {
            for (var f = u2.length; f--; ) if (u2[f] === l) continue e;
            t2 && u2.push(l), s.push(c2);
          } else i(u2, l, n2) || (u2 !== s && u2.push(l), s.push(c2));
        }
        return s;
      }, Yp = function(e) {
        for (var t2 = -1, n2 = null == e ? 0 : e.length, r = {}; ++t2 < n2; ) {
          var i = e[t2];
          r[i[0]] = i[1];
        }
        return r;
      }, he = function(e, t2) {
        for (var n2 = -1, r = null == e ? 0 : e.length, i = Array(r); ++n2 < r; ) i[n2] = t2(e[n2], n2, e);
        return i;
      };
      ee.prototype.clear = function() {
        this.__data__ = new rg(), this.size = 0;
      }, ee.prototype.delete = function(e) {
        var t2 = this.__data__;
        return e = t2.delete(e), this.size = t2.size, e;
      }, ee.prototype.get = function(e) {
        return this.__data__.get(e);
      }, ee.prototype.has = function(e) {
        return this.__data__.has(e);
      }, ee.prototype.set = function(e, t2) {
        var n2 = this.__data__;
        if (n2 instanceof rg) {
          var r = n2.__data__;
          if (!ag || 199 > r.length) return r.push([e, t2]), this.size = ++n2.size, this;
          n2 = this.__data__ = new qg(r);
        }
        return n2.set(e, t2), this.size = n2.size, this;
      };
      var ge = ee, Is = function(e, t2) {
        for (var n2 = -1, r = null == e ? 0 : e.length; ++n2 < r && false !== t2(e[n2], n2, e); ) ;
        return e;
      }, yh = function() {
        try {
          var e = Sd(Object, "defineProperty");
          return e({}, "", {}), e;
        } catch (e2) {
        }
      }(), bg = function(e, t2, n2) {
        "__proto__" == t2 && yh ? yh(e, t2, { configurable: true, enumerable: true, value: n2, writable: true }) : e[t2] = n2;
      }, jy = Object.prototype.hasOwnProperty, Ml = function(e, t2, n2) {
        var r = e[t2];
        jy.call(e, t2) && $f(r, n2) && (void 0 !== n2 || t2 in e) || bg(e, t2, n2);
      }, re = function(e, t2, n2, r) {
        var i = !n2;
        n2 || (n2 = {});
        for (var o = -1, a2 = t2.length; ++o < a2; ) {
          var s = t2[o], u2 = r ? r(n2[s], e[s], s, n2, e) : void 0;
          void 0 === u2 && (u2 = e[s]), i ? bg(n2, s, u2) : Ml(n2, s, u2);
        }
        return n2;
      }, gc = function(e) {
        return null != e && "object" == X(e);
      }, Zp = function(e) {
        return gc(e) && "[object Arguments]" == Qd(e);
      }, $p = Object.prototype, ky = $p.hasOwnProperty, ly = $p.propertyIsEnumerable, rf = Zp(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Zp : function(e) {
        return gc(e) && ky.call(e, "callee") && !ly.call(e, "callee");
      }, Va = Array.isArray, my = function() {
        return false;
      }, jf = $a(function(e, t2) {
        var n2 = (t2 = t2 && !t2.nodeType && t2) && e && !e.nodeType && e;
        t2 = n2 && n2.exports === t2 ? Cb.Buffer : void 0, e.exports = (t2 ? t2.isBuffer : void 0) || my;
      }), ny = /^(?:0|[1-9]\d*)$/, wk = function(e, t2) {
        var n2 = X(e);
        return !!(t2 = null == t2 ? 9007199254740991 : t2) && ("number" == n2 || "symbol" != n2 && ny.test(e)) && -1 < e && 0 == e % 1 && e < t2;
      }, xk = function(e) {
        return "number" == typeof e && -1 < e && 0 == e % 1 && 9007199254740991 >= e;
      }, Ea = {};
      Ea["[object Float32Array]"] = Ea["[object Float64Array]"] = Ea["[object Int8Array]"] = Ea["[object Int16Array]"] = Ea["[object Int32Array]"] = Ea["[object Uint8Array]"] = Ea["[object Uint8ClampedArray]"] = Ea["[object Uint16Array]"] = Ea["[object Uint32Array]"] = true, Ea["[object Arguments]"] = Ea["[object Array]"] = Ea["[object ArrayBuffer]"] = Ea["[object Boolean]"] = Ea["[object DataView]"] = Ea["[object Date]"] = Ea["[object Error]"] = Ea["[object Function]"] = Ea["[object Map]"] = Ea["[object Number]"] = Ea["[object Object]"] = Ea["[object RegExp]"] = Ea["[object Set]"] = Ea["[object String]"] = Ea["[object WeakMap]"] = false;
      var oy = function(e) {
        return gc(e) && xk(e.length) && !!Ea[Qd(e)];
      }, zh = function(e) {
        return function(t2) {
          return e(t2);
        };
      }, Se = $a(function(e, t2) {
        var n2 = t2 && !t2.nodeType && t2;
        n2 = (t2 = n2 && e && !e.nodeType && e) && t2.exports === n2 && Tp.process;
        e: {
          try {
            var r = t2 && t2.require && t2.require("util").types;
            if (r) {
              var i = r;
              break e;
            }
            i = n2 && n2.binding && n2.binding("util");
            break e;
          } catch (e2) {
          }
          i = void 0;
        }
        e.exports = i;
      }), aq = Se && Se.isTypedArray, bi = aq ? zh(aq) : oy, py = Object.prototype.hasOwnProperty, bq = function(e, t2) {
        var n2 = Va(e), r = !n2 && rf(e), i = !n2 && !r && jf(e), o = !n2 && !r && !i && bi(e);
        if (n2 = n2 || r || i || o) {
          r = e.length;
          for (var a2 = String, s = -1, u2 = Array(r); ++s < r; ) u2[s] = a2(s);
          r = u2;
        } else r = [];
        for (var c2 in a2 = r.length, e) !t2 && !py.call(e, c2) || n2 && ("length" == c2 || i && ("offset" == c2 || "parent" == c2) || o && ("buffer" == c2 || "byteLength" == c2 || "byteOffset" == c2) || wk(c2, a2)) || r.push(c2);
        return r;
      }, qy = Object.prototype, yk = function(e) {
        var t2 = e && e.constructor;
        return e === ("function" == typeof t2 && t2.prototype || qy);
      }, cq = function(e, t2) {
        return function(n2) {
          return e(t2(n2));
        };
      }, ry = cq(Object.keys, Object), sy = Object.prototype.hasOwnProperty, Ed = function(e) {
        return null != e && xk(e.length) && !qi(e);
      }, Ad = function(e) {
        if (Ed(e)) e = bq(e);
        else if (yk(e)) {
          var t2, n2 = [];
          for (t2 in Object(e)) sy.call(e, t2) && "constructor" != t2 && n2.push(t2);
          e = n2;
        } else e = ry(e);
        return e;
      }, Es = function(e, t2) {
        return e && re(t2, Ad(t2), e);
      }, ty = Object.prototype.hasOwnProperty, kf = function(e) {
        if (Ed(e)) e = bq(e, true);
        else if (lb(e)) {
          var t2 = yk(e), n2 = [];
          for (r in e) ("constructor" != r || !t2 && ty.call(e, r)) && n2.push(r);
          e = n2;
        } else {
          var r = [];
          if (null != e) for (t2 in Object(e)) r.push(t2);
          e = r;
        }
        return e;
      }, Cs = function(e, t2) {
        return e && re(t2, kf(t2), e);
      }, Jl = $a(function(e, t2) {
        var n2 = (t2 = t2 && !t2.nodeType && t2) && e && !e.nodeType && e, r = (t2 = n2 && n2.exports === t2 ? Cb.Buffer : void 0) ? t2.allocUnsafe : void 0;
        e.exports = function(e2, t3) {
          return t3 ? e2.slice() : (t3 = e2.length, t3 = r ? r(t3) : new e2.constructor(t3), e2.copy(t3), t3);
        };
      }), Xh = function(e, t2) {
        var n2 = -1, r = e.length;
        for (t2 || (t2 = Array(r)); ++n2 < r; ) t2[n2] = e[n2];
        return t2;
      }, uy = function(e, t2) {
        for (var n2 = -1, r = null == e ? 0 : e.length, i = 0, o = []; ++n2 < r; ) {
          var a2 = e[n2];
          t2(a2, n2, e) && (o[i++] = a2);
        }
        return o;
      }, dq = function() {
        return [];
      }, vy = Object.prototype.propertyIsEnumerable, eq = Object.getOwnPropertySymbols, zk = eq ? function(e) {
        return null == e ? [] : (e = Object(e), uy(eq(e), function(t2) {
          return vy.call(e, t2);
        }));
      } : dq, Ds = function(e, t2) {
        return re(e, zk(e), t2);
      }, ai = function(e, t2) {
        for (var n2 = -1, r = t2.length, i = e.length; ++n2 < r; ) e[i + n2] = t2[n2];
        return e;
      }, Ak = cq(Object.getPrototypeOf, Object), fq = Object.getOwnPropertySymbols ? function(e) {
        for (var t2 = []; e; ) ai(t2, zk(e)), e = Ak(e);
        return t2;
      } : dq, Bs = function(e, t2) {
        return re(e, fq(e), t2);
      }, gq = function(e, t2, n2) {
        return t2 = t2(e), Va(e) ? t2 : ai(t2, n2(e));
      }, Yh = function(e) {
        return gq(e, Ad, zk);
      }, Ll = function(e) {
        return gq(e, kf, fq);
      }, Bk = Sd(Cb, "DataView"), Ck = Sd(Cb, "Promise"), Dk = Sd(Cb, "WeakMap"), wy = Rd(Bk), xy = Rd(ag), yy = Rd(Ck), zy = Rd(Re), Ay = Rd(Dk), Td = Qd;
      (Bk && "[object DataView]" != Td(new Bk(new ArrayBuffer(1))) || ag && "[object Map]" != Td(new ag()) || Ck && "[object Promise]" != Td(Ck.resolve()) || Re && "[object Set]" != Td(new Re()) || Dk && "[object WeakMap]" != Td(new Dk())) && (Td = function(e) {
        var t2 = Qd(e);
        if (e = (e = "[object Object]" == t2 ? e.constructor : void 0) ? Rd(e) : "") switch (e) {
          case wy:
            return "[object DataView]";
          case xy:
            return "[object Map]";
          case yy:
            return "[object Promise]";
          case zy:
            return "[object Set]";
          case Ay:
            return "[object WeakMap]";
        }
        return t2;
      });
      var hf = Td, By = Object.prototype.hasOwnProperty, As = function(e) {
        var t2 = e.length, n2 = new e.constructor(t2);
        return t2 && "string" == typeof e[0] && By.call(e, "index") && (n2.index = e.index, n2.input = e.input), n2;
      }, Ah = Cb.Uint8Array, Ek = function(e) {
        var t2 = new e.constructor(e.byteLength);
        return new Ah(t2).set(new Ah(e)), t2;
      }, Cy = /\w*$/, hq = Pb ? Pb.prototype : void 0, iq = hq ? hq.valueOf : void 0, vm = function(e, t2) {
        return t2 = t2 ? Ek(e.buffer) : e.buffer, new e.constructor(t2, e.byteOffset, e.length);
      }, Fs = function(e, t2, n2) {
        var r = e.constructor;
        switch (t2) {
          case "[object ArrayBuffer]":
            return Ek(e);
          case "[object Boolean]":
          case "[object Date]":
            return new r(+e);
          case "[object DataView]":
            return t2 = n2 ? Ek(e.buffer) : e.buffer, new e.constructor(t2, e.byteOffset, e.byteLength);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return vm(e, n2);
          case "[object Map]":
            return new r();
          case "[object Number]":
          case "[object String]":
            return new r(e);
          case "[object RegExp]":
            return (t2 = new e.constructor(e.source, Cy.exec(e))).lastIndex = e.lastIndex, t2;
          case "[object Set]":
            return new r();
          case "[object Symbol]":
            return iq ? Object(iq.call(e)) : {};
        }
      }, jq = Object.create, Dy = /* @__PURE__ */ function() {
        function e() {
        }
        return function(t2) {
          return lb(t2) ? jq ? jq(t2) : (e.prototype = t2, t2 = new e(), e.prototype = void 0, t2) : {};
        };
      }(), Kl = function(e) {
        return "function" != typeof e.constructor || yk(e) ? {} : Dy(Ak(e));
      }, Ey = function(e) {
        return gc(e) && "[object Map]" == hf(e);
      }, kq = Se && Se.isMap, Hs = kq ? zh(kq) : Ey, Fy = function(e) {
        return gc(e) && "[object Set]" == hf(e);
      }, lq = Se && Se.isSet, Gs = lq ? zh(lq) : Fy, wa = {};
      wa["[object Arguments]"] = wa["[object Array]"] = wa["[object ArrayBuffer]"] = wa["[object DataView]"] = wa["[object Boolean]"] = wa["[object Date]"] = wa["[object Float32Array]"] = wa["[object Float64Array]"] = wa["[object Int8Array]"] = wa["[object Int16Array]"] = wa["[object Int32Array]"] = wa["[object Map]"] = wa["[object Number]"] = wa["[object Object]"] = wa["[object RegExp]"] = wa["[object Set]"] = wa["[object String]"] = wa["[object Symbol]"] = wa["[object Uint8Array]"] = wa["[object Uint8ClampedArray]"] = wa["[object Uint16Array]"] = wa["[object Uint32Array]"] = true, wa["[object Error]"] = wa["[object Function]"] = wa["[object WeakMap]"] = false;
      var ie = function(e) {
        return "symbol" == X(e) || gc(e) && "[object Symbol]" == Qd(e);
      }, Gy = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Hy = /^\w*$/, Fk = function(e, t2) {
        if (Va(e)) return false;
        var n2 = X(e);
        return !("number" != n2 && "symbol" != n2 && "boolean" != n2 && null != e && !ie(e)) || (Hy.test(e) || !Gy.test(e) || null != t2 && e in Object(t2));
      };
      Zh.Cache = qg;
      var Iy = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Jy = /\\(\\)?/g, Ky = function(e) {
        var t2 = (e = Zh(e, function(e2) {
          return 500 === t2.size && t2.clear(), e2;
        })).cache;
        return e;
      }(function(e) {
        var t2 = [];
        return 46 === e.charCodeAt(0) && t2.push(""), e.replace(Iy, function(e2, n2, r, i) {
          t2.push(r ? i.replace(Jy, "$1") : n2 || e2);
        }), t2;
      }), Js = 1 / 0, mq = Pb ? Pb.prototype : void 0, Ol = mq ? mq.toString : void 0, Bh = function(e, t2) {
        return Va(e) ? e : Fk(e, t2) ? [e] : Ky(null == e ? "" : Nl(e));
      }, Ly = 1 / 0, cg = function(e) {
        if ("string" == typeof e || ie(e)) return e;
        var t2 = e + "";
        return "0" == t2 && 1 / e == -Ly ? "-0" : t2;
      }, Ch = function(e, t2) {
        for (var n2 = 0, r = (t2 = Bh(t2, e)).length; null != e && n2 < r; ) e = e[cg(t2[n2++])];
        return n2 && n2 == r ? e : void 0;
      }, My = function(e, t2) {
        if (!(2 > (t2 = Bh(t2, e)).length)) {
          var n2 = t2, r = 0, i = -1, o = -1, a2 = n2.length;
          for (0 > r && (r = -r > a2 ? 0 : a2 + r), 0 > (i = i > a2 ? a2 : i) && (i += a2), a2 = r > i ? 0 : i - r >>> 0, r >>>= 0, i = Array(a2); ++o < a2; ) i[o] = n2[o + r];
          e = Ch(e, i);
        }
        return (n2 = null == e) || (n2 = null == t2 ? 0 : t2.length, n2 = delete e[cg(n2 ? t2[n2 - 1] : void 0)]), n2;
      }, nq = Function.prototype.toString, Ny = Object.prototype.hasOwnProperty, Oy = nq.call(Object), wm = function(e) {
        return !(!gc(e) || "[object Object]" != Qd(e)) && (null === (e = Ak(e)) || "function" == typeof (e = Ny.call(e, "constructor") && e.constructor) && e instanceof e && nq.call(e) == Oy);
      }, Py = function(e) {
        return wm(e) ? void 0 : e;
      }, oq = Pb ? Pb.isConcatSpreadable : void 0, Ks = function(e) {
        return Va(e) || rf(e) || !!(oq && e && e[oq]);
      }, Qy = function(e) {
        return null != e && e.length ? $h(e, 1) : [];
      }, Ry = function(e, t2, n2) {
        switch (n2.length) {
          case 0:
            return e.call(t2);
          case 1:
            return e.call(t2, n2[0]);
          case 2:
            return e.call(t2, n2[0], n2[1]);
          case 3:
            return e.call(t2, n2[0], n2[1], n2[2]);
        }
        return e.apply(t2, n2);
      }, pq = Math.max, qq = function(e, t2, n2) {
        return t2 = pq(void 0 === t2 ? e.length - 1 : t2, 0), function() {
          for (var r = arguments, i = -1, o = pq(r.length - t2, 0), a2 = Array(o); ++i < o; ) a2[i] = r[t2 + i];
          for (i = -1, o = Array(t2 + 1); ++i < t2; ) o[i] = r[i];
          return o[t2] = n2(a2), Ry(e, this, o);
        };
      }, Sy = function(e) {
        return function() {
          return e;
        };
      }, Dh = function(e) {
        return e;
      }, Ty = Date.now, rq = /* @__PURE__ */ function(e) {
        var t2 = 0, n2 = 0;
        return function() {
          var r = Ty(), i = 16 - (r - n2);
          if (n2 = r, 0 < i) {
            if (800 <= ++t2) return arguments[0];
          } else t2 = 0;
          return e.apply(void 0, arguments);
        };
      }(yh ? function(e, t2) {
        return yh(e, "toString", { configurable: true, enumerable: false, value: Sy(t2), writable: true });
      } : Dh), Gk = function(e) {
        return rq(qq(e, void 0, Qy), e + "");
      }(function(e, t2) {
        var n2 = {};
        if (null == e) return n2;
        var r = false;
        t2 = he(t2, function(t3) {
          return t3 = Bh(t3, e), r || (r = 1 < t3.length), t3;
        }), re(e, Ll(e), n2), r && (n2 = fe(n2, 7, Py));
        for (var i = t2.length; i--; ) My(n2, t2[i]);
        return n2;
      }), Uy = function(e, t2, n2, r) {
        for (var i = -1, o = null == e ? 0 : e.length; ++i < o; ) {
          var a2 = e[i];
          t2(r, a2, n2(a2), e);
        }
        return r;
      }, um = function(e, t2, n2) {
        for (var r = -1, i = Object(e), o = (n2 = n2(e)).length; o--; ) {
          var a2 = n2[++r];
          if (false === t2(i[a2], a2, i)) break;
        }
        return e;
      }, sq = function(e, t2) {
        return e && um(e, t2, Ad);
      }, Hk = /* @__PURE__ */ function(e, t2) {
        return function(t3, n2) {
          if (null == t3) return t3;
          if (!Ed(t3)) return e(t3, n2);
          for (var r = t3.length, i = -1, o = Object(t3); ++i < r && false !== n2(o[i], i, o); ) ;
          return t3;
        };
      }(sq), Vy = function(e, t2, n2, r) {
        return Hk(e, function(e2, i, o) {
          t2(r, e2, n2(e2), o);
        }), r;
      }, tq = function(e, t2) {
        for (var n2 = -1, r = null == e ? 0 : e.length; ++n2 < r; ) if (t2(e[n2], n2, e)) return true;
        return false;
      }, Pl = function(e, t2, n2, r, i, o) {
        var a2 = 1 & n2, s = e.length, u2 = t2.length;
        if (s != u2 && !(a2 && u2 > s)) return false;
        u2 = o.get(e);
        var c2 = o.get(t2);
        if (u2 && c2) return u2 == t2 && c2 == e;
        u2 = -1, c2 = true;
        var l = 2 & n2 ? new gf() : void 0;
        for (o.set(e, t2), o.set(t2, e); ++u2 < s; ) {
          var f = e[u2], h = t2[u2];
          if (r) var p = a2 ? r(h, f, u2, t2, e, o) : r(f, h, u2, e, t2, o);
          if (void 0 !== p) {
            if (p) continue;
            c2 = false;
            break;
          }
          if (l) {
            if (!tq(t2, function(e2, t3) {
              if (!l.has(t3) && (f === e2 || i(f, e2, n2, r, o))) return l.push(t3);
            })) {
              c2 = false;
              break;
            }
          } else if (f !== h && !i(f, h, n2, r, o)) {
            c2 = false;
            break;
          }
        }
        return o.delete(e), o.delete(t2), c2;
      }, Wy = function(e) {
        var t2 = -1, n2 = Array(e.size);
        return e.forEach(function(e2, r) {
          n2[++t2] = [r, e2];
        }), n2;
      }, uq = Pb ? Pb.prototype : void 0, Ik = uq ? uq.valueOf : void 0, Ls = function(e, t2, n2, r, i, o, a2) {
        switch (n2) {
          case "[object DataView]":
            if (e.byteLength != t2.byteLength || e.byteOffset != t2.byteOffset) break;
            e = e.buffer, t2 = t2.buffer;
          case "[object ArrayBuffer]":
            if (e.byteLength != t2.byteLength || !o(new Ah(e), new Ah(t2))) break;
            return true;
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return $f(+e, +t2);
          case "[object Error]":
            return e.name == t2.name && e.message == t2.message;
          case "[object RegExp]":
          case "[object String]":
            return e == t2 + "";
          case "[object Map]":
            var s = Wy;
          case "[object Set]":
            if (s || (s = uk), e.size != t2.size && !(1 & r)) break;
            return (n2 = a2.get(e)) ? n2 == t2 : (r |= 2, a2.set(e, t2), t2 = Pl(s(e), s(t2), r, i, o, a2), a2.delete(e), t2);
          case "[object Symbol]":
            if (Ik) return Ik.call(e) == Ik.call(t2);
        }
        return false;
      }, Ms = Object.prototype.hasOwnProperty, Ql = Object.prototype.hasOwnProperty, Xy = function(e, t2, n2, r) {
        var i = n2.length, o = i, a2 = !r;
        if (null == e) return !o;
        for (e = Object(e); i--; ) {
          var s = n2[i];
          if (a2 && s[2] ? s[1] !== e[s[0]] : !(s[0] in e)) return false;
        }
        for (; ++i < o; ) {
          var u2 = (s = n2[i])[0], c2 = e[u2], l = s[1];
          if (a2 && s[2]) {
            if (void 0 === c2 && !(u2 in e)) return false;
          } else {
            if (s = new ge(), r) var f = r(c2, l, u2, e, t2, s);
            if (void 0 === f ? !je(l, c2, 3, r, s) : !f) return false;
          }
        }
        return true;
      }, Yy = function(e) {
        for (var t2 = Ad(e), n2 = t2.length; n2--; ) {
          var r = t2[n2], i = e[r];
          t2[n2] = [r, i, i == i && !lb(i)];
        }
        return t2;
      }, vq = function(e, t2) {
        return function(n2) {
          return null != n2 && (n2[e] === t2 && (void 0 !== t2 || e in Object(n2)));
        };
      }, Zy = function(e) {
        var t2 = Yy(e);
        return 1 == t2.length && t2[0][2] ? vq(t2[0][0], t2[0][1]) : function(n2) {
          return n2 === e || Xy(n2, e, t2);
        };
      }, $y = function(e, t2) {
        return Fk(e) && t2 == t2 && !lb(t2) ? vq(cg(e), t2) : function(n2) {
          var r = null == n2 ? void 0 : Ch(n2, e);
          if (void 0 === (r = void 0 === r ? void 0 : r) && r === t2) {
            if (r = null != n2) {
              for (var i = -1, o = (r = Bh(r = e, n2)).length, a2 = false; ++i < o; ) {
                var s = cg(r[i]);
                if (!(a2 = null != n2 && null != n2 && s in Object(n2))) break;
                n2 = n2[s];
              }
              a2 || ++i != o ? r = a2 : r = !!(o = null == n2 ? 0 : n2.length) && xk(o) && wk(s, o) && (Va(n2) || rf(n2));
            }
            s = r;
          } else s = je(t2, r, 3);
          return s;
        };
      }, az = function(e) {
        return function(t2) {
          return null == t2 ? void 0 : t2[e];
        };
      }, bz = function(e) {
        return function(t2) {
          return Ch(t2, e);
        };
      }, Te = function(e) {
        return "function" == typeof e ? e : null == e ? Dh : "object" == X(e) ? Va(e) ? $y(e[0], e[1]) : Zy(e) : Fk(e) ? az(cg(e)) : bz(e);
      }, Jk = /* @__PURE__ */ function(e, t2) {
        return function(t3, n2) {
          var r = {};
          return (Va(t3) ? Uy : Vy)(t3, e, Te(n2), r);
        };
      }(function(e, t2, n2) {
        bg(e, n2, t2);
      }), uc = function(e, t2) {
        var n2 = {};
        return t2 = Te(t2), sq(e, function(e2, r, i) {
          bg(n2, r, t2(e2, r, i));
        }), n2;
      };
      N({ target: "String", proto: true, forced: R(function() {
        var e = "".sub('"');
        return e !== e.toLowerCase() || 3 < e.split('"').length;
      }) }, { sub: function() {
        return "<sub>" + String(jb(this)) + "</sub>";
      } });
      var U = xa, Qb = null;
      try {
        Qb = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (c2) {
      }
      xa.prototype.__isLong__, Object.defineProperty(xa.prototype, "__isLong__", { value: true }), xa.isLong = mb;
      var Sl = {}, Rl = {};
      xa.fromInt = Bd, xa.fromNumber = Gb, xa.fromBits = ya;
      var sg = Math.pow;
      xa.fromString = ci, xa.fromValue = Wb;
      var ke = 4294967296, Tl = ke * ke, Vl = Tl / 2, wq = Bd(16777216), Hb = Bd(0);
      xa.ZERO = Hb;
      var Cd = Bd(0, true);
      xa.UZERO = Cd;
      var Ue = Bd(1);
      xa.ONE = Ue;
      var xq = Bd(1, true);
      xa.UONE = xq;
      var Kk = Bd(-1);
      xa.NEG_ONE = Kk;
      var Wl = ya(-1, 2147483647, false);
      xa.MAX_VALUE = Wl;
      var Ul = ya(-1, -1, true);
      xa.MAX_UNSIGNED_VALUE = Ul;
      var nb = ya(0, -2147483648, false);
      xa.MIN_VALUE = nb;
      var D = xa.prototype;
      D.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, D.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * ke + (this.low >>> 0) : this.high * ke + (this.low >>> 0);
      }, D.toString = function(e) {
        if (2 > (e = e || 10) || 36 < e) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(nb)) {
            var t2 = Gb(e), n2 = this.div(t2);
            return t2 = n2.mul(t2).sub(this), n2.toString(e) + t2.toInt().toString(e);
          }
          return "-" + this.neg().toString(e);
        }
        n2 = Gb(sg(e, 6), this.unsigned), t2 = this;
        for (var r = ""; ; ) {
          var i = t2.div(n2), o = (t2.sub(i.mul(n2)).toInt() >>> 0).toString(e);
          if ((t2 = i).isZero()) return o + r;
          for (; 6 > o.length; ) o = "0" + o;
          r = "" + o + r;
        }
      }, D.getHighBits = function() {
        return this.high;
      }, D.getHighBitsUnsigned = function() {
        return this.high >>> 0;
      }, D.getLowBits = function() {
        return this.low;
      }, D.getLowBitsUnsigned = function() {
        return this.low >>> 0;
      }, D.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(nb) ? 64 : this.neg().getNumBitsAbs();
        for (var e = 0 != this.high ? this.high : this.low, t2 = 31; 0 < t2 && 0 == (e & 1 << t2); t2--) ;
        return 0 != this.high ? t2 + 33 : t2 + 1;
      }, D.isZero = function() {
        return 0 === this.high && 0 === this.low;
      }, D.eqz = D.isZero, D.isNegative = function() {
        return !this.unsigned && 0 > this.high;
      }, D.isPositive = function() {
        return this.unsigned || 0 <= this.high;
      }, D.isOdd = function() {
        return 1 == (1 & this.low);
      }, D.isEven = function() {
        return 0 == (1 & this.low);
      }, D.equals = function(e) {
        return mb(e) || (e = Wb(e)), (this.unsigned === e.unsigned || 1 != this.high >>> 31 || 1 != e.high >>> 31) && (this.high === e.high && this.low === e.low);
      }, D.eq = D.equals, D.notEquals = function(e) {
        return !this.eq(e);
      }, D.neq = D.notEquals, D.ne = D.notEquals, D.lessThan = function(e) {
        return 0 > this.comp(e);
      }, D.lt = D.lessThan, D.lessThanOrEqual = function(e) {
        return 0 >= this.comp(e);
      }, D.lte = D.lessThanOrEqual, D.le = D.lessThanOrEqual, D.greaterThan = function(e) {
        return 0 < this.comp(e);
      }, D.gt = D.greaterThan, D.greaterThanOrEqual = function(e) {
        return 0 <= this.comp(e);
      }, D.gte = D.greaterThanOrEqual, D.ge = D.greaterThanOrEqual, D.compare = function(e) {
        if (mb(e) || (e = Wb(e)), this.eq(e)) return 0;
        var t2 = this.isNegative(), n2 = e.isNegative();
        return t2 && !n2 ? -1 : !t2 && n2 ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
      }, D.comp = D.compare, D.negate = function() {
        return !this.unsigned && this.eq(nb) ? nb : this.not().add(Ue);
      }, D.neg = D.negate, D.add = function(e) {
        mb(e) || (e = Wb(e));
        var t2 = this.high >>> 16, n2 = 65535 & this.high, r = this.low >>> 16, i = e.high >>> 16, o = 65535 & e.high, a2 = e.low >>> 16;
        return r = (a2 = ((e = (65535 & this.low) + (65535 & e.low)) >>> 16) + (r + a2)) >>> 16, ya((65535 & a2) << 16 | 65535 & e, (t2 = ((r += n2 + o) >>> 16) + (t2 + i) & 65535) << 16 | 65535 & r, this.unsigned);
      }, D.subtract = function(e) {
        return mb(e) || (e = Wb(e)), this.add(e.neg());
      }, D.sub = D.subtract, D.multiply = function(e) {
        if (this.isZero()) return Hb;
        if (mb(e) || (e = Wb(e)), Qb) {
          var t2 = Qb.mul(this.low, this.high, e.low, e.high);
          return ya(t2, Qb.get_high(), this.unsigned);
        }
        if (e.isZero()) return Hb;
        if (this.eq(nb)) return e.isOdd() ? nb : Hb;
        if (e.eq(nb)) return this.isOdd() ? nb : Hb;
        if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
        if (e.isNegative()) return this.mul(e.neg()).neg();
        if (this.lt(wq) && e.lt(wq)) return Gb(this.toNumber() * e.toNumber(), this.unsigned);
        t2 = this.high >>> 16;
        var n2 = 65535 & this.high, r = this.low >>> 16, i = 65535 & this.low, o = e.high >>> 16, a2 = 65535 & e.high, s = e.low >>> 16, u2 = i * (e = 65535 & e.low), c2 = (u2 >>> 16) + r * e, l = c2 >>> 16;
        l += (c2 = (65535 & c2) + i * s) >>> 16;
        var f = (l += n2 * e) >>> 16;
        return ya((65535 & c2) << 16 | 65535 & u2, (f = (f += (l = (65535 & l) + r * s) >>> 16) + ((l = (65535 & l) + i * a2) >>> 16) + (t2 * e + n2 * s + r * a2 + i * o) & 65535) << 16 | 65535 & l, this.unsigned);
      }, D.mul = D.multiply, D.divide = function(e) {
        if (mb(e) || (e = Wb(e)), e.isZero()) throw Error("division by zero");
        if (Qb) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? ya(e = (this.unsigned ? Qb.div_u : Qb.div_s)(this.low, this.high, e.low, e.high), Qb.get_high(), this.unsigned) : this;
        if (this.isZero()) return this.unsigned ? Cd : Hb;
        if (this.unsigned) {
          if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return Cd;
          if (e.gt(this.shru(1))) return xq;
          var t2 = Cd;
        } else {
          if (this.eq(nb)) {
            if (e.eq(Ue) || e.eq(Kk)) return nb;
            if (e.eq(nb)) return Ue;
            var n2 = this.shr(1).div(e).shl(1);
            if (n2.eq(Hb)) return e.isNegative() ? Ue : Kk;
            var r = this.sub(e.mul(n2));
            return n2.add(r.div(e));
          }
          if (e.eq(nb)) return this.unsigned ? Cd : Hb;
          if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
          if (e.isNegative()) return this.div(e.neg()).neg();
          t2 = Hb;
        }
        for (r = this; r.gte(e); ) {
          n2 = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));
          var i = Math.ceil(Math.log(n2) / Math.LN2);
          i = 48 >= i ? 1 : sg(2, i - 48);
          for (var o = Gb(n2), a2 = o.mul(e); a2.isNegative() || a2.gt(r); ) a2 = (o = Gb(n2 -= i, this.unsigned)).mul(e);
          o.isZero() && (o = Ue), t2 = t2.add(o), r = r.sub(a2);
        }
        return t2;
      }, D.div = D.divide, D.modulo = function(e) {
        return mb(e) || (e = Wb(e)), Qb ? ya(e = (this.unsigned ? Qb.rem_u : Qb.rem_s)(this.low, this.high, e.low, e.high), Qb.get_high(), this.unsigned) : this.sub(this.div(e).mul(e));
      }, D.mod = D.modulo, D.rem = D.modulo, D.not = function() {
        return ya(~this.low, ~this.high, this.unsigned);
      }, D.and = function(e) {
        return mb(e) || (e = Wb(e)), ya(this.low & e.low, this.high & e.high, this.unsigned);
      }, D.or = function(e) {
        return mb(e) || (e = Wb(e)), ya(this.low | e.low, this.high | e.high, this.unsigned);
      }, D.xor = function(e) {
        return mb(e) || (e = Wb(e)), ya(this.low ^ e.low, this.high ^ e.high, this.unsigned);
      }, D.shiftLeft = function(e) {
        return mb(e) && (e = e.toInt()), 0 == (e &= 63) ? this : 32 > e ? ya(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : ya(0, this.low << e - 32, this.unsigned);
      }, D.shl = D.shiftLeft, D.shiftRight = function(e) {
        return mb(e) && (e = e.toInt()), 0 == (e &= 63) ? this : 32 > e ? ya(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : ya(this.high >> e - 32, 0 <= this.high ? 0 : -1, this.unsigned);
      }, D.shr = D.shiftRight, D.shiftRightUnsigned = function(e) {
        if (mb(e) && (e = e.toInt()), 0 === (e &= 63)) return this;
        var t2 = this.high;
        return 32 > e ? ya(this.low >>> e | t2 << 32 - e, t2 >>> e, this.unsigned) : ya(32 === e ? t2 : t2 >>> e - 32, 0, this.unsigned);
      }, D.shru = D.shiftRightUnsigned, D.shr_u = D.shiftRightUnsigned, D.toSigned = function() {
        return this.unsigned ? ya(this.low, this.high, false) : this;
      }, D.toUnsigned = function() {
        return this.unsigned ? this : ya(this.low, this.high, true);
      }, D.toBytes = function(e) {
        return e ? this.toBytesLE() : this.toBytesBE();
      }, D.toBytesLE = function() {
        var e = this.high, t2 = this.low;
        return [255 & t2, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
      }, D.toBytesBE = function() {
        var e = this.high, t2 = this.low;
        return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t2 >>> 24, t2 >>> 16 & 255, t2 >>> 8 & 255, 255 & t2];
      }, xa.fromBytes = function(e, t2, n2) {
        return n2 ? xa.fromBytesLE(e, t2) : xa.fromBytesBE(e, t2);
      }, xa.fromBytesLE = function(e, t2) {
        return new xa(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t2);
      }, xa.fromBytesBE = function(e, t2) {
        return new xa(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t2);
      };
      var di = function(e, t2) {
        return (di = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e2, t3) {
          e2.__proto__ = t3;
        } || function(e2, t3) {
          for (var n2 in t3) t3.hasOwnProperty(n2) && (e2[n2] = t3[n2]);
        })(e, t2);
      }, Lk = false, Ib = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(e) {
        e ? console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + Error().stack) : Lk && console.log("RxJS: Back to a better error behavior. Thank you. <3"), Lk = e;
      }, get useDeprecatedSynchronousErrorHandling() {
        return Lk;
      } }, Eh = { closed: true, next: function(e) {
      }, error: function(e) {
        if (Ib.useDeprecatedSynchronousErrorHandling) throw e;
        me(e);
      }, complete: function() {
      } }, Jb = Array.isArray || function(e) {
        return e && "number" == typeof e.length;
      }, lf = function() {
        function e(e2) {
          return Error.call(this), this.message = e2 ? e2.length + " errors occurred during unsubscription:\n" + e2.map(function(e3, t2) {
            return t2 + 1 + ") " + e3.toString();
          }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = e2, this;
        }
        return e.prototype = Object.create(Error.prototype), e;
      }(), Oa = function() {
        function e(e2) {
          this.closed = false, this._subscriptions = this._parentOrParents = null, e2 && (this._ctorUnsubscribe = true, this._unsubscribe = e2);
        }
        return e.prototype.unsubscribe = function() {
          if (!this.closed) {
            var t2 = this._parentOrParents, n2 = this._ctorUnsubscribe, r = this._unsubscribe, i = this._subscriptions;
            if (this.closed = true, this._subscriptions = this._parentOrParents = null, t2 instanceof e) t2.remove(this);
            else if (null !== t2) for (var o = 0; o < t2.length; ++o) t2[o].remove(this);
            if (le(r)) {
              n2 && (this._unsubscribe = void 0);
              try {
                r.call(this);
              } catch (e2) {
                var a2 = e2 instanceof lf ? Xl(e2.errors) : [e2];
              }
            }
            if (Jb(i)) {
              for (o = -1, t2 = i.length; ++o < t2; ) if (ei(n2 = i[o])) try {
                n2.unsubscribe();
              } catch (e2) {
                a2 = a2 || [], e2 instanceof lf ? a2 = a2.concat(Xl(e2.errors)) : a2.push(e2);
              }
            }
            if (a2) throw new lf(a2);
          }
        }, e.prototype.add = function(t2) {
          var n2 = t2;
          if (!t2) return e.EMPTY;
          switch (X(t2)) {
            case "function":
              n2 = new e(t2);
            case "object":
              if (n2 === this || n2.closed || "function" != typeof n2.unsubscribe) return n2;
              if (this.closed) return n2.unsubscribe(), n2;
              n2 instanceof e || (t2 = n2, (n2 = new e())._subscriptions = [t2]);
              break;
            default:
              throw Error("unrecognized teardown " + t2 + " added to Subscription.");
          }
          if (null === (t2 = n2._parentOrParents)) n2._parentOrParents = this;
          else if (t2 instanceof e) {
            if (t2 === this) return n2;
            n2._parentOrParents = [t2, this];
          } else {
            if (-1 !== t2.indexOf(this)) return n2;
            t2.push(this);
          }
          return null === (t2 = this._subscriptions) ? this._subscriptions = [n2] : t2.push(n2), n2;
        }, e.prototype.remove = function(e2) {
          var t2 = this._subscriptions;
          t2 && (-1 !== (e2 = t2.indexOf(e2)) && t2.splice(e2, 1));
        }, e.EMPTY = function(e2) {
          return e2.closed = true, e2;
        }(new e()), e;
      }(), Fh = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(), ia = function(e) {
        function t2(n2, r, i) {
          var o = e.call(this) || this;
          switch (o.syncErrorValue = null, o.syncErrorThrown = false, o.syncErrorThrowable = false, o.isStopped = false, arguments.length) {
            case 0:
              o.destination = Eh;
              break;
            case 1:
              if (!n2) {
                o.destination = Eh;
                break;
              }
              if ("object" === X(n2)) {
                n2 instanceof t2 ? (o.syncErrorThrowable = n2.syncErrorThrowable, o.destination = n2, n2.add(o)) : (o.syncErrorThrowable = true, o.destination = new yq(o, n2));
                break;
              }
            default:
              o.syncErrorThrowable = true, o.destination = new yq(o, n2, r, i);
          }
          return o;
        }
        return O(t2, e), t2.prototype[Fh] = function() {
          return this;
        }, t2.create = function(e2, n2, r) {
          return (e2 = new t2(e2, n2, r)).syncErrorThrowable = false, e2;
        }, t2.prototype.next = function(e2) {
          this.isStopped || this._next(e2);
        }, t2.prototype.error = function(e2) {
          this.isStopped || (this.isStopped = true, this._error(e2));
        }, t2.prototype.complete = function() {
          this.isStopped || (this.isStopped = true, this._complete());
        }, t2.prototype.unsubscribe = function() {
          this.closed || (this.isStopped = true, e.prototype.unsubscribe.call(this));
        }, t2.prototype._next = function(e2) {
          this.destination.next(e2);
        }, t2.prototype._error = function(e2) {
          this.destination.error(e2), this.unsubscribe();
        }, t2.prototype._complete = function() {
          this.destination.complete(), this.unsubscribe();
        }, t2.prototype._unsubscribeAndRecycle = function() {
          var e2 = this._parentOrParents;
          return this._parentOrParents = null, this.unsubscribe(), this.isStopped = this.closed = false, this._parentOrParents = e2, this;
        }, t2;
      }(Oa), yq = function(e) {
        function t2(t3, n2, r, i) {
          var o = e.call(this) || this;
          if (o._parentSubscriber = t3, t3 = o, le(n2)) var a2 = n2;
          else n2 && (a2 = n2.next, r = n2.error, i = n2.complete, n2 !== Eh && (le((t3 = Object.create(n2)).unsubscribe) && o.add(t3.unsubscribe.bind(t3)), t3.unsubscribe = o.unsubscribe.bind(o)));
          return o._context = t3, o._next = a2, o._error = r, o._complete = i, o;
        }
        return O(t2, e), t2.prototype.next = function(e2) {
          if (!this.isStopped && this._next) {
            var t3 = this._parentSubscriber;
            Ib.useDeprecatedSynchronousErrorHandling && t3.syncErrorThrowable ? this.__tryOrSetError(t3, this._next, e2) && this.unsubscribe() : this.__tryOrUnsub(this._next, e2);
          }
        }, t2.prototype.error = function(e2) {
          if (!this.isStopped) {
            var t3 = this._parentSubscriber, n2 = Ib.useDeprecatedSynchronousErrorHandling;
            if (this._error) n2 && t3.syncErrorThrowable ? this.__tryOrSetError(t3, this._error, e2) : this.__tryOrUnsub(this._error, e2), this.unsubscribe();
            else if (t3.syncErrorThrowable) n2 ? (t3.syncErrorValue = e2, t3.syncErrorThrown = true) : me(e2), this.unsubscribe();
            else {
              if (this.unsubscribe(), n2) throw e2;
              me(e2);
            }
          }
        }, t2.prototype.complete = function() {
          var e2 = this;
          if (!this.isStopped) {
            var t3 = this._parentSubscriber;
            if (this._complete) {
              var n2 = function() {
                return e2._complete.call(e2._context);
              };
              Ib.useDeprecatedSynchronousErrorHandling && t3.syncErrorThrowable ? this.__tryOrSetError(t3, n2) : this.__tryOrUnsub(n2);
            }
            this.unsubscribe();
          }
        }, t2.prototype.__tryOrUnsub = function(e2, t3) {
          try {
            e2.call(this._context, t3);
          } catch (e3) {
            if (this.unsubscribe(), Ib.useDeprecatedSynchronousErrorHandling) throw e3;
            me(e3);
          }
        }, t2.prototype.__tryOrSetError = function(e2, t3, n2) {
          if (!Ib.useDeprecatedSynchronousErrorHandling) throw Error("bad call");
          try {
            t3.call(this._context, n2);
          } catch (t4) {
            return Ib.useDeprecatedSynchronousErrorHandling ? (e2.syncErrorValue = t4, e2.syncErrorThrown = true) : me(t4), true;
          }
          return false;
        }, t2.prototype._unsubscribe = function() {
          var e2 = this._parentSubscriber;
          this._parentSubscriber = this._context = null, e2.unsubscribe();
        }, t2;
      }(ia), ne = "function" == typeof Symbol && Symbol.observable || "@@observable", Y = function() {
        function e(e2) {
          this._isScalar = false, e2 && (this._subscribe = e2);
        }
        return e.prototype.lift = function(t2) {
          var n2 = new e();
          return n2.source = this, n2.operator = t2, n2;
        }, e.prototype.subscribe = function(e2, t2, n2) {
          var r = this.operator;
          e: {
            if (e2) {
              if (e2 instanceof ia) break e;
              if (e2[Fh]) {
                e2 = e2[Fh]();
                break e;
              }
            }
            e2 = e2 || t2 || n2 ? new ia(e2, t2, n2) : new ia(Eh);
          }
          if (r ? e2.add(r.call(e2, this.source)) : e2.add(this.source || Ib.useDeprecatedSynchronousErrorHandling && !e2.syncErrorThrowable ? this._subscribe(e2) : this._trySubscribe(e2)), Ib.useDeprecatedSynchronousErrorHandling && e2.syncErrorThrowable && (e2.syncErrorThrowable = false, e2.syncErrorThrown)) throw e2.syncErrorValue;
          return e2;
        }, e.prototype._trySubscribe = function(e2) {
          try {
            return this._subscribe(e2);
          } catch (t2) {
            Ib.useDeprecatedSynchronousErrorHandling && (e2.syncErrorThrown = true, e2.syncErrorValue = t2), fi(e2) ? e2.error(t2) : console.warn(t2);
          }
        }, e.prototype.forEach = function(e2, t2) {
          var n2 = this;
          return new (t2 = Zl(t2))(function(t3, r) {
            var i = n2.subscribe(function(t4) {
              try {
                e2(t4);
              } catch (e3) {
                r(e3), i && i.unsubscribe();
              }
            }, r, t3);
          });
        }, e.prototype._subscribe = function(e2) {
          var t2 = this.source;
          return t2 && t2.subscribe(e2);
        }, e.prototype[ne] = function() {
          return this;
        }, e.prototype.pipe = function() {
          for (var e2 = [], t2 = 0; t2 < arguments.length; t2++) e2[t2] = arguments[t2];
          return 0 === e2.length ? this : Yl(e2)(this);
        }, e.prototype.toPromise = function(e2) {
          var t2 = this;
          return new (e2 = Zl(e2))(function(e3, n2) {
            var r;
            t2.subscribe(function(e4) {
              return r = e4;
            }, function(e4) {
              return n2(e4);
            }, function() {
              return e3(r);
            });
          });
        }, e.create = function(t2) {
          return new e(t2);
        }, e;
      }(), qd = function() {
        function e() {
          return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
        }
        return e.prototype = Object.create(Error.prototype), e;
      }(), zq = function(e) {
        function t2(t3, n2) {
          var r = e.call(this) || this;
          return r.subject = t3, r.subscriber = n2, r.closed = false, r;
        }
        return O(t2, e), t2.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.closed = true;
            var e2 = this.subject, t3 = e2.observers;
            this.subject = null, !t3 || 0 === t3.length || e2.isStopped || e2.closed || -1 !== (e2 = t3.indexOf(this.subscriber)) && t3.splice(e2, 1);
          }
        }, t2;
      }(Oa), Aq = function(e) {
        function t2(t3) {
          var n2 = e.call(this, t3) || this;
          return n2.destination = t3, n2;
        }
        return O(t2, e), t2;
      }(ia), Pa = function(e) {
        function t2() {
          var t3 = e.call(this) || this;
          return t3.observers = [], t3.closed = false, t3.isStopped = false, t3.hasError = false, t3.thrownError = null, t3;
        }
        return O(t2, e), t2.prototype[Fh] = function() {
          return new Aq(this);
        }, t2.prototype.lift = function(e2) {
          var t3 = new Bq(this, this);
          return t3.operator = e2, t3;
        }, t2.prototype.next = function(e2) {
          if (this.closed) throw new qd();
          if (!this.isStopped) {
            var t3 = this.observers, n2 = t3.length;
            t3 = t3.slice();
            for (var r = 0; r < n2; r++) t3[r].next(e2);
          }
        }, t2.prototype.error = function(e2) {
          if (this.closed) throw new qd();
          this.hasError = true, this.thrownError = e2, this.isStopped = true;
          var t3 = this.observers, n2 = t3.length;
          t3 = t3.slice();
          for (var r = 0; r < n2; r++) t3[r].error(e2);
          this.observers.length = 0;
        }, t2.prototype.complete = function() {
          if (this.closed) throw new qd();
          this.isStopped = true;
          var e2 = this.observers, t3 = e2.length;
          e2 = e2.slice();
          for (var n2 = 0; n2 < t3; n2++) e2[n2].complete();
          this.observers.length = 0;
        }, t2.prototype.unsubscribe = function() {
          this.closed = this.isStopped = true, this.observers = null;
        }, t2.prototype._trySubscribe = function(t3) {
          if (this.closed) throw new qd();
          return e.prototype._trySubscribe.call(this, t3);
        }, t2.prototype._subscribe = function(e2) {
          if (this.closed) throw new qd();
          return this.hasError ? (e2.error(this.thrownError), Oa.EMPTY) : this.isStopped ? (e2.complete(), Oa.EMPTY) : (this.observers.push(e2), new zq(this, e2));
        }, t2.prototype.asObservable = function() {
          var e2 = new Y();
          return e2.source = this, e2;
        }, t2.create = function(e2, t3) {
          return new Bq(e2, t3);
        }, t2;
      }(Y), Bq = function(e) {
        function t2(t3, n2) {
          var r = e.call(this) || this;
          return r.destination = t3, r.source = n2, r;
        }
        return O(t2, e), t2.prototype.next = function(e2) {
          var t3 = this.destination;
          t3 && t3.next && t3.next(e2);
        }, t2.prototype.error = function(e2) {
          var t3 = this.destination;
          t3 && t3.error && this.destination.error(e2);
        }, t2.prototype.complete = function() {
          var e2 = this.destination;
          e2 && e2.complete && this.destination.complete();
        }, t2.prototype._subscribe = function(e2) {
          return this.source ? this.source.subscribe(e2) : Oa.EMPTY;
        }, t2;
      }(Pa), Ns = function() {
        function e(e2) {
          this.connectable = e2;
        }
        return e.prototype.call = function(e2, t2) {
          var n2 = this.connectable;
          return n2._refCount++, e2 = new cz(e2, n2), t2 = t2.subscribe(e2), e2.closed || (e2.connection = n2.connect()), t2;
        }, e;
      }(), cz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).connectable = n2, t3;
        }
        return O(t2, e), t2.prototype._unsubscribe = function() {
          var e2 = this.connectable;
          if (e2) {
            this.connectable = null;
            var t3 = e2._refCount;
            0 >= t3 ? this.connection = null : (e2._refCount = t3 - 1, 1 < t3 ? this.connection = null : (t3 = this.connection, e2 = e2._connection, this.connection = null, !e2 || t3 && e2 !== t3 || e2.unsubscribe()));
          } else this.connection = null;
        }, t2;
      }(ia), Cq = function(e) {
        function t2(t3, n2) {
          var r = e.call(this) || this;
          return r.source = t3, r.subjectFactory = n2, r._refCount = 0, r._isComplete = false, r;
        }
        return O(t2, e), t2.prototype._subscribe = function(e2) {
          return this.getSubject().subscribe(e2);
        }, t2.prototype.getSubject = function() {
          var e2 = this._subject;
          return e2 && !e2.isStopped || (this._subject = this.subjectFactory()), this._subject;
        }, t2.prototype.connect = function() {
          var e2 = this._connection;
          return e2 || (this._isComplete = false, (e2 = this._connection = new Oa()).add(this.source.subscribe(new dz(this.getSubject(), this))), e2.closed && (this._connection = null, e2 = Oa.EMPTY)), e2;
        }, t2.prototype.refCount = function() {
          return $l()(this);
        }, t2;
      }(Y), At = function() {
        var e = Cq.prototype;
        return { operator: { value: null }, _refCount: { value: 0, writable: true }, _subject: { value: null, writable: true }, _connection: { value: null, writable: true }, _subscribe: { value: e._subscribe }, _isComplete: { value: e._isComplete, writable: true }, getSubject: { value: e.getSubject }, connect: { value: e.connect }, refCount: { value: e.refCount } };
      }(), dz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).connectable = n2, t3;
        }
        return O(t2, e), t2.prototype._error = function(t3) {
          this._unsubscribe(), e.prototype._error.call(this, t3);
        }, t2.prototype._complete = function() {
          this.connectable._isComplete = true, this._unsubscribe(), e.prototype._complete.call(this);
        }, t2.prototype._unsubscribe = function() {
          var e2 = this.connectable;
          if (e2) {
            this.connectable = null;
            var t3 = e2._connection;
            e2._refCount = 0, e2._subject = null, e2._connection = null, t3 && t3.unsubscribe();
          }
        }, t2;
      }(Aq);
      !function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).connectable = n2, t3;
        }
        O(t2, e), t2.prototype._unsubscribe = function() {
          var e2 = this.connectable;
          if (e2) {
            this.connectable = null;
            var t3 = e2._refCount;
            0 >= t3 ? this.connection = null : (e2._refCount = t3 - 1, 1 < t3 ? this.connection = null : (t3 = this.connection, e2 = e2._connection, this.connection = null, !e2 || t3 && e2 !== t3 || e2.unsubscribe()));
          } else this.connection = null;
        };
      }(ia), function(e) {
        function t2(t3, n2, r, i, o) {
          return (t3 = e.call(this, t3) || this).keySelector = n2, t3.elementSelector = r, t3.durationSelector = i, t3.subjectSelector = o, t3.groups = null, t3.attemptedToUnsubscribe = false, t3.count = 0, t3;
        }
        O(t2, e), t2.prototype._next = function(e2) {
          try {
            var t3 = this.keySelector(e2);
          } catch (e3) {
            return void this.error(e3);
          }
          this._group(e2, t3);
        }, t2.prototype._group = function(e2, t3) {
          var n2 = this.groups;
          n2 || (n2 = this.groups = /* @__PURE__ */ new Map());
          var r = n2.get(t3);
          if (this.elementSelector) try {
            var i = this.elementSelector(e2);
          } catch (e3) {
            this.error(e3);
          }
          else i = e2;
          if (!r && (r = this.subjectSelector ? this.subjectSelector() : new Pa(), n2.set(t3, r), e2 = new Mk(t3, r, this), this.destination.next(e2), this.durationSelector)) {
            e2 = void 0;
            try {
              e2 = this.durationSelector(new Mk(t3, r));
            } catch (e3) {
              return void this.error(e3);
            }
            this.add(e2.subscribe(new ez(t3, r, this)));
          }
          r.closed || r.next(i);
        }, t2.prototype._error = function(e2) {
          var t3 = this.groups;
          t3 && (t3.forEach(function(t4, n2) {
            t4.error(e2);
          }), t3.clear()), this.destination.error(e2);
        }, t2.prototype._complete = function() {
          var e2 = this.groups;
          e2 && (e2.forEach(function(e3, t3) {
            e3.complete();
          }), e2.clear()), this.destination.complete();
        }, t2.prototype.removeGroup = function(e2) {
          this.groups.delete(e2);
        }, t2.prototype.unsubscribe = function() {
          this.closed || (this.attemptedToUnsubscribe = true, 0 === this.count && e.prototype.unsubscribe.call(this));
        };
      }(ia);
      var ez = function(e) {
        function t2(t3, n2, r) {
          var i = e.call(this, n2) || this;
          return i.key = t3, i.group = n2, i.parent = r, i;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.complete();
        }, t2.prototype._unsubscribe = function() {
          var e2 = this.parent, t3 = this.key;
          this.key = this.parent = null, e2 && e2.removeGroup(t3);
        }, t2;
      }(ia), Mk = function(e) {
        function t2(t3, n2, r) {
          var i = e.call(this) || this;
          return i.key = t3, i.groupSubject = n2, i.refCountSubscription = r, i;
        }
        return O(t2, e), t2.prototype._subscribe = function(e2) {
          var t3 = new Oa(), n2 = this.refCountSubscription, r = this.groupSubject;
          return n2 && !n2.closed && t3.add(new fz(n2)), t3.add(r.subscribe(e2)), t3;
        }, t2;
      }(Y), fz = function(e) {
        function t2(t3) {
          var n2 = e.call(this) || this;
          return n2.parent = t3, t3.count++, n2;
        }
        return O(t2, e), t2.prototype.unsubscribe = function() {
          var t3 = this.parent;
          t3.closed || this.closed || (e.prototype.unsubscribe.call(this), --t3.count, 0 === t3.count && t3.attemptedToUnsubscribe && t3.unsubscribe());
        }, t2;
      }(Oa), gz = function(e) {
        function t2(t3) {
          var n2 = e.call(this) || this;
          return n2._value = t3, n2;
        }
        return O(t2, e), Object.defineProperty(t2.prototype, "value", { get: function() {
          return this.getValue();
        }, enumerable: true, configurable: true }), t2.prototype._subscribe = function(t3) {
          var n2 = e.prototype._subscribe.call(this, t3);
          return n2 && !n2.closed && t3.next(this._value), n2;
        }, t2.prototype.getValue = function() {
          if (this.hasError) throw this.thrownError;
          if (this.closed) throw new qd();
          return this._value;
        }, t2.prototype.next = function(t3) {
          e.prototype.next.call(this, this._value = t3);
        }, t2;
      }(Pa), dg = function(e) {
        function t2(t3, n2) {
          var r = e.call(this, t3, n2) || this;
          return r.scheduler = t3, r.work = n2, r.pending = false, r;
        }
        return O(t2, e), t2.prototype.schedule = function(e2, t3) {
          if (void 0 === t3 && (t3 = 0), this.closed) return this;
          this.state = e2, e2 = this.id;
          var n2 = this.scheduler;
          return null != e2 && (this.id = this.recycleAsyncId(n2, e2, t3)), this.pending = true, this.delay = t3, this.id = this.id || this.requestAsyncId(n2, this.id, t3), this;
        }, t2.prototype.requestAsyncId = function(e2, t3, n2) {
          return void 0 === n2 && (n2 = 0), setInterval(e2.flush.bind(e2, this), n2);
        }, t2.prototype.recycleAsyncId = function(e2, t3, n2) {
          if (void 0 === n2 && (n2 = 0), null !== n2 && this.delay === n2 && false === this.pending) return t3;
          clearInterval(t3);
        }, t2.prototype.execute = function(e2, t3) {
          return this.closed ? Error("executing a cancelled action") : (this.pending = false, (e2 = this._execute(e2, t3)) ? e2 : void (false === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))));
        }, t2.prototype._execute = function(e2, t3) {
          t3 = false;
          var n2 = void 0;
          try {
            this.work(e2);
          } catch (e3) {
            t3 = true, n2 = !!e3 && e3 || Error(e3);
          }
          if (t3) return this.unsubscribe(), n2;
        }, t2.prototype._unsubscribe = function() {
          var e2 = this.id, t3 = this.scheduler, n2 = t3.actions, r = n2.indexOf(this);
          this.state = this.work = null, this.pending = false, this.scheduler = null, -1 !== r && n2.splice(r, 1), null != e2 && (this.id = this.recycleAsyncId(t3, e2, null)), this.delay = null;
        }, t2;
      }(function(e) {
        function t2(t3, n2) {
          return e.call(this) || this;
        }
        return O(t2, e), t2.prototype.schedule = function(e2, t3) {
          return this;
        }, t2;
      }(Oa)), hz = function(e) {
        function t2(t3, n2) {
          var r = e.call(this, t3, n2) || this;
          return r.scheduler = t3, r.work = n2, r;
        }
        return O(t2, e), t2.prototype.schedule = function(t3, n2) {
          return void 0 === n2 && (n2 = 0), 0 < n2 ? e.prototype.schedule.call(this, t3, n2) : (this.delay = n2, this.state = t3, this.scheduler.flush(this), this);
        }, t2.prototype.execute = function(t3, n2) {
          return 0 < n2 || this.closed ? e.prototype.execute.call(this, t3, n2) : this._execute(t3, n2);
        }, t2.prototype.requestAsyncId = function(t3, n2, r) {
          return void 0 === r && (r = 0), null !== r && 0 < r || null === r && 0 < this.delay ? e.prototype.requestAsyncId.call(this, t3, n2, r) : t3.flush(this);
        }, t2;
      }(dg), Nk = function() {
        function e(t2, n2) {
          void 0 === n2 && (n2 = e.now), this.SchedulerAction = t2, this.now = n2;
        }
        return e.prototype.schedule = function(e2, t2, n2) {
          return void 0 === t2 && (t2 = 0), new this.SchedulerAction(this, e2).schedule(n2, t2);
        }, e.now = function() {
          return Date.now();
        }, e;
      }(), eg = function(e) {
        function t2(n2, r) {
          void 0 === r && (r = Nk.now);
          var i = e.call(this, n2, function() {
            return t2.delegate && t2.delegate !== i ? t2.delegate.now() : r();
          }) || this;
          return i.actions = [], i.active = false, i.scheduled = void 0, i;
        }
        return O(t2, e), t2.prototype.schedule = function(n2, r, i) {
          return void 0 === r && (r = 0), t2.delegate && t2.delegate !== this ? t2.delegate.schedule(n2, r, i) : e.prototype.schedule.call(this, n2, r, i);
        }, t2.prototype.flush = function(e2) {
          var t3 = this.actions;
          if (this.active) t3.push(e2);
          else {
            var n2;
            this.active = true;
            do {
              if (n2 = e2.execute(e2.state, e2.delay)) break;
            } while (e2 = t3.shift());
            if (this.active = false, n2) {
              for (; e2 = t3.shift(); ) e2.unsubscribe();
              throw n2;
            }
          }
        }, t2;
      }(Nk), fg = new (function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        return O(t2, e), t2;
      }(eg))(hz), vb = new Y(function(e) {
        return e.complete();
      }), am = function(e) {
        return function(t2) {
          for (var n2 = 0, r = e.length; n2 < r && !t2.closed; n2++) t2.next(e[n2]);
          t2.complete();
        };
      }, Ok;
      !function(e) {
        e.NEXT = "N", e.ERROR = "E", e.COMPLETE = "C";
      }(Ok || (Ok = {}));
      var Ve = function() {
        function e(e2, t2, n2) {
          this.kind = e2, this.value = t2, this.error = n2, this.hasValue = "N" === e2;
        }
        return e.prototype.observe = function(e2) {
          switch (this.kind) {
            case "N":
              return e2.next && e2.next(this.value);
            case "E":
              return e2.error && e2.error(this.error);
            case "C":
              return e2.complete && e2.complete();
          }
        }, e.prototype.do = function(e2, t2, n2) {
          switch (this.kind) {
            case "N":
              return e2 && e2(this.value);
            case "E":
              return t2 && t2(this.error);
            case "C":
              return n2 && n2();
          }
        }, e.prototype.accept = function(e2, t2, n2) {
          return e2 && "function" == typeof e2.next ? this.observe(e2) : this.do(e2, t2, n2);
        }, e.prototype.toObservable = function() {
          switch (this.kind) {
            case "N":
              return bb(this.value);
            case "E":
              return Z(this.error);
            case "C":
              return mf();
          }
          throw Error("unexpected notification kind value");
        }, e.createNext = function(t2) {
          return void 0 !== t2 ? new e("N", t2) : e.undefinedValueNotification;
        }, e.createError = function(t2) {
          return new e("E", void 0, t2);
        }, e.createComplete = function() {
          return e.completeNotification;
        }, e.completeNotification = new e("C"), e.undefinedValueNotification = new e("N", void 0), e;
      }(), Rs = function() {
        function e(e2, t2) {
          void 0 === t2 && (t2 = 0), this.scheduler = e2, this.delay = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Dq(e2, this.scheduler, this.delay));
        }, e;
      }(), Dq = function(e) {
        function t2(t3, n2, r) {
          return void 0 === r && (r = 0), (t3 = e.call(this, t3) || this).scheduler = n2, t3.delay = r, t3;
        }
        return O(t2, e), t2.dispatch = function(e2) {
          e2.notification.observe(e2.destination), this.unsubscribe();
        }, t2.prototype.scheduleMessage = function(e2) {
          this.destination.add(this.scheduler.schedule(t2.dispatch, this.delay, new iz(e2, this.destination)));
        }, t2.prototype._next = function(e2) {
          this.scheduleMessage(Ve.createNext(e2));
        }, t2.prototype._error = function(e2) {
          this.scheduleMessage(Ve.createError(e2)), this.unsubscribe();
        }, t2.prototype._complete = function() {
          this.scheduleMessage(Ve.createComplete()), this.unsubscribe();
        }, t2;
      }(ia), iz = function(e, t2) {
        this.notification = e, this.destination = t2;
      }, qe = function(e) {
        function t2(t3, n2, r) {
          void 0 === t3 && (t3 = Number.POSITIVE_INFINITY), void 0 === n2 && (n2 = Number.POSITIVE_INFINITY);
          var i = e.call(this) || this;
          return i.scheduler = r, i._events = [], i._infiniteTimeWindow = false, i._bufferSize = 1 > t3 ? 1 : t3, i._windowTime = 1 > n2 ? 1 : n2, n2 === Number.POSITIVE_INFINITY ? (i._infiniteTimeWindow = true, i.next = i.nextInfiniteTimeWindow) : i.next = i.nextTimeWindow, i;
        }
        return O(t2, e), t2.prototype.nextInfiniteTimeWindow = function(t3) {
          if (!this.isStopped) {
            var n2 = this._events;
            n2.push(t3), n2.length > this._bufferSize && n2.shift();
          }
          e.prototype.next.call(this, t3);
        }, t2.prototype.nextTimeWindow = function(t3) {
          this.isStopped || (this._events.push(new jz(this._getNow(), t3)), this._trimBufferThenGetEvents()), e.prototype.next.call(this, t3);
        }, t2.prototype._subscribe = function(e2) {
          var t3 = this._infiniteTimeWindow, n2 = t3 ? this._events : this._trimBufferThenGetEvents(), r = this.scheduler, i = n2.length;
          if (this.closed) throw new qd();
          if (this.isStopped || this.hasError) var o = Oa.EMPTY;
          else this.observers.push(e2), o = new zq(this, e2);
          if (r && e2.add(e2 = new Dq(e2, r)), t3) for (t3 = 0; t3 < i && !e2.closed; t3++) e2.next(n2[t3]);
          else for (t3 = 0; t3 < i && !e2.closed; t3++) e2.next(n2[t3].value);
          return this.hasError ? e2.error(this.thrownError) : this.isStopped && e2.complete(), o;
        }, t2.prototype._getNow = function() {
          return (this.scheduler || fg).now();
        }, t2.prototype._trimBufferThenGetEvents = function() {
          for (var e2 = this._getNow(), t3 = this._bufferSize, n2 = this._windowTime, r = this._events, i = r.length, o = 0; o < i && !(e2 - r[o].time < n2); ) o++;
          return i > t3 && (o = Math.max(o, i - t3)), 0 < o && r.splice(0, o), r;
        }, t2;
      }(Pa), jz = function(e, t2) {
        this.time = e, this.value = t2;
      }, of = function(e) {
        function t2() {
          var t3 = null !== e && e.apply(this, arguments) || this;
          return t3.value = null, t3.hasNext = false, t3.hasCompleted = false, t3;
        }
        return O(t2, e), t2.prototype._subscribe = function(t3) {
          return this.hasError ? (t3.error(this.thrownError), Oa.EMPTY) : this.hasCompleted && this.hasNext ? (t3.next(this.value), t3.complete(), Oa.EMPTY) : e.prototype._subscribe.call(this, t3);
        }, t2.prototype.next = function(e2) {
          this.hasCompleted || (this.value = e2, this.hasNext = true);
        }, t2.prototype.error = function(t3) {
          this.hasCompleted || e.prototype.error.call(this, t3);
        }, t2.prototype.complete = function() {
          this.hasCompleted = true, this.hasNext && e.prototype.next.call(this, this.value), e.prototype.complete.call(this);
        }, t2;
      }(Pa), kz = 1, lz = Promise.resolve(), ii = {}, Eq = { setImmediate: function(e) {
        var t2 = kz++;
        return ii[t2] = true, lz.then(function() {
          return bm(t2) && e();
        }), t2;
      }, clearImmediate: function(e) {
        bm(e);
      } }, mz = function(e) {
        function t2(t3, n2) {
          var r = e.call(this, t3, n2) || this;
          return r.scheduler = t3, r.work = n2, r;
        }
        return O(t2, e), t2.prototype.requestAsyncId = function(t3, n2, r) {
          return void 0 === r && (r = 0), null !== r && 0 < r ? e.prototype.requestAsyncId.call(this, t3, n2, r) : (t3.actions.push(this), t3.scheduled || (t3.scheduled = Eq.setImmediate(t3.flush.bind(t3, null))));
        }, t2.prototype.recycleAsyncId = function(t3, n2, r) {
          if (void 0 === r && (r = 0), null !== r && 0 < r || null === r && 0 < this.delay) return e.prototype.recycleAsyncId.call(this, t3, n2, r);
          0 === t3.actions.length && (Eq.clearImmediate(n2), t3.scheduled = void 0);
        }, t2;
      }(dg), ri = new (function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        return O(t2, e), t2.prototype.flush = function(e2) {
          this.active = true, this.scheduled = void 0;
          var t3, n2 = this.actions, r = -1, i = n2.length;
          e2 = e2 || n2.shift();
          do {
            if (t3 = e2.execute(e2.state, e2.delay)) break;
          } while (++r < i && (e2 = n2.shift()));
          if (this.active = false, t3) {
            for (; ++r < i && (e2 = n2.shift()); ) e2.unsubscribe();
            throw t3;
          }
        }, t2;
      }(eg))(mz), nz = ri, Pk = new eg(dg), bd = Pk, oz = function(e) {
        function t2(t3, n2) {
          var r = e.call(this, t3, n2) || this;
          return r.scheduler = t3, r.work = n2, r;
        }
        return O(t2, e), t2.prototype.requestAsyncId = function(t3, n2, r) {
          return void 0 === r && (r = 0), null !== r && 0 < r ? e.prototype.requestAsyncId.call(this, t3, n2, r) : (t3.actions.push(this), t3.scheduled || (t3.scheduled = requestAnimationFrame(function() {
            return t3.flush(null);
          })));
        }, t2.prototype.recycleAsyncId = function(t3, n2, r) {
          if (void 0 === r && (r = 0), null !== r && 0 < r || null === r && 0 < this.delay) return e.prototype.recycleAsyncId.call(this, t3, n2, r);
          0 === t3.actions.length && (cancelAnimationFrame(n2), t3.scheduled = void 0);
        }, t2;
      }(dg), Fq = new (function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        return O(t2, e), t2.prototype.flush = function(e2) {
          this.active = true, this.scheduled = void 0;
          var t3, n2 = this.actions, r = -1, i = n2.length;
          e2 = e2 || n2.shift();
          do {
            if (t3 = e2.execute(e2.state, e2.delay)) break;
          } while (++r < i && (e2 = n2.shift()));
          if (this.active = false, t3) {
            for (; ++r < i && (e2 = n2.shift()); ) e2.unsubscribe();
            throw t3;
          }
        }, t2;
      }(eg))(oz), pz = function(e) {
        function t2(t3, n2) {
          void 0 === t3 && (t3 = Gq), void 0 === n2 && (n2 = Number.POSITIVE_INFINITY);
          var r = e.call(this, t3, function() {
            return r.frame;
          }) || this;
          return r.maxFrames = n2, r.frame = 0, r.index = -1, r;
        }
        return O(t2, e), t2.prototype.flush = function() {
          for (var e2, t3, n2 = this.actions, r = this.maxFrames; (t3 = n2[0]) && t3.delay <= r && (n2.shift(), this.frame = t3.delay, !(e2 = t3.execute(t3.state, t3.delay))); ) ;
          if (e2) {
            for (; t3 = n2.shift(); ) t3.unsubscribe();
            throw e2;
          }
        }, t2.frameTimeFactor = 10, t2;
      }(eg), Gq = function(e) {
        function t2(t3, n2, r) {
          void 0 === r && (r = t3.index += 1);
          var i = e.call(this, t3, n2) || this;
          return i.scheduler = t3, i.work = n2, i.index = r, i.active = true, i.index = t3.index = r, i;
        }
        return O(t2, e), t2.prototype.schedule = function(n2, r) {
          if (void 0 === r && (r = 0), !this.id) return e.prototype.schedule.call(this, n2, r);
          this.active = false;
          var i = new t2(this.scheduler, this.work);
          return this.add(i), i.schedule(n2, r);
        }, t2.prototype.requestAsyncId = function(e2, n2, r) {
          return void 0 === r && (r = 0), this.delay = e2.frame + r, (e2 = e2.actions).push(this), e2.sort(t2.sortActions), true;
        }, t2.prototype.recycleAsyncId = function(e2, t3, n2) {
        }, t2.prototype._execute = function(t3, n2) {
          if (true === this.active) return e.prototype._execute.call(this, t3, n2);
        }, t2.sortActions = function(e2, t3) {
          return e2.delay === t3.delay ? e2.index === t3.index ? 0 : e2.index > t3.index ? 1 : -1 : e2.delay > t3.delay ? 1 : -1;
        }, t2;
      }(dg), Qk = function() {
        function e() {
          return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
        }
        return e.prototype = Object.create(Error.prototype), e;
      }(), vg = function() {
        function e() {
          return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
        }
        return e.prototype = Object.create(Error.prototype), e;
      }(), pb = function() {
        function e() {
          return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
        }
        return e.prototype = Object.create(Error.prototype), e;
      }(), Ss = function() {
        function e(e2, t2) {
          this.project = e2, this.thisArg = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new qz(e2, this.project, this.thisArg));
        }, e;
      }(), qz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).project = n2, t3.count = 0, t3.thisArg = r || t3, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          try {
            var t3 = this.project.call(this.thisArg, e2, this.count++);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.destination.next(t3);
        }, t2;
      }(ia), Rk = function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        return O(t2, e), t2.prototype.notifyNext = function(e2, t3, n2, r, i) {
          this.destination.next(t3);
        }, t2.prototype.notifyError = function(e2, t3) {
          this.destination.error(e2);
        }, t2.prototype.notifyComplete = function(e2) {
          this.destination.complete();
        }, t2;
      }(ia), Xs = function(e) {
        function t2(t3, n2, r) {
          var i = e.call(this) || this;
          return i.parent = t3, i.outerValue = n2, i.outerIndex = r, i.index = 0, i;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.parent.notifyNext(this.outerValue, e2, this.outerIndex, this.index++, this);
        }, t2.prototype._error = function(e2) {
          this.parent.notifyError(e2, this), this.unsubscribe();
        }, t2.prototype._complete = function() {
          this.parent.notifyComplete(this), this.unsubscribe();
        }, t2;
      }(ia), rz = function(e) {
        return function(t2) {
          return e.then(function(e2) {
            t2.closed || (t2.next(e2), t2.complete());
          }, function(e2) {
            return t2.error(e2);
          }).then(null, me), t2;
        };
      }, $c = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator", sz = function(e) {
        return function(t2) {
          for (var n2 = e[$c](); ; ) {
            var r = void 0;
            try {
              r = n2.next();
            } catch (e2) {
              return t2.error(e2), t2;
            }
            if (r.done) {
              t2.complete();
              break;
            }
            if (t2.next(r.value), t2.closed) break;
          }
          return "function" == typeof n2.return && t2.add(function() {
            n2.return && n2.return();
          }), t2;
        };
      }, tz = function(e) {
        return function(t2) {
          var n2 = e[ne]();
          if ("function" != typeof n2.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
          return n2.subscribe(t2);
        };
      }, hm = function(e) {
        return e && "number" == typeof e.length && "function" != typeof e;
      }, pf = function(e) {
        if (e && "function" == typeof e[ne]) return tz(e);
        if (hm(e)) return am(e);
        if (fm(e)) return rz(e);
        if (e && "function" == typeof e[$c]) return sz(e);
        throw e = ei(e) ? "an invalid object" : "'" + e + "'", new TypeError("You provided " + e + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.");
      }, Hq = {}, vz = function() {
        function e(e2) {
          this.resultSelector = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new uz(e2, this.resultSelector));
        }, e;
      }(), uz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).resultSelector = n2, t3.active = 0, t3.values = [], t3.observables = [], t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.values.push(Hq), this.observables.push(e2);
        }, t2.prototype._complete = function() {
          var e2 = this.observables, t3 = e2.length;
          if (0 === t3) this.destination.complete();
          else {
            this.toRespond = this.active = t3;
            for (var n2 = 0; n2 < t3; n2++) this.add(ji(this, e2[n2], void 0, n2));
          }
        }, t2.prototype.notifyComplete = function(e2) {
          0 == --this.active && this.destination.complete();
        }, t2.prototype.notifyNext = function(e2, t3, n2) {
          var r = (e2 = this.values)[n2];
          r = this.toRespond ? r === Hq ? --this.toRespond : this.toRespond : 0, e2[n2] = t3, 0 === r && (this.resultSelector ? this._tryResultSelector(e2) : this.destination.next(e2.slice()));
        }, t2.prototype._tryResultSelector = function(e2) {
          try {
            var t3 = this.resultSelector.apply(this, e2);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.destination.next(t3);
        }, t2;
      }(Rk), vc = function(e) {
        function t2(t3) {
          var n2 = e.call(this) || this;
          return n2.parent = t3, n2;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.parent.notifyNext(e2);
        }, t2.prototype._error = function(e2) {
          this.parent.notifyError(e2), this.unsubscribe();
        }, t2.prototype._complete = function() {
          this.parent.notifyComplete(), this.unsubscribe();
        }, t2;
      }(ia);
      !function(e) {
        function t2(t3, n2, r) {
          var i = e.call(this) || this;
          return i.parent = t3, i.outerValue = n2, i.outerIndex = r, i;
        }
        O(t2, e), t2.prototype._next = function(e2) {
          this.parent.notifyNext(this.outerValue, e2, this.outerIndex, this);
        }, t2.prototype._error = function(e2) {
          this.parent.notifyError(e2), this.unsubscribe();
        }, t2.prototype._complete = function() {
          this.parent.notifyComplete(this), this.unsubscribe();
        };
      }(ia);
      var wc = function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        return O(t2, e), t2.prototype.notifyNext = function(e2) {
          this.destination.next(e2);
        }, t2.prototype.notifyError = function(e2) {
          this.destination.error(e2);
        }, t2.prototype.notifyComplete = function() {
          this.destination.complete();
        }, t2;
      }(ia);
      !function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        O(t2, e), t2.prototype.notifyNext = function(e2, t3, n2, r) {
          this.destination.next(t3);
        }, t2.prototype.notifyError = function(e2) {
          this.destination.error(e2);
        }, t2.prototype.notifyComplete = function(e2) {
          this.destination.complete();
        };
      }(ia);
      var at = function() {
        function e(e2, t2) {
          void 0 === t2 && (t2 = Number.POSITIVE_INFINITY), this.project = e2, this.concurrent = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new wz(e2, this.project, this.concurrent));
        }, e;
      }(), wz = function(e) {
        function t2(t3, n2, r) {
          return void 0 === r && (r = Number.POSITIVE_INFINITY), (t3 = e.call(this, t3) || this).project = n2, t3.concurrent = r, t3.hasCompleted = false, t3.buffer = [], t3.active = 0, t3.index = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.active < this.concurrent ? this._tryNext(e2) : this.buffer.push(e2);
        }, t2.prototype._tryNext = function(e2) {
          var t3 = this.index++;
          try {
            var n2 = this.project(e2, t3);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.active++, this._innerSub(n2);
        }, t2.prototype._innerSub = function(e2) {
          var t3 = new vc(this), n2 = this.destination;
          n2.add(t3), (e2 = ic(e2, t3)) !== t3 && n2.add(e2);
        }, t2.prototype._complete = function() {
          this.hasCompleted = true, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe();
        }, t2.prototype.notifyNext = function(e2) {
          this.destination.next(e2);
        }, t2.prototype.notifyComplete = function() {
          var e2 = this.buffer;
          this.active--, 0 < e2.length ? this._next(e2.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete();
        }, t2;
      }(wc), Sk = y.parseFloat, Iq = -1 / 0 != 1 / Sk("	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF-0") ? function(e) {
        e = ik(String(e));
        var t2 = Sk(e);
        return 0 === t2 && "-" == e.charAt(0) ? -0 : t2;
      } : Sk;
      N({ global: true, forced: parseFloat != Iq }, { parseFloat: Iq });
      var Tk = new Y(hc), ft = function() {
        function e(e2, t2) {
          this.predicate = e2, this.thisArg = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new xz(e2, this.predicate, this.thisArg));
        }, e;
      }(), xz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).predicate = n2, t3.thisArg = r, t3.count = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          try {
            var t3 = this.predicate.call(this.thisArg, e2, this.count++);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          t3 && this.destination.next(e2);
        }, t2;
      }(ia), gt = function() {
        function e() {
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new yz(e2));
        }, e;
      }(), yz = function(e) {
        function t2(t3) {
          return (t3 = e.call(this, t3) || this).hasFirst = false, t3.observables = [], t3.subscriptions = [], t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.observables.push(e2);
        }, t2.prototype._complete = function() {
          var e2 = this.observables, t3 = e2.length;
          if (0 === t3) this.destination.complete();
          else {
            for (var n2 = 0; n2 < t3 && !this.hasFirst; n2++) {
              var r = ji(this, e2[n2], void 0, n2);
              this.subscriptions && this.subscriptions.push(r), this.add(r);
            }
            this.observables = null;
          }
        }, t2.prototype.notifyNext = function(e2, t3, n2) {
          if (!this.hasFirst) {
            for (this.hasFirst = true, e2 = 0; e2 < this.subscriptions.length; e2++) if (e2 !== n2) {
              var r = this.subscriptions[e2];
              r.unsubscribe(), this.remove(r);
            }
            this.subscriptions = null;
          }
          this.destination.next(t3);
        }, t2;
      }(Rk), jt = function() {
        function e(e2) {
          this.resultSelector = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new zz(e2, this.resultSelector));
        }, e;
      }(), zz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).resultSelector = n2, t3.iterators = [], t3.active = 0, t3.resultSelector = "function" == typeof n2 ? n2 : void 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          var t3 = this.iterators;
          Jb(e2) ? t3.push(new Az(e2)) : "function" == typeof e2[$c] ? t3.push(new Bz(e2[$c]())) : t3.push(new Cz(this.destination, this, e2));
        }, t2.prototype._complete = function() {
          var e2 = this.iterators, t3 = e2.length;
          if (this.unsubscribe(), 0 === t3) this.destination.complete();
          else {
            this.active = t3;
            for (var n2 = 0; n2 < t3; n2++) {
              var r = e2[n2];
              r.stillUnsubscribed ? this.destination.add(r.subscribe()) : this.active--;
            }
          }
        }, t2.prototype.notifyInactive = function() {
          this.active--, 0 === this.active && this.destination.complete();
        }, t2.prototype.checkIterators = function() {
          for (var e2 = this.iterators, t3 = e2.length, n2 = this.destination, r = 0; r < t3; r++) {
            var i = e2[r];
            if ("function" == typeof i.hasValue && !i.hasValue()) return;
          }
          var o = false, a2 = [];
          for (r = 0; r < t3; r++) {
            var s = (i = e2[r]).next();
            if (i.hasCompleted() && (o = true), s.done) return void n2.complete();
            a2.push(s.value);
          }
          this.resultSelector ? this._tryresultSelector(a2) : n2.next(a2), o && n2.complete();
        }, t2.prototype._tryresultSelector = function(e2) {
          try {
            var t3 = this.resultSelector.apply(this, e2);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.destination.next(t3);
        }, t2;
      }(ia), Bz = function() {
        function e(e2) {
          this.iterator = e2, this.nextResult = e2.next();
        }
        return e.prototype.hasValue = function() {
          return true;
        }, e.prototype.next = function() {
          var e2 = this.nextResult;
          return this.nextResult = this.iterator.next(), e2;
        }, e.prototype.hasCompleted = function() {
          var e2 = this.nextResult;
          return !(!e2 || !e2.done);
        }, e;
      }(), Az = function() {
        function e(e2) {
          this.array = e2, this.length = this.index = 0, this.length = e2.length;
        }
        return e.prototype[$c] = function() {
          return this;
        }, e.prototype.next = function(e2) {
          e2 = this.index++;
          var t2 = this.array;
          return e2 < this.length ? { value: t2[e2], done: false } : { value: null, done: true };
        }, e.prototype.hasValue = function() {
          return this.array.length > this.index;
        }, e.prototype.hasCompleted = function() {
          return this.array.length === this.index;
        }, e;
      }(), Cz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).parent = n2, t3.observable = r, t3.stillUnsubscribed = true, t3.buffer = [], t3.isComplete = false, t3;
        }
        return O(t2, e), t2.prototype[$c] = function() {
          return this;
        }, t2.prototype.next = function() {
          var e2 = this.buffer;
          return 0 === e2.length && this.isComplete ? { value: null, done: true } : { value: e2.shift(), done: false };
        }, t2.prototype.hasValue = function() {
          return 0 < this.buffer.length;
        }, t2.prototype.hasCompleted = function() {
          return 0 === this.buffer.length && this.isComplete;
        }, t2.prototype.notifyComplete = function() {
          0 < this.buffer.length ? (this.isComplete = true, this.parent.notifyInactive()) : this.destination.complete();
        }, t2.prototype.notifyNext = function(e2) {
          this.buffer.push(e2), this.parent.checkIterators();
        }, t2.prototype.subscribe = function() {
          return ic(this.observable, new vc(this));
        }, t2;
      }(wc), Dz = Object.freeze({ __proto__: null, Observable: Y, ConnectableObservable: Cq, GroupedObservable: Mk, observable: ne, Subject: Pa, BehaviorSubject: gz, ReplaySubject: qe, AsyncSubject: of, asap: nz, asapScheduler: ri, async: bd, asyncScheduler: Pk, queue: fg, queueScheduler: fg, animationFrame: Fq, animationFrameScheduler: Fq, VirtualTimeScheduler: pz, VirtualAction: Gq, Scheduler: Nk, Subscription: Oa, Subscriber: ia, Notification: Ve, get NotificationKind() {
        return Ok;
      }, pipe: gi, noop: hc, identity: Yc, isObservable: function(e) {
        return !!e && (e instanceof Y || "function" == typeof e.lift && "function" == typeof e.subscribe);
      }, ArgumentOutOfRangeError: Qk, EmptyError: vg, ObjectUnsubscribedError: qd, UnsubscriptionError: lf, TimeoutError: pb, bindCallback: cm, bindNodeCallback: dm, combineLatest: function() {
        for (var e = [], t2 = 0; t2 < arguments.length; t2++) e[t2] = arguments[t2];
        var n2 = t2 = void 0;
        return Zc(e[e.length - 1]) && (n2 = e.pop()), "function" == typeof e[e.length - 1] && (t2 = e.pop()), 1 === e.length && Jb(e[0]) && (e = e[0]), nf(e, n2).lift(new vz(t2));
      }, concat: im, defer: ad, empty: mf, forkJoin: jm, from: Kb, fromEvent: gb, fromEventPattern: lm, generate: function(e, t2, n2, r, i) {
        if (1 == arguments.length) {
          var o = e.initialState;
          t2 = e.condition, n2 = e.iterate;
          var a2 = e.resultSelector || Yc;
          i = e.scheduler;
        } else void 0 === r || Zc(r) ? (o = e, a2 = Yc, i = r) : (o = e, a2 = r);
        return new Y(function(e2) {
          var r2 = o;
          if (i) return i.schedule(bt, 0, { subscriber: e2, iterate: n2, condition: t2, resultSelector: a2, state: r2 });
          for (; ; ) {
            if (t2) {
              var s = void 0;
              try {
                s = t2(r2);
              } catch (t3) {
                e2.error(t3);
                break;
              }
              if (!s) {
                e2.complete();
                break;
              }
            }
            s = void 0;
            try {
              s = a2(r2);
            } catch (t3) {
              e2.error(t3);
              break;
            }
            if (e2.next(s), e2.closed) break;
            try {
              r2 = n2(r2);
            } catch (t3) {
              e2.error(t3);
              break;
            }
          }
        });
      }, iif: function(e, t2, n2) {
        return void 0 === t2 && (t2 = vb), void 0 === n2 && (n2 = vb), ad(function() {
          return e() ? t2 : n2;
        });
      }, interval: mm, merge: Xb, never: function() {
        return Tk;
      }, of: bb, onErrorResumeNext: li, pairs: function(e, t2) {
        return new Y(t2 ? function(n2) {
          var r = Object.keys(e), i = new Oa();
          return i.add(t2.schedule(dt, 0, { keys: r, index: 0, subscriber: n2, subscription: i, obj: e })), i;
        } : function(t3) {
          for (var n2 = Object.keys(e), r = 0; r < n2.length && !t3.closed; r++) {
            var i = n2[r];
            e.hasOwnProperty(i) && t3.next([i, e[i]]);
          }
          t3.complete();
        });
      }, partition: function(e, t2, n2) {
        return [wb(t2, n2)(new Y(pf(e))), wb(et(t2, n2))(new Y(pf(e)))];
      }, race: Ca, range: function(e, t2, n2) {
        return void 0 === e && (e = 0), new Y(function(r) {
          void 0 === t2 && (t2 = e, e = 0);
          var i = 0, o = e;
          if (n2) return n2.schedule(ht, 0, { index: i, count: t2, start: e, subscriber: r });
          for (; ; ) {
            if (i++ >= t2) {
              r.complete();
              break;
            }
            if (r.next(o++), r.closed) break;
          }
        });
      }, throwError: Z, timer: Bc, using: function(e, t2) {
        return new Y(function(n2) {
          try {
            var r = e();
          } catch (e2) {
            return void n2.error(e2);
          }
          try {
            var i = t2(r);
          } catch (e2) {
            return void n2.error(e2);
          }
          var o = (i ? Kb(i) : vb).subscribe(n2);
          return function() {
            o.unsubscribe(), r && r.unsubscribe();
          };
        });
      }, zip: mi, scheduled: gm, EMPTY: vb, NEVER: Tk, config: Ib }), kt = function() {
        function e(e2) {
          this.selector = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Ez(e2, this.selector, this.caught));
        }, e;
      }(), Ez = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).selector = n2, t3.caught = r, t3;
        }
        return O(t2, e), t2.prototype.error = function(t3) {
          if (!this.isStopped) {
            var n2 = void 0;
            try {
              n2 = this.selector(t3, this.caught);
            } catch (t4) {
              return void e.prototype.error.call(this, t4);
            }
            this._unsubscribeAndRecycle(), t3 = new vc(this), this.add(t3), (n2 = ic(n2, t3)) !== t3 && this.add(n2);
          }
        }, t2;
      }(wc), lt = function() {
        function e(e2) {
          this.defaultValue = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Fz(e2, this.defaultValue));
        }, e;
      }(), Fz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).defaultValue = n2, t3.isEmpty = true, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.isEmpty = false, this.destination.next(e2);
        }, t2.prototype._complete = function() {
          this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
        }, t2;
      }(ia), mt = function() {
        function e(e2, t2) {
          this.delay = e2, this.scheduler = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Gz(e2, this.delay, this.scheduler));
        }, e;
      }(), Gz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).delay = n2, t3.scheduler = r, t3.queue = [], t3.active = false, t3.errored = false, t3;
        }
        return O(t2, e), t2.dispatch = function(e2) {
          for (var t3 = e2.source, n2 = t3.queue, r = e2.scheduler, i = e2.destination; 0 < n2.length && 0 >= n2[0].time - r.now(); ) n2.shift().notification.observe(i);
          0 < n2.length ? (t3 = Math.max(0, n2[0].time - r.now()), this.schedule(e2, t3)) : (this.unsubscribe(), t3.active = false);
        }, t2.prototype._schedule = function(e2) {
          this.active = true, this.destination.add(e2.schedule(t2.dispatch, this.delay, { source: this, destination: this.destination, scheduler: e2 }));
        }, t2.prototype.scheduleNotification = function(e2) {
          if (true !== this.errored) {
            var t3 = this.scheduler;
            e2 = new Hz(t3.now() + this.delay, e2), this.queue.push(e2), false === this.active && this._schedule(t3);
          }
        }, t2.prototype._next = function(e2) {
          this.scheduleNotification(Ve.createNext(e2));
        }, t2.prototype._error = function(e2) {
          this.errored = true, this.queue = [], this.destination.error(e2), this.unsubscribe();
        }, t2.prototype._complete = function() {
          this.scheduleNotification(Ve.createComplete()), this.unsubscribe();
        }, t2;
      }(ia), Hz = function(e, t2) {
        this.time = e, this.notification = t2;
      }, nt = function() {
        function e(e2, t2) {
          this.keySelector = e2, this.flushes = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Iz(e2, this.keySelector, this.flushes));
        }, e;
      }(), Iz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).keySelector = n2, t3.values = /* @__PURE__ */ new Set(), r && t3.add(ic(r, new vc(t3))), t3;
        }
        return O(t2, e), t2.prototype.notifyNext = function() {
          this.values.clear();
        }, t2.prototype.notifyError = function(e2) {
          this._error(e2);
        }, t2.prototype._next = function(e2) {
          this.keySelector ? this._useKeySelector(e2) : this._finalizeNext(e2, e2);
        }, t2.prototype._useKeySelector = function(e2) {
          var t3 = this.destination;
          try {
            var n2 = this.keySelector(e2);
          } catch (e3) {
            return void t3.error(e3);
          }
          this._finalizeNext(n2, e2);
        }, t2.prototype._finalizeNext = function(e2, t3) {
          var n2 = this.values;
          n2.has(e2) || (n2.add(e2), this.destination.next(t3));
        }, t2;
      }(wc), pt = function() {
        function e(e2) {
          this.errorFactory = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Jz(e2, this.errorFactory));
        }, e;
      }(), Jz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).errorFactory = n2, t3.hasValue = false, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.hasValue = true, this.destination.next(e2);
        }, t2.prototype._complete = function() {
          if (this.hasValue) return this.destination.complete();
          var e2 = void 0;
          try {
            e2 = this.errorFactory();
          } catch (t3) {
            e2 = t3;
          }
          this.destination.error(e2);
        }, t2;
      }(ia), qt = function() {
        function e(e2) {
          if (this.total = e2, 0 > this.total) throw new Qk();
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Kz(e2, this.total));
        }, e;
      }(), Kz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).total = n2, t3.count = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          var t3 = this.total, n2 = ++this.count;
          n2 <= t3 && (this.destination.next(e2), n2 === t3 && (this.destination.complete(), this.unsubscribe()));
        }, t2;
      }(ia), rt = function() {
        function e(e2) {
          this.project = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Lz(e2, this.project));
        }, e;
      }(), Lz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).project = n2, t3.hasSubscription = false, t3.hasCompleted = false, t3.index = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.hasSubscription || this.tryNext(e2);
        }, t2.prototype.tryNext = function(e2) {
          var t3 = this.index++;
          try {
            var n2 = this.project(e2, t3);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.hasSubscription = true, this._innerSub(n2);
        }, t2.prototype._innerSub = function(e2) {
          var t3 = new vc(this), n2 = this.destination;
          n2.add(t3), (e2 = ic(e2, t3)) !== t3 && n2.add(e2);
        }, t2.prototype._complete = function() {
          this.hasCompleted = true, this.hasSubscription || this.destination.complete(), this.unsubscribe();
        }, t2.prototype.notifyNext = function(e2) {
          this.destination.next(e2);
        }, t2.prototype.notifyError = function(e2) {
          this.destination.error(e2);
        }, t2.prototype.notifyComplete = function() {
          this.hasSubscription = false, this.hasCompleted && this.destination.complete();
        }, t2;
      }(wc), st = function() {
        function e(e2) {
          this.callback = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Mz(e2, this.callback));
        }, e;
      }(), Mz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).add(new Oa(n2)), t3;
        }
        return O(t2, e), t2;
      }(ia), ut = function() {
        function e() {
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Nz(e2));
        }, e;
      }(), Nz = function(e) {
        function t2() {
          return null !== e && e.apply(this, arguments) || this;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
        }, t2;
      }(ia), vt = function() {
        function e(e2) {
          if (this.total = e2, 0 > this.total) throw new Qk();
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Oz(e2, this.total));
        }, e;
      }(), Oz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).total = n2, t3.ring = [], t3.count = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          var t3 = this.ring, n2 = this.total, r = this.count++;
          t3.length < n2 ? t3.push(e2) : t3[r % n2] = e2;
        }, t2.prototype._complete = function() {
          var e2 = this.destination, t3 = this.count;
          if (0 < t3) for (var n2 = this.count >= this.total ? this.total : this.count, r = this.ring, i = 0; i < n2; i++) {
            var o = t3++ % n2;
            e2.next(r[o]);
          }
          e2.complete();
        }, t2;
      }(ia), wt = function() {
        function e(e2) {
          this.value = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Pz(e2, this.value));
        }, e;
      }(), Pz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).value = n2, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.destination.next(this.value);
        }, t2;
      }(ia), xt = function() {
        function e(e2, t2, n2) {
          void 0 === n2 && (n2 = false), this.accumulator = e2, this.seed = t2, this.hasSeed = n2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Qz(e2, this.accumulator, this.seed, this.hasSeed));
        }, e;
      }(), Qz = function(e) {
        function t2(t3, n2, r, i) {
          return (t3 = e.call(this, t3) || this).accumulator = n2, t3._seed = r, t3.hasSeed = i, t3.index = 0, t3;
        }
        return O(t2, e), Object.defineProperty(t2.prototype, "seed", { get: function() {
          return this._seed;
        }, set: function(e2) {
          this.hasSeed = true, this._seed = e2;
        }, enumerable: true, configurable: true }), t2.prototype._next = function(e2) {
          if (this.hasSeed) return this._tryNext(e2);
          this.seed = e2, this.destination.next(e2);
        }, t2.prototype._tryNext = function(e2) {
          var t3 = this.index++;
          try {
            var n2 = this.accumulator(this.seed, e2, t3);
          } catch (e3) {
            this.destination.error(e3);
          }
          this.seed = n2, this.destination.next(n2);
        }, t2;
      }(ia), zt = function() {
        function e(e2, t2) {
          this.subjectFactory = e2, this.selector = t2;
        }
        return e.prototype.call = function(e2, t2) {
          var n2 = this.selector, r = this.subjectFactory();
          return (e2 = n2(r).subscribe(e2)).add(t2.subscribe(r)), e2;
        }, e;
      }(), Bt = function() {
        function e(e2, t2) {
          this.notifier = e2, this.source = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Rz(e2, this.notifier, this.source));
        }, e;
      }(), Rz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).notifier = n2, t3.source = r, t3;
        }
        return O(t2, e), t2.prototype.error = function(t3) {
          if (!this.isStopped) {
            var n2 = this.errors, r = this.retries, i = this.retriesSubscription;
            if (r) this.retriesSubscription = this.errors = void 0;
            else {
              n2 = new Pa();
              try {
                r = (0, this.notifier)(n2);
              } catch (t4) {
                return e.prototype.error.call(this, t4);
              }
              i = ic(r, new vc(this));
            }
            this._unsubscribeAndRecycle(), this.errors = n2, this.retries = r, this.retriesSubscription = i, n2.next(t3);
          }
        }, t2.prototype._unsubscribe = function() {
          var e2 = this.errors, t3 = this.retriesSubscription;
          e2 && (e2.unsubscribe(), this.errors = void 0), t3 && (t3.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
        }, t2.prototype.notifyNext = function() {
          var e2 = this._unsubscribe;
          this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = e2, this.source.subscribe(this);
        }, t2;
      }(wc), Et = function() {
        function e(e2) {
          this.project = e2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Sz(e2, this.project));
        }, e;
      }(), Sz = function(e) {
        function t2(t3, n2) {
          return (t3 = e.call(this, t3) || this).project = n2, t3.index = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          var t3 = this.index++;
          try {
            var n2 = this.project(e2, t3);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this._innerSub(n2);
        }, t2.prototype._innerSub = function(e2) {
          var t3 = this.innerSubscription;
          t3 && t3.unsubscribe(), t3 = new vc(this);
          var n2 = this.destination;
          n2.add(t3), this.innerSubscription = ic(e2, t3), this.innerSubscription !== t3 && n2.add(this.innerSubscription);
        }, t2.prototype._complete = function() {
          var t3 = this.innerSubscription;
          t3 && !t3.closed || e.prototype._complete.call(this), this.unsubscribe();
        }, t2.prototype._unsubscribe = function() {
          this.innerSubscription = void 0;
        }, t2.prototype.notifyComplete = function() {
          this.innerSubscription = void 0, this.isStopped && e.prototype._complete.call(this);
        }, t2.prototype.notifyNext = function(e2) {
          this.destination.next(e2);
        }, t2;
      }(wc), Ft = function() {
        function e(e2) {
          this.notifier = e2;
        }
        return e.prototype.call = function(e2, t2) {
          e2 = new Tz(e2);
          var n2 = ic(this.notifier, new vc(e2));
          return n2 && !e2.seenValue ? (e2.add(n2), t2.subscribe(e2)) : e2;
        }, e;
      }(), Tz = function(e) {
        function t2(t3) {
          return (t3 = e.call(this, t3) || this).seenValue = false, t3;
        }
        return O(t2, e), t2.prototype.notifyNext = function() {
          this.seenValue = true, this.complete();
        }, t2.prototype.notifyComplete = function() {
        }, t2;
      }(wc), Ht = function() {
        function e(e2, t2) {
          this.predicate = e2, this.inclusive = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Uz(e2, this.predicate, this.inclusive));
        }, e;
      }(), Uz = function(e) {
        function t2(t3, n2, r) {
          return (t3 = e.call(this, t3) || this).predicate = n2, t3.inclusive = r, t3.index = 0, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          var t3 = this.destination;
          try {
            var n2 = this.predicate(e2, this.index++);
          } catch (e3) {
            return void t3.error(e3);
          }
          this.nextOrComplete(e2, n2);
        }, t2.prototype.nextOrComplete = function(e2, t3) {
          var n2 = this.destination;
          t3 ? n2.next(e2) : (this.inclusive && n2.next(e2), n2.complete());
        }, t2;
      }(ia), It = function() {
        function e(e2, t2, n2) {
          this.nextOrObserver = e2, this.error = t2, this.complete = n2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Vz(e2, this.nextOrObserver, this.error, this.complete));
        }, e;
      }(), Vz = function(e) {
        function t2(t3, n2, r, i) {
          return (t3 = e.call(this, t3) || this)._tapNext = hc, t3._tapError = hc, t3._tapComplete = hc, t3._tapError = r || hc, t3._tapComplete = i || hc, le(n2) ? (t3._context = t3, t3._tapNext = n2) : n2 && (t3._context = n2, t3._tapNext = n2.next || hc, t3._tapError = n2.error || hc, t3._tapComplete = n2.complete || hc), t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          try {
            this._tapNext.call(this._context, e2);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.destination.next(e2);
        }, t2.prototype._error = function(e2) {
          try {
            this._tapError.call(this._context, e2);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.destination.error(e2);
        }, t2.prototype._complete = function() {
          try {
            this._tapComplete.call(this._context);
          } catch (e2) {
            return void this.destination.error(e2);
          }
          return this.destination.complete();
        }, t2;
      }(ia), Kt = { leading: true, trailing: false };
      !function(e) {
        function t2(t3, n2, r, i) {
          var o = e.call(this, t3) || this;
          return o.destination = t3, o.durationSelector = n2, o._leading = r, o._trailing = i, o._hasValue = false, o;
        }
        O(t2, e), t2.prototype._next = function(e2) {
          this._hasValue = true, this._sendValue = e2, this._throttled || (this._leading ? this.send() : this.throttle(e2));
        }, t2.prototype.send = function() {
          var e2 = this._sendValue;
          this._hasValue && (this.destination.next(e2), this.throttle(e2)), this._hasValue = false, this._sendValue = void 0;
        }, t2.prototype.throttle = function(e2) {
          (e2 = this.tryDurationSelector(e2)) && this.add(this._throttled = ic(e2, new vc(this)));
        }, t2.prototype.tryDurationSelector = function(e2) {
          try {
            return this.durationSelector(e2);
          } catch (e3) {
            return this.destination.error(e3), null;
          }
        }, t2.prototype.throttlingDone = function() {
          var e2 = this._throttled, t3 = this._trailing;
          e2 && e2.unsubscribe(), this._throttled = void 0, t3 && this.send();
        }, t2.prototype.notifyNext = function() {
          this.throttlingDone();
        }, t2.prototype.notifyComplete = function() {
          this.throttlingDone();
        };
      }(wc);
      for (var Lt = function() {
        function e(e2, t2, n2, r) {
          this.duration = e2, this.scheduler = t2, this.leading = n2, this.trailing = r;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Wz(e2, this.duration, this.scheduler, this.leading, this.trailing));
        }, e;
      }(), Wz = function(e) {
        function t2(t3, n2, r, i, o) {
          return (t3 = e.call(this, t3) || this).duration = n2, t3.scheduler = r, t3.leading = i, t3.trailing = o, t3._hasTrailingValue = false, t3._trailingValue = null, t3;
        }
        return O(t2, e), t2.prototype._next = function(e2) {
          this.throttled ? this.trailing && (this._trailingValue = e2, this._hasTrailingValue = true) : (this.add(this.throttled = this.scheduler.schedule(Mt, this.duration, { subscriber: this })), this.leading ? this.destination.next(e2) : this.trailing && (this._trailingValue = e2, this._hasTrailingValue = true));
        }, t2.prototype._complete = function() {
          this._hasTrailingValue && this.destination.next(this._trailingValue), this.destination.complete();
        }, t2.prototype.clearThrottle = function() {
          var e2 = this.throttled;
          e2 && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = false), e2.unsubscribe(), this.remove(e2), this.throttled = null);
        }, t2;
      }(ia), Ot = function() {
        function e(e2, t2, n2, r) {
          this.waitFor = e2, this.absoluteTimeout = t2, this.withObservable = n2, this.scheduler = r;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Xz(e2, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
        }, e;
      }(), Xz = function(e) {
        function t2(t3, n2, r, i, o) {
          return (t3 = e.call(this, t3) || this).absoluteTimeout = n2, t3.waitFor = r, t3.withObservable = i, t3.scheduler = o, t3.scheduleTimeout(), t3;
        }
        return O(t2, e), t2.dispatchTimeout = function(e2) {
          var t3 = e2.withObservable;
          e2._unsubscribeAndRecycle(), e2.add(ic(t3, new vc(e2)));
        }, t2.prototype.scheduleTimeout = function() {
          var e2 = this.action;
          e2 ? this.action = e2.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(t2.dispatchTimeout, this.waitFor, this));
        }, t2.prototype._next = function(t3) {
          this.absoluteTimeout || this.scheduleTimeout(), e.prototype._next.call(this, t3);
        }, t2.prototype._unsubscribe = function() {
          this.action = void 0, this.withObservable = this.scheduler = null;
        }, t2;
      }(wc), Qt = function() {
        function e(e2, t2) {
          this.observables = e2, this.project = t2;
        }
        return e.prototype.call = function(e2, t2) {
          return t2.subscribe(new Yz(e2, this.observables, this.project));
        }, e;
      }(), Yz = function(e) {
        function t2(t3, n2, r) {
          (t3 = e.call(this, t3) || this).observables = n2, t3.project = r, t3.toRespond = [], r = n2.length, t3.values = Array(r);
          for (var i = 0; i < r; i++) t3.toRespond.push(i);
          for (i = 0; i < r; i++) t3.add(ji(t3, n2[i], void 0, i));
          return t3;
        }
        return O(t2, e), t2.prototype.notifyNext = function(e2, t3, n2) {
          this.values[n2] = t3, 0 < (e2 = this.toRespond).length && (-1 !== (n2 = e2.indexOf(n2)) && e2.splice(n2, 1));
        }, t2.prototype.notifyComplete = function() {
        }, t2.prototype._next = function(e2) {
          0 === this.toRespond.length && (e2 = [e2].concat(this.values), this.project ? this._tryProject(e2) : this.destination.next(e2));
        }, t2.prototype._tryProject = function(e2) {
          try {
            var t3 = this.project.apply(this, e2);
          } catch (e3) {
            return void this.destination.error(e3);
          }
          this.destination.next(t3);
        }, t2;
      }(Rk), Jq = $a(function(e) {
        var t2 = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
        if (t2) {
          var n2 = new Uint8Array(16);
          e.exports = function() {
            return t2(n2), n2;
          };
        } else {
          var r = Array(16);
          e.exports = function() {
            for (var e2, t3 = 0; 16 > t3; t3++) 0 == (3 & t3) && (e2 = 4294967296 * Math.random()), r[t3] = e2 >>> ((3 & t3) << 3) & 255;
            return r;
          };
        }
      }), ab = [], Gh = 0; 256 > Gh; ++Gh) ab[Gh] = (Gh + 256).toString(16).substr(1);
      var Kq = function(e, t2) {
        return t2 = t2 || 0, [ab[e[t2++]], ab[e[t2++]], ab[e[t2++]], ab[e[t2++]], "-", ab[e[t2++]], ab[e[t2++]], "-", ab[e[t2++]], ab[e[t2++]], "-", ab[e[t2++]], ab[e[t2++]], "-", ab[e[t2++]], ab[e[t2++]], ab[e[t2++]], ab[e[t2++]], ab[e[t2++]], ab[e[t2++]]].join("");
      }, Ud = function(e, t2, n2) {
        if (n2 = t2 && n2 || 0, "string" == typeof e && (t2 = "binary" === e ? Array(16) : null, e = null), (e = (e = e || {}).random || (e.rng || Jq)())[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128, t2) for (var r = 0; 16 > r; ++r) t2[n2 + r] = e[r];
        return t2 || Kq(e);
      }, gg = Ud(), Uk = false, Pc, rd, Vk, Wk, sd, Vd, ec, We, Rb, Xk, Qc, Wd, Rc, Sc, Tc, Xe, Uc, Vc;
      !function(e) {
        e[e.ATTRIBUTE_OPERATION_ERR_FAILURE = 2] = "ATTRIBUTE_OPERATION_ERR_FAILURE", e[e.ATTRIBUTE_OPERATION_ERR_INVALID_ARGUMENT = 3] = "ATTRIBUTE_OPERATION_ERR_INVALID_ARGUMENT", e[e.ATTRIBUTE_OPERATION_ERR_SIZE_OVERFLOW = 4] = "ATTRIBUTE_OPERATION_ERR_SIZE_OVERFLOW", e[e.ATTRIBUTE_OPERATION_ERR_TOO_OFTEN = 5] = "ATTRIBUTE_OPERATION_ERR_TOO_OFTEN", e[e.ATTRIBUTE_OPERATION_ERR_USER_NOT_FOUND = 6] = "ATTRIBUTE_OPERATION_ERR_USER_NOT_FOUND", e[e.ATTRIBUTE_OPERATION_ERR_TIMEOUT = 7] = "ATTRIBUTE_OPERATION_ERR_TIMEOUT", e[e.ATTRIBUTE_OPERATION_ERR_USER_NOT_LOGGED_IN = 102] = "ATTRIBUTE_OPERATION_ERR_USER_NOT_LOGGED_IN";
      }(Pc || (Pc = {})), function(e) {
        e[e.CHANNEL_MESSAGE_ERR_FAILURE = 1] = "CHANNEL_MESSAGE_ERR_FAILURE", e[e.CHANNEL_MESSAGE_ERR_TIMEOUT = 2] = "CHANNEL_MESSAGE_ERR_TIMEOUT", e[e.CHANNEL_MESSAGE_ERR_TOO_OFTEN = 3] = "CHANNEL_MESSAGE_ERR_TOO_OFTEN", e[e.CHANNEL_MESSAGE_ERR_INVALID_MESSAGE = 4] = "CHANNEL_MESSAGE_ERR_INVALID_MESSAGE", e[e.CHANNEL_MESSAGE_ERR_NOT_IN_CHANNEL = 5] = "CHANNEL_MESSAGE_ERR_NOT_IN_CHANNEL", e[e.CHANNEL_MESSAGE_ERR_USER_NOT_LOGGED_IN = 102] = "CHANNEL_MESSAGE_ERR_USER_NOT_LOGGED_IN";
      }(rd || (rd = {})), function(e) {
        e[e.CREATE_CHANNEL_ERR_INVALID_ARGUMENT = 1] = "CREATE_CHANNEL_ERR_INVALID_ARGUMENT";
      }(Vk || (Vk = {})), function(e) {
        e[e.CREATE_INSTANCE_ERR_INVALID_ARGUMENT = 1] = "CREATE_INSTANCE_ERR_INVALID_ARGUMENT";
      }(Wk || (Wk = {})), function(e) {
        e[e.GET_MEMBERS_ERR_FAILURE = 1] = "GET_MEMBERS_ERR_FAILURE", e[e.GET_MEMBERS_ERR_REJECTED = 2] = "GET_MEMBERS_ERR_REJECTED", e[e.GET_MEMBERS_ERR_TIMEOUT = 3] = "GET_MEMBERS_ERR_TIMEOUT", e[e.GET_MEMBERS_ERR_TOO_OFTEN = 4] = "GET_MEMBERS_ERR_TOO_OFTEN", e[e.GET_MEMBERS_ERR_NOT_IN_CHANNEL = 5] = "GET_MEMBERS_ERR_NOT_IN_CHANNEL", e[e.GET_MEMBERS_ERR_USER_NOT_LOGGED_IN = 102] = "GET_MEMBERS_ERR_USER_NOT_LOGGED_IN";
      }(sd || (sd = {})), function(e) {
        e[e.INVITATION_API_CALL_ERR_INVALID_ARGUMENT = 1] = "INVITATION_API_CALL_ERR_INVALID_ARGUMENT", e[e.INVITATION_API_CALL_ERR_NOT_STARTED = 2] = "INVITATION_API_CALL_ERR_NOT_STARTED", e[e.INVITATION_API_CALL_ERR_ALREADY_END = 3] = "INVITATION_API_CALL_ERR_ALREADY_END", e[e.INVITATION_API_CALL_ERR_ALREADY_ACCEPT = 4] = "INVITATION_API_CALL_ERR_ALREADY_ACCEPT", e[e.INVITATION_API_CALL_ERR_ALREADY_SENT = 5] = "INVITATION_API_CALL_ERR_ALREADY_SENT";
      }(Vd || (Vd = {})), function(e) {
        e[e.JOIN_CHANNEL_ERR_FAILURE = 1] = "JOIN_CHANNEL_ERR_FAILURE", e[e.JOIN_CHANNEL_ERR_REJECTED = 2] = "JOIN_CHANNEL_ERR_REJECTED", e[e.JOIN_CHANNEL_ERR_INVALID_ARGUMENT = 3] = "JOIN_CHANNEL_ERR_INVALID_ARGUMENT", e[e.JOIN_CHANNEL_TIMEOUT = 4] = "JOIN_CHANNEL_TIMEOUT", e[e.JOIN_CHANNEL_ERR_EXCEED_LIMIT = 5] = "JOIN_CHANNEL_ERR_EXCEED_LIMIT", e[e.JOIN_CHANNEL_ERR_ALREADY_JOINED = 6] = "JOIN_CHANNEL_ERR_ALREADY_JOINED", e[e.JOIN_CHANNEL_ERR_TOO_OFTEN = 7] = "JOIN_CHANNEL_ERR_TOO_OFTEN", e[e.JOIN_CHANNEL_ERR_JOIN_SAME_CHANNEL_TOO_OFTEN = 8] = "JOIN_CHANNEL_ERR_JOIN_SAME_CHANNEL_TOO_OFTEN", e[e.JOIN_CHANNEL_ERR_USER_NOT_LOGGED_IN = 102] = "JOIN_CHANNEL_ERR_USER_NOT_LOGGED_IN", e[e.JOIN_CHANNEL_ERR_ABORTED_BY_LEAVE = 201] = "JOIN_CHANNEL_ERR_ABORTED_BY_LEAVE", e[e.JOIN_CHANNEL_ERR_ALREADY_JOINED_CHANNEL_OF_SAME_ID = 202] = "JOIN_CHANNEL_ERR_ALREADY_JOINED_CHANNEL_OF_SAME_ID";
      }(ec || (ec = {})), function(e) {
        e[e.LEAVE_CHANNEL_ERR_FAILURE = 1] = "LEAVE_CHANNEL_ERR_FAILURE", e[e.LEAVE_CHANNEL_ERR_REJECTED = 2] = "LEAVE_CHANNEL_ERR_REJECTED", e[e.LEAVE_CHANNEL_ERR_NOT_IN_CHANNEL = 3] = "LEAVE_CHANNEL_ERR_NOT_IN_CHANNEL", e[e.LEAVE_CHANNEL_ERR_USER_NOT_LOGGED_IN = 102] = "LEAVE_CHANNEL_ERR_USER_NOT_LOGGED_IN";
      }(We || (We = {})), function(e) {
        e[e.LOGIN_ERR_UNKNOWN = 1] = "LOGIN_ERR_UNKNOWN", e[e.LOGIN_ERR_REJECTED = 2] = "LOGIN_ERR_REJECTED", e[e.LOGIN_ERR_INVALID_ARGUMENT = 3] = "LOGIN_ERR_INVALID_ARGUMENT", e[e.LOGIN_ERR_INVALID_APP_ID = 4] = "LOGIN_ERR_INVALID_APP_ID", e[e.LOGIN_ERR_INVALID_TOKEN = 5] = "LOGIN_ERR_INVALID_TOKEN", e[e.LOGIN_ERR_TOKEN_EXPIRED = 6] = "LOGIN_ERR_TOKEN_EXPIRED", e[e.LOGIN_ERR_NOT_AUTHORIZED = 7] = "LOGIN_ERR_NOT_AUTHORIZED", e[e.LOGIN_ERR_ALREADY_LOGIN = 8] = "LOGIN_ERR_ALREADY_LOGIN", e[e.LOGIN_ERR_TIMEOUT = 9] = "LOGIN_ERR_TIMEOUT", e[e.LOGIN_ERR_TOO_OFTEN = 10] = "LOGIN_ERR_TOO_OFTEN", e[e.LOGIN_ERR_ABORTED_BY_LOGOUT = 201] = "LOGIN_ERR_ABORTED_BY_LOGOUT";
      }(Rb || (Rb = {})), function(e) {
        e[e.LOGOUT_ERR_USER_NOT_LOGGED_IN = 102] = "LOGOUT_ERR_USER_NOT_LOGGED_IN";
      }(Xk || (Xk = {})), function(e) {
        e[e.PEER_MESSAGE_ERR_FAILURE = 1] = "PEER_MESSAGE_ERR_FAILURE", e[e.PEER_MESSAGE_ERR_TIMEOUT = 2] = "PEER_MESSAGE_ERR_TIMEOUT", e[e.PEER_MESSAGE_ERR_TOO_OFTEN = 5] = "PEER_MESSAGE_ERR_TOO_OFTEN", e[e.PEER_MESSAGE_ERR_INVALID_USERID = 6] = "PEER_MESSAGE_ERR_INVALID_USERID", e[e.PEER_MESSAGE_ERR_INVALID_MESSAGE = 7] = "PEER_MESSAGE_ERR_INVALID_MESSAGE", e[e.PEER_MESSAGE_ERR_INCOMPATIBLE_MESSAGE = 8] = "PEER_MESSAGE_ERR_INCOMPATIBLE_MESSAGE", e[e.PEER_MESSAGE_ERR_USER_NOT_LOGGED_IN = 102] = "PEER_MESSAGE_ERR_USER_NOT_LOGGED_IN";
      }(Qc || (Qc = {})), function(e) {
        e[e.QUERY_PEERS_ONLINE_STATUS_ERR_INVALID_ARGUMENT = 2] = "QUERY_PEERS_ONLINE_STATUS_ERR_INVALID_ARGUMENT", e[e.QUERY_PEERS_ONLINE_STATUS_ERR_REJECTED = 3] = "QUERY_PEERS_ONLINE_STATUS_ERR_REJECTED", e[e.QUERY_PEERS_ONLINE_STATUS_ERR_TIMEOUT = 4] = "QUERY_PEERS_ONLINE_STATUS_ERR_TIMEOUT", e[e.QUERY_PEERS_ONLINE_STATUS_ERR_TOO_OFTEN = 5] = "QUERY_PEERS_ONLINE_STATUS_ERR_TOO_OFTEN", e[e.QUERY_PEERS_ONLINE_STATUS_ERR_USER_NOT_LOGGED_IN = 102] = "QUERY_PEERS_ONLINE_STATUS_ERR_USER_NOT_LOGGED_IN";
      }(Wd || (Wd = {})), function(e) {
        e[e.RENEW_TOKEN_ERR_FAILURE = 1] = "RENEW_TOKEN_ERR_FAILURE", e[e.RENEW_TOKEN_ERR_INVALID_ARGUMENT = 2] = "RENEW_TOKEN_ERR_INVALID_ARGUMENT", e[e.RENEW_TOKEN_ERR_REJECTED = 3] = "RENEW_TOKEN_ERR_REJECTED", e[e.RENEW_TOKEN_ERR_TOO_OFTEN = 4] = "RENEW_TOKEN_ERR_TOO_OFTEN", e[e.RENEW_TOKEN_ERR_TOKEN_EXPIRED = 5] = "RENEW_TOKEN_ERR_TOKEN_EXPIRED", e[e.RENEW_TOKEN_ERR_INVALID_TOKEN = 6] = "RENEW_TOKEN_ERR_INVALID_TOKEN", e[e.RENEW_TOKEN_ERR_USER_NOT_LOGGED_IN = 102] = "RENEW_TOKEN_ERR_USER_NOT_LOGGED_IN", e[e.RENEW_TOKEN_ERR_ABORTED_BY_LOGOUT = 201] = "RENEW_TOKEN_ERR_ABORTED_BY_LOGOUT";
      }(Rc || (Rc = {})), function(e) {
        e[e.GET_CHANNEL_MEMBER_COUNT_ERR_FAILURE = 1] = "GET_CHANNEL_MEMBER_COUNT_ERR_FAILURE", e[e.GET_CHANNEL_MEMBER_COUNT_ERR_INVALID_ARGUMENT = 2] = "GET_CHANNEL_MEMBER_COUNT_ERR_INVALID_ARGUMENT", e[e.GET_CHANNEL_MEMBER_COUNT_ERR_TOO_OFTEN = 3] = "GET_CHANNEL_MEMBER_COUNT_ERR_TOO_OFTEN", e[e.GET_CHANNEL_MEMBER_COUNT_ERR_TIMEOUT = 4] = "GET_CHANNEL_MEMBER_COUNT_ERR_TIMEOUT", e[e.GET_CHANNEL_MEMBER_COUNT_ERR_EXCEED_LIMIT = 5] = "GET_CHANNEL_MEMBER_COUNT_ERR_EXCEED_LIMIT", e[e.GET_CHANNEL_MEMBER_COUNT_ERR_NOT_INITIALIZED = 101] = "GET_CHANNEL_MEMBER_COUNT_ERR_NOT_INITIALIZED", e[e.GET_CHANNEL_MEMBER_COUNT_ERR_USER_NOT_LOGGED_IN = 102] = "GET_CHANNEL_MEMBER_COUNT_ERR_USER_NOT_LOGGED_IN";
      }(Sc || (Sc = {})), function(e) {
        e[e.PEER_SUBSCRIPTION_STATUS_ERR_FAILURE = 1] = "PEER_SUBSCRIPTION_STATUS_ERR_FAILURE", e[e.PEER_SUBSCRIPTION_STATUS_ERR_INVALID_ARGUMENT = 2] = "PEER_SUBSCRIPTION_STATUS_ERR_INVALID_ARGUMENT", e[e.PEER_SUBSCRIPTION_STATUS_ERR_REJECTED = 3] = "PEER_SUBSCRIPTION_STATUS_ERR_REJECTED", e[e.PEER_SUBSCRIPTION_STATUS_ERR_TIMEOUT = 4] = "PEER_SUBSCRIPTION_STATUS_ERR_TIMEOUT", e[e.PEER_SUBSCRIPTION_STATUS_ERR_TOO_OFTEN = 5] = "PEER_SUBSCRIPTION_STATUS_ERR_TOO_OFTEN", e[e.PEER_SUBSCRIPTION_STATUS_ERR_OVERFLOW = 6] = "PEER_SUBSCRIPTION_STATUS_ERR_OVERFLOW", e[e.PEER_SUBSCRIPTION_STATUS_ERR_USER_NOT_LOGGED_IN = 102] = "PEER_SUBSCRIPTION_STATUS_ERR_USER_NOT_LOGGED_IN";
      }(Tc || (Tc = {})), function(e) {
        e[e.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_FAILURE = 1] = "QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_FAILURE", e[e.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TIMEOUT = 2] = "QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TIMEOUT", e[e.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TOO_OFTEN = 3] = "QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TOO_OFTEN", e[e.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_USER_NOT_LOGGED_IN = 102] = "QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_USER_NOT_LOGGED_IN";
      }(Xe || (Xe = {})), function(e) {
        e[e.UPLOAD_MEDIA_ERR_FAILURE = 1] = "UPLOAD_MEDIA_ERR_FAILURE", e[e.UPLOAD_MEDIA_ERR_INVALID_ARGUMENT = 2] = "UPLOAD_MEDIA_ERR_INVALID_ARGUMENT", e[e.UPLOAD_MEDIA_ERR_TIMEOUT = 3] = "UPLOAD_MEDIA_ERR_TIMEOUT", e[e.UPLOAD_MEDIA_ERR_SIZE_OVERFLOW = 4] = "UPLOAD_MEDIA_ERR_SIZE_OVERFLOW", e[e.UPLOAD_MEDIA_ERR_CONCURRENCY_LIMIT_EXCEEDED = 5] = "UPLOAD_MEDIA_ERR_CONCURRENCY_LIMIT_EXCEEDED", e[e.UPLOAD_MEDIA_ERR_INTERRUPTED = 6] = "UPLOAD_MEDIA_ERR_INTERRUPTED", e[e.UPLOAD_MEDIA_ERR_NOT_LOGGED_IN = 102] = "UPLOAD_MEDIA_ERR_NOT_LOGGED_IN";
      }(Uc || (Uc = {})), function(e) {
        e[e.DOWNLOAD_MEDIA_ERR_FAILURE = 1] = "DOWNLOAD_MEDIA_ERR_FAILURE", e[e.DOWNLOAD_MEDIA_ERR_INVALID_ARGUMENT = 2] = "DOWNLOAD_MEDIA_ERR_INVALID_ARGUMENT", e[e.DOWNLOAD_MEDIA_ERR_TIMEOUT = 3] = "DOWNLOAD_MEDIA_ERR_TIMEOUT", e[e.DOWNLOAD_MEDIA_ERR_NOT_EXIST = 4] = "DOWNLOAD_MEDIA_ERR_NOT_EXIST", e[e.DOWNLOAD_MEDIA_ERR_CONCURRENCY_LIMIT_EXCEEDED = 5] = "DOWNLOAD_MEDIA_ERR_CONCURRENCY_LIMIT_EXCEEDED", e[e.DOWNLOAD_MEDIA_ERR_INTERRUPTED = 6] = "DOWNLOAD_MEDIA_ERR_INTERRUPTED", e[e.DOWNLOAD_MEDIA_ERR_NOT_LOGGED_IN = 102] = "DOWNLOAD_MEDIA_ERR_NOT_LOGGED_IN";
      }(Vc || (Vc = {}));
      var Sb = Pc.ATTRIBUTE_OPERATION_ERR_FAILURE, Ja = Pc.ATTRIBUTE_OPERATION_ERR_INVALID_ARGUMENT, se = Pc.ATTRIBUTE_OPERATION_ERR_SIZE_OVERFLOW;
      Pc.ATTRIBUTE_OPERATION_ERR_TOO_OFTEN;
      var Lq = Pc.ATTRIBUTE_OPERATION_ERR_USER_NOT_FOUND, Tb = Pc.ATTRIBUTE_OPERATION_ERR_TIMEOUT, Ub = Pc.ATTRIBUTE_OPERATION_ERR_USER_NOT_LOGGED_IN, hg = rd.CHANNEL_MESSAGE_ERR_FAILURE, Yk = rd.CHANNEL_MESSAGE_ERR_TIMEOUT, Mq = rd.CHANNEL_MESSAGE_ERR_TOO_OFTEN, Hh = rd.CHANNEL_MESSAGE_ERR_INVALID_MESSAGE;
      rd.CHANNEL_MESSAGE_ERR_NOT_IN_CHANNEL;
      var ig = rd.CHANNEL_MESSAGE_ERR_USER_NOT_LOGGED_IN, Zz = Vk.CREATE_CHANNEL_ERR_INVALID_ARGUMENT, Nq = Wk.CREATE_INSTANCE_ERR_INVALID_ARGUMENT;
      Sc.GET_CHANNEL_MEMBER_COUNT_ERR_FAILURE;
      var Oq = Sc.GET_CHANNEL_MEMBER_COUNT_ERR_INVALID_ARGUMENT;
      Sc.GET_CHANNEL_MEMBER_COUNT_ERR_TOO_OFTEN;
      var Pq = Sc.GET_CHANNEL_MEMBER_COUNT_ERR_TIMEOUT, $z = Sc.GET_CHANNEL_MEMBER_COUNT_ERR_EXCEED_LIMIT;
      Sc.GET_CHANNEL_MEMBER_COUNT_ERR_NOT_INITIALIZED;
      var aA = Sc.GET_CHANNEL_MEMBER_COUNT_ERR_USER_NOT_LOGGED_IN, bA = sd.GET_MEMBERS_ERR_FAILURE, cA = sd.GET_MEMBERS_ERR_REJECTED;
      sd.GET_MEMBERS_ERR_TIMEOUT, sd.GET_MEMBERS_ERR_TOO_OFTEN;
      var dA = sd.GET_MEMBERS_ERR_NOT_IN_CHANNEL, eA = sd.GET_MEMBERS_ERR_USER_NOT_LOGGED_IN, xc = Vd.INVITATION_API_CALL_ERR_INVALID_ARGUMENT, fA = Vd.INVITATION_API_CALL_ERR_NOT_STARTED, Ih = Vd.INVITATION_API_CALL_ERR_ALREADY_END, Qq = Vd.INVITATION_API_CALL_ERR_ALREADY_ACCEPT, gA = Vd.INVITATION_API_CALL_ERR_ALREADY_SENT, Rq = ec.JOIN_CHANNEL_ERR_FAILURE;
      ec.JOIN_CHANNEL_ERR_REJECTED;
      var hA = ec.JOIN_CHANNEL_ERR_INVALID_ARGUMENT, Sq = ec.JOIN_CHANNEL_TIMEOUT, Tq = ec.JOIN_CHANNEL_ERR_EXCEED_LIMIT, Uq = ec.JOIN_CHANNEL_ERR_ALREADY_JOINED;
      ec.JOIN_CHANNEL_ERR_TOO_OFTEN;
      var Vq = ec.JOIN_CHANNEL_ERR_USER_NOT_LOGGED_IN, Wq = ec.JOIN_CHANNEL_ERR_ALREADY_JOINED_CHANNEL_OF_SAME_ID, Xq = We.LEAVE_CHANNEL_ERR_FAILURE, Yq = We.LEAVE_CHANNEL_ERR_REJECTED, iA = We.LEAVE_CHANNEL_ERR_NOT_IN_CHANNEL, jA = We.LEAVE_CHANNEL_ERR_USER_NOT_LOGGED_IN, Zq = Rb.LOGIN_ERR_UNKNOWN, jg = Rb.LOGIN_ERR_REJECTED, Jh = Rb.LOGIN_ERR_INVALID_ARGUMENT, $q = Rb.LOGIN_ERR_INVALID_APP_ID, ar = Rb.LOGIN_ERR_INVALID_TOKEN, Kh = Rb.LOGIN_ERR_TOKEN_EXPIRED;
      Rb.LOGIN_ERR_NOT_AUTHORIZED;
      var kA = Rb.LOGIN_ERR_ALREADY_LOGIN, lA = Rb.LOGIN_ERR_TIMEOUT, mA = Rb.LOGIN_ERR_TOO_OFTEN, br = Xk.LOGOUT_ERR_USER_NOT_LOGGED_IN, cr = Qc.PEER_MESSAGE_ERR_FAILURE, Zk = Qc.PEER_MESSAGE_ERR_TIMEOUT, dr = Qc.PEER_MESSAGE_ERR_TOO_OFTEN, $k = Qc.PEER_MESSAGE_ERR_INVALID_USERID, ve = Qc.PEER_MESSAGE_ERR_INVALID_MESSAGE, al = Qc.PEER_MESSAGE_ERR_USER_NOT_LOGGED_IN, nA = Qc.PEER_MESSAGE_ERR_INCOMPATIBLE_MESSAGE, er = Wd.QUERY_PEERS_ONLINE_STATUS_ERR_INVALID_ARGUMENT;
      Wd.QUERY_PEERS_ONLINE_STATUS_ERR_REJECTED;
      var oA = Wd.QUERY_PEERS_ONLINE_STATUS_ERR_TIMEOUT;
      Wd.QUERY_PEERS_ONLINE_STATUS_ERR_TOO_OFTEN;
      var pA = Wd.QUERY_PEERS_ONLINE_STATUS_ERR_USER_NOT_LOGGED_IN, qA = Rc.RENEW_TOKEN_ERR_FAILURE, rA = Rc.RENEW_TOKEN_ERR_INVALID_ARGUMENT;
      Rc.RENEW_TOKEN_ERR_REJECTED, Rc.RENEW_TOKEN_ERR_TOO_OFTEN;
      var sA = Rc.RENEW_TOKEN_ERR_TOKEN_EXPIRED, tA = Rc.RENEW_TOKEN_ERR_INVALID_TOKEN, uA = Rc.RENEW_TOKEN_ERR_USER_NOT_LOGGED_IN, fr = Tc.PEER_SUBSCRIPTION_STATUS_ERR_FAILURE, kg = Tc.PEER_SUBSCRIPTION_STATUS_ERR_INVALID_ARGUMENT;
      Tc.PEER_SUBSCRIPTION_STATUS_ERR_REJECTED;
      var vA = Tc.PEER_SUBSCRIPTION_STATUS_ERR_TIMEOUT;
      Tc.PEER_SUBSCRIPTION_STATUS_ERR_TOO_OFTEN;
      var gr = Tc.PEER_SUBSCRIPTION_STATUS_ERR_OVERFLOW, bl = Tc.PEER_SUBSCRIPTION_STATUS_ERR_USER_NOT_LOGGED_IN;
      Xe.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_FAILURE, Xe.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TIMEOUT, Xe.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_TOO_OFTEN, Xe.QUERY_PEERS_BY_SUBSCRIPTION_OPTION_ERR_USER_NOT_LOGGED_IN;
      var lg = Uc.UPLOAD_MEDIA_ERR_FAILURE, wf = Uc.UPLOAD_MEDIA_ERR_INVALID_ARGUMENT, Lh = Uc.UPLOAD_MEDIA_ERR_TIMEOUT, wA = Uc.UPLOAD_MEDIA_ERR_SIZE_OVERFLOW, xA = Uc.UPLOAD_MEDIA_ERR_CONCURRENCY_LIMIT_EXCEEDED, hr = Uc.UPLOAD_MEDIA_ERR_INTERRUPTED, yA = Uc.UPLOAD_MEDIA_ERR_NOT_LOGGED_IN, mg = Vc.DOWNLOAD_MEDIA_ERR_FAILURE, cl = Vc.DOWNLOAD_MEDIA_ERR_INVALID_ARGUMENT, zA = Vc.DOWNLOAD_MEDIA_ERR_TIMEOUT, AA = Vc.DOWNLOAD_MEDIA_ERR_NOT_EXIST, BA = Vc.DOWNLOAD_MEDIA_ERR_CONCURRENCY_LIMIT_EXCEEDED, ir = Vc.DOWNLOAD_MEDIA_ERR_INTERRUPTED, CA = Vc.DOWNLOAD_MEDIA_ERR_NOT_LOGGED_IN, DA = function(e, t2) {
        var n2;
        return Hk(e, function(e2, r, i) {
          return !(n2 = t2(e2, r, i));
        }), !!n2;
      }, Mh = function(e, t2, n2) {
        if (!lb(n2)) return false;
        var r = X(t2);
        return !!("number" == r ? Ed(n2) && wk(t2, n2.length) : "string" == r && t2 in n2) && $f(n2[t2], e);
      }, dl = function(e, t2, n2) {
        var r = Va(e) ? tq : DA;
        return n2 && Mh(e, t2, n2) && (t2 = void 0), r(e, Te(t2));
      }, EA = function(e, t2) {
        var n2 = -1, r = Ed(e) ? Array(e.length) : [];
        return Hk(e, function(e2, i, o) {
          r[++n2] = t2(e2, i, o);
        }), r;
      }, FA = function(e, t2) {
        var n2 = e.length;
        for (e.sort(t2); n2--; ) e[n2] = e[n2].value;
        return e;
      }, GA = function(e, t2, n2) {
        t2 = t2.length ? he(t2, function(e2) {
          return Va(e2) ? function(t3) {
            return Ch(t3, 1 === e2.length ? e2[0] : e2);
          } : e2;
        }) : [Dh];
        var r = -1;
        return t2 = he(t2, zh(Te)), e = EA(e, function(e2, n3, i) {
          return { criteria: he(t2, function(t3) {
            return t3(e2);
          }), index: ++r, value: e2 };
        }), FA(e, function(e2, t3) {
          e: {
            for (var r2 = -1, i = e2.criteria, o = t3.criteria, a2 = i.length, s = n2.length; ++r2 < a2; ) {
              t: {
                var u2 = i[r2], c2 = o[r2];
                if (u2 !== c2) {
                  var l = void 0 !== u2, f = null === u2, h = u2 == u2, p = ie(u2), d = void 0 !== c2, v2 = null === c2, b = c2 == c2, g = ie(c2);
                  if (!v2 && !g && !p && u2 > c2 || p && d && b && !v2 && !g || f && d && b || !l && b || !h) {
                    u2 = 1;
                    break t;
                  }
                  if (!f && !p && !g && u2 < c2 || g && l && h && !f && !p || v2 && l && h || !d && h || !b) {
                    u2 = -1;
                    break t;
                  }
                }
                u2 = 0;
              }
              if (u2) {
                e2 = r2 >= s ? u2 : u2 * ("desc" == n2[r2] ? -1 : 1);
                break e;
              }
            }
            e2 = e2.index - t3.index;
          }
          return e2;
        });
      }, jr = function(e, t2) {
        return rq(qq(e, t2, Dh), e + "");
      }, kr = jr(function(e, t2) {
        if (null == e) return [];
        var n2 = t2.length;
        return 1 < n2 && Mh(e, t2[0], t2[1]) ? t2 = [] : 2 < n2 && Mh(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), GA(e, $h(t2, 1), []);
      }), lr = function(e) {
        if (e.__esModule) return e;
        var t2 = Object.defineProperty({}, "__esModule", { value: true });
        return Object.keys(e).forEach(function(n2) {
          var r = Object.getOwnPropertyDescriptor(e, n2);
          Object.defineProperty(t2, n2, r.get ? r : { enumerable: true, get: function() {
            return e[n2];
          } });
        }), t2;
      }(Dz), mr = $a(function(e, t2) {
        Object.defineProperty(t2, "__esModule", { value: true });
        var n2 = [], r = function(e2, t3) {
          return new WebSocket(e2, t3);
        };
        t2.normalClosureMessage = "Normal closure", t2.default = function(e2, i) {
          var o = (i = void 0 === i ? { protocols: n2, makeWebSocket: r } : i).protocols, a2 = void 0 === o ? n2 : o, s = void 0 === (i = i.makeWebSocket) ? r : i;
          return new lr.Observable(function(n3) {
            var r2, i2 = new lr.Subject(), o2 = s(e2, a2), u2 = false, c2 = false, l = function(e3) {
              if (r2) throw u2 = true, e3 = Error("Web socket message factory function called more than once"), n3.error(e3), e3;
              return r2 = e3.subscribe(function(e4) {
                o2.send(e4);
              }), i2;
            };
            return o2.onopen = function() {
              c2 ? (u2 = true, o2.close()) : n3.next(l);
            }, o2.onmessage = function(e3) {
              i2.next(e3.data);
            }, o2.onerror = function(e3) {
              u2 = true, n3.error(Error(e3.message));
            }, o2.onclose = function(e3) {
              u2 || (u2 = true, c2 ? (n3.complete(), i2.complete()) : n3.error(Error(1e3 === e3.code ? t2.normalClosureMessage : e3.reason)));
            }, function() {
              c2 = true, r2 && r2.unsubscribe(), u2 || (u2 = true, o2.close());
            };
          });
        };
      });
      !function(e) {
        e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") && e.default;
      }(mr);
      var pi = function(e, t2, n2) {
        (void 0 === n2 || $f(e[t2], n2)) && (void 0 !== n2 || t2 in e) || bg(e, t2, n2);
      }, oi = function(e, t2) {
        if (("constructor" !== t2 || "function" != typeof e[t2]) && "__proto__" != t2) return e[t2];
      }, HA = function(e) {
        return jr(function(t2, n2) {
          var r = -1, i = n2.length, o = 1 < i ? n2[i - 1] : void 0, a2 = 2 < i ? n2[2] : void 0;
          for (o = 3 < e.length && "function" == typeof o ? (i--, o) : void 0, a2 && Mh(n2[0], n2[1], a2) && (o = 3 > i ? void 0 : o, i = 1), t2 = Object(t2); ++r < i; ) (a2 = n2[r]) && e(t2, a2, r, o);
          return t2;
        });
      }(function(e, t2, n2, r) {
        tm(e, t2, n2, r);
      }), IA = Math.floor, JA = Math.random, nr = function(e, t2) {
        return e + IA(JA() * (t2 - e + 1));
      }, or = function(e) {
        var t2 = e.length;
        return t2 ? e[nr(0, t2 - 1)] : void 0;
      }, KA = function(e, t2) {
        return he(t2, function(t3) {
          return e[t3];
        });
      }, Ni = function(e) {
        return null == e ? [] : KA(e, Ad(e));
      }, LA = function(e) {
        return or(Ni(e));
      }, bn = function(e) {
        return (Va(e) ? or : LA)(e);
      }, xm = [], ym = function(e, t2) {
        return new WebSocket(e, t2);
      }, MA = Math.floor;
      N({ target: "Number", stat: true }, { isInteger: function(e) {
        return !ha(e) && isFinite(e) && MA(e) === e;
      } }), Oo("from", Ej, Dj);
      var NA = function(e, t2) {
        for (var n2 = Array(arguments.length - 1), r = 0, i = 2, o = true; i < arguments.length; ) n2[r++] = arguments[i++];
        return new Promise(function(i2, a2) {
          n2[r] = function(e2) {
            if (o) if (o = false, e2) a2(e2);
            else {
              for (var t3 = Array(arguments.length - 1), n3 = 0; n3 < t3.length; ) t3[n3++] = arguments[n3];
              i2.apply(null, t3);
            }
          };
          try {
            e.apply(t2 || null, n2);
          } catch (e2) {
            o && (o = false, a2(e2));
          }
        });
      }, OA = $a(function(e, t2) {
        t2.length = function(e2) {
          var t3 = e2.length;
          if (!t3) return 0;
          for (var n3 = 0; 1 < --t3 % 4 && "=" === e2.charAt(t3); ) ++n3;
          return Math.ceil(3 * e2.length) / 4 - n3;
        };
        var n2 = Array(64), r = Array(123);
        for (e = 0; 64 > e; ) r[n2[e] = 26 > e ? e + 65 : 52 > e ? e + 71 : 62 > e ? e - 4 : e - 59 | 43] = e++;
        t2.encode = function(e2, t3, r2) {
          for (var i, o = null, a2 = [], s = 0, u2 = 0; t3 < r2; ) {
            var c2 = e2[t3++];
            switch (u2) {
              case 0:
                a2[s++] = n2[c2 >> 2], i = (3 & c2) << 4, u2 = 1;
                break;
              case 1:
                a2[s++] = n2[i | c2 >> 4], i = (15 & c2) << 2, u2 = 2;
                break;
              case 2:
                a2[s++] = n2[i | c2 >> 6], a2[s++] = n2[63 & c2], u2 = 0;
            }
            8191 < s && ((o || (o = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
          }
          return u2 && (a2[s++] = n2[i], a2[s++] = 61, 1 === u2 && (a2[s++] = 61)), o ? (s && o.push(String.fromCharCode.apply(String, a2.slice(0, s))), o.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
        }, t2.decode = function(e2, t3, n3) {
          for (var i, o = n3, a2 = 0, s = 0; s < e2.length; ) {
            var u2 = e2.charCodeAt(s++);
            if (61 === u2 && 1 < a2) break;
            if (void 0 === (u2 = r[u2])) throw Error("invalid encoding");
            switch (a2) {
              case 0:
                i = u2, a2 = 1;
                break;
              case 1:
                t3[n3++] = i << 2 | (48 & u2) >> 4, i = u2, a2 = 2;
                break;
              case 2:
                t3[n3++] = (15 & i) << 4 | (60 & u2) >> 2, i = u2, a2 = 3;
                break;
              case 3:
                t3[n3++] = (3 & i) << 6 | u2, a2 = 0;
            }
          }
          if (1 === a2) throw Error("invalid encoding");
          return n3 - o;
        }, t2.test = function(e2) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e2);
        };
      });
      yg.prototype.on = function(e, t2, n2) {
        return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t2, ctx: n2 || this }), this;
      }, yg.prototype.off = function(e, t2) {
        if (void 0 === e) this._listeners = {};
        else if (void 0 === t2) this._listeners[e] = [];
        else {
          e = this._listeners[e];
          for (var n2 = 0; n2 < e.length; ) e[n2].fn === t2 ? e.splice(n2, 1) : ++n2;
        }
        return this;
      }, yg.prototype.emit = function(e) {
        var t2 = this._listeners[e];
        if (t2) {
          for (var n2 = [], r = 1; r < arguments.length; ) n2.push(arguments[r++]);
          for (r = 0; r < t2.length; ) t2[r].fn.apply(t2[r++].ctx, n2);
        }
        return this;
      };
      var PA = zm(zm), QA = function(c) {
        try {
          var a = eval("quire".replace(/^/, "re"))(c);
          if (a && (a.length || Object.keys(a).length)) return a;
        } catch (e) {
        }
        return null;
      }, RA = $a(function(e, t2) {
        t2.length = function(e2) {
          for (var t3, n2 = 0, r = 0; r < e2.length; ++r) 128 > (t3 = e2.charCodeAt(r)) ? n2 += 1 : 2048 > t3 ? n2 += 2 : 55296 == (64512 & t3) && 56320 == (64512 & e2.charCodeAt(r + 1)) ? (++r, n2 += 4) : n2 += 3;
          return n2;
        }, t2.read = function(e2, t3, n2) {
          if (1 > n2 - t3) return "";
          for (var r, i = null, o = [], a2 = 0; t3 < n2; ) 128 > (r = e2[t3++]) ? o[a2++] = r : 191 < r && 224 > r ? o[a2++] = (31 & r) << 6 | 63 & e2[t3++] : 239 < r && 365 > r ? (r = ((7 & r) << 18 | (63 & e2[t3++]) << 12 | (63 & e2[t3++]) << 6 | 63 & e2[t3++]) - 65536, o[a2++] = 55296 + (r >> 10), o[a2++] = 56320 + (1023 & r)) : o[a2++] = (15 & r) << 12 | (63 & e2[t3++]) << 6 | 63 & e2[t3++], 8191 < a2 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a2 = 0);
          return i ? (a2 && i.push(String.fromCharCode.apply(String, o.slice(0, a2))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, a2));
        }, t2.write = function(e2, t3, n2) {
          for (var r, i, o = n2, a2 = 0; a2 < e2.length; ++a2) 128 > (r = e2.charCodeAt(a2)) ? t3[n2++] = r : (2048 > r ? t3[n2++] = r >> 6 | 192 : (55296 == (64512 & r) && 56320 == (64512 & (i = e2.charCodeAt(a2 + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a2, t3[n2++] = r >> 18 | 240, t3[n2++] = r >> 12 & 63 | 128) : t3[n2++] = r >> 12 | 224, t3[n2++] = r >> 6 & 63 | 128), t3[n2++] = 63 & r | 128);
          return n2 - o;
        };
      }), SA = function(e, t2, n2) {
        var r = n2 || 8192, i = r >>> 1, o = null, a2 = r;
        return function(n3) {
          return 1 > n3 || n3 > i ? e(n3) : (a2 + n3 > r && (o = e(r), a2 = 0), n3 = t2.call(o, a2, a2 += n3), 7 & a2 && (a2 = 1 + (7 | a2)), n3);
        };
      }, Xd = Wa.zero = new Wa(0, 0);
      Xd.toNumber = function() {
        return 0;
      }, Xd.zzEncode = Xd.zzDecode = function() {
        return this;
      }, Xd.length = function() {
        return 1;
      };
      var TA = Wa.zeroHash = "\0\0\0\0\0\0\0\0";
      Wa.fromNumber = function(e) {
        if (0 === e) return Xd;
        var t2 = 0 > e;
        t2 && (e = -e);
        var n2 = e >>> 0;
        return e = (e - n2) / 4294967296 >>> 0, t2 && (e = ~e >>> 0, n2 = ~n2 >>> 0, 4294967295 < ++n2 && (n2 = 0, 4294967295 < ++e && (e = 0))), new Wa(n2, e);
      }, Wa.from = function(e) {
        if ("number" == typeof e) return Wa.fromNumber(e);
        if (V.isString(e)) {
          if (!V.Long) return Wa.fromNumber(parseInt(e, 10));
          e = V.Long.fromString(e);
        }
        return e.low || e.high ? new Wa(e.low >>> 0, e.high >>> 0) : Xd;
      }, Wa.prototype.toNumber = function(e) {
        if (!e && this.hi >>> 31) {
          e = 1 + ~this.lo >>> 0;
          var t2 = ~this.hi >>> 0;
          return e || (t2 = t2 + 1 >>> 0), -(e + 4294967296 * t2);
        }
        return this.lo + 4294967296 * this.hi;
      }, Wa.prototype.toLong = function(e) {
        return V.Long ? new V.Long(0 | this.lo, 0 | this.hi, !!e) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: !!e };
      };
      var td = String.prototype.charCodeAt;
      Wa.fromHash = function(e) {
        return e === TA ? Xd : new Wa((td.call(e, 0) | td.call(e, 1) << 8 | td.call(e, 2) << 16 | td.call(e, 3) << 24) >>> 0, (td.call(e, 4) | td.call(e, 5) << 8 | td.call(e, 6) << 16 | td.call(e, 7) << 24) >>> 0);
      }, Wa.prototype.toHash = function() {
        return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
      }, Wa.prototype.zzEncode = function() {
        var e = this.hi >> 31;
        return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;
      }, Wa.prototype.zzDecode = function() {
        var e = -(1 & this.lo);
        return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;
      }, Wa.prototype.length = function() {
        var e = this.lo, t2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
        return 0 === n2 ? 0 === t2 ? 16384 > e ? 128 > e ? 1 : 2 : 2097152 > e ? 3 : 4 : 16384 > t2 ? 128 > t2 ? 5 : 6 : 2097152 > t2 ? 7 : 8 : 128 > n2 ? 9 : 10;
      };
      var V = $a(function(e, t2) {
        function n2(e2, t3, n3) {
          for (var r2 = Object.keys(t3), i = 0; i < r2.length; ++i) void 0 !== e2[r2[i]] && n3 || (e2[r2[i]] = t3[r2[i]]);
          return e2;
        }
        function r(e2) {
          function t3(e3, r2) {
            if (!(this instanceof t3)) return new t3(e3, r2);
            Object.defineProperty(this, "message", { get: function() {
              return e3;
            } }), Error.captureStackTrace ? Error.captureStackTrace(this, t3) : Object.defineProperty(this, "stack", { value: Error().stack || "" }), r2 && n2(this, r2);
          }
          return (t3.prototype = Object.create(Error.prototype)).constructor = t3, Object.defineProperty(t3.prototype, "name", { get: function() {
            return e2;
          } }), t3.prototype.toString = function() {
            return this.name + ": " + this.message;
          }, t3;
        }
        t2.asPromise = NA, t2.base64 = OA, t2.EventEmitter = yg, t2.float = PA, t2.inquire = QA, t2.utf8 = RA, t2.pool = SA, t2.LongBits = Wa, t2.isNode = !!(void 0 !== Ya && Ya && Ya.process && Ya.process.versions && Ya.process.versions.node), t2.global = t2.isNode && Ya || "undefined" != typeof window && window || "undefined" != typeof self && self || Ya, t2.emptyArray = Object.freeze ? Object.freeze([]) : [], t2.emptyObject = Object.freeze ? Object.freeze({}) : {}, t2.isInteger = Number.isInteger || function(e2) {
          return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
        }, t2.isString = function(e2) {
          return "string" == typeof e2 || e2 instanceof String;
        }, t2.isObject = function(e2) {
          return e2 && "object" === X(e2);
        }, t2.isset = t2.isSet = function(e2, t3) {
          var n3 = e2[t3];
          return !(null == n3 || !e2.hasOwnProperty(t3)) && ("object" !== X(n3) || 0 < (Array.isArray(n3) ? n3.length : Object.keys(n3).length));
        }, t2.Buffer = function() {
          try {
            var e2 = t2.inquire("buffer").Buffer;
            return e2.prototype.utf8Write ? e2 : null;
          } catch (e3) {
            return null;
          }
        }(), t2._Buffer_from = null, t2._Buffer_allocUnsafe = null, t2.newBuffer = function(e2) {
          return "number" == typeof e2 ? t2.Buffer ? t2._Buffer_allocUnsafe(e2) : new t2.Array(e2) : t2.Buffer ? t2._Buffer_from(e2) : "undefined" == typeof Uint8Array ? e2 : new Uint8Array(e2);
        }, t2.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, t2.Long = t2.global.dcodeIO && t2.global.dcodeIO.Long || t2.global.Long || t2.inquire("long"), t2.key2Re = /^true|false|0|1$/, t2.key32Re = /^-?(?:0|[1-9][0-9]*)$/, t2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, t2.longToHash = function(e2) {
          return e2 ? t2.LongBits.from(e2).toHash() : t2.LongBits.zeroHash;
        }, t2.longFromHash = function(e2, n3) {
          return e2 = t2.LongBits.fromHash(e2), t2.Long ? t2.Long.fromBits(e2.lo, e2.hi, n3) : e2.toNumber(!!n3);
        }, t2.merge = n2, t2.lcFirst = function(e2) {
          return e2.charAt(0).toLowerCase() + e2.substring(1);
        }, t2.newError = r, t2.ProtocolError = r("ProtocolError"), t2.oneOfGetter = function(e2) {
          for (var t3 = {}, n3 = 0; n3 < e2.length; ++n3) t3[e2[n3]] = 1;
          return function() {
            for (var e3 = Object.keys(this), n4 = e3.length - 1; -1 < n4; --n4) if (1 === t3[e3[n4]] && void 0 !== this[e3[n4]] && null !== this[e3[n4]]) return e3[n4];
          };
        }, t2.oneOfSetter = function(e2) {
          return function(t3) {
            for (var n3 = 0; n3 < e2.length; ++n3) e2[n3] !== t3 && delete this[e2[n3]];
          };
        }, t2.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, t2._configure = function() {
          var e2 = t2.Buffer;
          e2 ? (t2._Buffer_from = e2.from !== Uint8Array.from && e2.from || function(t3, n3) {
            return new e2(t3, n3);
          }, t2._Buffer_allocUnsafe = e2.allocUnsafe || function(t3) {
            return new e2(t3);
          }) : t2._Buffer_from = t2._Buffer_allocUnsafe = null;
        };
      }), xi = ja, el, Nh = V.LongBits, pr = V.base64, qr = V.utf8, rr = function() {
        return V.Buffer ? function() {
          return (ja.create = function() {
            return new el();
          })();
        } : function() {
          return new ja();
        };
      };
      ja.create = rr(), ja.alloc = function(e) {
        return new V.Array(e);
      }, V.Array !== Array && (ja.alloc = V.pool(ja.alloc, V.Array.prototype.subarray)), ja.prototype._push = function(e, t2, n2) {
        return this.tail = this.tail.next = new sf(e, t2, n2), this.len += t2, this;
      }, ui.prototype = Object.create(sf.prototype), ui.prototype.fn = function(e, t2, n2) {
        for (; 127 < e; ) t2[n2++] = 127 & e | 128, e >>>= 7;
        t2[n2] = e;
      }, ja.prototype.uint32 = function(e) {
        return this.len += (this.tail = this.tail.next = new ui(128 > (e >>>= 0) ? 1 : 16384 > e ? 2 : 2097152 > e ? 3 : 268435456 > e ? 4 : 5, e)).len, this;
      }, ja.prototype.int32 = function(e) {
        return 0 > e ? this._push(vi, 10, Nh.fromNumber(e)) : this.uint32(e);
      }, ja.prototype.sint32 = function(e) {
        return this.uint32((e << 1 ^ e >> 31) >>> 0);
      }, ja.prototype.uint64 = function(e) {
        return e = Nh.from(e), this._push(vi, e.length(), e);
      }, ja.prototype.int64 = ja.prototype.uint64, ja.prototype.sint64 = function(e) {
        return e = Nh.from(e).zzEncode(), this._push(vi, e.length(), e);
      }, ja.prototype.bool = function(e) {
        return this._push(ti, 1, e ? 1 : 0);
      }, ja.prototype.fixed32 = function(e) {
        return this._push(wi, 4, e >>> 0);
      }, ja.prototype.sfixed32 = ja.prototype.fixed32, ja.prototype.fixed64 = function(e) {
        return e = Nh.from(e), this._push(wi, 4, e.lo)._push(wi, 4, e.hi);
      }, ja.prototype.sfixed64 = ja.prototype.fixed64, ja.prototype.float = function(e) {
        return this._push(V.float.writeFloatLE, 4, e);
      }, ja.prototype.double = function(e) {
        return this._push(V.float.writeDoubleLE, 8, e);
      };
      var UA = V.Array.prototype.set ? function(e, t2, n2) {
        t2.set(e, n2);
      } : function(e, t2, n2) {
        for (var r = 0; r < e.length; ++r) t2[n2 + r] = e[r];
      };
      ja.prototype.bytes = function(e) {
        var t2 = e.length >>> 0;
        if (!t2) return this._push(ti, 1, 0);
        if (V.isString(e)) {
          var n2 = ja.alloc(t2 = pr.length(e));
          pr.decode(e, n2, 0), e = n2;
        }
        return this.uint32(t2)._push(UA, t2, e);
      }, ja.prototype.string = function(e) {
        var t2 = qr.length(e);
        return t2 ? this.uint32(t2)._push(qr.write, t2, e) : this._push(ti, 1, 0);
      }, ja.prototype.fork = function() {
        return this.states = new Tt(this), this.head = this.tail = new sf(si, 0, 0), this.len = 0, this;
      }, ja.prototype.reset = function() {
        return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new sf(si, 0, 0), this.len = 0), this;
      }, ja.prototype.ldelim = function() {
        var e = this.head, t2 = this.tail, n2 = this.len;
        return this.reset().uint32(n2), n2 && (this.tail.next = e.next, this.tail = t2, this.len += n2), this;
      }, ja.prototype.finish = function() {
        for (var e = this.head.next, t2 = this.constructor.alloc(this.len), n2 = 0; e; ) e.fn(e.val, t2, n2), n2 += e.len, e = e.next;
        return t2;
      }, ja._configure = function(e) {
        el = e, ja.create = rr(), el._configure();
      }, (jc.prototype = Object.create(xi.prototype)).constructor = jc, jc._configure = function() {
        jc.alloc = V._Buffer_allocUnsafe, jc.writeBytesBuffer = V.Buffer && V.Buffer.prototype instanceof Uint8Array && "set" === V.Buffer.prototype.set.name ? function(e, t2, n2) {
          t2.set(e, n2);
        } : function(e, t2, n2) {
          if (e.copy) e.copy(t2, n2, 0, e.length);
          else for (var r = 0; r < e.length; ) t2[n2++] = e[r++];
        };
      }, jc.prototype.bytes = function(e) {
        V.isString(e) && (e = V._Buffer_from(e, "base64"));
        var t2 = e.length >>> 0;
        return this.uint32(t2), t2 && this._push(jc.writeBytesBuffer, t2, e), this;
      }, jc.prototype.string = function(e) {
        var t2 = V.Buffer.byteLength(e);
        return this.uint32(t2), t2 && this._push(Ut, t2, e), this;
      }, jc._configure();
      var zi = La, fl, Em = V.LongBits, VA = V.utf8, sr = "undefined" != typeof Uint8Array ? function(e) {
        if (e instanceof Uint8Array || Array.isArray(e)) return new La(e);
        throw Error("illegal buffer");
      } : function(e) {
        if (Array.isArray(e)) return new La(e);
        throw Error("illegal buffer");
      }, tr = function() {
        return V.Buffer ? function(e) {
          return (La.create = function(e2) {
            return V.Buffer.isBuffer(e2) ? new fl(e2) : sr(e2);
          })(e);
        } : sr;
      };
      La.create = tr(), La.prototype._slice = V.Array.prototype.subarray || V.Array.prototype.slice, La.prototype.uint32 = /* @__PURE__ */ function() {
        var e = 4294967295;
        return function() {
          if (e = (127 & this.buf[this.pos]) >>> 0, 128 > this.buf[this.pos++]) return e;
          if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, 128 > this.buf[this.pos++]) return e;
          if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, 128 > this.buf[this.pos++]) return e;
          if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, 128 > this.buf[this.pos++]) return e;
          if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, 128 > this.buf[this.pos++]) return e;
          if ((this.pos += 5) > this.len) throw this.pos = this.len, Yb(this, 10);
          return e;
        };
      }(), La.prototype.int32 = function() {
        return 0 | this.uint32();
      }, La.prototype.sint32 = function() {
        var e = this.uint32();
        return e >>> 1 ^ -(1 & e) | 0;
      }, La.prototype.bool = function() {
        return 0 !== this.uint32();
      }, La.prototype.fixed32 = function() {
        if (this.pos + 4 > this.len) throw Yb(this, 4);
        return zg(this.buf, this.pos += 4);
      }, La.prototype.sfixed32 = function() {
        if (this.pos + 4 > this.len) throw Yb(this, 4);
        return 0 | zg(this.buf, this.pos += 4);
      }, La.prototype.float = function() {
        if (this.pos + 4 > this.len) throw Yb(this, 4);
        var e = V.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4, e;
      }, La.prototype.double = function() {
        if (this.pos + 8 > this.len) throw Yb(this, 4);
        var e = V.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8, e;
      }, La.prototype.bytes = function() {
        var e = this.uint32(), t2 = this.pos, n2 = this.pos + e;
        if (n2 > this.len) throw Yb(this, e);
        return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t2, n2) : t2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, t2, n2);
      }, La.prototype.string = function() {
        var e = this.bytes();
        return VA.read(e, 0, e.length);
      }, La.prototype.skip = function(e) {
        if ("number" == typeof e) {
          if (this.pos + e > this.len) throw Yb(this, e);
          this.pos += e;
        } else do {
          if (this.pos >= this.len) throw Yb(this);
        } while (128 & this.buf[this.pos++]);
        return this;
      }, La.prototype.skipType = function(e) {
        switch (e) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (; 4 != (e = 7 & this.uint32()); ) this.skipType(e);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + e + " at offset " + this.pos);
        }
        return this;
      }, La._configure = function(e) {
        fl = e, La.create = tr(), fl._configure();
        var t2 = V.Long ? "toLong" : "toNumber";
        V.merge(La.prototype, { int64: function() {
          return yi.call(this)[t2](false);
        }, uint64: function() {
          return yi.call(this)[t2](true);
        }, sint64: function() {
          return yi.call(this).zzDecode()[t2](false);
        }, fixed64: function() {
          return Fm.call(this)[t2](true);
        }, sfixed64: function() {
          return Fm.call(this)[t2](false);
        } });
      }, (Fd.prototype = Object.create(zi.prototype)).constructor = Fd, Fd._configure = function() {
        V.Buffer && (Fd.prototype._slice = V.Buffer.prototype.slice);
      }, Fd.prototype.string = function() {
        var e = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len));
      }, Fd._configure(), (tf.prototype = Object.create(V.EventEmitter.prototype)).constructor = tf, tf.prototype.rpcCall = function e(t2, n2, r, i, o) {
        if (!i) throw TypeError("request must be specified");
        var a2 = this;
        if (!o) return V.asPromise(e, a2, t2, n2, r, i);
        if (a2.rpcImpl) try {
          return a2.rpcImpl(t2, n2[a2.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), function(e2, n3) {
            if (e2) return a2.emit("error", e2, t2), o(e2);
            if (null !== n3) {
              if (!(n3 instanceof r)) try {
                n3 = r[a2.responseDelimited ? "decodeDelimited" : "decode"](n3);
              } catch (e3) {
                return a2.emit("error", e3, t2), o(e3);
              }
              return a2.emit("data", n3, t2), o(null, n3);
            }
            a2.end(true);
          });
        } catch (e2) {
          a2.emit("error", e2, t2), setTimeout(function() {
            o(e2);
          }, 0);
        }
        else setTimeout(function() {
          o(Error("already ended"));
        }, 0);
      }, tf.prototype.end = function(e) {
        return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
      };
      var WA = $a(function(e, t2) {
        t2.Service = tf;
      }), XA = {}, fc = $a(function(e, t2) {
        function n2() {
          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
        }
        var r = t2;
        r.build = "minimal", r.Writer = xi, r.BufferWriter = jc, r.Reader = zi, r.BufferReader = Fd, r.util = V, r.rpc = WA, r.roots = XA, r.configure = n2, n2();
      });
      fc.util.Long = U, fc.configure();
      var u = fc.Reader, L = fc.Writer, q = fc.util, t = fc.roots.default || (fc.roots.default = {}), YA = t.URI = function() {
        var e = {}, t2 = Object.create(e);
        return t2[e[0] = "Unknown"] = 0, t2[e[1] = "PingUri"] = 1, t2[e[2] = "PongUri"] = 2, t2[e[11] = "UserJoinUri"] = 11, t2[e[12] = "UserRespUri"] = 12, t2[e[21] = "UserQuitUri"] = 21, t2[e[22] = "UserDropUri"] = 22, t2[e[31] = "GroupEnterUri"] = 31, t2[e[32] = "GroupLeaveUri"] = 32, t2[e[33] = "GroupReplyUri"] = 33, t2[e[36] = "GroupEnterNoticeUri"] = 36, t2[e[37] = "GroupLeaveNoticeUri"] = 37, t2[e[38] = "GroupEventNoticeUri"] = 38, t2[e[39] = "GroupCountNoticeUri"] = 39, t2[e[41] = "UserStatusListUri"] = 41, t2[e[42] = "UserStatusResultUri"] = 42, t2[e[51] = "GroupStatusListUri"] = 51, t2[e[52] = "GroupStatusResultUri"] = 52, t2[e[55] = "GroupAllUsersListUri"] = 55, t2[e[56] = "GroupAllUsersResultUri"] = 56, t2[e[100] = "MessageUri"] = 100, t2[e[101] = "AckUri"] = 101, t2[e[115] = "FileUploadIndexGetUri"] = 115, t2[e[116] = "FileUploadIndexRetUri"] = 116, t2[e[117] = "FileUploadIndexSetUri"] = 117, t2[e[118] = "FileUploadIndexFinUri"] = 118, t2[e[119] = "FileUploadIndexErrUri"] = 119, t2[e[125] = "FileDownloadIndexGetUri"] = 125, t2[e[126] = "FileDownloadIndexRetUri"] = 126, t2[e[127] = "FileDownloadIndexErrUri"] = 127, t2[e[201] = "UserJoinNoticeUri"] = 201, t2[e[202] = "UserQuitNoticeUri"] = 202, t2[e[203] = "UserWaitNoticeUri"] = 203, t2[e[301] = "UserAttributeGetUri"] = 301, t2[e[302] = "UserAttributeRetUri"] = 302, t2[e[303] = "UserAttributeSetUri"] = 303, t2[e[304] = "UserAttributeModUri"] = 304, t2[e[305] = "UserAttributeDelUri"] = 305, t2[e[307] = "UserAttributeRspUri"] = 307, t2[e[308] = "UserAttributeErrUri"] = 308, t2[e[311] = "UserAttributeKeysGetUri"] = 311, t2[e[312] = "UserAttributeKeysRetUri"] = 312, t2[e[351] = "GroupAttributeGetUri"] = 351, t2[e[352] = "GroupAttributeRetUri"] = 352, t2[e[353] = "GroupAttributeSetUri"] = 353, t2[e[354] = "GroupAttributeModUri"] = 354, t2[e[355] = "GroupAttributeDelUri"] = 355, t2[e[356] = "GroupAttributeAltUri"] = 356, t2[e[357] = "GroupAttributeRspUri"] = 357, t2[e[358] = "GroupAttributeErrUri"] = 358, t2[e[361] = "GroupAttributeKeysGetUri"] = 361, t2[e[362] = "GroupAttributeKeysRetUri"] = 362, t2[e[401] = "SubscribeUserStatusUri"] = 401, t2[e[402] = "UnsubscribeUserStatusUri"] = 402, t2[e[499] = "SubscribeResponseUri"] = 499, t2;
      }(), Oh = t.Wrapper = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.uri = 0, e.prototype.data = q.newBuffer([]), e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.uri && Object.hasOwnProperty.call(e2, "uri") && t2.uint32(8).int32(e2.uri), null != e2.data && Object.hasOwnProperty.call(e2, "data") && t2.uint32(18).bytes(e2.data), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.Wrapper(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.uri = e2.int32();
                break;
              case 2:
                r.data = e2.bytes();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), ZA = t.Ping = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.ms = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.ms && Object.hasOwnProperty.call(e2, "ms") && t2.uint32(16).uint64(e2.ms), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.Ping(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.ms = e2.uint64();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), $A = t.Pong = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.ms = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.ms && Object.hasOwnProperty.call(e2, "ms") && t2.uint32(16).uint64(e2.ms), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.Pong(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.ms = e2.uint64();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), aB = t.UserJoin = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.opt = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.ticket = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.opt && Object.hasOwnProperty.call(e2, "opt") && t2.uint32(16).uint64(e2.opt), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(24).uint64(e2.instance), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(34).string(e2.account), null != e2.ticket && Object.hasOwnProperty.call(e2, "ticket") && t2.uint32(42).string(e2.ticket), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserJoin(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.opt = e2.uint64();
                break;
              case 3:
                r.instance = e2.uint64();
                break;
              case 4:
                r.account = e2.string();
                break;
              case 5:
                r.ticket = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), bB = t.UserResp = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(18).string(e2.account), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(24).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserResp(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              case 3:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), cB = t.UserQuit = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserQuit(); e2.pos < n2; ) {
            var i = e2.uint32();
            e2.skipType(7 & i);
          }
          return r;
        }, e;
      }(), dB = t.UserDrop = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(8).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserDrop(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), eB = t.GroupEnter = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(18).string(e2.account), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupEnter(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), fB = t.GroupLeave = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.account = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(10).string(e2.account), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupLeave(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.account = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), gB = t.GroupReply = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(18).string(e2.account), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(24).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupReply(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              case 3:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), ur = t.GroupLeaveNotice = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.user = "", e.prototype.group = "", e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.size = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.user && Object.hasOwnProperty.call(e2, "user") && t2.uint32(18).string(e2.user), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(26).string(e2.group), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(32).uint64(e2.instance), null != e2.size && Object.hasOwnProperty.call(e2, "size") && t2.uint32(40).uint32(e2.size), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupLeaveNotice(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.user = e2.string();
                break;
              case 3:
                r.group = e2.string();
                break;
              case 4:
                r.instance = e2.uint64();
                break;
              case 5:
                r.size = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), vr = t.GroupEnterNotice = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.user = "", e.prototype.group = "", e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.size = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.user && Object.hasOwnProperty.call(e2, "user") && t2.uint32(18).string(e2.user), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(26).string(e2.group), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(32).uint64(e2.instance), null != e2.size && Object.hasOwnProperty.call(e2, "size") && t2.uint32(40).uint32(e2.size), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupEnterNotice(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.user = e2.string();
                break;
              case 3:
                r.group = e2.string();
                break;
              case 4:
                r.instance = e2.uint64();
                break;
              case 5:
                r.size = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), wr = t.Message = function() {
        function e(e2) {
          if (this.MiscMap = {}, e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.dialogue = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.sequence = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.options = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.src = "", e.prototype.dst = "", e.prototype.payload = q.newBuffer([]), e.prototype.MiscMap = q.emptyObject, e.prototype.ms = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(8).uint64(e2.instance), null != e2.dialogue && Object.hasOwnProperty.call(e2, "dialogue") && t2.uint32(16).uint64(e2.dialogue), null != e2.sequence && Object.hasOwnProperty.call(e2, "sequence") && t2.uint32(24).uint64(e2.sequence), null != e2.options && Object.hasOwnProperty.call(e2, "options") && t2.uint32(32).uint64(e2.options), null != e2.src && Object.hasOwnProperty.call(e2, "src") && t2.uint32(42).string(e2.src), null != e2.dst && Object.hasOwnProperty.call(e2, "dst") && t2.uint32(50).string(e2.dst), null != e2.payload && Object.hasOwnProperty.call(e2, "payload") && t2.uint32(58).bytes(e2.payload), null != e2.MiscMap && Object.hasOwnProperty.call(e2, "MiscMap")) for (var n2 = Object.keys(e2.MiscMap), r = 0; r < n2.length; ++r) t2.uint32(66).fork().uint32(10).string(n2[r]).uint32(18).bytes(e2.MiscMap[n2[r]]).ldelim();
          return null != e2.ms && Object.hasOwnProperty.call(e2, "ms") && t2.uint32(72).uint64(e2.ms), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r, i, o = new t.Message(); e2.pos < n2; ) switch (r = e2.uint32(), r >>> 3) {
            case 1:
              o.instance = e2.uint64();
              break;
            case 2:
              o.dialogue = e2.uint64();
              break;
            case 3:
              o.sequence = e2.uint64();
              break;
            case 4:
              o.options = e2.uint64();
              break;
            case 5:
              o.src = e2.string();
              break;
            case 6:
              o.dst = e2.string();
              break;
            case 7:
              o.payload = e2.bytes();
              break;
            case 8:
              o.MiscMap === q.emptyObject && (o.MiscMap = {});
              var a2 = e2.uint32() + e2.pos;
              for (r = "", i = []; e2.pos < a2; ) {
                var s = e2.uint32();
                switch (s >>> 3) {
                  case 1:
                    r = e2.string();
                    break;
                  case 2:
                    i = e2.bytes();
                    break;
                  default:
                    e2.skipType(7 & s);
                }
              }
              o.MiscMap[r] = i;
              break;
            case 9:
              o.ms = e2.uint64();
              break;
            default:
              e2.skipType(7 & r);
          }
          return o;
        }, e;
      }(), xr = t.Ack = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.dialogue = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.sequence = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(8).uint64(e2.instance), null != e2.dialogue && Object.hasOwnProperty.call(e2, "dialogue") && t2.uint32(16).uint64(e2.dialogue), null != e2.sequence && Object.hasOwnProperty.call(e2, "sequence") && t2.uint32(24).uint64(e2.sequence), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(32).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.Ack(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.instance = e2.uint64();
                break;
              case 2:
                r.dialogue = e2.uint64();
                break;
              case 3:
                r.sequence = e2.uint64();
                break;
              case 4:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), hB = t.FileUploadIndexGet = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.hash = q.newBuffer([]), e.prototype.size = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.hash && Object.hasOwnProperty.call(e2, "hash") && t2.uint32(18).bytes(e2.hash), null != e2.size && Object.hasOwnProperty.call(e2, "size") && t2.uint32(24).uint32(e2.size), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileUploadIndexGet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.hash = e2.bytes();
                break;
              case 3:
                r.size = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), iB = t.FileUploadIndexRet = function() {
        function e(e2) {
          if (this.servers = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.unit = 0, e.prototype.servers = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.unit && Object.hasOwnProperty.call(e2, "unit") && t2.uint32(16).uint32(e2.unit), null != e2.servers && e2.servers.length) {
            t2.uint32(26).fork();
            for (var n2 = 0; n2 < e2.servers.length; ++n2) t2.uint32(e2.servers[n2]);
            t2.ldelim();
          }
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileUploadIndexRet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.unit = e2.uint32();
                break;
              case 3:
                if (r.servers && r.servers.length || (r.servers = []), 2 == (7 & i)) for (i = e2.uint32() + e2.pos; e2.pos < i; ) r.servers.push(e2.uint32());
                else r.servers.push(e2.uint32());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), jB = t.FileUploadIndexSet = function() {
        function e(e2) {
          if (this.servers = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.hash = q.newBuffer([]), e.prototype.unit = 0, e.prototype.servers = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.hash && Object.hasOwnProperty.call(e2, "hash") && t2.uint32(18).bytes(e2.hash), null != e2.unit && Object.hasOwnProperty.call(e2, "unit") && t2.uint32(24).uint32(e2.unit), null != e2.servers && e2.servers.length) {
            t2.uint32(34).fork();
            for (var n2 = 0; n2 < e2.servers.length; ++n2) t2.uint32(e2.servers[n2]);
            t2.ldelim();
          }
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileUploadIndexSet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.hash = e2.bytes();
                break;
              case 3:
                r.unit = e2.uint32();
                break;
              case 4:
                if (r.servers && r.servers.length || (r.servers = []), 2 == (7 & i)) for (i = e2.uint32() + e2.pos; e2.pos < i; ) r.servers.push(e2.uint32());
                else r.servers.push(e2.uint32());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), kB = t.FileUploadIndexFin = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.zone = 0, e.prototype.unit = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.zone && Object.hasOwnProperty.call(e2, "zone") && t2.uint32(16).uint32(e2.zone), null != e2.unit && Object.hasOwnProperty.call(e2, "unit") && t2.uint32(24).uint32(e2.unit), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileUploadIndexFin(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.zone = e2.uint32();
                break;
              case 3:
                r.unit = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), lB = t.FileUploadIndexErr = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(16).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileUploadIndexErr(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), mB = t.FileDownloadIndexGet = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.zone = 0, e.prototype.hash = q.newBuffer([]), e.prototype.size = 0, e.prototype.unit = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.zone && Object.hasOwnProperty.call(e2, "zone") && t2.uint32(16).uint32(e2.zone), null != e2.hash && Object.hasOwnProperty.call(e2, "hash") && t2.uint32(26).bytes(e2.hash), null != e2.size && Object.hasOwnProperty.call(e2, "size") && t2.uint32(32).uint32(e2.size), null != e2.unit && Object.hasOwnProperty.call(e2, "unit") && t2.uint32(40).uint32(e2.unit), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileDownloadIndexGet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.zone = e2.uint32();
                break;
              case 3:
                r.hash = e2.bytes();
                break;
              case 4:
                r.size = e2.uint32();
                break;
              case 5:
                r.unit = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), nB = t.FileDownloadIndexRet = function() {
        function e(e2) {
          if (this.servers = [], this.backups = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.unit = 0, e.prototype.zone = 0, e.prototype.servers = q.emptyArray, e.prototype.backups = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.unit && Object.hasOwnProperty.call(e2, "unit") && t2.uint32(16).uint32(e2.unit), null != e2.zone && Object.hasOwnProperty.call(e2, "zone") && t2.uint32(24).uint32(e2.zone), null != e2.servers && e2.servers.length) {
            t2.uint32(34).fork();
            for (var n2 = 0; n2 < e2.servers.length; ++n2) t2.uint32(e2.servers[n2]);
            t2.ldelim();
          }
          if (null != e2.backups && e2.backups.length) {
            for (t2.uint32(42).fork(), n2 = 0; n2 < e2.backups.length; ++n2) t2.uint32(e2.backups[n2]);
            t2.ldelim();
          }
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileDownloadIndexRet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.unit = e2.uint32();
                break;
              case 3:
                r.zone = e2.uint32();
                break;
              case 4:
                if (r.servers && r.servers.length || (r.servers = []), 2 == (7 & i)) for (i = e2.uint32() + e2.pos; e2.pos < i; ) r.servers.push(e2.uint32());
                else r.servers.push(e2.uint32());
                break;
              case 5:
                if (r.backups && r.backups.length || (r.backups = []), 2 == (7 & i)) for (i = e2.uint32() + e2.pos; e2.pos < i; ) r.backups.push(e2.uint32());
                else r.backups.push(e2.uint32());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), oB = t.FileDownloadIndexErr = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(16).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.FileDownloadIndexErr(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), pB = t.GroupAllUsersList = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.pageSize = 0, e.prototype.pageNumber = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(18).string(e2.group), null != e2.pageSize && Object.hasOwnProperty.call(e2, "pageSize") && t2.uint32(24).uint32(e2.pageSize), null != e2.pageNumber && Object.hasOwnProperty.call(e2, "pageNumber") && t2.uint32(32).uint32(e2.pageNumber), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAllUsersList(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.pageSize = e2.uint32();
                break;
              case 4:
                r.pageNumber = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), qB = t.GroupAllUsersResult = function() {
        function e(e2) {
          if (this.memberInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.totalSize = 0, e.prototype.pageSize = 0, e.prototype.pageNumber = 0, e.prototype.memberInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && n2.uint32(18).string(e2.group), null != e2.totalSize && Object.hasOwnProperty.call(e2, "totalSize") && n2.uint32(24).uint32(e2.totalSize), null != e2.pageSize && Object.hasOwnProperty.call(e2, "pageSize") && n2.uint32(32).uint32(e2.pageSize), null != e2.pageNumber && Object.hasOwnProperty.call(e2, "pageNumber") && n2.uint32(40).uint32(e2.pageNumber), null != e2.memberInfos && e2.memberInfos.length) for (var r = 0; r < e2.memberInfos.length; ++r) t.GroupAllUsersResult.MemberInfo.encode(e2.memberInfos[r], n2.uint32(50).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAllUsersResult(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.totalSize = e2.uint32();
                break;
              case 4:
                r.pageSize = e2.uint32();
                break;
              case 5:
                r.pageNumber = e2.uint32();
                break;
              case 6:
                r.memberInfos && r.memberInfos.length || (r.memberInfos = []), r.memberInfos.push(t.GroupAllUsersResult.MemberInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.MemberInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.account = "", e2.prototype.ts = 0, e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.account && Object.hasOwnProperty.call(e3, "account") && t2.uint32(10).string(e3.account), null != e3.ts && Object.hasOwnProperty.call(e3, "ts") && t2.uint32(16).uint32(e3.ts), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.GroupAllUsersResult.MemberInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.account = e3.string();
                  break;
                case 2:
                  r.ts = e3.uint32();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), rB = t.UserStatusList = function() {
        function e(e2) {
          if (this.users = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.users = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.users && e2.users.length) for (var n2 = 0; n2 < e2.users.length; ++n2) t2.uint32(18).string(e2.users[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserStatusList(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.users && r.users.length || (r.users = []), r.users.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), sB = t.UserStatusResult = function() {
        function e(e2) {
          if (this.userInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.userInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.userInfos && e2.userInfos.length) for (var r = 0; r < e2.userInfos.length; ++r) t.UserStatusResult.UserStatusInfo.encode(e2.userInfos[r], n2.uint32(18).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserStatusResult(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.userInfos && r.userInfos.length || (r.userInfos = []), r.userInfos.push(t.UserStatusResult.UserStatusInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.UserStatusInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.account = "", e2.prototype.ts = 0, e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.account && Object.hasOwnProperty.call(e3, "account") && t2.uint32(10).string(e3.account), null != e3.ts && Object.hasOwnProperty.call(e3, "ts") && t2.uint32(16).uint32(e3.ts), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.UserStatusResult.UserStatusInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.account = e3.string();
                  break;
                case 2:
                  r.ts = e3.uint32();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), tB = t.UserAttributeGet = function() {
        function e(e2) {
          if (this.attributes = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.attributes = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(18).string(e2.account), null != e2.attributes && e2.attributes.length) for (var n2 = 0; n2 < e2.attributes.length; ++n2) t2.uint32(26).string(e2.attributes[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeGet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              case 3:
                r.attributes && r.attributes.length || (r.attributes = []), r.attributes.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), uB = t.UserAttributeRet = function() {
        function e(e2) {
          if (this.attributeInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.attributeInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.attributeInfos && e2.attributeInfos.length) for (var r = 0; r < e2.attributeInfos.length; ++r) t.UserAttributeRet.AttributeInfo.encode(e2.attributeInfos[r], n2.uint32(18).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeRet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.attributeInfos && r.attributeInfos.length || (r.attributeInfos = []), r.attributeInfos.push(t.UserAttributeRet.AttributeInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.UserAttributeRet.AttributeInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), vB = t.UserAttributeSet = function() {
        function e(e2) {
          if (this.attributeInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.attributeInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && n2.uint32(18).string(e2.account), null != e2.attributeInfos && e2.attributeInfos.length) for (var r = 0; r < e2.attributeInfos.length; ++r) t.UserAttributeSet.AttributeInfo.encode(e2.attributeInfos[r], n2.uint32(26).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeSet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              case 3:
                r.attributeInfos && r.attributeInfos.length || (r.attributeInfos = []), r.attributeInfos.push(t.UserAttributeSet.AttributeInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.UserAttributeSet.AttributeInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), wB = t.UserAttributeMod = function() {
        function e(e2) {
          if (this.attributeInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.attributeInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && n2.uint32(18).string(e2.account), null != e2.attributeInfos && e2.attributeInfos.length) for (var r = 0; r < e2.attributeInfos.length; ++r) t.UserAttributeMod.AttributeInfo.encode(e2.attributeInfos[r], n2.uint32(26).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeMod(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              case 3:
                r.attributeInfos && r.attributeInfos.length || (r.attributeInfos = []), r.attributeInfos.push(t.UserAttributeMod.AttributeInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.UserAttributeMod.AttributeInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), xB = t.UserAttributeDel = function() {
        function e(e2) {
          if (this.attributes = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.prototype.attributes = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(18).string(e2.account), null != e2.attributes && e2.attributes.length) for (var n2 = 0; n2 < e2.attributes.length; ++n2) t2.uint32(26).string(e2.attributes[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeDel(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              case 3:
                r.attributes && r.attributes.length || (r.attributes = []), r.attributes.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), yB = t.UserAttributeErr = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(16).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeErr(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), zB = t.UserAttributeKeysGet = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.account = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.account && Object.hasOwnProperty.call(e2, "account") && t2.uint32(18).string(e2.account), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeKeysGet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.account = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), AB = t.UserAttributeKeysRet = function() {
        function e(e2) {
          if (this.keys = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.keys = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.keys && e2.keys.length) for (var n2 = 0; n2 < e2.keys.length; ++n2) t2.uint32(18).string(e2.keys[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeKeysRet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.keys && r.keys.length || (r.keys = []), r.keys.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), BB = t.UserAttributeRsp = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserAttributeRsp(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), CB = t.GroupStatusList = function() {
        function e(e2) {
          if (this.groups = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.groups = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.groups && e2.groups.length) for (var n2 = 0; n2 < e2.groups.length; ++n2) t2.uint32(18).string(e2.groups[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupStatusList(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.groups && r.groups.length || (r.groups = []), r.groups.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), DB = t.GroupStatusResult = function() {
        function e(e2) {
          if (this.groupInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.groupInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.groupInfos && e2.groupInfos.length) for (var r = 0; r < e2.groupInfos.length; ++r) t.GroupStatusResult.GroupInfo.encode(e2.groupInfos[r], n2.uint32(18).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupStatusResult(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.groupInfos && r.groupInfos.length || (r.groupInfos = []), r.groupInfos.push(t.GroupStatusResult.GroupInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.GroupInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.group = "", e2.prototype.memberCount = 0, e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.group && Object.hasOwnProperty.call(e3, "group") && t2.uint32(10).string(e3.group), null != e3.memberCount && Object.hasOwnProperty.call(e3, "memberCount") && t2.uint32(16).uint32(e3.memberCount), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.GroupStatusResult.GroupInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.group = e3.string();
                  break;
                case 2:
                  r.memberCount = e3.uint32();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), EB = t.GroupCountNotice = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.size = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(8).uint64(e2.instance), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(16).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(26).string(e2.group), null != e2.size && Object.hasOwnProperty.call(e2, "size") && t2.uint32(32).uint32(e2.size), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupCountNotice(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.instance = e2.uint64();
                break;
              case 2:
                r.seq = e2.uint64();
                break;
              case 3:
                r.group = e2.string();
                break;
              case 4:
                r.size = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), FB = t.GroupAttributeGet = function() {
        function e(e2) {
          if (this.attributes = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.attributes = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(18).string(e2.group), null != e2.attributes && e2.attributes.length) for (var n2 = 0; n2 < e2.attributes.length; ++n2) t2.uint32(26).string(e2.attributes[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeGet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.attributes && r.attributes.length || (r.attributes = []), r.attributes.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), GB = t.GroupAttributeRet = function() {
        function e(e2) {
          if (this.attributeMaps = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.attributeMaps = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.attributeMaps && e2.attributeMaps.length) for (var r = 0; r < e2.attributeMaps.length; ++r) t.GroupAttributeRet.AttributeMap.encode(e2.attributeMaps[r], n2.uint32(18).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeRet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.attributeMaps && r.attributeMaps.length || (r.attributeMaps = []), r.attributeMaps.push(t.GroupAttributeRet.AttributeMap.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeMap = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.prototype.origin = "", e2.prototype.ms = q.Long ? q.Long.fromBits(0, 0, true) : 0, e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), null != e3.origin && Object.hasOwnProperty.call(e3, "origin") && t2.uint32(26).string(e3.origin), null != e3.ms && Object.hasOwnProperty.call(e3, "ms") && t2.uint32(32).uint64(e3.ms), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.GroupAttributeRet.AttributeMap(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                case 3:
                  r.origin = e3.string();
                  break;
                case 4:
                  r.ms = e3.uint64();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), HB = t.GroupAttributeSet = function() {
        function e(e2) {
          if (this.attributeInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.broadcast = false, e.prototype.attributeInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && n2.uint32(18).string(e2.group), null != e2.broadcast && Object.hasOwnProperty.call(e2, "broadcast") && n2.uint32(24).bool(e2.broadcast), null != e2.attributeInfos && e2.attributeInfos.length) for (var r = 0; r < e2.attributeInfos.length; ++r) t.GroupAttributeSet.AttributeInfo.encode(e2.attributeInfos[r], n2.uint32(34).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeSet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.broadcast = e2.bool();
                break;
              case 4:
                r.attributeInfos && r.attributeInfos.length || (r.attributeInfos = []), r.attributeInfos.push(t.GroupAttributeSet.AttributeInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.GroupAttributeSet.AttributeInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), IB = t.GroupAttributeMod = function() {
        function e(e2) {
          if (this.attributeInfos = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.broadcast = false, e.prototype.attributeInfos = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && n2.uint32(18).string(e2.group), null != e2.broadcast && Object.hasOwnProperty.call(e2, "broadcast") && n2.uint32(24).bool(e2.broadcast), null != e2.attributeInfos && e2.attributeInfos.length) for (var r = 0; r < e2.attributeInfos.length; ++r) t.GroupAttributeMod.AttributeInfo.encode(e2.attributeInfos[r], n2.uint32(34).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeMod(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.broadcast = e2.bool();
                break;
              case 4:
                r.attributeInfos && r.attributeInfos.length || (r.attributeInfos = []), r.attributeInfos.push(t.GroupAttributeMod.AttributeInfo.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeInfo = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.GroupAttributeMod.AttributeInfo(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), JB = t.GroupAttributeDel = function() {
        function e(e2) {
          if (this.attributes = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.broadcast = false, e.prototype.attributes = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(18).string(e2.group), null != e2.broadcast && Object.hasOwnProperty.call(e2, "broadcast") && t2.uint32(24).bool(e2.broadcast), null != e2.attributes && e2.attributes.length) for (var n2 = 0; n2 < e2.attributes.length; ++n2) t2.uint32(34).string(e2.attributes[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeDel(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.broadcast = e2.bool();
                break;
              case 4:
                r.attributes && r.attributes.length || (r.attributes = []), r.attributes.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), KB = t.GroupAttributeAlt = function() {
        function e(e2) {
          if (this.attributeMaps = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.attributeMaps = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && n2.uint32(18).string(e2.group), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && n2.uint32(24).uint64(e2.instance), null != e2.attributeMaps && e2.attributeMaps.length) for (var r = 0; r < e2.attributeMaps.length; ++r) t.GroupAttributeAlt.AttributeMap.encode(e2.attributeMaps[r], n2.uint32(34).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeAlt(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              case 3:
                r.instance = e2.uint64();
                break;
              case 4:
                r.attributeMaps && r.attributeMaps.length || (r.attributeMaps = []), r.attributeMaps.push(t.GroupAttributeAlt.AttributeMap.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.AttributeMap = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.prototype.origin = "", e2.prototype.ms = q.Long ? q.Long.fromBits(0, 0, true) : 0, e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), null != e3.origin && Object.hasOwnProperty.call(e3, "origin") && t2.uint32(26).string(e3.origin), null != e3.ms && Object.hasOwnProperty.call(e3, "ms") && t2.uint32(32).uint64(e3.ms), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.GroupAttributeAlt.AttributeMap(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.key = e3.string();
                  break;
                case 2:
                  r.value = e3.string();
                  break;
                case 3:
                  r.origin = e3.string();
                  break;
                case 4:
                  r.ms = e3.uint64();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), LB = t.GroupAttributeRsp = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeRsp(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), MB = t.GroupAttributeErr = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.code = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(16).uint32(e2.code), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeErr(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.code = e2.uint32();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), NB = t.GroupAttributeKeysGet = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.group = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.group && Object.hasOwnProperty.call(e2, "group") && t2.uint32(18).string(e2.group), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeKeysGet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.group = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), OB = t.GroupAttributeKeysRet = function() {
        function e(e2) {
          if (this.keys = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.keys = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.keys && e2.keys.length) for (var n2 = 0; n2 < e2.keys.length; ++n2) t2.uint32(18).string(e2.keys[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.GroupAttributeKeysRet(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.keys && r.keys.length || (r.keys = []), r.keys.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), PB = t.SubscribeUserStatus = function() {
        function e(e2) {
          if (this.users = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.users = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.users && e2.users.length) for (var n2 = 0; n2 < e2.users.length; ++n2) t2.uint32(18).string(e2.users[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.SubscribeUserStatus(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.users && r.users.length || (r.users = []), r.users.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), QB = t.UnsubscribeUserStatus = function() {
        function e(e2) {
          if (this.users = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.users = q.emptyArray, e.encode = function(e2, t2) {
          if (t2 || (t2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(8).uint64(e2.seq), null != e2.users && e2.users.length) for (var n2 = 0; n2 < e2.users.length; ++n2) t2.uint32(18).string(e2.users[n2]);
          return t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UnsubscribeUserStatus(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.users && r.users.length || (r.users = []), r.users.push(e2.string());
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), RB = t.UserJoinNotice = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.user = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(8).uint64(e2.instance), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(16).uint64(e2.seq), null != e2.user && Object.hasOwnProperty.call(e2, "user") && t2.uint32(26).string(e2.user), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserJoinNotice(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.instance = e2.uint64();
                break;
              case 2:
                r.seq = e2.uint64();
                break;
              case 3:
                r.user = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), SB = t.UserQuitNotice = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.user = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(8).uint64(e2.instance), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(16).uint64(e2.seq), null != e2.user && Object.hasOwnProperty.call(e2, "user") && t2.uint32(26).string(e2.user), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserQuitNotice(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.instance = e2.uint64();
                break;
              case 2:
                r.seq = e2.uint64();
                break;
              case 3:
                r.user = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), TB = t.UserWaitNotice = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.instance = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.user = "", e.encode = function(e2, t2) {
          return t2 || (t2 = L.create()), null != e2.instance && Object.hasOwnProperty.call(e2, "instance") && t2.uint32(8).uint64(e2.instance), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && t2.uint32(16).uint64(e2.seq), null != e2.user && Object.hasOwnProperty.call(e2, "user") && t2.uint32(26).string(e2.user), t2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.UserWaitNotice(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.instance = e2.uint64();
                break;
              case 2:
                r.seq = e2.uint64();
                break;
              case 3:
                r.user = e2.string();
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e;
      }(), UB = t.SubscribeResponse = function() {
        function e(e2) {
          if (this.errors = [], e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.seq = q.Long ? q.Long.fromBits(0, 0, true) : 0, e.prototype.errors = q.emptyArray, e.encode = function(e2, n2) {
          if (n2 || (n2 = L.create()), null != e2.seq && Object.hasOwnProperty.call(e2, "seq") && n2.uint32(8).uint64(e2.seq), null != e2.errors && e2.errors.length) for (var r = 0; r < e2.errors.length; ++r) t.SubscribeResponse.SubscribeErrorsType.encode(e2.errors[r], n2.uint32(18).fork()).ldelim();
          return n2;
        }, e.decode = function(e2, n2) {
          e2 instanceof u || (e2 = u.create(e2)), n2 = void 0 === n2 ? e2.len : e2.pos + n2;
          for (var r = new t.SubscribeResponse(); e2.pos < n2; ) {
            var i = e2.uint32();
            switch (i >>> 3) {
              case 1:
                r.seq = e2.uint64();
                break;
              case 2:
                r.errors && r.errors.length || (r.errors = []), r.errors.push(t.SubscribeResponse.SubscribeErrorsType.decode(e2, e2.uint32()));
                break;
              default:
                e2.skipType(7 & i);
            }
          }
          return r;
        }, e.SubscribeErrorsType = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.account = "", e2.prototype.code = 0, e2.encode = function(e3, t2) {
            return t2 || (t2 = L.create()), null != e3.account && Object.hasOwnProperty.call(e3, "account") && t2.uint32(10).string(e3.account), null != e3.code && Object.hasOwnProperty.call(e3, "code") && t2.uint32(16).uint32(e3.code), t2;
          }, e2.decode = function(e3, n2) {
            e3 instanceof u || (e3 = u.create(e3)), n2 = void 0 === n2 ? e3.len : e3.pos + n2;
            for (var r = new t.SubscribeResponse.SubscribeErrorsType(); e3.pos < n2; ) {
              var i = e3.uint32();
              switch (i >>> 3) {
                case 1:
                  r.account = e3.string();
                  break;
                case 2:
                  r.code = e3.uint32();
                  break;
                default:
                  e3.skipType(7 & i);
              }
            }
            return r;
          }, e2;
        }(), e;
      }(), VB = Object.freeze({ __proto__: null, URI: YA, Wrapper: Oh, Ping: ZA, Pong: $A, UserJoin: aB, UserResp: bB, UserQuit: cB, UserDrop: dB, GroupEnter: eB, GroupLeave: fB, GroupReply: gB, GroupLeaveNotice: ur, GroupEnterNotice: vr, Message: wr, Ack: xr, FileUploadIndexGet: hB, FileUploadIndexRet: iB, FileUploadIndexSet: jB, FileUploadIndexFin: kB, FileUploadIndexErr: lB, FileDownloadIndexGet: mB, FileDownloadIndexRet: nB, FileDownloadIndexErr: oB, GroupAllUsersList: pB, GroupAllUsersResult: qB, UserStatusList: rB, UserStatusResult: sB, UserAttributeGet: tB, UserAttributeRet: uB, UserAttributeSet: vB, UserAttributeMod: wB, UserAttributeDel: xB, UserAttributeErr: yB, UserAttributeKeysGet: zB, UserAttributeKeysRet: AB, UserAttributeRsp: BB, GroupStatusList: CB, GroupStatusResult: DB, GroupCountNotice: EB, GroupAttributeGet: FB, GroupAttributeRet: GB, GroupAttributeSet: HB, GroupAttributeMod: IB, GroupAttributeDel: JB, GroupAttributeAlt: KB, GroupAttributeRsp: LB, GroupAttributeErr: MB, GroupAttributeKeysGet: NB, GroupAttributeKeysRet: OB, SubscribeUserStatus: PB, UnsubscribeUserStatus: QB, UserJoinNotice: RB, UserQuitNotice: SB, UserWaitNotice: TB, SubscribeResponse: UB, default: t }), WB = Math.ceil, yr = function(e) {
        return function(t2, n2, r) {
          var i = (t2 = String(jb(t2))).length;
          return r = void 0 === r ? " " : String(r), (n2 = ta(n2)) <= i || "" == r ? t2 : (n2 -= i, (i = Pn.call(r, WB(n2 / r.length))).length > n2 && (i = i.slice(0, n2)), e ? t2 + i : i + t2);
        };
      }, XB = yr(false), YB = yr(true), zr = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(De);
      N({ target: "String", proto: true, forced: zr }, { padEnd: function(e) {
        return YB(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } });
      var ZB = zf, Ar = function(e) {
        return function(t2) {
          t2 = qb(t2);
          for (var n2, r = Dc(t2), i = r.length, o = 0, a2 = []; i > o; ) n2 = r[o++], ka && !ZB.call(t2, n2) || a2.push(e ? [n2, t2[n2]] : t2[n2]);
          return a2;
        };
      }, $B = Ar(true), aC = Ar(false);
      N({ target: "Object", stat: true }, { entries: function(e) {
        return $B(e);
      } });
      var bC = Fb.f, Br = "".endsWith, cC = Math.min, Cr = dk("endsWith"), dC = !Cr && !!function() {
        var e = bC(String.prototype, "endsWith");
        return e && !e.writable;
      }();
      N({ target: "String", proto: true, forced: !dC && !Cr }, { endsWith: function(e) {
        var t2 = String(jb(this));
        ck(e);
        var n2 = 1 < arguments.length ? arguments[1] : void 0, r = ta(t2.length);
        return n2 = void 0 === n2 ? r : cC(ta(n2), r), r = String(e), Br ? Br.call(t2, r, n2) : t2.slice(n2 - r.length, n2) === r;
      } }), dh("match", 1, function(e, t2, n2) {
        return [function(t3) {
          var n3 = jb(this), r = null == t3 ? void 0 : t3[e];
          return void 0 !== r ? r.call(t3, n3) : new RegExp(t3)[e](String(n3));
        }, function(e2) {
          var r = n2(t2, e2, this);
          if (r.done) return r.value;
          if (e2 = va(e2), r = String(this), !e2.global) return Ke(e2, r);
          var i = e2.unicode;
          e2.lastIndex = 0;
          for (var o, a2 = [], s = 0; null !== (o = Ke(e2, r)); ) o = String(o[0]), a2[s] = o, "" === o && (e2.lastIndex = xj(r, ta(e2.lastIndex), i)), s++;
          return 0 === s ? null : a2;
        }];
      });
      var eC = Fb.f, Dr = "".startsWith, fC = Math.min, Er = dk("startsWith"), gC = !Er && !!function() {
        var e = eC(String.prototype, "startsWith");
        return e && !e.writable;
      }();
      N({ target: "String", proto: true, forced: !gC && !Er }, { startsWith: function(e) {
        var t2 = String(jb(this));
        ck(e);
        var n2 = ta(fC(1 < arguments.length ? arguments[1] : void 0, t2.length)), r = String(e);
        return Dr ? Dr.call(t2, r, n2) : t2.slice(n2, n2 + r.length) === r;
      } });
      var Nm = function(e) {
        var t2 = /(%?)(%([jds]))/g, n2 = Array.prototype.slice.call(arguments, 1);
        return n2.length && (e = e.replace(t2, function(e2, t3, r, i) {
          switch (r = n2.shift(), i) {
            case "s":
              r = "" + r;
              break;
            case "d":
              r = Number(r);
              break;
            case "j":
              r = JSON.stringify(r);
          }
          return t3 ? (n2.unshift(r), e2) : r;
        })), n2.length && (e += " " + n2.join(" ")), "" + (e = e.replace(/%{2,2}/g, "%"));
      }, hC = /\s/, iC = function(e) {
        for (var t2 = e.length; t2-- && hC.test(e.charAt(t2)); ) ;
        return t2;
      }, jC = /^\s+/, Fr = NaN, kC = /^[-+]0x[0-9a-f]+$/i, lC = /^0b[01]+$/i, mC = /^0o[0-7]+$/i, nC = parseInt, gl = function(e) {
        if ("number" == typeof e) return e;
        if (ie(e)) return Fr;
        if (lb(e) && (e = "function" == typeof e.valueOf ? e.valueOf() : e, e = lb(e) ? e + "" : e), "string" != typeof e) return 0 === e ? e : +e;
        e = e ? e.slice(0, iC(e) + 1).replace(jC, "") : e;
        var t2 = lC.test(e);
        return t2 || mC.test(e) ? nC(e.slice(2), t2 ? 2 : 8) : kC.test(e) ? Fr : +e;
      }, oC = Math.max, pC = Math.min, qC = function(e, t2, n2) {
        function r(t3) {
          var n3 = u2, r2 = c2;
          return u2 = c2 = void 0, p = t3, l = e.apply(r2, n3);
        }
        function i(e2) {
          var n3 = e2 - h;
          return e2 -= p, void 0 === h || n3 >= t2 || 0 > n3 || v2 && e2 >= g;
        }
        function o() {
          var e2 = Cb.Date.now();
          if (i(e2)) return a2(e2);
          var n3 = setTimeout, r2 = e2 - p;
          e2 = t2 - (e2 - h), r2 = v2 ? pC(e2, g - r2) : e2, f = n3(o, r2);
        }
        function a2(e2) {
          return f = void 0, b && u2 ? r(e2) : (u2 = c2 = void 0, l);
        }
        function s() {
          var e2 = Cb.Date.now(), n3 = i(e2);
          if (u2 = arguments, c2 = this, h = e2, n3) {
            if (void 0 === f) return p = e2 = h, f = setTimeout(o, t2), d ? r(e2) : l;
            if (v2) return clearTimeout(f), f = setTimeout(o, t2), r(h);
          }
          return void 0 === f && (f = setTimeout(o, t2)), l;
        }
        var u2, c2, l, f, h, p = 0, d = false, v2 = false, b = true;
        if ("function" != typeof e) throw new TypeError("Expected a function");
        if (t2 = gl(t2) || 0, lb(n2)) {
          d = !!n2.leading;
          var g = (v2 = "maxWait" in n2) ? oC(gl(n2.maxWait) || 0, t2) : g;
          b = "trailing" in n2 ? !!n2.trailing : b;
        }
        return s.cancel = function() {
          void 0 !== f && clearTimeout(f), p = 0, u2 = h = c2 = f = void 0;
        }, s.flush = function() {
          return void 0 === f ? l : a2(Cb.Date.now());
        }, s;
      }, yc = function(e) {
        function t2(e2, i) {
          return W(this, t2), m(n(e2 = r.call(this, Mm(e2, i))), "originalError", void 0), m(n(e2), "code", void 0), m(n(e2), "serverCode", void 0), "number" == typeof i ? e2.code = i : "string" == typeof i ? e2.name = i : void 0 !== i && (i.originalError && (e2.originalError = i.originalError), void 0 !== i.code && (e2.code = i.code), void 0 !== i.serverCode && (e2.serverCode = i.serverCode)), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(ef(Error)), Ia = function(e) {
        function t2(e2, i) {
          return W(this, t2), m(n(e2 = r.call(this, Mm(e2, i))), "name", "RtmInternalError"), m(n(e2), "code", void 0), e2.code = i, e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(ef(Error)), Ph = function() {
        return function(e) {
          function t2(e2) {
            W(this, t2);
            var r = Object.keys(e2);
            return n2.call(this, e2[r[0]], r[0]);
          }
          la(t2, e);
          var n2 = ma(t2);
          return t2;
        }(Ia);
      }, Fa = Ph(), db = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmTimeoutError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), I = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmInvalidArgumentError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), K = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmInvalidStatusError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), hl = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmInterruptedError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), ib = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmLimitExceededError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), rC = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmInvokeTooOftenError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), da = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmUnavailableError"), m(n(e2), "serverCode", void 0), m(n(e2), "statusCode", void 0), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), Ye = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmUnauthenticatedError"), m(n(e2), "serverCode", void 0), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), Wc = function(e) {
        function t2() {
          W(this, t2);
          for (var e2 = arguments.length, i = Array(e2), o = 0; o < e2; o++) i[o] = arguments[o];
          return m(n(e2 = r.call.apply(r, [this].concat(i))), "name", "RtmUnknownError"), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return t2;
      }(yc), Sa = function(e) {
        return e instanceof db || e instanceof pb;
      }, sa = function(e) {
        return e instanceof yc;
      }, Yd = function(e, t2, n2) {
        return ['Executing "%s.%s" timed out after %ds', e, t2, n2 / 1e3];
      }, Lm = /* @__PURE__ */ new Map(), sC = function() {
        var e = /* @__PURE__ */ new Date();
        return "".concat(e.toISOString().split("T")[1].replace(/\..+/, ""), ".").concat(e.getMilliseconds());
      }, xf = Object.keys, Hg = Object.entries.bind(Object), Cg = function(e) {
        return "string" == typeof e ? e.endsWith(".") ? e : "".concat(e, ".") : e;
      }, Sm = function(e) {
        for (var t2 = "", n2 = (e = new Uint8Array(e)).byteLength, r = -1; ++r < n2; ) t2 += String.fromCharCode(e[r]);
        return t2 = btoa(t2), "data:;base64,".concat(t2);
      }, tC = R(function() {
        return null !== (/* @__PURE__ */ new Date(NaN)).toJSON() || 1 !== Date.prototype.toJSON.call({ toISOString: function() {
          return 1;
        } });
      });
      N({ target: "Date", proto: true, forced: tC }, { toJSON: function(e) {
        e = Qa(this);
        var t2 = lc(e);
        return "number" != typeof t2 || isFinite(t2) ? e.toISOString() : null;
      } }), N({ target: "URL", proto: true, enumerable: true }, { toJSON: function() {
        return URL.prototype.toString.call(this);
      } });
      var $t = Object.prototype.hasOwnProperty, Gr = function(e, t2, n2) {
        return JSON.stringify(Ym(e), t2, n2);
      };
      Gr.ensureProperties = Ym;
      var uC = function(e, t2) {
        t2 = t2 || {};
        var n2 = X(e);
        if ("string" === n2 && 0 < e.length) return au(e);
        if ("number" === n2 && isFinite(e)) return t2.long ? e = 864e5 <= (t2 = Math.abs(e)) ? Jg(e, t2, 864e5, "day") : 36e5 <= t2 ? Jg(e, t2, 36e5, "hour") : 6e4 <= t2 ? Jg(e, t2, 6e4, "minute") : 1e3 <= t2 ? Jg(e, t2, 1e3, "second") : e + " ms" : e = 864e5 <= (t2 = Math.abs(e)) ? Math.round(e / 864e5) + "d" : 36e5 <= t2 ? Math.round(e / 36e5) + "h" : 6e4 <= t2 ? Math.round(e / 6e4) + "m" : 1e3 <= t2 ? Math.round(e / 1e3) + "s" : e + "ms", e;
        throw Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
      }, vC = function(e) {
        function t2(e2) {
          function r2() {
            for (var e3 = arguments.length, n3 = Array(e3), o2 = 0; o2 < e3; o2++) n3[o2] = arguments[o2];
            if (r2.enabled) {
              e3 = Number(/* @__PURE__ */ new Date()), r2.diff = e3 - (i || e3), r2.prev = i, i = r2.curr = e3, n3[0] = t2.coerce(n3[0]), "string" != typeof n3[0] && n3.unshift("%O");
              var a2 = 0;
              n3[0] = n3[0].replace(/%([a-zA-Z%])/g, function(e4, i2) {
                return "%%" === e4 ? "%" : (a2++, "function" == typeof (i2 = t2.formatters[i2]) && (e4 = i2.call(r2, n3[a2]), n3.splice(a2, 1), a2--), e4);
              }), t2.formatArgs.call(r2, n3), (r2.log || t2.log).apply(r2, n3);
            }
          }
          var i, o = null;
          return r2.namespace = e2, r2.useColors = t2.useColors(), r2.color = t2.selectColor(e2), r2.extend = n2, r2.destroy = t2.destroy, Object.defineProperty(r2, "enabled", { enumerable: true, configurable: false, get: function() {
            return null === o ? t2.enabled(e2) : o;
          }, set: function(e3) {
            o = e3;
          } }), "function" == typeof t2.init && t2.init(r2), r2;
        }
        function n2(e2, n3) {
          return (e2 = t2(this.namespace + (void 0 === n3 ? ":" : n3) + e2)).log = this.log, e2;
        }
        function r(e2) {
          return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        return t2.debug = t2, t2.default = t2, t2.coerce = function(e2) {
          return e2 instanceof Error ? e2.stack || e2.message : e2;
        }, t2.disable = function() {
          var e2 = [].concat(G(t2.names.map(r)), G(t2.skips.map(r).map(function(e3) {
            return "-" + e3;
          }))).join(",");
          return t2.enable(""), e2;
        }, t2.enable = function(e2) {
          t2.save(e2), t2.names = [], t2.skips = [];
          var n3, r2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), i = r2.length;
          for (n3 = 0; n3 < i; n3++) r2[n3] && ("-" === (e2 = r2[n3].replace(/\*/g, ".*?"))[0] ? t2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : t2.names.push(new RegExp("^" + e2 + "$")));
        }, t2.enabled = function(e2) {
          if ("*" === e2[e2.length - 1]) return true;
          var n3, r2 = 0;
          for (n3 = t2.skips.length; r2 < n3; r2++) if (t2.skips[r2].test(e2)) return false;
          for (r2 = 0, n3 = t2.names.length; r2 < n3; r2++) if (t2.names[r2].test(e2)) return true;
          return false;
        }, t2.humanize = uC, t2.destroy = function() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }, Object.keys(e).forEach(function(n3) {
          t2[n3] = e[n3];
        }), t2.names = [], t2.skips = [], t2.formatters = {}, t2.selectColor = function(e2) {
          for (var n3 = 0, r2 = 0; r2 < e2.length; r2++) n3 = (n3 << 5) - n3 + e2.charCodeAt(r2), n3 |= 0;
          return t2.colors[Math.abs(n3) % t2.colors.length];
        }, t2.enable(t2.load()), t2;
      }, Hr = $a(function(e, t2) {
        t2.formatArgs = function(t3) {
          if (t3[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t3[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), this.useColors) {
            var n3 = "color: " + this.color;
            t3.splice(1, 0, n3, "color: inherit");
            var r = 0, i = 0;
            t3[0].replace(/%[a-zA-Z%]/g, function(e2) {
              "%%" !== e2 && (r++, "%c" === e2 && (i = r));
            }), t3.splice(i, 0, n3);
          }
        }, t2.save = function(e2) {
          try {
            e2 ? t2.storage.setItem("debug", e2) : t2.storage.removeItem("debug");
          } catch (e3) {
          }
        }, t2.load = function() {
          try {
            var e2 = t2.storage.getItem("debug");
          } catch (e3) {
          }
          return !e2 && "undefined" != typeof process && "env" in process && (e2 = process.env.DEBUG), e2;
        }, t2.useColors = function() {
          return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type && !window.process.__nwjs) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
        };
        e: {
          try {
            var n2 = localStorage;
            break e;
          } catch (e2) {
          }
          n2 = void 0;
        }
        t2.storage = n2, t2.destroy = /* @__PURE__ */ function() {
          var e2 = false;
          return function() {
            e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        }(), t2.colors = "#0000CC #0000FF #0033CC #0033FF #0066CC #0066FF #0099CC #0099FF #00CC00 #00CC33 #00CC66 #00CC99 #00CCCC #00CCFF #3300CC #3300FF #3333CC #3333FF #3366CC #3366FF #3399CC #3399FF #33CC00 #33CC33 #33CC66 #33CC99 #33CCCC #33CCFF #6600CC #6600FF #6633CC #6633FF #66CC00 #66CC33 #9900CC #9900FF #9933CC #9933FF #99CC00 #99CC33 #CC0000 #CC0033 #CC0066 #CC0099 #CC00CC #CC00FF #CC3300 #CC3333 #CC3366 #CC3399 #CC33CC #CC33FF #CC6600 #CC6633 #CC9900 #CC9933 #CCCC00 #CCCC33 #FF0000 #FF0033 #FF0066 #FF0099 #FF00CC #FF00FF #FF3300 #FF3333 #FF3366 #FF3399 #FF33CC #FF33FF #FF6600 #FF6633 #FF9900 #FF9933 #FFCC00 #FFCC33".split(" "), t2.log = console.debug || console.log || function() {
        }, e.exports = vC(t2), e.exports.formatters.j = function(e2) {
          try {
            return JSON.stringify(e2);
          } catch (e3) {
            return "[UnexpectedJSONParseError]: " + e3.message;
          }
        };
      }), Ir = Hr("RTM:DEBUG"), Ze;
      Ir.enabled = false, function(e) {
        e[e.Uploading = 0] = "Uploading", e[e.Free = 1] = "Free";
      }(Ze || (Ze = {}));
      var wC = function() {
        function e(t2) {
          W(this, e), m(this, "uploadRequest", void 0), m(this, "uploadState", void 0), m(this, "uploadResendCount", void 0), m(this, "LogCache", void 0), m(this, "LogsToPost", void 0), m(this, "processId", void 0), m(this, "sdkVersion", void 0), m(this, "logId", void 0), m(this, "rtmConfig", void 0), this.processId = t2.processId, this.sdkVersion = t2.sdkVersion, this.rtmConfig = t2.rtmConfig, this.uploadRequest = t2.uploadRequest, this.uploadState = Ze.Free, this.uploadResendCount = 0, this.LogCache = [], this.LogsToPost = [], this.logId = 0;
        }
        return Ha(e, [{ key: "upload", value: function(e2) {
          this.LogCache.push(e2), this.uploadState === Ze.Free && (this.LogsToPost = 40 > this.LogCache.length ? this.LogCache.splice(0, this.LogCache.length) : this.LogCache.splice(0, 40), this.postLog(this.LogsToPost));
        } }, { key: "postLog", value: function(e2) {
          var t2 = this;
          this.uploadState = Ze.Uploading, setTimeout(J(w.mark(function n2() {
            var r, i, o;
            return w.wrap(function(n3) {
              for (; ; ) switch (n3.prev = n3.next) {
                case 0:
                  return r = { sdk_version: t2.sdkVersion, process_id: t2.processId, payload: JSON.stringify(e2) }, n3.prev = 1, n3.next = 4, t2.uploadRequest(r, null !== (i = t2.rtmConfig.enableCloudProxy) && void 0 !== i && i);
                case 4:
                  if (!Uk) {
                    n3.next = 6;
                    break;
                  }
                  throw Error("RTM is busy");
                case 6:
                  n3.next = 13;
                  break;
                case 8:
                  return n3.prev = 8, n3.t0 = n3.catch(1), o = 2 > t2.uploadResendCount++ ? 2e3 : 1e4, setTimeout(function() {
                    return t2.postLog(t2.LogsToPost);
                  }, o), n3.abrupt("return");
                case 13:
                  if (Ir('The logs uploaded for "process-'.concat(gg, '"')), 0 !== t2.LogCache.length) {
                    n3.next = 17;
                    break;
                  }
                  return t2.uploadState = Ze.Free, n3.abrupt("return");
                case 17:
                  t2.uploadResendCount = 0, t2.LogsToPost = 40 > t2.LogCache.length ? t2.LogCache.splice(0, t2.LogCache.length) : t2.LogCache.splice(0, 40), t2.postLog(t2.LogsToPost);
                case 20:
                case "end":
                  return n3.stop();
              }
            }, n2, null, [[1, 8]]);
          })), Zd.getParameter("LOG_UPLOAD_INTERVAL"));
        } }]), e;
      }(), Jr = function(e, t2, n2, r, i, o, a2, s) {
        var u2 = 0;
        for (a2 = !!a2 && Id(a2, s, 3); u2 < r; ) {
          if (u2 in n2) {
            if (s = a2 ? a2(n2[u2], u2, t2) : n2[u2], 0 < o && gd(s)) i = Jr(e, t2, s, ta(s.length), i, o - 1) - 1;
            else {
              if (9007199254740991 <= i) throw TypeError("Exceed the acceptable array length");
              e[i] = s;
            }
            i++;
          }
          u2++;
        }
        return i;
      }, xC = Jr;
      N({ target: "Array", proto: true }, { flat: function() {
        var e = arguments.length ? arguments[0] : void 0, t2 = Qa(this), n2 = ta(t2.length), r = Sg(t2, 0);
        return r.length = xC(r, t2, t2, n2, 0, void 0 === e ? 1 : $b(e)), r;
      } }), N({ target: "Object", stat: true }, { values: function(e) {
        return aC(e);
      } });
      var yC = ["CODE"], Db, ud, F;
      !function(e) {
        e.CHINA = "CN", e.ASIA = "AS", e.NORTH_AMERICA = "NA", e.EUROPE = "EU", e.JAPAN = "JP", e.INDIA = "IN", e.OCEANIA = "OC", e.SOUTH_AMERICA = "SA", e.AFRICA = "AF", e.OVERSEA = "OVERSEA", e.GLOBAL = "GLOBAL";
      }(F || (F = {}));
      var zC = { CN: F.CHINA, NA: F.NORTH_AMERICA, EU: F.EUROPE, AS: F.ASIA, JP: F.JAPAN, IN: F.INDIA, GLOB: F.GLOBAL, AF: F.AFRICA, OC: F.OVERSEA, OVS: F.OVERSEA, SA: F.SOUTH_AMERICA }, Kg = Wm((Db = {}, m(Db, F.ASIA, { CODE: F.ASIA, AP_DOMAINS: ["ap-web-1-asia.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-asia.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_AP: ["proxy-ap-web-asia.agora.io"], PROXY_NGINX: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.NORTH_AMERICA, { CODE: F.NORTH_AMERICA, AP_DOMAINS: ["ap-web-1-north-america.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-north-america.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_AP: ["proxy-ap-web-america.agora.io"], PROXY_NGINX: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.EUROPE, { CODE: F.EUROPE, AP_DOMAINS: ["ap-web-1-europe.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-europe.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_AP: ["proxy-ap-web-europe.agora.io"], PROXY_NGINX: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.JAPAN, { CODE: F.JAPAN, AP_DOMAINS: ["ap-web-1-japan.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-japan.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_AP: ["proxy-ap-web-japan.agora.io"], PROXY_NGINX: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.INDIA, { CODE: F.INDIA, AP_DOMAINS: ["ap-web-1-india.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-india.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_AP: ["proxy-ap-web-india.agora.io"], PROXY_NGINX: ["india.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.OVERSEA, { CODE: F.OVERSEA, AP_DOMAINS: ["ap-web-1-oversea.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_AP: ["proxy-ap-web-oversea.agora.io"], PROXY_NGINX: ["webrtc-cloud-proxy.agora.io"] }), m(Db, F.GLOBAL, { CODE: F.GLOBAL, AP_DOMAINS: ["ap-web-1.agora.io", "ap-web-2.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-3.agora.io", "ap-web-4.agora.io"], EVENT_REPORT_DOMAIN: ["webcollector-rtm.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["webcollector-1.agora.io"], LOG_UPLOAD_SERVER: ["logservice-rtm.agora.io"], PROXY_AP: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], PROXY_NGINX: ["webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.OCEANIA, { CODE: F.OCEANIA, AP_DOMAINS: ["ap-web-1-oceania.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-oceania.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_AP: ["proxy-ap-web-oceania.agora.io"], PROXY_NGINX: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.SOUTH_AMERICA, { CODE: F.SOUTH_AMERICA, AP_DOMAINS: ["ap-web-1-south-america.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-south-america.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_AP: ["proxy-ap-web-south-america.agora.io"], PROXY_NGINX: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.AFRICA, { CODE: F.AFRICA, AP_DOMAINS: ["ap-web-1-africa.agora.io"], AP_BACKUP_DOMAINS: ["ap-web-2-africa.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_AP: ["proxy-ap-web-africa.agora.io"], PROXY_NGINX: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }), m(Db, F.CHINA, { CODE: F.CHINA, AP_DOMAINS: ["webrtc2-2.ap.sd-rtn.com"], AP_BACKUP_DOMAINS: ["webrtc2-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_AP: ["proxy-ap-web.agoraio.cn"], PROXY_NGINX: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), Db)), yf = (ud = {}, m(ud, F.ASIA, [F.CHINA, F.JAPAN, F.INDIA]), m(ud, F.EUROPE, []), m(ud, F.NORTH_AMERICA, []), m(ud, F.SOUTH_AMERICA, []), m(ud, F.OCEANIA, []), m(ud, F.AFRICA, []), ud), Kr = [F.OVERSEA, F.GLOBAL, F.CHINA, F.NORTH_AMERICA, F.EUROPE, F.ASIA, F.JAPAN, F.INDIA, F.OCEANIA, F.SOUTH_AMERICA, F.AFRICA], Zm = function(e) {
        return Object.values(yf).flat().includes(e);
      }, cu = function(e) {
        var t2;
        return null === (t2 = Hg(yf).find(function(t3) {
          return (t3 = ra(t3, 2))[0], t3[1].includes(e);
        })) || void 0 === t2 ? void 0 : t2[0];
      }, AC = function(e) {
        return e.sort(function(e2, t2) {
          return Kr.indexOf(e2) - Kr.indexOf(t2);
        });
      }, xe = function(e) {
        var t2 = /* @__PURE__ */ new Set();
        if (0 === (e = AC(e).slice(0, 3).map(function(e2) {
          var n2 = Kg[e2];
          if (void 0 === n2) throw new Ia("invalid area key");
          return e2 = n2.CODE, n2 = ff(n2, yC), t2.add(e2), n2;
        })).length) throw new Ia("areas cannot be empty");
        return ua({ CODES: t2 }, e.reduce(function(e2, t3) {
          for (var n2 = 0, r = Hg(e2); n2 < r.length; n2++) {
            var i = ra(r[n2], 2), o = i[0];
            i = i[1], e2[o] = Array.from(new Set([].concat(G(t3[o]), G(i))));
          }
          return e2;
        }));
      }, M, Lr = function() {
        var e = J(w.mark(function e2(t2, n2) {
          var r, i, o, a2, s, u2 = arguments;
          return w.wrap(function(e3) {
            for (; ; ) switch (e3.prev = e3.next) {
              case 0:
                if (!(2 < (i = 2 < u2.length && void 0 !== u2[2] ? u2[2] : 0))) {
                  e3.next = 3;
                  break;
                }
                return e3.abrupt("return");
              case 3:
                return o = { withCredentials: true, body: t2, timeout: 2e4 }, a2 = 0 < i ? (null == M ? void 0 : M.LOG_UPLOAD_SERVER[0]) || "rtm.logservice.sd-rtn.com" : (null == M ? void 0 : M.LOG_UPLOAD_SERVER[0]) || "logservice-rtm.agora.io", s = n2 ? "https://".concat(null !== (r = null == M ? void 0 : M.PROXY_NGINX[0]) && void 0 !== r ? r : "webrtc-cloud-proxy.sd-rtn.com", "/ls/?h=").concat(a2, "&p=443&d=upload/v1") : "https://".concat(a2, "/upload/v1"), e3.next = 8, te(s, o).catch(function(e4) {
                  return Lr(t2, n2, i + 1);
                });
              case 8:
              case "end":
                return e3.stop();
            }
          }, e2);
        }));
        return function(t2, n2) {
          return e.apply(this, arguments);
        };
      }(), Mr = new wC({ processId: "process-".concat(gg), sdkVersion: "Agora_RTM_SDK_for_Web_".concat("v1.4.3-17-g1e27aa38"), uploadRequest: Lr, rtmConfig: {} }), il = "text payload rawMessage thumbnail attributeInfos keys value extra".split(" "), Nr = "account ticket uid detail token account fileName cname user group key origin users src dst lastUpdateUserId channel cert wan_ip".split(" "), Or = "serverReceivedTs isOfflineMessage enableHistoricalMessaging enableOfflineMessaging hasPeerReceived messageType enableNotificationToChannelMembers lastUpdateTs".split(" "), BC = "ChannelMessage MemberLeft MessageFromPeer LocalInvitationRefused LocalInvitationAccepted RemoteInvitationCanceled PeersOnlineStatusChanged AttributesUpdated MemberJoined".split(" "), ye = function(e) {
        if ("string" == typeof e) return oa(e);
        if (Array.isArray(e) && e.every(function(e2) {
          return "string" == typeof e2;
        })) return e.map(function(e2) {
          return oa(e2);
        });
        if (!Il(e)) {
          for (var t2 = {}, n2 = 0; n2 < Or.length; n2++) {
            var r = Or[n2];
            r in e && (t2[r] = e[r]);
          }
          if (0 < Object.keys(t2).length) return t2;
          if (5 > Object.keys(e).length) {
            for (n2 = 0, e = Object.entries(e); n2 < e.length; n2++) {
              var i = ra(e[n2], 2);
              r = i[0], i = i[1], il.includes(r) ? t2[r] = "[Hidden Info]" : t2[oa(r)] = "string" == typeof i ? oa(i) : "[Sensitive Info]";
            }
            return t2;
          }
          return "[Sensitive Info]";
        }
        return e;
      }, Pr = function(e) {
        return "object" === X(e) ? yd(e) ? Vm(fe(e, 5), il, Nr) : e.constructor && e.constructor.name : e;
      }, Qr = function(e, t2) {
        return e instanceof Error ? e.message : "string" != typeof e ? JSON.stringify(Vm(fe(e, 5), il, Nr)) : (t2 = t2.map(function(e2) {
          return e2 instanceof Error ? e2.message : "object" === X(e2) ? Gr(Array.isArray(e2) ? e2.map(Pr) : Pr(e2)) : e2;
        }), Nm.apply(void 0, [e.replace(/%[%Oo]/g, function(e2) {
          return "%%" === e2 ? "%" : "%o" === e2 || "%O" === e2 ? "%s" : e2;
        })].concat(G(t2))));
      }, CC = 1, Rr = function(e, t2, n2) {
        var r = Hr(e);
        return r.enabled = true, r.log = n2, r.useColors = false, function(n3) {
          for (var i = arguments.length, o = Array(1 < i ? i - 1 : 0), a2 = 1; a2 < i; a2++) o[a2 - 1] = arguments[a2];
          if (t2.enableLogUpload) {
            i = Cg(n3);
            var s = Qr(i, o);
            Mr.upload({ log_item_id: "".concat(CC++), log_level: e, payload_str: "[".concat(sC(), "] ").concat(e, " - ").concat(256 < s.length ? s.slice(0, 256) : s) });
          }
          switch (i = function(e2) {
            var t3 = s || Qr(Cg(n3), o), i2 = Nc.LOG_HANDLER;
            "function" == typeof i2 && i2({ level: e2, message: t3 }), r(t3);
          }, e) {
            case "RTM:INFO":
              t2.logFilter.info && i("log");
              break;
            case "RTM:WARN":
              t2.logFilter.warn && i("warning");
              break;
            case "RTM:ERROR":
              t2.logFilter.error && i("error");
              break;
            case "RTM:TRACK":
              t2.logFilter.track && i("log");
              break;
            case "RTM:MSG:RECV":
            case "RTM:MSG:SEND":
              t2.logFilter.debug && i("debug");
              break;
            case "RTM:DEBUG":
              t2.logFilter.debug && i("debug");
          }
        };
      }, jl, Sr = function(e) {
        return function(t2) {
          var n2 = 1 === jl || void 0 === e ? "" : "Ins#".concat(e, " ");
          return "".concat(n2).concat(t2);
        };
      }, kl = function(e, t2, n2) {
        var r = Sr(jl);
        return Rr("RTM:".concat(t2), n2, function(t3) {
          return e(r(t3));
        });
      }, tb = function() {
        return function(e) {
          function t2(e2, i) {
            var o = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
            W(this, t2);
            var a2 = r.call(this);
            if (m(n(a2), "logError", void 0), m(n(a2), "invokeTracker", void 0), m(n(a2), "resultTracker", void 0), m(n(a2), "errorTracker", void 0), m(n(a2), "eventTracker", void 0), m(n(a2), "info", void 0), m(n(a2), "warn", void 0), m(n(a2), "log", void 0), m(n(a2), "genLogger", void 0), m(n(a2), "loggerId", void 0), m(n(a2), "logger", void 0), m(n(a2), "name", void 0), a2.logger = e2, a2.name = i, a2.loggerId = e2.loggerId, a2.info = e2.info, a2.warn = e2.warn, a2.logError = e2.logError, a2.genLogger = e2.genLogger, a2.log = e2.genLogger("RTM:DEBUG", "<".concat(i, "> ")), a2.invokeTracker = e2.genTracker("Invoke"), a2.eventTracker = e2.genTracker("Event"), a2.resultTracker = e2.genTracker("Result"), a2.errorTracker = e2.genTracker("Error"), o) {
              var s = a2.emit.bind(n(a2));
              a2.emit = function() {
                for (var e3 = arguments.length, t3 = Array(e3), n2 = 0; n2 < e3; n2++) t3[n2] = arguments[n2];
                e3 = t3[0], n2 = t3.slice(1);
                var r2 = BC.includes(e3);
                a2.eventTracker.apply(a2, ["%s: ".concat(0 < n2.length ? "%s emitted with args: ".concat(n2.map(function() {
                  return "%o";
                })) : "%s emitted"), i, e3].concat(G(r2 ? n2.map(ye) : n2)));
                try {
                  s.apply(void 0, t3);
                } catch (t4) {
                  a2.logError("Caught in the callback function of the event %s", e3, t4);
                }
              };
            }
            return a2;
          }
          la(t2, e);
          var r = ma(t2);
          return t2;
        }(ea);
      }, DC = function(e) {
        return kl(console.log.bind(console), "INFO", e);
      }, EC = function(e) {
        return kl(console.warn.bind(console), "WARN", e);
      }, FC = function(e) {
        return kl(console.error.bind(console), "ERROR", e);
      }, Tr = function(e, t2) {
        return function(n2) {
          var r = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "", i = Sr(e), o = console.debug.bind(console), a2 = Rr(n2, t2, function(e2) {
            return o(i(e2));
          });
          return function(e2) {
            for (var t3 = arguments.length, n3 = Array(1 < t3 ? t3 - 1 : 0), i2 = 1; i2 < t3; i2++) n3[i2 - 1] = arguments[i2];
            return a2.apply(void 0, [r + e2].concat(n3));
          };
        };
      }, GC = function(e, t2) {
        return function(n2) {
          return Tr(e, t2)("RTM:TRACK", "[".concat(n2, "] "));
        };
      }, Li = t.URI, eu = Oh, HC = ff(VB, ["Wrapper"]), $m = Gk(HC, "URI"), Ur = function(e, t2) {
        var n2 = -1, r = e.length, i = r - 1;
        for (t2 = void 0 === t2 ? r : t2; ++n2 < t2; ) {
          var o = e[r = nr(n2, i)];
          e[r] = e[n2], e[n2] = o;
        }
        return e.length = t2, e;
      }, IC = function(e) {
        return Ur(Xh(e));
      }, JC = function(e) {
        return Ur(Ni(e));
      }, $e = function(e) {
        return (Va(e) ? IC : JC)(e);
      }, af = { 0: 9591, 1: 9593 }, $d = function(e) {
        return "https://".concat(e, "/api/v1");
      }, KC = bb.apply(void 0, G($e(["web-1.ap.sd-rtn.com", "web-2.ap.sd-rtn.com"].map($d)))), LC = bb.apply(void 0, G($e(["ap-web-1.agora.io", "ap-web-2.agora.io"].map($d)))), MC = bb.apply(void 0, G($e(["web-3.ap.sd-rtn.com", "web-4.ap.sd-rtn.com"].map($d)))), NC = bb.apply(void 0, G($e(["ap-web-3.agora.io", "ap-web-4.agora.io"].map($d)))), ll = Ph(), ml = function(e) {
        function t2(e2, i, o, a2, s, u2) {
          W(this, t2);
          var c2 = r.call(this, s, Ai("Socket-", s.loggerId));
          if (m(n(c2), "isActiveClose", false), m(n(c2), "loggedIn", false), m(n(c2), "useNewDomain", void 0), m(n(c2), "receivedPacket", new Pa()), m(n(c2), "open$", void 0), m(n(c2), "input$", new Pa()), m(n(c2), "userJoin$", new Pa()), m(n(c2), "attemptsSinceLastError", 0), m(n(c2), "message$", new Pa()), m(n(c2), "socket$", void 0), m(n(c2), "toClose", new Pa()), m(n(c2), "toReconnect", new Pa()), m(n(c2), "sendLogger", void 0), m(n(c2), "receiveLogger", void 0), m(n(c2), "ip", void 0), m(n(c2), "env", void 0), m(n(c2), "ticket", void 0), m(n(c2), "context", void 0), m(n(c2), "getDomain", function() {
            return an(c2.ip, c2.useNewDomain);
          }), m(n(c2), "socketReconnector", function(e3) {
            var t3 = function(e4) {
              return c2.attemptsSinceLastError += 1, c2.warn("The %s of Env %d reconnecting %s", c2.name, c2.env, e4.message), Bc(3e3);
            };
            return e3.pipe(Ga(function(e4) {
              return c2.log("socket connection closed"), c2.loggedIn = false, 2 <= c2.attemptsSinceLastError ? (c2.warn("socket connection failure"), c2.emit("connectionFailure"), c2.close(), Z(e4)) : c2.isActiveClose ? vb : (c2.emit("reconnect"), c2.useNewDomain = !c2.useNewDomain, Z(e4));
            }), oe(function(e4) {
              return e4.pipe(Cc(t3));
            }));
          }), c2.ip = e2, c2.env = i, c2.ticket = o, c2.context = a2, c2.useNewDomain = null != u2 ? u2 : 0.5 <= Math.random(), c2.sendLogger = c2.genLogger("RTM:MSG:SEND"), c2.receiveLogger = c2.genLogger("RTM:MSG:RECV"), 0 !== i && 1 !== i) throw new ll({ ILLEGAL_RTM_ENV: "The env number is out of rtm env count" });
          if (!Gm(e2)) throw new ll({ IP_NOT_VALID: "The ip from ap is not valid" });
          var l = af[i];
          c2.log("Opening websocket address %s for the Env %d", c2.ip, c2.env);
          var f = Xb(c2.input$, c2.userJoin$.pipe(Rt(2)), c2.message$).pipe(ba(function(e3) {
            return Oh.encode(e3).finish();
          }));
          return e2 = Xb(St("", { protocols: [], makeWebSocket: function() {
            if (c2.context.config.enableCloudProxy) {
              if (0 === c2.context.cloudProxyServers.length) throw c2.logError("No cloud proxy server to connect"), new da();
              var e3 = "wss://".concat(an(bn(c2.context.cloudProxyServers), false), "/");
              e3 = we(e3, "sid", c2.context.sid), e3 = we(e3, "remote_port", l.toString()), e3 = we(e3, "remote_ip", c2.ip), e3 = we(e3, "token", c2.context.key), e3 = new WebSocket(e3);
            } else e3 = new WebSocket("wss://".concat(c2.getDomain(), ":").concat(l));
            return e3.binaryType = "arraybuffer", e3;
          } }), c2.toReconnect), c2.socket$ = Ca(e2, Tk.pipe(hb(15e3), Ga(function(e3) {
            return Sa(e3) && c2.warn("socket open timed out"), Z(e3);
          }))).pipe(ba(function(e3) {
            if (e3 instanceof Error) throw c2.warn("Env_%d: Force reconnect the socket", c2.env), e3;
            return e3(f).pipe(ba(function(e4) {
              return Oh.decode(new Uint8Array(e4));
            }));
          }), c2.socketReconnector), c2.open$ = c2.socket$.pipe(ca(function(e3) {
            c2.log("Websocket opened", c2.name), e3.subscribe(function(e4) {
              var t3 = e4.data;
              e4 = Li[e4.uri].slice(0, -3), t3 = $m[e4].decode(t3);
              var n2 = HA({}, Gk(t3, "toJSON"), function(e5, t4) {
                return t4 instanceof U ? Km(t4) : t4;
              }), r2 = false;
              if ((t3 instanceof vr || t3 instanceof ur) && t3.instance.lessThanOrEqual(4294967295) && (r2 = true), t3 instanceof wr || t3 instanceof xr) {
                var i2 = t3.instance, o2 = t3.sequence;
                (t3.dialogue.lessThanOrEqual(4294967295) || i2.lessThanOrEqual(4294967295) || o2.lessThan(1)) && (r2 = true);
              }
              r2 ? c2.warn("Env_%d: Illegal %s, abandoned %o", c2.env, e4, n2) : ("Pong" !== e4 && c2.receiveLogger("Env_%d: %s %o", c2.env, e4, n2), c2.receivedPacket.next([e4, t3]));
            }, function() {
            });
          }), qf(void 0), ob(c2.toClose), pe()), c2;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "address", get: function() {
          return "".concat(this.ip, ":").concat(af[this.env]);
        } }, { key: "sendPacket", value: function(e2, t3) {
          if ("Ping" !== e2) {
            var n2 = uc(t3, function(e3) {
              return e3 instanceof U ? Km(e3) : e3;
            });
            this.sendLogger("Env_%d: %s %o", this.env, e2, n2);
          }
          t3 = du(e2, t3), "UserJoin" === e2 ? this.userJoin$.next(t3) : "Message" === e2 ? this.message$.next(t3) : this.input$.next(t3);
        } }, { key: "close", value: function() {
          this.isActiveClose = true, this.loggedIn = false, this.toClose.next();
        } }, { key: "fromReceived", value: function(e2) {
          var t3 = this;
          return this.receivedPacket.pipe(ca(function(e3) {
            var n2 = ra(e3, 2);
            e3 = n2[0], n2 = n2[1], "UserResp" === e3 && (t3.attemptsSinceLastError = 0, t3.loggedIn = true), "UserDrop" === e3 && t3.emit("socketUserDrop", n2);
          }), wb(function(t4) {
            return ra(t4, 1)[0] === e2;
          }), ba(function(e3) {
            return ra(e3, 2)[1];
          }));
        } }, { key: "forceReconnect", value: function() {
          this.toReconnect.next(new ll({ FORCE_RECONNECTING: "Connection seems broken, try force reconnecting" }));
        } }]), t2;
      }(tb());
      N({ target: "String", proto: true, forced: zr }, { padStart: function(e) {
        return XB(this, e, 1 < arguments.length ? arguments[1] : void 0);
      } });
      var OC = function(e) {
        var t2 = xf(Kg);
        e = Yt(e);
        for (var n2 = 0; n2 < t2.length; n2++) {
          var r = Kg[t2[n2]];
          if (null != r && r.AP_DOMAINS.includes(e) || null != r && r.AP_BACKUP_DOMAINS.includes(e) || null != r && r.PROXY_AP.includes(e)) return [r.CODE];
        }
        return [F.CHINA, F.GLOBAL];
      }, PC = { INVALID_APP_ID: "Illegal App ID", NO_AUTHORIZED: "Signature verification failed", TOKEN_TIMEOUT: "Dynamic key expired", INVALID_TOKEN_UID: "UID in the security key(token) is not valid", APP_ID_NO_ACTIVATED: "The vendor is not activated", DYNAMIC_KEY_NOT_ENABLED: "The vendor did not enable the dynamic key, but uses the dynamic key", DYNAMIC_ENABLED_BUT_STATIC_KEY: "The vendor enabled the dynamic key, but uses the static key", TOKEN_EXPIRED: "The token has expired", INVALID_USER_ID: "The user ID to login does not match the token", FORBIDDEN_REGION: "Forbidden to access the request in this area", CANNOT_MEET_AREA_DEMAND: "Cannot allocate to meet the requirements of the given area limit" }, Vr = { 5: "INVALID_APP_ID", 7: "INVALID_USER_ID", 9: "NO_AUTHORIZED", 10: "TOKEN_TIMEOUT", 11: "APP_ID_NO_ACTIVATED", 12: "INVALID_TOKEN_UID", 13: "TOKEN_EXPIRED", 14: "DYNAMIC_KEY_NOT_ENABLED", 15: "DYNAMIC_ENABLED_BUT_STATIC_KEY", 18: "FORBIDDEN_REGION", 19: "CANNOT_MEET_AREA_DEMAND" }, QC = [100, 101, 102], Qh = /web-(\d)/, Wr = function(e) {
        function t2(e2, i) {
          var o = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
          W(this, t2);
          var a2 = r.call(this, i, "AccessPoint");
          return m(n(a2), "handleUniLbsError", function(e3, t3) {
            var n2 = e3;
            if (4 < e3.toString().length) {
              var r2 = e3.toString().padStart(8, "0"), i2 = parseInt(r2.slice(0, 4), 10);
              if (r2 = parseInt(r2.slice(4, 8), 10), 201 === i2) n2 = r2;
              else if (101 === i2 && !QC.includes(r2)) return Z(Error("service is currently unavailable"));
            }
            if (i2 = n2.toString(), !Object.keys(Vr).includes(i2)) return (e3 = new da(["Login is rejected by the server. The response code is %d", e3], jg)).serverCode = n2, Z(e3);
            switch (i2 = Vr[i2], n2 = PC[i2], i2) {
              case "INVALID_APP_ID":
              case "APP_ID_NO_ACTIVATED":
                return (t3 = new Ye(n2, $q)).serverCode = e3, Z(t3);
              case "INVALID_USER_ID":
                return (t3 = new Ye(n2, Jh)).serverCode = e3, Z(t3);
              case "TOKEN_EXPIRED":
              case "TOKEN_TIMEOUT":
                return (t3 = new Ye(n2, Kh)).serverCode = e3, Z(t3);
              case "NO_AUTHORIZED":
              case "INVALID_TOKEN_UID":
              case "DYNAMIC_KEY_NOT_ENABLED":
              case "DYNAMIC_ENABLED_BUT_STATIC_KEY":
                return (t3 = new Ye(n2, ar)).serverCode = e3, Z(t3);
              case "CANNOT_MEET_AREA_DEMAND":
                return (t3 = OC(t3)).forEach(function(e4) {
                  return a2.failedAreas.add(e4);
                }), a2.failedAreas.size === (void 0 === M ? 2 : M.CODES.size) ? ((t3 = new I(n2, jg)).serverCode = e3, Z(t3)) : Z(Error("ap ".concat(t3.join(", "), " cannot meet requirement")));
              case "FORBIDDEN_REGION":
                return (t3 = new da(n2, jg)).serverCode = e3, Z(t3);
              default:
                return Z(Im("ApResErrType", i2));
            }
          }), m(n(a2), "getApEdgeInfo$", void 0), m(n(a2), "getApEdgeInfoEndFirst$", void 0), m(n(a2), "apFinish$", new Pa()), m(n(a2), "retryCount", 0), m(n(a2), "failedAreas", /* @__PURE__ */ new Set()), m(n(a2), "usedUrl", []), m(n(a2), "newDomainUsed", false), m(n(a2), "backupNewDomainUsed", false), m(n(a2), "genUrl", function() {
            return void 0 === M ? mi.apply(void 0, G($e([KC, LC]))).pipe(ni(function(e3) {
              return bb.apply(void 0, G(e3));
            })) : bb.apply(void 0, G(M.AP_DOMAINS.slice(0, 3).map($d)));
          }), m(n(a2), "genBackupUrl", function() {
            return void 0 === M ? mi.apply(void 0, G($e([MC, NC]))).pipe(ni(function(e3) {
              return bb.apply(void 0, G(e3));
            })) : bb.apply(void 0, G(M.AP_BACKUP_DOMAINS.slice(0, 3).map($d)));
          }), m(n(a2), "getApUrl$", function(e3) {
            var n2, r2;
            return a2.genUrl().pipe(wb(function(e4) {
              return (!a2.newDomainUsed || !e4.includes("sd-rtn.com")) && (e4.includes("sd-rtn.com") && (a2.newDomainUsed = true), !dl(a2.usedUrl, function(t3) {
                var n3;
                return t3 === (null === (n3 = e4.match(Qh)) || void 0 === n3 ? void 0 : n3[1]);
              }));
            }), ca(function(e4) {
              var t3;
              void 0 === M && ("string" == typeof (e4 = null === (t3 = e4.match(Qh)) || void 0 === t3 ? void 0 : t3[1]) && a2.usedUrl.push(e4));
            }), Ka(e3 ? Math.max(Nc.RECONNECTING_AP_NUM, null !== (n2 = null == M ? void 0 : M.CODES.size) && void 0 !== n2 ? n2 : 0) : null !== (r2 = null == M ? void 0 : M.CODES.size) && void 0 !== r2 ? r2 : 2), Dd(function() {
              return t2.runOutOfUrlSymbol;
            }), Ga(function(e4, n3) {
              return a2.newDomainUsed = false, e4 === t2.runOutOfUrlSymbol ? (a2.usedUrl = [], n3) : Z(e4);
            }));
          }), m(n(a2), "getBackupApUrl$", function(e3) {
            var n2, r2;
            return a2.genBackupUrl().pipe(wb(function(e4) {
              return (!a2.backupNewDomainUsed || !e4.includes("sd-rtn.com")) && (e4.includes("sd-rtn.com") && (a2.backupNewDomainUsed = true), !dl(a2.usedUrl, function(t3) {
                var n3;
                return t3 === (null === (n3 = e4.match(Qh)) || void 0 === n3 ? void 0 : n3[1]);
              }));
            }), ca(function(e4) {
              var t3;
              void 0 === M && ("string" == typeof (e4 = null === (t3 = e4.match(Qh)) || void 0 === t3 ? void 0 : t3[1]) && a2.usedUrl.push(e4));
            }), Ka(e3 ? Math.max(Nc.RECONNECTING_AP_NUM, null !== (n2 = null == M ? void 0 : M.CODES.size) && void 0 !== n2 ? n2 : 0) : null !== (r2 = null == M ? void 0 : M.CODES.size) && void 0 !== r2 ? r2 : 2), Dd(function() {
              return t2.runOutOfUrlSymbol;
            }), Ga(function(e4, n3) {
              return a2.backupNewDomainUsed = false, e4 === t2.runOutOfUrlSymbol ? (a2.usedUrl = [], n3) : Z(e4);
            }));
          }), m(n(a2), "getProxyApUrl$", function(e3) {
            var t3, n2;
            return bb.apply(void 0, G(((null == M ? void 0 : M.PROXY_AP.slice(0, 3)) || ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"]).map($d))).pipe(Ka(e3 ? Math.max(Nc.RECONNECTING_AP_NUM, null !== (t3 = null == M ? void 0 : M.CODES.size) && void 0 !== t3 ? t3 : 0) : null !== (n2 = null == M ? void 0 : M.CODES.size) && void 0 !== n2 ? n2 : 2));
          }), m(n(a2), "context", void 0), m(n(a2), "fetchCloudProxy", function(e3, t3) {
            var n2 = Ai("AP-", a2.loggerId);
            a2.log("The AccessPoint requests %s(%s)", e3, n2);
            var r2 = new AbortController();
            return a2.apFinish$.pipe(Ka(1)).subscribe(function() {
              return r2.abort();
            }), ad(J(w.mark(function i2() {
              var o2;
              return w.wrap(function(i3) {
                for (; ; ) switch (i3.prev = i3.next) {
                  case 0:
                    return o2 = Ag(0, Number.MAX_SAFE_INTEGER), a2.log("%s request opid: %d", n2, o2), i3.abrupt("return", te(e3, { headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "90", "Content-Type": "application/json" }, body: { sid: a2.context.sid, opid: o2, appid: a2.context.appId, client_ts: Math.ceil(Date.now() / 1e3), request_bodies: [{ uri: 22, buffer: { service_ids: [7, 16], key: null != t3 ? t3 : a2.context.key, cname: a2.context.uid, uid: 0, detail: ua({}, void 0 === M ? { 11: [F.CHINA, F.GLOBAL].join() } : { 11: Array.from(M.CODES).map(function(e4) {
                      return e4 === F.OVERSEA ? "".concat(F.ASIA, ",").concat(F.EUROPE, ",").concat(F.AFRICA, ",").concat(F.NORTH_AMERICA, ",").concat(F.SOUTH_AMERICA, ",").concat(F.OCEANIA) : e4;
                    }).join(",") }) } }] }, signal: r2.signal }));
                  case 3:
                  case "end":
                    return i3.stop();
                }
              }, i2);
            }))).pipe(Ga(function(t4) {
              return "AbortError" !== t4.name && (a2.logError(t4), a2.warn("The AP server %s request failure", e3, t4)), vb;
            }), cb(function() {
              var t4 = J(w.mark(function t5(r3) {
                var i2, o2, s, u2, c2, l, f, h, p, d, v2, b, g, y2, m2, E2, _, O2, I2;
                return w.wrap(function(t6) {
                  for (; ; ) switch (t6.prev = t6.next) {
                    case 0:
                      if (i2 = r3.responseText, o2 = JSON.parse(i2), a2.log("The %s response is %o", n2, o2), (void 0 === (s = o2.response_body) || 0 === s.length || s.some(function(e4) {
                        var t7;
                        return void 0 === (null === (t7 = e4.buffer) || void 0 === t7 ? void 0 : t7.code) || 23 !== e4.uri;
                      })) && Z(new da("cloud proxy response_body not valid", jg)), 0 === (u2 = s.filter(function(e4) {
                        return 0 !== e4.buffer.code;
                      })).length) {
                        t6.next = 14;
                        break;
                      }
                      if (void 0 === (c2 = u2.find(function(e4) {
                        return 128 === e4.buffer.flag;
                      }))) {
                        t6.next = 12;
                        break;
                      }
                      return t6.abrupt("return", a2.handleUniLbsError(c2.buffer.code, e3));
                    case 12:
                      return a2.logError("cloud proxy error response"), t6.abrupt("return", a2.handleUniLbsError(u2[0].buffer.code, e3));
                    case 14:
                      for (l = [], f = 0; f < s.length; f++) if (262144 === (null == (d = s[f]) || null === (h = d.buffer) || void 0 === h ? void 0 : h.flag)) null === (v2 = d.buffer) || void 0 === v2 || null === (b = v2.edges_services) || void 0 === b || null === (g = b.forEach) || void 0 === g || g.call(b, function(e4) {
                        Gm(e4 = e4.ip) && -1 === a2.context.cloudProxyServers.indexOf(e4) && (a2.log("got cloud proxy server: %s", e4), a2.context.cloudProxyServers.push(e4));
                      });
                      else if (128 === (null == d || null === (p = d.buffer) || void 0 === p ? void 0 : p.flag)) {
                        for (_ = function(e4, t7) {
                          var n3 = t7[e4];
                          l.some(function(e5) {
                            return e5.ip === n3.ip;
                          }) || l.push({ ip: n3.ip, ticket: d.buffer.cert });
                        }, O2 = 0, I2 = d.buffer.edges_services; O2 < I2.length; O2++) _(O2, I2);
                        a2.context.rtmArea = null !== (y2 = null === (m2 = d.buffer) || void 0 === m2 || null === (E2 = m2.detail) || void 0 === E2 ? void 0 : E2[9]) && void 0 !== y2 ? y2 : "";
                      }
                      return t6.abrupt("return", bb.apply(void 0, G(l).concat([fg])));
                    case 19:
                    case "end":
                      return t6.stop();
                  }
                }, t5);
              }));
              return function(e4) {
                return t4.apply(this, arguments);
              };
            }()), Ga(function(e4) {
              return sa(e4) ? Z(e4) : vb;
            }), tg(), wb(function(e4) {
              return void 0 !== e4 && "string" == typeof e4.ip && "string" == typeof e4.ticket;
            }));
          }), m(n(a2), "fetchAp", function(e3, t3) {
            var n2 = Ai("AP-", a2.loggerId);
            a2.log("The AccessPoint requests %s(%s)", e3, n2);
            var r2 = new AbortController();
            return a2.apFinish$.pipe(Ka(1)).subscribe(function() {
              return r2.abort();
            }), ad(J(w.mark(function i2() {
              var o2;
              return w.wrap(function(i3) {
                for (; ; ) switch (i3.prev = i3.next) {
                  case 0:
                    return o2 = Ag(0, Number.MAX_SAFE_INTEGER), a2.log("%s request opid: %d", n2, o2), i3.abrupt("return", te(e3, { headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "69", "Content-Type": "application/json" }, body: { flag: 128, opid: o2, key: t3 || a2.context.key, cname: a2.context.uid, detail: ua({}, void 0 === M ? { 11: [F.CHINA, F.GLOBAL].join() } : { 11: Array.from(M.CODES).map(function(e4) {
                      return e4 === F.OVERSEA ? "".concat(F.ASIA, ",").concat(F.EUROPE, ",").concat(F.AFRICA, ",").concat(F.NORTH_AMERICA, ",").concat(F.SOUTH_AMERICA, ",").concat(F.OCEANIA) : e4;
                    }).join(",") }), uid: 0, sid: a2.context.sid }, signal: r2.signal }));
                  case 3:
                  case "end":
                    return i3.stop();
                }
              }, i2);
            }))).pipe(Ga(function(t4) {
              return "AbortError" !== t4.name && (a2.logError(t4), a2.warn("The AP server %s request failure", e3, t4)), vb;
            }), cb(function() {
              var t4 = J(w.mark(function t5(r3) {
                var i2, o2, s, u2, c2, l, f;
                return w.wrap(function(t6) {
                  for (; ; ) switch (t6.prev = t6.next) {
                    case 0:
                      if (i2 = r3.responseText, o2 = JSON.parse(i2), a2.log("The %s response is %o", n2, o2), u2 = (s = o2).code, c2 = s.addresses, l = s.detail, 0 === u2) {
                        t6.next = 6;
                        break;
                      }
                      return t6.abrupt("return", a2.handleUniLbsError(u2, e3));
                    case 6:
                      if (0 !== (f = c2).length) {
                        t6.next = 11;
                        break;
                      }
                      return t6.abrupt("return", Z(Error("No available edge address to connect")));
                    case 11:
                      return a2.context.rtmArea = null == l ? void 0 : l[9], t6.abrupt("return", bb.apply(void 0, G(f).concat([fg])));
                    case 13:
                    case "end":
                      return t6.stop();
                  }
                }, t5);
              }));
              return function(e4) {
                return t4.apply(this, arguments);
              };
            }()), tg(), Ga(function(e4) {
              return sa(e4) ? Z(e4) : vb;
            }), wb(function(e4) {
              return void 0 !== e4 && "string" == typeof e4.ip && "string" == typeof e4.ticket;
            }));
          }), a2.context = e2, a2.getApEdgeInfoEndFirst$ = function() {
            var e3 = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
            return Bc(0, e3 || o ? Nc.RECONNECTING_AP_INTERVAL : 2e3).pipe(Ka(1), ca(function() {
              a2.retryCount += 1;
            }), cb(function() {
              return a2.context.config.enableCloudProxy ? a2.getProxyApUrl$(e3 || o) : (4 <= a2.retryCount && (a2.retryCount = 0), 3 >= a2.retryCount ? a2.getApUrl$(e3 || o) : a2.getBackupApUrl$(e3 || o));
            }), cb(function(e4) {
              return a2.context.config.enableCloudProxy ? a2.fetchCloudProxy(e4) : a2.fetchAp(e4);
            }), Ga(function(e4) {
              return e4 instanceof pb && a2.warn("AP request timeout"), Z(e4);
            }), om(function(e4) {
              return e4.ip;
            }), ob(a2.apFinish$));
          }, a2.getApEdgeInfo$ = function(e3) {
            return Bc(0, e3 || o ? Nc.RECONNECTING_AP_INTERVAL : 2e3).pipe(Ka(8), ca(function() {
              a2.retryCount += 1;
            }), cb(function() {
              return a2.context.config.enableCloudProxy ? a2.getProxyApUrl$(e3 || o) : 3 >= a2.retryCount ? a2.getApUrl$(e3 || o) : a2.getBackupApUrl$(e3 || o);
            }), cb(function(e4) {
              return (a2.context.config.enableCloudProxy ? a2.fetchCloudProxy(e4) : a2.fetchAp(e4)).pipe();
            }), Ga(function(e4) {
              return e4 instanceof pb && a2.warn("AP request timeout"), Z(e4);
            }), om(function(e4) {
              return e4.ip;
            }), ob(a2.apFinish$));
          }, a2;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "clearUp", value: function() {
          this.failedAreas.clear(), this.retryCount = 0;
        } }]), t2;
      }(tb());
      m(Wr, "runOutOfUrlSymbol", Symbol("AP urls are used up"));
      var Xr = Ph(), Yr = function(e) {
        function t2(e2, i, o) {
          W(this, t2);
          var a2 = r.call(this, i, "Connection");
          m(n(a2), "apClient", void 0), m(n(a2), "lastOpenSockets", [new qe(1), new qe(1)]), m(n(a2), "curOpenSockets", [void 0, void 0]), m(n(a2), "ipIterator", 0), m(n(a2), "firstEnv", 0.5 <= Math.random() ? 1 : 0), m(n(a2), "firstSocketOpener", void 0), m(n(a2), "secondSocketOpener", void 0), m(n(a2), "firstOpenKeeperSubject", new Pa()), m(n(a2), "secondOpenKeeperSubject", new Pa()), m(n(a2), "edgeInfoReplayed", void 0), m(n(a2), "firstEnvOpenSocket", void 0), m(n(a2), "firstOpenKeeperSub", void 0), m(n(a2), "secondOpenKeeperSub", void 0), m(n(a2), "context", void 0), m(n(a2), "logger", void 0), a2.context = e2, a2.logger = i, a2.apClient = new Wr(a2.context, i), a2.apClient.apFinish$.subscribe(function() {
            a2.log("Ap client fetch finished");
          });
          var s, u2 = [];
          return a2.edgeInfoReplayed = a2.apClient.getApEdgeInfo$(o).pipe(oe(function(e3) {
            return e3.pipe(ca(function(e4) {
              if (sa(e4)) throw e4;
            }), cd(o ? Zd.getParameter("RECONNECTING_AP_INTERVAL") : 900), ob(Bc(2e4)));
          }), wb(function(e3) {
            return !dl(u2, e3);
          }), Dd(function() {
            return new Xr({ AP_NO_AVAILABLE_EDGE: "No available edge address to connect" });
          }), ca(function(e3) {
            u2.push(e3), a2.log("An edge info got %o", e3);
          }), ca({ error: function(e3) {
            a2.emit("connectionInitFailure", e3);
          } }), wg(function() {
            a2.apClient.clearUp();
          }), sm()), a2.firstEnvOpenSocket = a2.edgeInfoReplayed.pipe(cb(function(e3) {
            if (void 0 === e3) return Z(Error("Invalid edge info"));
            var t3 = new ml(e3.ip, a2.firstEnv, e3.ticket, a2.context, i, s);
            return a2.firstEnv = 1 === a2.firstEnv ? 0 : 1, t3.on("connectionFailure", function() {
              return a2.onSocketConnectionFailure(t3);
            }), s = !t3.useNewDomain, t3.open$.pipe(qf(t3));
          }), ca(function(e3) {
            a2.log("The websocket of ENV_%d opened to %s:%d", e3.env, e3.ip, af[e3.env]), a2.curOpenSockets[e3.env] = e3, a2.lastOpenSockets[e3.env].next(e3), a2.firstEnv = e3.env, a2.openSecondSocket(e3.env, e3.ip, e3.useNewDomain);
          }), Ka(1), pe()), a2.firstSocketOpener = a2.firstEnvOpenSocket.pipe(cb(function(e3) {
            return e3.open$.pipe(ca(function() {
              a2.log("The websocket of first ENV_%d re-opened to %s:%d", e3.env, e3.ip, af[e3.env]), a2.curOpenSockets[e3.env] = e3, a2.lastOpenSockets[e3.env].next(e3);
            }));
          })), e2 = a2.firstOpenKeeperSubject.pipe(Cc(Yc)), a2.firstOpenKeeperSub = e2.subscribe({ error: a2.logError }), a2;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "initConnection", value: function() {
          this.firstOpenKeeperSubject.next(this.firstSocketOpener);
        } }, { key: "closeSocket", value: function(e2, t3) {
          if (![0, 1].includes(e2)) throw new Fa({ INVALID_ENV: "The env argument is not 0 or 1" });
          var n2 = e2 === this.firstEnv ? this.firstOpenKeeperSub : this.secondOpenKeeperSub;
          this.firstOpenKeeperSub = void 0;
          var r2 = this.curOpenSockets[e2];
          this.curOpenSockets[e2] = void 0, r2 && (r2.isActiveClose = true, setTimeout(function() {
            r2.close();
          }, t3)), void 0 !== n2 && setTimeout(function() {
            null == n2 || n2.unsubscribe();
          }, t3);
        } }, { key: "waitClosing", value: function(e2) {
          var t3 = this;
          return e2.isActiveClose = true, e2.open$.pipe(tt(), Ga(function(e3) {
            return e3.message === mr.normalClosureMessage ? vb : Z(e3);
          }), hb(5e3), Ga(function(n2) {
            return n2 instanceof pb ? (t3.warn("Force closing the ENV_%d connection", e2.env), vb) : Z(n2);
          }));
        } }, { key: "onSocketConnectionFailure", value: function(e2) {
          var t3 = [0, 1].filter(function(t4) {
            return t4 !== e2.env;
          })[0];
          (t3 = this.curOpenSockets[t3]) && t3.loggedIn ? this.reopenSocketWithApRequest(e2.env) : this.emit("socketsFailure");
        } }, { key: "openSecondSocket", value: function(e2, t3, n2) {
          var r2 = this, i = 1 === e2 ? 0 : 1;
          this.secondSocketOpener = this.edgeInfoReplayed.pipe(rm(function(e3, t4) {
            return [].concat(G(e3), [t4]);
          }, []), ba(function(e3) {
            return kr(e3, function(e4) {
              return Jm(t3, e4.ip);
            }).slice(-1)[0];
          }), Ka(1), cb(function(e3) {
            if (void 0 === e3) return Z(Error("Invalid edge info"));
            var t4 = new ml(e3.ip, i, e3.ticket, r2.context, r2.logger, n2);
            return t4.on("connectionFailure", function() {
              return r2.onSocketConnectionFailure(t4);
            }), t4.open$.pipe(ca(function() {
              r2.lastOpenSockets[i].next(t4), r2.curOpenSockets[i] = t4;
            }));
          }), pe()), this.secondOpenKeeperSub = this.secondOpenKeeperSubject.pipe(Cc(Yc)).subscribe({ error: this.logError }), this.secondOpenKeeperSubject.next(this.secondSocketOpener);
        } }, { key: "reopenSocketWithApRequest", value: function(e2) {
          var t3 = this, n2 = [0, 1].filter(function(t4) {
            return t4 !== e2;
          })[0];
          if (void 0 !== (n2 = this.curOpenSockets[n2])) {
            var r2, i = n2.ip;
            n2 = this.apClient.getApEdgeInfoEndFirst$(true).pipe(Dd(function() {
              return new Xr({ AP_NO_AVAILABLE_EDGE: "No available edge address to connect" });
            }), oe(function(e3) {
              return e3.pipe(ca(function(e4) {
                if (e4.code === Kh) t3.emit("tokenExpired"), t3.apClient.apFinish$.next(void 0);
                else if (sa(e4)) throw e4;
              }), cd(Zd.getParameter("RECONNECTING_AP_INTERVAL")), ob(Bc(15e3)));
            }), ca(function(e3) {
              t3.log("An edge info got %o", e3);
            }), wg(function() {
              t3.apClient.clearUp();
            })).pipe(rm(function(e3, t4) {
              return [].concat(G(e3), [t4]);
            }, []), ba(function(e3) {
              return (e3 = kr(e3, function(e4) {
                return Jm(i, e4.ip);
              })).length - 1 >= t3.ipIterator ? e3.slice(-t3.ipIterator++ - 1)[0] : (t3.ipIterator = 0, e3.slice(-1)[0]);
            }), Dd(), cb(function(n3) {
              if (void 0 === n3) return Z(Error("Invalid edge info"));
              var i2 = new ml(n3.ip, e2, n3.ticket, t3.context, t3.logger, r2);
              return i2.on("connectionFailure", function() {
                return t3.onSocketConnectionFailure(i2);
              }), r2 = !i2.useNewDomain, i2.open$.pipe(qf(i2));
            }), ca(function(n3) {
              t3.log("The websocket of ENV_%d re-opened to %s:%d using ap", n3.env, n3.ip, af[n3.env]), t3.curOpenSockets[e2] = n3, t3.lastOpenSockets[e2].next(n3);
            }), cb(function(n3) {
              return n3.open$.pipe(ca(function() {
                t3.log("The websocket of ENV_%d re-opened to %s:%d", n3.env, n3.ip, af[n3.env]), t3.curOpenSockets[e2] = n3, t3.lastOpenSockets[e2].next(n3);
              }));
            }), pe()), e2 === this.firstEnv ? this.firstOpenKeeperSubject.next(n2) : this.secondOpenKeeperSubject.next(n2);
          }
        } }]), t2;
      }(tb()), Xc = fc.Writer, na = fc.util, zc = fc.roots.default || (fc.roots.default = {}), RC = zc.Session = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.appId = "", e.prototype.ver = "", e.prototype.buildno = 0, e.prototype.installId = "", e.prototype.os = 0, e.prototype.did = "", e.prototype.index = null, e.prototype.token = "", e.prototype.version = 0, e.prototype.subVersion = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.appId && Object.hasOwnProperty.call(e2, "appId") && t2.uint32(42).string(e2.appId), null != e2.ver && Object.hasOwnProperty.call(e2, "ver") && t2.uint32(50).string(e2.ver), null != e2.buildno && Object.hasOwnProperty.call(e2, "buildno") && t2.uint32(56).int32(e2.buildno), null != e2.installId && Object.hasOwnProperty.call(e2, "installId") && t2.uint32(66).string(e2.installId), null != e2.os && Object.hasOwnProperty.call(e2, "os") && t2.uint32(128).int32(e2.os), null != e2.did && Object.hasOwnProperty.call(e2, "did") && t2.uint32(138).string(e2.did), null != e2.index && Object.hasOwnProperty.call(e2, "index") && zc.Session.CommonIndex.encode(e2.index, t2.uint32(162).fork()).ldelim(), null != e2.token && Object.hasOwnProperty.call(e2, "token") && t2.uint32(170).string(e2.token), null != e2.version && Object.hasOwnProperty.call(e2, "version") && t2.uint32(176).int32(e2.version), null != e2.subVersion && Object.hasOwnProperty.call(e2, "subVersion") && t2.uint32(184).int32(e2.subVersion), t2;
        }, e.CommonIndex = function() {
          function e2(e3) {
            if (e3) for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2) null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.index1 = "", e2.prototype.index2 = "", e2.prototype.index3 = "", e2.encode = function(e3, t2) {
            return t2 || (t2 = Xc.create()), null != e3.index1 && Object.hasOwnProperty.call(e3, "index1") && t2.uint32(10).string(e3.index1), null != e3.index2 && Object.hasOwnProperty.call(e3, "index2") && t2.uint32(18).string(e3.index2), null != e3.index3 && Object.hasOwnProperty.call(e3, "index3") && t2.uint32(26).string(e3.index3), t2;
          }, e2;
        }(), e;
      }(), SC = zc.Link = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.ec = 0, e.prototype.sc = 0, e.prototype.destServerIp = "", e.prototype.ackedServerIp = "", e.prototype.responseTime = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.ec && Object.hasOwnProperty.call(e2, "ec") && t2.uint32(40).int32(e2.ec), null != e2.sc && Object.hasOwnProperty.call(e2, "sc") && t2.uint32(48).int32(e2.sc), null != e2.destServerIp && Object.hasOwnProperty.call(e2, "destServerIp") && t2.uint32(58).string(e2.destServerIp), null != e2.ackedServerIp && Object.hasOwnProperty.call(e2, "ackedServerIp") && t2.uint32(66).string(e2.ackedServerIp), null != e2.responseTime && Object.hasOwnProperty.call(e2, "responseTime") && t2.uint32(72).int32(e2.responseTime), t2;
        }, e;
      }(), TC = zc.Logout = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), t2;
        }, e;
      }(), UC = zc.KickedOff = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.linkId = 0, e.prototype.code = 0, e.prototype.server = "", e.prototype.serverCode = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.linkId && Object.hasOwnProperty.call(e2, "linkId") && t2.uint32(48).int32(e2.linkId), null != e2.code && Object.hasOwnProperty.call(e2, "code") && t2.uint32(56).int32(e2.code), null != e2.server && Object.hasOwnProperty.call(e2, "server") && t2.uint32(66).string(e2.server), null != e2.serverCode && Object.hasOwnProperty.call(e2, "serverCode") && t2.uint32(72).int32(e2.serverCode), t2;
        }, e;
      }(), VC = zc.ChnJoin = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.cname = "", e.prototype.errCode = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.cname && Object.hasOwnProperty.call(e2, "cname") && t2.uint32(50).string(e2.cname), null != e2.errCode && Object.hasOwnProperty.call(e2, "errCode") && t2.uint32(56).int32(e2.errCode), t2;
        }, e;
      }(), WC = zc.ChnJoinRes = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.cname = "", e.prototype.errCode = 0, e.prototype.serverErrCode = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.cname && Object.hasOwnProperty.call(e2, "cname") && t2.uint32(50).string(e2.cname), null != e2.errCode && Object.hasOwnProperty.call(e2, "errCode") && t2.uint32(56).int32(e2.errCode), null != e2.serverErrCode && Object.hasOwnProperty.call(e2, "serverErrCode") && t2.uint32(64).int32(e2.serverErrCode), t2;
        }, e;
      }(), XC = zc.ChnLeave = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.cname = "", e.prototype.errCode = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.cname && Object.hasOwnProperty.call(e2, "cname") && t2.uint32(50).string(e2.cname), null != e2.errCode && Object.hasOwnProperty.call(e2, "errCode") && t2.uint32(56).int32(e2.errCode), t2;
        }, e;
      }(), YC = zc.ConnectionStateChange = function() {
        function e(e2) {
          if (e2) for (var t2 = Object.keys(e2), n2 = 0; n2 < t2.length; ++n2) null != e2[t2[n2]] && (this[t2[n2]] = e2[t2[n2]]);
        }
        return e.prototype.sid = "", e.prototype.userId = "", e.prototype.lts = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.elapse = na.Long ? na.Long.fromBits(0, 0, false) : 0, e.prototype.oldState = 0, e.prototype.newState = 0, e.prototype.reason = 0, e.prototype.reconnId = 0, e.encode = function(e2, t2) {
          return t2 || (t2 = Xc.create()), null != e2.sid && Object.hasOwnProperty.call(e2, "sid") && t2.uint32(10).string(e2.sid), null != e2.userId && Object.hasOwnProperty.call(e2, "userId") && t2.uint32(18).string(e2.userId), null != e2.lts && Object.hasOwnProperty.call(e2, "lts") && t2.uint32(24).int64(e2.lts), null != e2.elapse && Object.hasOwnProperty.call(e2, "elapse") && t2.uint32(32).int64(e2.elapse), null != e2.oldState && Object.hasOwnProperty.call(e2, "oldState") && t2.uint32(40).int32(e2.oldState), null != e2.newState && Object.hasOwnProperty.call(e2, "newState") && t2.uint32(48).int32(e2.newState), null != e2.reason && Object.hasOwnProperty.call(e2, "reason") && t2.uint32(56).int32(e2.reason), null != e2.reconnId && Object.hasOwnProperty.call(e2, "reconnId") && t2.uint32(64).int32(e2.reconnId), t2;
        }, e;
      }(), fu = Object.freeze({ __proto__: null, Session: RC, Link: SC, Logout: TC, KickedOff: UC, ChnJoin: VC, ChnJoinRes: WC, ChnLeave: XC, ConnectionStateChange: YC, default: zc }), gu = Object.freeze({ __proto__: null, Counter: 1, ApiExec: 154, Session: 164, ApEvent: 165, Link: 166, Logout: 167, TxMessage: 168, RxMessage: 169, KickedOff: 170, TxMessageRes: 171, ChnJoin: 172, ChnJoinRes: 173, ChnLeave: 174, ChnGetMembers: 175, ChnGetMembersRes: 176, ChnMemberJoined: 177, ChnMemberLeft: 178, QueryPeersOnlineStatus: 179, QueryPeersOnlineStatusRes: 180, RenewToken: 181, OperateAttribute: 186, OperateAttributeRes: 187, ApRequest: 188, LinkTcpEvent: 189, LinkLoginRequest: 190, ConnectionStateChange: 191, default: { Counter: 1, ApiExec: 154, Session: 164, ApEvent: 165, Link: 166, Logout: 167, TxMessage: 168, RxMessage: 169, KickedOff: 170, TxMessageRes: 171, ChnJoin: 172, ChnJoinRes: 173, ChnLeave: 174, ChnGetMembers: 175, ChnGetMembersRes: 176, ChnMemberJoined: 177, ChnMemberLeft: 178, QueryPeersOnlineStatus: 179, QueryPeersOnlineStatusRes: 180, RenewToken: 181, OperateAttribute: 186, OperateAttributeRes: 187, ApRequest: 188, LinkTcpEvent: 189, LinkLoginRequest: 190, ConnectionStateChange: 191 } }), ZC = function(e) {
        function t2(e2, i, o) {
          return W(this, t2), m(n(o = r.call(this, o, "Context")), "_token", void 0), m(n(o), "config", void 0), m(n(o), "_uid", void 0), m(n(o), "_sid", void 0), m(n(o), "_area", "CN"), m(n(o), "appId", void 0), m(n(o), "enableCloudProxy", false), m(n(o), "cloudProxyServers", []), o.appId = e2, o.config = i, o;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "token", set: function(e2) {
          this._token = "string" == typeof e2 && e2 ? e2 : void 0;
        } }, { key: "uid", get: function() {
          if ("string" == typeof this._uid && this._uid) return this._uid;
          throw new Ia("Cannot get illegal uid");
        }, set: function(e2) {
          if (this.log("The user ID is set to %s", oa(e2)), !za(e2)) throw new Ia();
          this._uid = e2;
        } }, { key: "key", get: function() {
          if ("string" == typeof this._token && this._token) return this._token;
          if ("string" == typeof this.appId && this.appId) return this.appId;
          throw new Ia("Cannot get illegal key");
        } }, { key: "sid", get: function() {
          if ("string" == typeof this._sid && this._sid) return this._sid;
          throw new Ia("Cannot get illegal sid");
        }, set: function(e2) {
          if (this.log("sid is set to %s", e2), "string" != typeof e2 || !e2) throw new Ia();
          this._sid = e2;
        } }, { key: "rtmArea", get: function() {
          if ("string" == typeof this._area && this._area) return this._area;
          throw new Ia("Cannot get illegal area");
        }, set: function(e2) {
          this.log("area is set to %s", e2), "string" == typeof e2 && e2 ? this._area = e2 : this.warn("set area failed");
        } }]), t2;
      }(tb()), $C = !!Fc && R(function() {
        Fc.prototype.finally.call({ then: function() {
        } }, function() {
        });
      });
      if (N({ target: "Promise", proto: true, real: true, forced: $C }, { finally: function(e) {
        var t2 = kd(this, mc("Promise")), n2 = "function" == typeof e;
        return this.then(n2 ? function(n3) {
          return mj(t2, e()).then(function() {
            return n3;
          });
        } : e, n2 ? function(n3) {
          return mj(t2, e()).then(function() {
            throw n3;
          });
        } : e);
      } }), "function" == typeof Fc) {
        var Zr = mc("Promise").prototype.finally;
        Fc.prototype.finally !== Zr && Ta(Fc.prototype, "finally", Zr, { unsafe: true });
      }
      var aD = function() {
        var e = J(w.mark(function e2(t2) {
          return w.wrap(function(e3) {
            for (; ; ) switch (e3.prev = e3.next) {
              case 0:
                return e3.t0 = Uint8Array, e3.next = 3, crypto.subtle.digest("SHA-256", t2);
              case 3:
                return e3.t1 = e3.sent, e3.abrupt("return", new e3.t0(e3.t1));
              case 5:
              case "end":
                return e3.stop();
            }
          }, e2);
        }));
        return function(t2) {
          return e.apply(this, arguments);
        };
      }(), $r = function(e) {
        return Array.from(e).map(function(e2) {
          return e2.toString(16).padStart(2, "0");
        }).join("");
      }, bD = function(e) {
        if ("string" != typeof e) throw new TypeError("Expected input to be a string");
        if (0 != e.length % 2) throw new RangeError("Expected string to be an even number of characters");
        for (var t2 = new Uint8Array(e.length / 2), n2 = 0; n2 < e.length; n2 += 2) t2[n2 / 2] = parseInt(e.substring(n2, n2 + 2), 16);
        return t2;
      }, as = function(e) {
        return btoa(String.fromCharCode.apply(String, G(e))).replace(/={1,2}$/, "");
      }, bs = function() {
        var e = J(w.mark(function e2(t2) {
          var n2;
          return w.wrap(function(e3) {
            for (; ; ) switch (e3.prev = e3.next) {
              case 0:
                return e3.prev = 0, e3.next = 3, crypto.subtle.digest("SHA-1", t2);
              case 3:
                n2 = e3.sent, e3.next = 9;
                break;
              case 6:
                e3.prev = 6, e3.t0 = e3.catch(0), n2 = sha1.arrayBuffer(t2);
              case 9:
                return e3.abrupt("return", as(new Uint8Array(n2)));
              case 10:
              case "end":
                return e3.stop();
            }
          }, e2, null, [[0, 6]]);
        }));
        return function(t2) {
          return e.apply(this, arguments);
        };
      }(), cs = function(e, t2, n2, r) {
        r[t2] = true, n2.has(e) ? n2.get(e).add(t2) : n2.set(e, /* @__PURE__ */ new Set([t2]));
      }, cD = function(e) {
        switch (e) {
          case "89504E47":
            return "image/png";
          case "47494638":
            return "image/gif";
          case "25504446":
            return "application/pdf";
          case "FFD8FFDB":
          case "FFD8FFE0":
          case "FFD8FFE1":
            return "image/jpeg";
          case "504B0304":
            return "application/zip";
          default:
            return "application/octet-stream";
        }
      }, ds = function(e) {
        function t2(e2, i, o, a2) {
          W(this, t2);
          var s = r.call(this, o, "ChunkDownloadManager");
          if (m(n(s), "abortController", new AbortController()), m(n(s), "downloadedSize", 0), m(n(s), "successCount", 0), m(n(s), "timer", void 0), m(n(s), "chunks", []), m(n(s), "retUnit", void 0), m(n(s), "singleThread", false), m(n(s), "initialized", false), m(n(s), "ee", void 0), m(n(s), "chunkCount", void 0), m(n(s), "aborted", false), m(n(s), "serverToIndices", /* @__PURE__ */ new Map()), m(n(s), "backupToIndices", /* @__PURE__ */ new Map()), m(n(s), "indexToBackupServers", []), m(n(s), "busyBackupServers", /* @__PURE__ */ new Map()), m(n(s), "downloadingChunks", /* @__PURE__ */ new Set()), m(n(s), "metaInfo", void 0), m(n(s), "transHandler", void 0), s.metaInfo = e2, s.transHandler = i, s.ee = void 0 === a2 ? new ea() : a2, o = e2.size, e2 = e2.unit, 0 === o) throw new Ia("size cannot be 0");
          return void 0 !== i.cancelSignal && i.cancelSignal.addEventListener("abort", function() {
            s.abortController.abort();
          }, { once: true }), s.abortController.signal.addEventListener("abort", function() {
            s.aborted = true;
          }, { once: true }), s.chunkCount = Math.ceil(o / (32768 * e2)), s;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "setInfoByResponse", value: function(e2) {
          var t3 = this, n2 = e2.serverList, r2 = e2.backupList;
          if (e2 = e2.unit, n2.length < this.chunkCount && r2.length < this.chunkCount) throw new Ia("servers is not enough");
          this.updateProgress(0), this.initialized = true;
          var i = Array(this.chunkCount).fill(false);
          if (n2.forEach(function(e3, n3) {
            return e3.forEach(function(e4) {
              return cs(e4, n3, t3.serverToIndices, i);
            });
          }), r2.forEach(function(e3, n3) {
            return e3.forEach(function(e4) {
              return cs(e4, n3, t3.backupToIndices, i);
            });
          }), i.some(function() {
            return false;
          })) throw new da("Not enough servers to download", mg);
          this.indexToBackupServers = r2.map(function(e3) {
            return new Set(e3);
          }), this.retUnit = e2;
        } }, { key: "downloadChunks", value: function() {
          this.aborted ? this.warn("downloadChunks after abort, ignored") : 1 === this.serverToIndices.size && 0 === Array.from(this.serverToIndices.keys())[0] ? this.serversDownload(this.backupToIndices) : 1 <= this.serverToIndices.size ? this.serversDownload(this.serverToIndices, true) : this.ee.emit("error", new da("not enough servers to download", mg));
        } }, { key: "updateProgress", value: function(e2) {
          var t3 = this, n2 = this.downloadedSize + e2;
          this.downloadedSize > this.metaInfo.size ? (this.warn("Invalid download size, overflowed"), this.ee.emit("error", new Wc("Invalid download size", mg))) : (this.downloadedSize = n2, void 0 !== this.timer && 0 !== e2 && (clearTimeout(this.timer), this.timer = void 0), void 0 === this.timer && this.successCount !== this.chunkCount && (this.timer = setTimeout(function() {
            t3.ee.emit("timedOut"), t3.abortController.abort();
          }, 12e4)), this.initialized && 0 === e2 || void 0 === this.transHandler.onOperationProgress || this.transHandler.onOperationProgress({ totalSize: this.metaInfo.size, currentSize: this.downloadedSize }));
        } }, { key: "getPayload", value: function() {
          for (var e2 = 0, t3 = 0, n2 = this.chunks; t3 < n2.length; t3++) e2 += n2[t3].byteLength;
          if (e2 !== this.metaInfo.size) throw new Ia("invalid chunks total size");
          e2 = new Uint8Array(e2), n2 = t3 = 0;
          for (var r2 = this.chunks; n2 < r2.length; n2++) {
            var i = r2[n2];
            e2.set(new Uint8Array(i), t3), t3 += i.byteLength;
          }
          return t3 = Array.from(e2.subarray(0, 4)).map(function(e3) {
            return e3.toString(16);
          }).join("").toUpperCase(), Zt(e2.buffer, cD(t3));
        } }, { key: "getDownloadUrl", value: function(e2) {
          var t3 = this.metaInfo.useNewDomain ? "sd-rtn.com" : "agora.io";
          return "https://".concat(Dg(e2).split(".").join("-"), ".edge.").concat(t3, ":9601/api/v1/chuck/download");
        } }, { key: "serversDownload", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2 = this, i = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return n2 = 1 < i.length && void 0 !== i[1] && i[1], e4.next = 3, Promise.all(Array.from(t3.entries()).map(function(e5) {
                    return e5 = ra(e5, 2), r2.postDownloadRequest(e5[0], Array.from(e5[1]), n2).catch(function(e6) {
                      404 === e6.statusCode ? (r2.ee.emit("notExist"), r2.abortController.abort()) : "AbortError" !== e6.name && (Sa(e6) ? r2.singleThread ? (r2.abortController.abort(), r2.ee.emit("timedOut")) : (r2.warn("%d download timed out after %d, retrying use single thread", e6.index, r2.singleThread ? 6e4 : 3e4), r2.abortController.abort(), r2.singleThread = true, r2.ee.emit("multiTimeOut")) : (r2.ee.emit("error", e6), r2.abortController.abort()));
                    });
                  }));
                case 3:
                case "end":
                  return e4.stop();
              }
            }, e3);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "postDownloadRequest", value: function() {
          var e2 = J(w.mark(function e3(t3, n2, r2) {
            var i, o, a2, s, u2, c2, l, f, h, p = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (h = function() {
                    return (h = J(w.mark(function e5(o2) {
                      var a3, h2, p2, d, v2, b, g, y2, m2;
                      return w.wrap(function(e6) {
                        for (; ; ) switch (e6.prev = e6.next) {
                          case 0:
                            if (e6.prev = 0, void 0 !== o2 || 0 !== t3) {
                              e6.next = 5;
                              break;
                            }
                            throw new Ia("Invalid serverIp");
                          case 5:
                            a3 = void 0 === o2 ? l.getDownloadUrl(t3) : o2;
                          case 6:
                            return l.downloadingChunks.add(i), e6.next = 9, c2(a3);
                          case 9:
                            return h2 = e6.sent, p2 = h2.responseData, l.downloadingChunks.delete(i), e6.abrupt("return", p2);
                          case 15:
                            if (e6.prev = 15, e6.t0 = e6.catch(0), l.downloadingChunks.delete(i), n2.unshift(i), l.metaInfo.useNewDomain = false, "AbortError" !== e6.t0.name) {
                              e6.next = 22;
                              break;
                            }
                            throw e6.t0;
                          case 22:
                            if (!Sa(e6.t0)) {
                              e6.next = 25;
                              break;
                            }
                            throw e6.t0.index = i, e6.t0;
                          case 25:
                            if (d = s, s += 1, !(2 > d)) {
                              e6.next = 30;
                              break;
                            }
                            return e6.t0 instanceof Ia || l.warn("%o, %d download failed, retrying", e6.t0, i), e6.abrupt("return", f());
                          case 30:
                            if (504 !== e6.t0.statusCode) {
                              e6.next = 34;
                              break;
                            }
                            throw (v2 = new db("download server timed out", { originalError: e6.t0, serverCode: 504 })).index = i, v2;
                          case 34:
                            if (!r2 || 2 !== d || 0 === u2[0]) {
                              e6.next = 45;
                              break;
                            }
                            return e6.t0 instanceof Ia || l.warn("%d download failed, using backup: %d, %o", i, u2[0], e6.t0), e6.next = 38, l.busyBackupServers.get(u2[0]);
                          case 38:
                            return b = f(l.getDownloadUrl(u2[0])), l.busyBackupServers.set(u2[0], b), e6.next = 42, b;
                          case 42:
                            return g = e6.sent, l.busyBackupServers.delete(u2[0]), e6.abrupt("return", g);
                          case 45:
                            if (!(r2 && 2 < d && void 0 !== u2[1] && 0 !== u2[1])) {
                              e6.next = 56;
                              break;
                            }
                            return l.warn("%d download failed, using backup 1: %d", i, u2[1]), e6.next = 49, l.busyBackupServers.get(u2[1]);
                          case 49:
                            return y2 = f(l.getDownloadUrl(u2[1])), l.busyBackupServers.set(u2[1], y2), e6.next = 53, y2;
                          case 53:
                            return m2 = e6.sent, l.busyBackupServers.delete(u2[1]), e6.abrupt("return", m2);
                          case 56:
                            throw e6.t0.index = i, e6.t0;
                          case 58:
                          case "end":
                            return e6.stop();
                        }
                      }, e5, null, [[0, 15]]);
                    }))).apply(this, arguments);
                  }, f = function(e5) {
                    return h.apply(this, arguments);
                  }, !this.aborted) {
                    e4.next = 4;
                    break;
                  }
                  throw new Ia("download already aborted");
                case 4:
                  if (void 0 !== (i = n2.shift())) {
                    e4.next = 8;
                    break;
                  }
                  return this.log("%s download finished", t3), e4.abrupt("return");
                case 8:
                  if (!(this.singleThread && 0 < this.downloadingChunks.size)) {
                    e4.next = 10;
                    break;
                  }
                  return e4.abrupt("return");
                case 10:
                  if (!this.downloadingChunks.has(i)) {
                    e4.next = 13;
                    break;
                  }
                  return this.log("%s already downloading, return", i), e4.abrupt("return");
                case 13:
                  if (void 0 === this.chunks[i]) {
                    e4.next = 19;
                    break;
                  }
                  return this.successCount === this.chunkCount && (this.log("chunks all download"), this.ee.emit("finished")), this.log("%s already downloaded, do next", i), e4.next = 18, this.postDownloadRequest(t3, n2, r2);
                case 18:
                  return e4.abrupt("return");
                case 19:
                  return o = new FormData(), a2 = { hash: hu(this.metaInfo.hashHexStr), unit: void 0 === this.retUnit ? this.metaInfo.unit : this.retUnit, instance: this.metaInfo.instance, loginOpt: this.metaInfo.loginOpt, ticket: this.metaInfo.ticket, index: i }, o.append("parameter", JSON.stringify(a2)), s = 0, u2 = Array.from(this.indexToBackupServers[i]), c2 = function(e5) {
                    return te(e5, { body: o, signal: p.abortController.signal, timeout: p.singleThread ? 12e4 : 3e4 }, { useBinaryResponse: true });
                  }, l = this, e4.next = 28, f().then(function(e5) {
                    return void 0 !== p.chunks[i] ? p.log("chunk %d download duplicated", i) : (p.chunks[i] = e5, p.log("chunk %d downloaded", i), p.successCount += 1, p.updateProgress(p.chunks[i].byteLength)), p.successCount === p.chunkCount && (p.log("chunks all download"), p.ee.emit("finished")), p.singleThread ? (p.downloadChunks(), Promise.resolve()) : p.postDownloadRequest(t3, n2, r2);
                  });
                case 28:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2, r2) {
            return e2.apply(this, arguments);
          };
        }() }]), t2;
      }(tb()), es = function(e) {
        function t2(e2, i, o, a2) {
          W(this, t2);
          var s = r.call(this, o, "ChunkUploadManager");
          if (m(n(s), "chunkCount", 0), m(n(s), "chunks", []), m(n(s), "uploadedChunks", []), m(n(s), "totalFailures", 0), m(n(s), "timer", void 0), m(n(s), "initState", "uninitialized"), m(n(s), "ee", void 0), m(n(s), "unit", 0), m(n(s), "uploadedSize", 0), m(n(s), "singleThread", false), m(n(s), "abortController", new AbortController()), m(n(s), "servers", []), m(n(s), "aborted", false), m(n(s), "metaInfo", void 0), m(n(s), "transHandler", void 0), s.metaInfo = e2, s.transHandler = i, s.ee = void 0 === a2 ? new ea() : a2, 0 === e2.file.length) throw new I("file not found or is empty", wf);
          return void 0 !== i.cancelSignal && i.cancelSignal.addEventListener("abort", function() {
            s.abortController.abort();
          }, { once: true }), s.abortController.signal.addEventListener("abort", function() {
            s.aborted = true;
          }, { once: true }), s;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "initChunks", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if ("initialized" !== this.initState && "initializing" !== this.initState) {
                    e4.next = 2;
                    break;
                  }
                  throw new Ia("cannot re-initialize");
                case 2:
                  for (this.initState = "initializing", this.unit = t3, n2 = this.sliceFile(t3, this.metaInfo.file), this.chunkCount = n2.length, r2 = [], i = function(e5, t4) {
                    var n3 = (e5 = ra(t4[e5], 2))[0], i2 = e5[1];
                    e5 = bs(i2).then(function(e6) {
                      s.chunks[n3] = { payload: i2, sha1: e6, uploadedTo: void 0, index: n3, processed: false };
                    }), r2.push(e5);
                  }, o = 0, a2 = Array.from(n2.entries()); o < a2.length; o++) i(o, a2);
                  return e4.next = 11, Promise.all(r2);
                case 11:
                  this.updateProgress(0), this.initState = "initialized", this.log("upload chunks initialized");
                case 14:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "uploadToServers", value: function() {
          var e2 = this;
          if (!this.aborted) {
            for (var t3 = this.chunks.filter(function(e3) {
              return !e3.processed;
            }), n2 = function(n3) {
              var r3 = t3[n3], i = e2.servers.filter(function(e3) {
                return !e3.isUploading;
              }).sort(function(e3, t4) {
                return e3.successCount - t4.successCount;
              }).sort(function(e3, t4) {
                return e3.failureCount - t4.failureCount;
              })[0];
              if (void 0 === i || 1 < i.failureCount) return e2.log("Upload server not available, waiting"), e2.ee.emit("serverUsedUp"), Om(1e3).then(function() {
                e2.totalFailures > 2 * e2.chunkCount && e2.ee.emit("error"), e2.totalFailures += 1, void 0 !== i && (i.failureCount = 0), e2.uploadToServers();
              }).catch(function() {
              }), "break";
              r3.processed = true, i.isUploading = true, e2.log("uploading chunk %d to server %s", r3.index, Dg(i.ip));
              var o = e2.getUploadUrl(i.ip);
              return J(w.mark(function t4() {
                var n4;
                return w.wrap(function(t5) {
                  for (; ; ) switch (t5.prev = t5.next) {
                    case 0:
                      return t5.prev = 0, t5.next = 3, e2.postChunk(r3.payload, o, r3.index);
                    case 3:
                      n4 = e2.chunks.findIndex(function(e3) {
                        return e3 === r3;
                      }), r3.uploadedTo = i.ip, e2.chunks.splice(n4, 1), e2.uploadedChunks.push(r3), i.successCount += 1, i.isUploading = false, e2.updateProgress(r3.payload.byteLength), e2.log("upload chunk %d successfully", r3.index), t5.next = 31;
                      break;
                    case 13:
                      if (t5.prev = 13, t5.t0 = t5.catch(0), i.isUploading = false, r3.processed = false, 504 !== t5.t0.statusCode && !Sa(t5.t0)) {
                        t5.next = 27;
                        break;
                      }
                      if (e2.singleThread) {
                        t5.next = 24;
                        break;
                      }
                      return e2.warn("%d upload timed out after %d, retrying use single thread", r3.index, e2.singleThread ? 12e4 : 3e4), e2.abortController.abort(), e2.singleThread = true, e2.ee.emit("multiTimeOut"), t5.abrupt("return");
                    case 24:
                      return e2.ee.emit("timedOut"), e2.abortController.abort(), t5.abrupt("return");
                    case 27:
                      return e2.metaInfo.useNewDomain = false, i.failureCount += 1, t5.next = 31, Om(1e3);
                    case 31:
                      e2.uploadedChunks.length === e2.chunkCount ? (e2.log("chunks uploaded"), e2.ee.emit("finished")) : (e2.singleThread || 1 === e2.chunks.filter(function(e3) {
                        return !e3.processed;
                      }).length) && e2.uploadToServers();
                    case 32:
                    case "end":
                      return t5.stop();
                  }
                }, t4, null, [[0, 13]]);
              }))(), e2.singleThread ? "break" : void 0;
            }, r2 = 0; r2 < t3.length && "break" !== n2(r2); r2++) ;
            0 === t3.length && this.uploadedChunks.length !== this.chunkCount && this.log("%d chunks left uploading", this.chunkCount - this.uploadedChunks.length);
          }
        } }, { key: "getUploadServerIPs", value: function() {
          var e2 = true, t3 = [], n2 = G(this.uploadedChunks).sort(function(e3, t4) {
            return e3.index - t4.index;
          }), r2 = 0;
          for (n2 = Array.from(n2.values()); r2 < n2.length; r2++) {
            var i = n2[r2].uploadedTo;
            if (void 0 === i) {
              e2 = false;
              break;
            }
            t3.push(i);
          }
          if (!e2) throw new Ia("some chunks not uploaded, cannot get upload server ips");
          return t3;
        } }, { key: "addServers", value: function(e2) {
          var t3 = this;
          e2.forEach(function(e3) {
            var n2 = t3.servers.findIndex(function(t4) {
              return t4.ip === e3;
            });
            -1 !== n2 ? t3.servers[n2].failureCount = 0 : (t3.log("server %s added", Dg(e3)), t3.servers.push({ successCount: 0, isUploading: false, ip: e3, failureCount: 0 }));
          });
        } }, { key: "updateProgress", value: function(e2) {
          var t3 = this, n2 = void 0 !== e2 ? this.uploadedSize + e2 : this.metaInfo.file.length;
          n2 > this.metaInfo.file.length ? (this.warn("Invalid upload size, overflowed"), this.ee.emit("error", new Wc("Invalid upload size", lg))) : (this.uploadedSize = n2, void 0 !== this.timer && 0 !== e2 && (clearTimeout(this.timer), this.timer = void 0), void 0 === this.timer && void 0 !== e2 && this.uploadedChunks.length !== this.chunkCount && (this.timer = setTimeout(function() {
            t3.ee.emit("timedOut"), t3.abortController.abort();
          }, 12e4)), "initialized" === this.initState && 0 === e2 || void 0 === this.transHandler.onOperationProgress || this.transHandler.onOperationProgress({ totalSize: this.metaInfo.file.length, currentSize: this.uploadedSize }));
        } }, { key: "sliceFile", value: function(e2, t3) {
          var n2 = 0, r2 = [], i = t3.length;
          for (e2 *= 32768; n2 < i; ) r2.push(t3.slice(n2, n2 + e2)), n2 += e2;
          return this.log("chunks split into %d", r2.length), r2;
        } }, { key: "postChunk", value: function() {
          var e2 = J(w.mark(function e3(t3, n2, r2) {
            var i, o, a2, s, u2, c2, l, f;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (!this.aborted) {
                    e4.next = 2;
                    break;
                  }
                  throw new Ia("upload already aborted");
                case 2:
                  if (void 0 !== this.unit) {
                    e4.next = 4;
                    break;
                  }
                  throw new Ia("unit is undefined");
                case 4:
                  return i = this.metaInfo, o = i.ticket, a2 = i.instance, s = i.loginOpt, u2 = i.hashStr, e4.t0 = r2, e4.t1 = u2, e4.next = 9, bs(t3);
                case 9:
                  return e4.t2 = e4.sent, e4.t3 = this.unit, e4.t4 = o, e4.t5 = a2, e4.t6 = s, c2 = { index: e4.t0, hash: e4.t1, sha1: e4.t2, unit: e4.t3, ticket: e4.t4, instance: e4.t5, loginOpt: e4.t6 }, (l = new FormData()).append("parameter", JSON.stringify(c2)), l.append("payload", new Blob([t3])), e4.next = 20, te(n2, { headers: { Accept: "application/json" }, body: l, timeout: this.singleThread ? 12e4 : 3e4, signal: this.abortController.signal });
                case 20:
                  if (f = e4.sent, 201 === f.status) {
                    e4.next = 24;
                    break;
                  }
                  throw new da("uploading chunk ".concat(r2, " failed"));
                case 24:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2, r2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getUploadUrl", value: function(e2) {
          var t3 = this.metaInfo.useNewDomain ? "sd-rtn.com" : "agora.io";
          return "https://".concat(Dg(e2).split(".").join("-"), ".edge.").concat(t3, ":9601/api/v1/chuck/upload");
        } }]), t2;
      }(tb()), fs = function(e) {
        function t2(e2) {
          W(this, t2);
          var i = r.call(this, e2, "MediaTaskManager");
          return m(n(i), "isProcessing", false), m(n(i), "authInfo", void 0), m(n(i), "taskFinishers", {}), m(n(i), "mediaTasks", /* @__PURE__ */ new Map()), m(n(i), "ongoingTask", void 0), i.on("connectionStateChanged", function(e3) {
            if (e3 === S.ConnectionState.ABORTED || e3 === S.ConnectionState.DISCONNECTED) {
              void 0 !== i.ongoingTask && i.cancelTask(i.ongoingTask), e3 = 0;
              for (var t3 = Array.from(i.mediaTasks.entries()); e3 < t3.length; e3++) {
                var n2 = ra(t3[e3], 2)[1];
                i.cancelTask(n2);
              }
              i.mediaTasks.clear(), i.taskFinishers = {};
            } else e3 === S.ConnectionState.RECONNECTING ? void 0 !== i.ongoingTask && i.ongoingTask.manager.abortController.abort() : e3 === S.ConnectionState.CONNECTED && void 0 !== i.ongoingTask && i.ongoingTask.manager.ee.emit("reconnected");
          }), i;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "setAuthInfo", value: function(e2) {
          this.authInfo = e2;
        } }, { key: "waitMediaTask", value: function(e2) {
          var t3 = this;
          return new Promise(function(n2, r2) {
            t3.taskFinishers[e2] = { resolve: n2, reject: r2 }, t3.isProcessing || t3.processMediaTask();
          }).finally(function() {
            void 0 !== t3.ongoingTask && void 0 !== t3.ongoingTask.manager.timer && clearTimeout(t3.ongoingTask.manager.timer), delete t3.taskFinishers[e2], 0 !== t3.mediaTasks.size ? t3.processMediaTask() : t3.isProcessing = false;
          });
        } }, { key: "addUploadTask", value: function(e2, n2, r2, i) {
          var o = e2.file;
          if (e2 = e2.hash, void 0 === this.authInfo) throw new Ia("session not found");
          if (this.mediaTasks.size >= t2.MAX_PENDING_TASK_COUNT - 1) throw new ib("Upload media failed, exceed max pending jobs", xA);
          return i = new es({ hashStr: as(e2), file: o, ticket: this.authInfo.ticket, instance: this.authInfo.instance.toString(), loginOpt: this.authInfo.loginOpt.toString(), useNewDomain: this.authInfo.useNewDomain }, i, this.logger), o = Ud(), this.mediaTasks.set(o, { type: "UPLOAD", manager: i, hash: e2, setter: r2, fetcher: n2, taskId: o }), o;
        } }, { key: "addDownloadTask", value: function(e2, n2, r2) {
          var i = e2.hashHexStr, o = e2.size, a2 = e2.unit;
          if (e2 = e2.zone, void 0 === this.authInfo) throw new Ia("session not found");
          if (this.mediaTasks.size >= t2.MAX_PENDING_TASK_COUNT - 1) throw new ib("Download media failed, exceed max pending jobs", BA);
          return r2 = new ds({ hashHexStr: i, ticket: this.authInfo.ticket, useNewDomain: this.authInfo.useNewDomain, instance: this.authInfo.instance.toString(), loginOpt: this.authInfo.loginOpt.toString(), size: o, zone: e2, unit: a2 }, r2, this.logger), i = Ud(), this.mediaTasks.set(i, { type: "DOWNLOAD", manager: r2, fetcher: n2, taskId: i }), i;
        } }, { key: "doDownloadTaskImpl", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2, l, f = this, h = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return r2 = 2 < h.length && void 0 !== h[2] && h[2], o = i = t3.manager, r2 && (i = new ds(o.metaInfo, o.transHandler, this.logger, o.ee)), a2 = t3.fetcher, e4.next = 7, a2();
                case 7:
                  if (s = e4.sent, u2 = s.serverList, c2 = s.backupList, l = s.unit, !r2 || l === o.retUnit) {
                    e4.next = 13;
                    break;
                  }
                  throw new da("download unit is different, reject to continue", mg);
                case 13:
                  r2 && (t3.manager = i, i.downloadedSize = o.downloadedSize, i.successCount = o.successCount, i.timer = o.timer, i.chunks = o.chunks, i.initialized = o.initialized, i.singleThread = o.singleThread, i.updateProgress(0)), i.ee.once("reconnected", function() {
                    i.ee.removeAllListeners(), f.doDownloadTaskImpl(t3, n2, true).catch(function(e5) {
                      n2.reject(e5);
                    });
                  }), i.ee.once("multiTimeOut", function() {
                    i.ee.removeAllListeners(), f.doDownloadTaskImpl(t3, n2, true).catch(function(e5) {
                      n2.reject(e5);
                    });
                  }), i.ee.once("error", function(e5) {
                    i.ee.removeAllListeners(), n2.reject(new da(["download file file, index %d", e5.index], { code: mg, originalError: e5 }));
                  }), i.ee.once("notExist", function() {
                    i.abortController.abort(), i.ee.removeAllListeners(), n2.reject(new da("download file not found", AA));
                  }), i.ee.once("timedOut", function() {
                    i.ee.removeAllListeners(), i.abortController.abort(), n2.reject(new db("download timed out", zA));
                  }), void 0 !== i.transHandler.cancelSignal && i.transHandler.cancelSignal.addEventListener("abort", function() {
                    n2.reject(new hl("Downloading canceled", ir));
                  }, { once: true }), i.ee.once("finished", function() {
                    n2.resolve({ type: "DOWNLOAD", payload: i.getPayload() });
                  }), i.setInfoByResponse({ serverList: u2, backupList: c2, unit: l }), i.downloadChunks();
                case 23:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "doDownloadTask", value: function(e2, t3) {
          var n2 = this, r2 = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], i = e2.taskId;
          return r2 || (this.mediaTasks.delete(i), this.ongoingTask = e2), new Promise(function(i2, o) {
            n2.doDownloadTaskImpl(e2, t3, r2).then(i2).catch(o);
          });
        } }, { key: "doUploadTaskImpl", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2, l, f, h = this, p = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return r2 = 2 < p.length && void 0 !== p[2] && p[2], o = i = t3.manager, r2 && (i = new es(o.metaInfo, o.transHandler, this.logger, o.ee)), a2 = t3.fetcher, s = new Pa(), c2 = new Promise(function(e5, c3) {
                    var l2 = a2(), f2 = l2.ret, h2 = l2.err, p2 = l2.timeout;
                    l2.fin.pipe(ob(s)).subscribe({ next: function(e6) {
                      n2.resolve({ type: "UPLOAD", retUnit: e6.unit, zone: e6.zone });
                    }, complete: function() {
                      e5({ hasExist: true }), s.next(), s.complete();
                    } }), f2.pipe(ob(s), cb(function() {
                      var e6 = J(w.mark(function e7(a3) {
                        var s2, c4;
                        return w.wrap(function(e8) {
                          for (; ; ) switch (e8.prev = e8.next) {
                            case 0:
                              if (s2 = a3.servers, c4 = a3.unit, r2 && o.unit !== c4 ? n2.reject(new da("upload unit is different, reject to continue", lg)) : r2 && (t3.manager = i, i.chunkCount = o.chunkCount, i.chunks = o.chunks, i.totalFailures = o.totalFailures, i.uploadedChunks = o.uploadedChunks, i.timer = o.timer, i.initState = o.initState, i.unit = o.unit, i.uploadedSize = o.uploadedSize, i.singleThread = o.singleThread, i.updateProgress(0)), i.addServers(s2), "uninitialized" !== i.initState) {
                                e8.next = 7;
                                break;
                              }
                              return u2 = i.initChunks(c4), e8.next = 7, u2;
                            case 7:
                            case "end":
                              return e8.stop();
                          }
                        }, e7);
                      }));
                      return function(t4) {
                        return e6.apply(this, arguments);
                      };
                    }())).subscribe({ complete: function() {
                      return e5({ hasExist: false });
                    }, error: c3 }), l2 = function(t4) {
                      "uninitialized" !== i.initState && u2 ? e5(u2.then(function() {
                        return { hasExist: false };
                      })) : c3(t4);
                    }, h2.pipe(ob(s)).subscribe({ error: l2 }), p2.pipe(ob(s)).subscribe({ error: l2 });
                  }), e4.next = 9, c2;
                case 9:
                  if (l = e4.sent, !l.hasExist) {
                    e4.next = 15;
                    break;
                  }
                  return i.updateProgress(), this.log("file already exists, skipping upload"), e4.abrupt("return");
                case 15:
                  s.next(), s.complete(), this.log("chunks initialization promise resolved"), f = gb(i.ee, "serverUsedUp").pipe(Gt(function() {
                    return i.chunkCount !== i.uploadedChunks.length;
                  }), Jt(5e3, void 0, { leading: false }), pm(function() {
                    return a2().ret;
                  })).subscribe(function(e5) {
                    i.addServers(e5.servers);
                  }), i.ee.once("reconnected", function() {
                    i.ee.removeAllListeners(), h.doUploadTask(t3, n2, true).catch(function(e5) {
                      n2.reject(e5);
                    });
                  }), i.ee.once("multiTimeOut", function() {
                    i.ee.removeAllListeners(), h.doUploadTask(t3, n2, true).catch(function(e5) {
                      n2.reject(e5);
                    });
                  }), i.ee.once("timedOut", function() {
                    f.unsubscribe(), i.ee.removeAllListeners(), i.abortController.abort(), n2.reject(new db("upload timed out", Lh));
                  }), i.ee.once("error", function(e5) {
                    f.unsubscribe(), i.ee.removeAllListeners(), i.abortController.abort(), n2.reject(e5 || new da("upload error", lg));
                  }), void 0 !== i.transHandler.cancelSignal && i.transHandler.cancelSignal.addEventListener("abort", function() {
                    n2.reject(new hl("Uploading canceled", hr));
                  }, { once: true }), i.ee.once("finished", J(w.mark(function e5() {
                    var r3, o2, a3;
                    return w.wrap(function(e6) {
                      for (; ; ) switch (e6.prev = e6.next) {
                        case 0:
                          return f.unsubscribe(), e6.next = 3, t3.setter(i.unit, i.getUploadServerIPs());
                        case 3:
                          r3 = e6.sent, o2 = r3.zone, a3 = r3.unit, i.ee.removeAllListeners(), n2.resolve({ type: "UPLOAD", retUnit: a3, zone: o2 });
                        case 8:
                        case "end":
                          return e6.stop();
                      }
                    }, e5);
                  }))), i.uploadToServers();
                case 26:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "doUploadTask", value: function(e2, t3) {
          var n2 = this, r2 = 2 < arguments.length && void 0 !== arguments[2] && arguments[2], i = e2.taskId;
          return r2 || (this.mediaTasks.delete(i), this.ongoingTask = e2), new Promise(function(i2, o) {
            n2.doUploadTaskImpl(e2, t3, r2).then(i2).catch(o);
          });
        } }, { key: "processMediaTask", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3, n2, r2;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (0 !== this.mediaTasks.size) {
                    e4.next = 2;
                    break;
                  }
                  throw Error("no upload tasks");
                case 2:
                  if (this.isProcessing = true, t3 = this.mediaTasks.keys().next().value, void 0 !== (n2 = this.taskFinishers[t3])) {
                    e4.next = 7;
                    break;
                  }
                  throw Error("top task not found");
                case 7:
                  if (void 0 !== (r2 = this.mediaTasks.get(t3))) {
                    e4.next = 10;
                    break;
                  }
                  throw new Ia("task invalid");
                case 10:
                  if ("UPLOAD" !== r2.type) {
                    e4.next = 15;
                    break;
                  }
                  return e4.next = 13, this.doUploadTask(r2, n2).catch(function(e5) {
                    r2.manager.ee.removeAllListeners(), n2.reject(e5);
                  });
                case 13:
                  e4.next = 18;
                  break;
                case 15:
                  if ("DOWNLOAD" !== r2.type) {
                    e4.next = 18;
                    break;
                  }
                  return e4.next = 18, this.doDownloadTask(r2, n2).catch(function(e5) {
                    r2.manager.ee.removeAllListeners(), n2.reject(e5);
                  });
                case 18:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "cancelTask", value: function(e2) {
          var t3 = "DOWNLOAD" === e2.type ? ir : hr;
          e2.manager.ee.removeAllListeners(), e2.manager.abortController.abort(), void 0 !== this.taskFinishers[e2.taskId] && this.taskFinishers[e2.taskId].reject(new hl("User logged out or kicked off, media task canceled", t3));
        } }]), t2;
      }(tb());
      m(fs, "MAX_PENDING_TASK_COUNT", 9), Oo("of", function() {
        for (var e = 0, t2 = arguments.length, n2 = new (Ne(this))(t2); t2 > e; ) n2[e] = arguments[e++];
        return n2;
      }, Dj);
      var gs = 1 / 0, dD = Math.max, ju = function(e, t2, n2) {
        var r = Object(e);
        if (!Ed(e)) {
          var i = Te(t2);
          e = Ad(e), t2 = function(e2) {
            return i(r[e2], e2, r);
          };
        }
        return -1 < (t2 = function(e2, t3, n3) {
          var r2 = null == e2 ? 0 : e2.length;
          if (!r2) return -1;
          if (null == n3) n3 = 0;
          else {
            var i2 = (n3 = n3 ? (n3 = gl(n3)) === gs || n3 === -gs ? 17976931348623157e292 * (0 > n3 ? -1 : 1) : n3 == n3 ? n3 : 0 : 0 === n3 ? n3 : 0) % 1;
            n3 = n3 == n3 ? i2 ? n3 - i2 : n3 : 0;
          }
          return 0 > n3 && (n3 = dD(r2 + n3, 0)), Xp(e2, Te(t3), n3);
        }(e, t2, n2)) ? r[i ? e[t2] : t2] : void 0;
      }, iu = function(e, t2) {
        return e && e.length ? vk(e, void 0, "function" == typeof t2 ? t2 : void 0) : [];
      }, hs = function() {
        function e() {
          W(this, e), m(this, "size", 0), m(this, "fields", /* @__PURE__ */ new Map());
        }
        return Ha(e, [{ key: "define", value: function(e2, t2, n2) {
          if (this.size += n2, 64 < this.size) throw new RangeError("the struct over 64 bits is not supported");
          Mg(t2 = { val: 0, isNumber: "number" === t2, isBoolean: "boolean" === t2, oneof: "number" === t2 || "boolean" === t2 ? void 0 : t2, len: n2 }), this.fields.set(e2, t2);
        } }, { key: "set", value: function(e2, t2) {
          if (!(e2 = this.fields.get(e2))) throw Error("field not found");
          var n2 = e2.oneof;
          if (!U.isLong(t2) && "number" != typeof t2) if ("boolean" == typeof t2) t2 = t2 ? 1 : 0;
          else {
            if (void 0 === n2) throw Error("invalid field type");
            if (void 0 === (t2 = n2[t2])) throw Error("field type not found");
          }
          Mg(e2, t2), e2.val = t2;
        } }, { key: "toNumber", value: function() {
          for (var e2 = 0, t2 = 0, n2 = 0, r = Array.from(this.fields); n2 < r.length; n2++) {
            var i = ra(r[n2], 2)[1], o = i.len;
            void 0 !== (i = i.val) && (e2 += U.fromValue(i).shiftLeft(t2).toNumber(), t2 += o);
          }
          return e2;
        } }, { key: "toLong", value: function() {
          for (var e2 = U.fromNumber(0, true), t2 = 0, n2 = 0, r = Array.from(this.fields); n2 < r.length; n2++) {
            var i = ra(r[n2], 2)[1], o = i.len;
            void 0 !== (i = i.val) && (e2 = U.fromValue(i).shiftLeft(t2).add(e2), t2 += o);
          }
          return e2;
        } }, { key: "assert", value: function(e2, t2) {
          function n2(e3) {
            if (!U.isLong(e3) && "number" != typeof e3) if ("boolean" == typeof e3) e3 = e3 ? 1 : 0;
            else {
              if (void 0 === i) throw Error("invalid field type");
              if (void 0 === (e3 = i[e3])) throw Error("field type not found");
            }
            return Mg(r, e3), Lg(e3, r.val);
          }
          var r = this.fields.get(e2);
          if (!r) throw Error("field not found");
          var i = r.oneof;
          if (!Array.isArray(t2)) return n2(t2);
          if (1 === t2.length) return n2(t2[0]);
          if (t2.every(function(e3) {
            return "string" == typeof e3;
          }) && void 0 !== i) return t2.some(function(e3) {
            return n2(e3);
          });
          throw Error("invalid valueTypes");
        } }, { key: "from", value: function(e2) {
          e2 = U.fromValue(e2);
          for (var t2 = 0, n2 = 0, r = Array.from(this.fields); n2 < r.length; n2++) {
            var i = ra(r[n2], 2)[1], o = i.len, a2 = U.fromNumber(Math.pow(2, o) - 1, true).shiftLeft(t2);
            Mg(i, a2 = e2.and(a2).shiftRightUnsigned(t2)), i.val = a2, t2 += o;
          }
        } }, { key: "typeOf", value: function(e2) {
          if (void 0 !== (e2 = this.fields.get(e2))) {
            var t2 = e2.oneof;
            if (e2 = e2.val, void 0 !== t2) {
              var n2 = 0;
              for (t2 = Object.entries(t2); n2 < t2.length; n2++) {
                var r = ra(t2[n2], 2), i = r[0];
                if (Lg(e2, r[1])) return i;
              }
            }
          }
          throw new TypeError("can only get type of oneof type");
        } }]), e;
      }(), is = function(e) {
        function t2(e2) {
          W(this, t2);
          var r = n2.call(this);
          return r.define("Rejoin", "boolean", 1), r.define("Unused", "number", 31), r.define("Platform", "number", 8), r.define("Version", "number", 12), r.define("Subversion", "number", 12), r.set("Platform", 7), r.set("Version", 4), r.set("Subversion", 203), r.set("Rejoin", e2), r;
        }
        la(t2, e);
        var n2 = ma(t2);
        return t2;
      }(hs), eD = ua(ua(ua(ua({}, { PeerTextMessage: 0, ChannelTextMessage: 1, VendorTextMessage: 2 }), { PeerRawMessage: 3, ChannelRawMessage: 4, VendorRawMessage: 5 }), { PeerImageMessage: 6, ChannelImageMessage: 7, VendorImageMessage: 8 }), { PeerFileMessage: 15, ChannelFileMessage: 16, VendorFileMessage: 17 }), js = { CallInvite: 101, CallAccept: 102, CallReject: 103, CallCancel: 104 }, fD = ua(ua({}, eD), js), gD = { Uncompressed: 0, Zlib: 1 }, ae = function(e) {
        function t2(e2) {
          W(this, t2);
          var r = n2.call(this);
          if (r.define("MessageType", fD, 8), r.define("BroadcastJumps", "number", 2), r.define("ToCache", "boolean", 1), r.define("FromCache", "boolean", 1), r.define("CompressionMethod", gD, 2), r.define("IterationNumber", "number", 4), r.define("BufferedMessage", "boolean", 1), r.define("ToArchive", "boolean", 1), r.define("FromArchive", "boolean", 1), "number" == typeof e2 || U.isLong(e2)) r.from(e2);
          else if (void 0 !== e2) {
            var i = 0;
            for (e2 = Hg(e2); i < e2.length; i++) {
              var o = ra(e2[i], 2);
              r.set(o[0], o[1]);
            }
          }
          return r;
        }
        la(t2, e);
        var n2 = ma(t2);
        return Ha(t2, [{ key: "isTextMessage", value: function() {
          return this.assert("MessageType", ["PeerTextMessage", "ChannelTextMessage", "VendorTextMessage"]);
        } }, { key: "isRawMessage", value: function() {
          return this.assert("MessageType", ["ChannelRawMessage", "PeerRawMessage", "VendorRawMessage"]);
        } }, { key: "isRawPeerMessage", value: function() {
          return this.assert("MessageType", "PeerRawMessage");
        } }, { key: "isRawChannelMessage", value: function() {
          return this.assert("MessageType", "ChannelRawMessage");
        } }, { key: "isPeerTextMessage", value: function() {
          return this.assert("MessageType", "PeerTextMessage");
        } }, { key: "isChannelTextMessage", value: function() {
          return this.assert("MessageType", "ChannelTextMessage");
        } }, { key: "isInvitation", value: function(e2) {
          var t3 = this;
          return void 0 !== e2 ? this.assert("MessageType", e2) : xf(js).some(function(e3) {
            return t3.assert("MessageType", e3);
          });
        } }, { key: "isFileMessage", value: function() {
          return this.assert("MessageType", ["PeerFileMessage", "ChannelFileMessage", "VendorFileMessage"]);
        } }, { key: "isImageMessage", value: function() {
          return this.assert("MessageType", ["PeerImageMessage", "ChannelImageMessage", "VendorImageMessage"]);
        } }, { key: "isPeerMessage", value: function() {
          return this.assert("MessageType", ["PeerFileMessage", "PeerTextMessage", "PeerImageMessage", "PeerRawMessage"]);
        } }, { key: "isZlibCompressed", value: function() {
          return this.assert("CompressionMethod", "Zlib");
        } }, { key: "isFromCache", value: function() {
          return this.assert("FromCache", true);
        } }, { key: "isBufferedMessage", value: function() {
          return this.assert("BufferedMessage", true);
        } }, { key: "getInvitationType", value: function() {
          if (!this.isInvitation()) throw new TypeError("cannot get InvitationType of a normal message type");
          return this.typeOf("MessageType");
        } }]), t2;
      }(hs), hD = function(e) {
        function t2(e2) {
          return W(this, t2), m(n(e2 = r.call(this, e2, "ChatManager")), "dialogueLru", new Sx(void 0, { maxlen: 1e4, ttl: 1e4 })), e2;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "getChatInfo", value: function(e2) {
          var t3 = this.dialogueLru.get(e2);
          if (this.dialogueLru.prune(), t3) {
            var n2 = t3.dialogue, r2 = { dialogue: n2, sequence: t3 = t3.sequence.add(1) };
            return this.dialogueLru.set(e2, { dialogue: n2, sequence: t3 }), r2;
          }
          return n2 = { dialogue: Bg(), sequence: U.fromNumber(1, true) }, this.dialogueLru.set(e2, n2), n2;
        } }]), t2;
      }(tb()), v = {};
      "object" == ("undefined" == typeof module ? "undefined" : X(module)) && (module.exports = v), v.parse = function(e, t2) {
        var n2, r = v.bin.readUshort, i = v.bin.readUint, o = {};
        for (n2 = (e = new Uint8Array(e)).length - 4; 101010256 != i(e, n2); ) n2--;
        var a2 = r(e, n2 = n2 + 4 + 4);
        r(e, n2 += 2), i(e, n2 += 2), n2 = i(e, n2 += 4);
        for (var s = 0; s < a2; s++) {
          i(e, n2), n2 += 4, n2 += 4, n2 += 4, i(e, n2 += 4);
          var u2 = i(e, n2 += 4), c2 = i(e, n2 += 4), l = r(e, n2 += 4), f = r(e, n2 + 2), h = r(e, n2 + 4);
          n2 += 6;
          var p = i(e, n2 += 8);
          n2 += 4, n2 += l + f + h, v._readLocal(e, p, o, u2, c2, t2);
        }
        return o;
      }, v._readLocal = function(e, t2, n2, r, i, o) {
        var a2 = v.bin.readUshort, s = v.bin.readUint;
        s(e, t2), a2(e, t2 += 4), a2(e, t2 += 2);
        var u2 = a2(e, t2 += 2);
        s(e, t2 += 2), s(e, t2 += 4), s = a2(e, t2 = t2 + 4 + 8);
        var c2 = a2(e, t2 += 2);
        if (t2 += 2, a2 = v.bin.readUTF8(e, t2, s), t2 = t2 + s + c2, o) n2[a2] = { size: i, csize: r };
        else if (e = new Uint8Array(e.buffer, t2), 0 == u2) n2[a2] = new Uint8Array(e.buffer.slice(t2, t2 + r));
        else {
          if (8 != u2) throw "unknown compression method: " + u2;
          t2 = new Uint8Array(i), v.inflateRaw(e, t2), n2[a2] = t2;
        }
      }, v.inflateRaw = function(e, t2) {
        return v.F.inflate(e, t2);
      }, v.inflate = function(e, t2) {
        return e[0], e[1], v.inflateRaw(new Uint8Array(e.buffer, e.byteOffset + 2, e.length - 2), t2);
      }, v.deflate = function(e, t2) {
        null == t2 && (t2 = { level: 6 });
        var n2 = 0, r = new Uint8Array(50 + Math.floor(1.1 * e.length));
        return r[n2] = 120, r[n2 + 1] = 156, n2 = v.F.deflateRaw(e, r, n2 + 2, t2.level), e = v.adler(e, 0, e.length), r[n2 + 0] = e >>> 24 & 255, r[n2 + 1] = e >>> 16 & 255, r[n2 + 2] = e >>> 8 & 255, r[n2 + 3] = e >>> 0 & 255, new Uint8Array(r.buffer, 0, n2 + 4);
      }, v.deflateRaw = function(e, t2) {
        null == t2 && (t2 = { level: 6 });
        var n2 = new Uint8Array(50 + Math.floor(1.1 * e.length)), r = v.F.deflateRaw(e, n2, r, t2.level);
        return new Uint8Array(n2.buffer, 0, r);
      }, v.encode = function(e, t2) {
        null == t2 && (t2 = false);
        var n2, r = 0, i = v.bin.writeUint, o = v.bin.writeUshort, a2 = {};
        for (n2 in e) {
          var s = !v._noNeed(n2) && !t2, u2 = e[n2], c2 = v.crc.crc(u2, 0, u2.length);
          a2[n2] = { cpr: s, usize: u2.length, crc: c2, file: s ? v.deflateRaw(u2) : u2 };
        }
        for (n2 in a2) r += a2[n2].file.length + 30 + 46 + 2 * v.bin.sizeUTF8(n2);
        for (n2 in e = new Uint8Array(r + 22), t2 = 0, u2 = [], a2) c2 = a2[n2], u2.push(t2), t2 = v._writeHeader(e, t2, n2, c2, 0);
        for (n2 in r = 0, s = t2, a2) c2 = a2[n2], u2.push(t2), t2 = v._writeHeader(e, t2, n2, c2, 1, u2[r++]);
        return a2 = t2 - s, i(e, t2, 101010256), o(e, t2 = t2 + 4 + 4, r), o(e, t2 += 2, r), i(e, t2 += 2, a2), i(e, t2 + 4, s), e.buffer;
      }, v._noNeed = function(e) {
        return e = e.split(".").pop().toLowerCase(), -1 != "png,jpg,jpeg,zip".indexOf(e);
      }, v._writeHeader = function(e, t2, n2, r, i, o) {
        var a2 = v.bin.writeUint, s = v.bin.writeUshort, u2 = r.file;
        return a2(e, t2, 0 == i ? 67324752 : 33639248), t2 += 4, 1 == i && (t2 += 2), s(e, t2, 20), s(e, t2 += 2, 0), s(e, t2 += 2, r.cpr ? 8 : 0), a2(e, t2 += 2, 0), a2(e, t2 += 4, r.crc), a2(e, t2 += 4, u2.length), a2(e, t2 += 4, r.usize), s(e, t2 += 4, v.bin.sizeUTF8(n2)), s(e, t2 += 2, 0), t2 += 2, 1 == i && (a2(e, t2 = t2 + 2 + 2 + 6, o), t2 += 4), t2 += n2 = v.bin.writeUTF8(e, t2, n2), 0 == i && (e.set(u2, t2), t2 += u2.length), t2;
      }, v.crc = { table: function() {
        for (var e = new Uint32Array(256), t2 = 0; 256 > t2; t2++) {
          for (var n2 = t2, r = 0; 8 > r; r++) n2 = 1 & n2 ? 3988292384 ^ n2 >>> 1 : n2 >>> 1;
          e[t2] = n2;
        }
        return e;
      }(), update: function(e, t2, n2, r) {
        for (var i = 0; i < r; i++) e = v.crc.table[255 & (e ^ t2[n2 + i])] ^ e >>> 8;
        return e;
      }, crc: function(e, t2, n2) {
        return 4294967295 ^ v.crc.update(4294967295, e, t2, n2);
      } }, v.adler = function(e, t2, n2) {
        var r = 1, i = 0, o = t2;
        for (t2 += n2; o < t2; ) {
          for (n2 = Math.min(o + 5552, t2); o < n2; ) i += r += e[o++];
          r %= 65521, i %= 65521;
        }
        return i << 16 | r;
      }, v.bin = { readUshort: function(e, t2) {
        return e[t2] | e[t2 + 1] << 8;
      }, writeUshort: function(e, t2, n2) {
        e[t2] = 255 & n2, e[t2 + 1] = n2 >> 8 & 255;
      }, readUint: function(e, t2) {
        return 16777216 * e[t2 + 3] + (e[t2 + 2] << 16 | e[t2 + 1] << 8 | e[t2]);
      }, writeUint: function(e, t2, n2) {
        e[t2] = 255 & n2, e[t2 + 1] = n2 >> 8 & 255, e[t2 + 2] = n2 >> 16 & 255, e[t2 + 3] = n2 >> 24 & 255;
      }, readASCII: function(e, t2, n2) {
        for (var r = "", i = 0; i < n2; i++) r += String.fromCharCode(e[t2 + i]);
        return r;
      }, writeASCII: function(e, t2, n2) {
        for (var r = 0; r < n2.length; r++) e[t2 + r] = n2.charCodeAt(r);
      }, pad: function(e) {
        return 2 > e.length ? "0" + e : e;
      }, readUTF8: function(e, t2, n2) {
        for (var r, i = "", o = 0; o < n2; o++) i += "%" + v.bin.pad(e[t2 + o].toString(16));
        try {
          r = decodeURIComponent(i);
        } catch (r2) {
          return v.bin.readASCII(e, t2, n2);
        }
        return r;
      }, writeUTF8: function(e, t2, n2) {
        for (var r = n2.length, i = 0, o = 0; o < r; o++) {
          var a2 = n2.charCodeAt(o);
          if (0 == (4294967168 & a2)) e[t2 + i] = a2, i++;
          else if (0 == (4294965248 & a2)) e[t2 + i] = 192 | a2 >> 6, e[t2 + i + 1] = 128 | a2 >> 0 & 63, i += 2;
          else if (0 == (4294901760 & a2)) e[t2 + i] = 224 | a2 >> 12, e[t2 + i + 1] = 128 | a2 >> 6 & 63, e[t2 + i + 2] = 128 | a2 >> 0 & 63, i += 3;
          else {
            if (0 != (4292870144 & a2)) throw "e";
            e[t2 + i] = 240 | a2 >> 18, e[t2 + i + 1] = 128 | a2 >> 12 & 63, e[t2 + i + 2] = 128 | a2 >> 6 & 63, e[t2 + i + 3] = 128 | a2 >> 0 & 63, i += 4;
          }
        }
        return i;
      }, sizeUTF8: function(e) {
        for (var t2 = e.length, n2 = 0, r = 0; r < t2; r++) {
          var i = e.charCodeAt(r);
          if (0 == (4294967168 & i)) n2++;
          else if (0 == (4294965248 & i)) n2 += 2;
          else if (0 == (4294901760 & i)) n2 += 3;
          else {
            if (0 != (4292870144 & i)) throw "e";
            n2 += 4;
          }
        }
        return n2;
      } }, v.F = {}, v.F.deflateRaw = function(e, t2, n2, r) {
        var i = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][r], o = v.F.U, a2 = v.F._goodIndex;
        v.F._hash;
        var s = v.F._putsE, u2 = 0;
        n2 <<= 3;
        var c2 = 0, l = e.length;
        if (0 == r) {
          for (; u2 < l; ) {
            var f = Math.min(65535, l - u2);
            s(t2, n2, u2 + f == l ? 1 : 0), n2 = v.F._copyExact(e, u2, f, t2, n2 + 8), u2 += f;
          }
          return n2 >>> 3;
        }
        s = o.lits, r = o.strt;
        var h = o.prev, p = 0, d = 0, b = 0, g = 0, y2 = 0;
        for (2 < l && (r[y2 = v.F._hash(e, 0)] = 0), u2 = 0; u2 < l; u2++) {
          if (f = y2, u2 + 1 < l - 2) {
            y2 = v.F._hash(e, u2 + 1);
            var m2 = u2 + 1 & 32767;
            h[m2] = r[y2], r[y2] = m2;
          }
          if (c2 <= u2) {
            if ((14e3 < p || 26697 < d) && 100 < l - u2 && (c2 < u2 && (s[p] = u2 - c2, p += 2, c2 = u2), n2 = v.F._writeBlock(u2 == l - 1 || c2 == l ? 1 : 0, s, p, g, e, b, u2 - b, t2, n2), p = d = g = 0, b = u2), m2 = 0, u2 < l - 2 && (m2 = v.F._bestMatch(e, u2, h, f, Math.min(i[2], l - u2), i[3])), 0 != m2) {
              f = m2 >>> 16, m2 &= 65535;
              var E2 = a2(f, o.of0);
              o.lhst[257 + E2]++;
              var w2 = a2(m2, o.df0);
              o.dhst[w2]++, g += o.exb[E2] + o.dxb[w2], s[p] = f << 23 | u2 - c2, s[p + 1] = m2 << 16 | E2 << 8 | w2, p += 2, c2 = u2 + f;
            } else o.lhst[e[u2]]++;
            d++;
          }
        }
        for (b == u2 && 0 != e.length || (c2 < u2 && (s[p] = u2 - c2, p += 2), n2 = v.F._writeBlock(1, s, p, g, e, b, u2 - b, t2, n2)); 0 != (7 & n2); ) n2++;
        return n2 >>> 3;
      }, v.F._bestMatch = function(e, t2, n2, r, i, o) {
        var a2 = 32767 & t2, s = n2[a2], u2 = a2 - s + 32768 & 32767;
        if (s == a2 || r != v.F._hash(e, t2 - u2)) return 0;
        for (var c2 = r = 0, l = Math.min(32767, t2); u2 <= l && 0 != --o && s != a2; ) {
          if ((0 == r || e[t2 + r] == e[t2 + r - u2]) && (a2 = v.F._howLong(e, t2, u2)) > r) {
            if (c2 = u2, (r = a2) >= i) break;
            u2 + 2 < a2 && (a2 = u2 + 2);
            for (var f = 0, h = 0; h < a2 - 2; h++) {
              var p = t2 - u2 + h + 32768 & 32767, d = p - n2[p] + 32768 & 32767;
              d > f && (f = d, s = p);
            }
          }
          u2 += (a2 = s) - (s = n2[a2]) + 32768 & 32767;
        }
        return r << 16 | c2;
      }, v.F._howLong = function(e, t2, n2) {
        if (e[t2] != e[t2 - n2] || e[t2 + 1] != e[t2 + 1 - n2] || e[t2 + 2] != e[t2 + 2 - n2]) return 0;
        var r = t2, i = Math.min(e.length, t2 + 258);
        for (t2 += 3; t2 < i && e[t2] == e[t2 - n2]; ) t2++;
        return t2 - r;
      }, v.F._hash = function(e, t2) {
        return (e[t2] << 8 | e[t2 + 1]) + (e[t2 + 2] << 4) & 65535;
      }, v.saved = 0, v.F._writeBlock = function(e, t2, n2, r, i, o, a2, s, u2) {
        var c2 = v.F.U, l = v.F._putsF, f = v.F._putsE;
        c2.lhst[256]++;
        var h = v.F.getTrees(), p = h[0], d = h[1], b = h[2], g = h[3], y2 = h[4], m2 = h[5], E2 = h[6];
        h = h[7];
        var w2 = 32 + (0 == (u2 + 3 & 7) ? 0 : 8 - (u2 + 3 & 7)) + (a2 << 3), _ = r + v.F.contSize(c2.fltree, c2.lhst) + v.F.contSize(c2.fdtree, c2.dhst);
        r = r + v.F.contSize(c2.ltree, c2.lhst) + v.F.contSize(c2.dtree, c2.dhst), r += 14 + 3 * m2 + v.F.contSize(c2.itree, c2.ihst) + (2 * c2.ihst[16] + 3 * c2.ihst[17] + 7 * c2.ihst[18]);
        for (var O2 = 0; 286 > O2; O2++) c2.lhst[O2] = 0;
        for (O2 = 0; 30 > O2; O2++) c2.dhst[O2] = 0;
        for (O2 = 0; 19 > O2; O2++) c2.ihst[O2] = 0;
        if (w2 = w2 < _ && w2 < r ? 0 : _ < r ? 1 : 2, l(s, u2, e), l(s, u2 + 1, w2), u2 += 3, 0 == w2) {
          for (; 0 != (7 & u2); ) u2++;
          u2 = v.F._copyExact(i, o, a2, s, u2);
        } else {
          if (1 == w2) var I2 = c2.fltree, A = c2.fdtree;
          if (2 == w2) {
            for (v.F.makeCodes(c2.ltree, p), v.F.revCodes(c2.ltree, p), v.F.makeCodes(c2.dtree, d), v.F.revCodes(c2.dtree, d), v.F.makeCodes(c2.itree, b), v.F.revCodes(c2.itree, b), I2 = c2.ltree, A = c2.dtree, f(s, u2, g - 257), f(s, u2 += 5, y2 - 1), f(s, u2 += 5, m2 - 4), u2 += 4, e = 0; e < m2; e++) f(s, u2 + 3 * e, c2.itree[1 + (c2.ordr[e] << 1)]);
            u2 = v.F._codeTiny(E2, c2.itree, s, u2 + 3 * m2), u2 = v.F._codeTiny(h, c2.itree, s, u2);
          }
          for (m2 = 0; m2 < n2; m2 += 2) {
            for (E2 = (e = t2[m2]) >>> 23, e = o + (8388607 & e); o < e; ) u2 = v.F._writeLit(i[o++], I2, s, u2);
            0 != E2 && (e = (p = t2[m2 + 1]) >> 16, a2 = p >> 8 & 255, p &= 255, f(s, u2 = v.F._writeLit(257 + a2, I2, s, u2), E2 - c2.of0[a2]), u2 += c2.exb[a2], l(s, u2 = v.F._writeLit(p, A, s, u2), e - c2.df0[p]), u2 += c2.dxb[p], o += E2);
          }
          u2 = v.F._writeLit(256, I2, s, u2);
        }
        return u2;
      }, v.F._copyExact = function(e, t2, n2, r, i) {
        var o = i >>> 3;
        return r[o] = n2, r[o + 1] = n2 >>> 8, r[o + 2] = 255 - r[o], r[o + 3] = 255 - r[o + 1], o += 4, r.set(new Uint8Array(e.buffer, t2, n2), o), i + (n2 + 4 << 3);
      }, v.F.getTrees = function() {
        for (var e = v.F.U, t2 = v.F._hufTree(e.lhst, e.ltree, 15), n2 = v.F._hufTree(e.dhst, e.dtree, 15), r = [], i = v.F._lenCodes(e.ltree, r), o = [], a2 = v.F._lenCodes(e.dtree, o), s = 0; s < r.length; s += 2) e.ihst[r[s]]++;
        for (s = 0; s < o.length; s += 2) e.ihst[o[s]]++;
        s = v.F._hufTree(e.ihst, e.itree, 7);
        for (var u2 = 19; 4 < u2 && 0 == e.itree[1 + (e.ordr[u2 - 1] << 1)]; ) u2--;
        return [t2, n2, s, i, a2, u2, r, o];
      }, v.F.getSecond = function(e) {
        for (var t2 = [], n2 = 0; n2 < e.length; n2 += 2) t2.push(e[n2 + 1]);
        return t2;
      }, v.F.nonZero = function(e) {
        for (var t2 = "", n2 = 0; n2 < e.length; n2 += 2) 0 != e[n2 + 1] && (t2 += (n2 >> 1) + ",");
        return t2;
      }, v.F.contSize = function(e, t2) {
        for (var n2 = 0, r = 0; r < t2.length; r++) n2 += t2[r] * e[1 + (r << 1)];
        return n2;
      }, v.F._codeTiny = function(e, t2, n2, r) {
        for (var i = 0; i < e.length; i += 2) {
          var o = e[i], a2 = e[i + 1];
          r = v.F._writeLit(o, t2, n2, r);
          var s = 16 == o ? 2 : 17 == o ? 3 : 7;
          15 < o && (v.F._putsE(n2, r, a2, s), r += s);
        }
        return r;
      }, v.F._lenCodes = function(e, t2) {
        for (var n2 = e.length; 2 != n2 && 0 == e[n2 - 1]; ) n2 -= 2;
        for (var r = 0; r < n2; r += 2) {
          var i = e[r + 1], o = r + 3 < n2 ? e[r + 3] : -1, a2 = r + 5 < n2 ? e[r + 5] : -1, s = 0 == r ? -1 : e[r - 1];
          if (0 == i && o == i && a2 == i) {
            for (o = r + 5; o + 2 < n2 && e[o + 2] == i; ) o += 2;
            11 > (i = Math.min(o + 1 - r >>> 1, 138)) ? t2.push(17, i - 3) : t2.push(18, i - 11), r += 2 * i - 2;
          } else if (i == s && o == i && a2 == i) {
            for (o = r + 5; o + 2 < n2 && e[o + 2] == i; ) o += 2;
            i = Math.min(o + 1 - r >>> 1, 6), t2.push(16, i - 3), r += 2 * i - 2;
          } else t2.push(i, 0);
        }
        return n2 >>> 1;
      }, v.F._hufTree = function(e, t2, n2) {
        var r = [], i = e.length, o = t2.length, a2 = 0;
        for (a2 = 0; a2 < o; a2 += 2) t2[a2] = 0, t2[a2 + 1] = 0;
        for (a2 = 0; a2 < i; a2++) 0 != e[a2] && r.push({ lit: a2, f: e[a2] });
        if (e = r.length, i = r.slice(0), 0 == e) return 0;
        if (1 == e) return t2[1 + ((n2 = r[0].lit) << 1)] = 1, t2[1 + ((0 == n2 ? 1 : 0) << 1)] = 1;
        r.sort(function(e2, t3) {
          return e2.f - t3.f;
        }), a2 = r[0], o = r[1];
        var s = 0, u2 = 1, c2 = 2;
        for (r[0] = { lit: -1, f: a2.f + o.f, l: a2, r: o, d: 0 }; u2 != e - 1; ) a2 = s != u2 && (c2 == e || r[s].f < r[c2].f) ? r[s++] : r[c2++], o = s != u2 && (c2 == e || r[s].f < r[c2].f) ? r[s++] : r[c2++], r[u2++] = { lit: -1, f: a2.f + o.f, l: a2, r: o };
        for ((r = v.F.setDepth(r[u2 - 1], 0)) > n2 && (v.F.restrictDepth(i, n2, r), r = n2), a2 = 0; a2 < e; a2++) t2[1 + (i[a2].lit << 1)] = i[a2].d;
        return r;
      }, v.F.setDepth = function(e, t2) {
        return -1 != e.lit ? e.d = t2 : Math.max(v.F.setDepth(e.l, t2 + 1), v.F.setDepth(e.r, t2 + 1));
      }, v.F.restrictDepth = function(e, t2, n2) {
        var r = 0, i = 1 << n2 - t2, o = 0;
        for (e.sort(function(e2, t3) {
          return t3.d == e2.d ? e2.f - t3.f : t3.d - e2.d;
        }), r = 0; r < e.length && e[r].d > t2; r++) {
          var a2 = e[r].d;
          e[r].d = t2, o += i - (1 << n2 - a2);
        }
        for (o >>>= n2 - t2; 0 < o; ) (a2 = e[r].d) < t2 ? (e[r].d++, o -= 1 << t2 - a2 - 1) : r++;
        for (; 0 <= r; r--) e[r].d == t2 && 0 > o && (e[r].d--, o++);
        0 != o && console.log("debt left");
      }, v.F._goodIndex = function(e, t2) {
        var n2 = 0;
        return t2[16 | n2] <= e && (n2 |= 16), t2[8 | n2] <= e && (n2 |= 8), t2[4 | n2] <= e && (n2 |= 4), t2[2 | n2] <= e && (n2 |= 2), t2[1 | n2] <= e && (n2 |= 1), n2;
      }, v.F._writeLit = function(e, t2, n2, r) {
        return v.F._putsF(n2, r, t2[e << 1]), r + t2[1 + (e << 1)];
      }, v.F.inflate = function(e, t2) {
        var n2 = Uint8Array;
        if (3 == e[0] && 0 == e[1]) return t2 || new n2(0);
        var r = v.F, i = r._bitsF, o = r._bitsE, a2 = r._decodeTiny, s = r.makeCodes, u2 = r.codes2map, c2 = r._get17, l = r.U, f = null == t2;
        f && (t2 = new n2(e.length >>> 2 << 3));
        for (var h, p, d, b, g = 0, y2 = 0, m2 = p = 0, E2 = 0; 0 == g; ) if (g = i(e, E2, 1), h = i(e, E2 + 1, 2), E2 += 3, 0 == h) 0 != (7 & E2) && (E2 += 8 - (7 & E2)), h = e[(E2 = 4 + (E2 >>> 3)) - 4] | e[E2 - 3] << 8, f && (t2 = v.F._check(t2, m2 + h)), t2.set(new n2(e.buffer, e.byteOffset + E2, h), m2), E2 = E2 + h << 3, m2 += h;
        else {
          if (f && (t2 = v.F._check(t2, m2 + 131072)), 1 == h && (d = l.flmap, b = l.fdmap, y2 = 511, p = 31), 2 == h) {
            for (p = o(e, E2, 5) + 257, h = o(e, E2 + 5, 5) + 1, d = o(e, E2 + 10, 4) + 4, E2 += 14, b = 0; 38 > b; b += 2) l.itree[b] = 0, l.itree[b + 1] = 0;
            for (y2 = 1, b = 0; b < d; b++) {
              var w2 = o(e, E2 + 3 * b, 3);
              l.itree[1 + (l.ordr[b] << 1)] = w2, w2 > y2 && (y2 = w2);
            }
            E2 += 3 * d, s(l.itree, y2), u2(l.itree, y2, l.imap), d = l.lmap, b = l.dmap, E2 = a2(l.imap, (1 << y2) - 1, p + h, e, E2, l.ttree), y2 = (1 << (w2 = r._copyOut(l.ttree, 0, p, l.ltree))) - 1, p = (1 << (h = r._copyOut(l.ttree, p, h, l.dtree))) - 1, s(l.ltree, w2), u2(l.ltree, w2, d), s(l.dtree, h), u2(l.dtree, h, b);
          }
          for (; ; ) if (E2 += 15 & (h = d[c2(e, E2) & y2]), 0 == (w2 = h >>> 4) >>> 8) t2[m2++] = w2;
          else {
            if (256 == w2) break;
            h = m2 + w2 - 254, 264 < w2 && (h = m2 + ((w2 = l.ldef[w2 - 257]) >>> 3) + o(e, E2, 7 & w2), E2 += 7 & w2), E2 += 15 & (w2 = b[c2(e, E2) & p]);
            var _ = ((w2 = l.ddef[w2 >>> 4]) >>> 4) + i(e, E2, 15 & w2);
            for (E2 += 15 & w2, f && (t2 = v.F._check(t2, m2 + 131072)); m2 < h; ) t2[m2] = t2[m2++ - _], t2[m2] = t2[m2++ - _], t2[m2] = t2[m2++ - _], t2[m2] = t2[m2++ - _];
            m2 = h;
          }
        }
        return t2.length == m2 ? t2 : t2.slice(0, m2);
      }, v.F._check = function(e, t2) {
        var n2 = e.length;
        return t2 <= n2 ? e : ((t2 = new Uint8Array(Math.max(n2 << 1, t2))).set(e, 0), t2);
      }, v.F._decodeTiny = function(e, t2, n2, r, i, o) {
        for (var a2 = v.F._bitsE, s = v.F._get17, u2 = 0; u2 < n2; ) {
          var c2 = e[s(r, i) & t2];
          i += 15 & c2;
          var l = c2 >>> 4;
          if (15 >= l) o[u2] = l, u2++;
          else {
            var f = c2 = 0;
            for (16 == l ? (f = 3 + a2(r, i, 2), i += 2, c2 = o[u2 - 1]) : 17 == l ? (f = 3 + a2(r, i, 3), i += 3) : 18 == l && (f = 11 + a2(r, i, 7), i += 7), l = u2 + f; u2 < l; ) o[u2] = c2, u2++;
          }
        }
        return i;
      }, v.F._copyOut = function(e, t2, n2, r) {
        for (var i = 0, o = 0, a2 = r.length >>> 1; o < n2; ) {
          var s = e[o + t2];
          r[o << 1] = 0, r[1 + (o << 1)] = s, s > i && (i = s), o++;
        }
        for (; o < a2; ) r[o << 1] = 0, r[1 + (o << 1)] = 0, o++;
        return i;
      }, v.F.makeCodes = function(e, t2) {
        var n2, r, i = v.F.U, o = e.length, a2 = i.bl_count;
        for (n2 = 0; n2 <= t2; n2++) a2[n2] = 0;
        for (n2 = 1; n2 < o; n2 += 2) a2[e[n2]]++;
        for (i = i.next_code, n2 = 0, a2[0] = 0, r = 1; r <= t2; r++) n2 = n2 + a2[r - 1] << 1, i[r] = n2;
        for (t2 = 0; t2 < o; t2 += 2) 0 != (a2 = e[t2 + 1]) && (e[t2] = i[a2], i[a2]++);
      }, v.F.codes2map = function(e, t2, n2) {
        for (var r = e.length, i = v.F.U.rev15, o = 0; o < r; o += 2) if (0 != e[o + 1]) {
          var a2 = e[o + 1], s = o >> 1 << 4 | a2, u2 = t2 - a2;
          for (u2 = (a2 = e[o] << u2) + (1 << u2); a2 != u2; ) n2[i[a2] >>> 15 - t2] = s, a2++;
        }
      }, v.F.revCodes = function(e, t2) {
        for (var n2 = v.F.U.rev15, r = 15 - t2, i = 0; i < e.length; i += 2) e[i] = n2[e[i] << t2 - e[i + 1]] >>> r;
      }, v.F._putsE = function(e, t2, n2) {
        n2 <<= 7 & t2, e[t2 >>>= 3] |= n2, e[t2 + 1] |= n2 >>> 8;
      }, v.F._putsF = function(e, t2, n2) {
        n2 <<= 7 & t2, e[t2 >>>= 3] |= n2, e[t2 + 1] |= n2 >>> 8, e[t2 + 2] |= n2 >>> 16;
      }, v.F._bitsE = function(e, t2, n2) {
        return (e[t2 >>> 3] | e[1 + (t2 >>> 3)] << 8) >>> (7 & t2) & (1 << n2) - 1;
      }, v.F._bitsF = function(e, t2, n2) {
        return (e[t2 >>> 3] | e[1 + (t2 >>> 3)] << 8 | e[2 + (t2 >>> 3)] << 16) >>> (7 & t2) & (1 << n2) - 1;
      }, v.F._get17 = function(e, t2) {
        return (e[t2 >>> 3] | e[1 + (t2 >>> 3)] << 8 | e[2 + (t2 >>> 3)] << 16) >>> (7 & t2);
      }, v.F._get25 = function(e, t2) {
        return (e[t2 >>> 3] | e[1 + (t2 >>> 3)] << 8 | e[2 + (t2 >>> 3)] << 16 | e[3 + (t2 >>> 3)] << 24) >>> (7 & t2);
      }, v.F.U = function() {
        var e = Uint16Array, t2 = Uint32Array;
        return { next_code: new e(16), bl_count: new e(16), ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], ldef: new e(32), df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], ddef: new t2(32), flmap: new e(512), fltree: [], fdmap: new e(32), fdtree: [], lmap: new e(32768), ltree: [], ttree: [], dmap: new e(32768), dtree: [], imap: new e(512), itree: [], rev15: new e(32768), lhst: new t2(286), dhst: new t2(30), ihst: new t2(19), lits: new t2(15e3), strt: new e(65536), prev: new e(32768) };
      }(), function() {
        function e(e2, t3, n3) {
          for (; 0 != t3--; ) e2.push(0, n3);
        }
        for (var t2 = v.F.U, n2 = 0; 32768 > n2; n2++) {
          var r = n2;
          r = (4278255360 & (r = (4042322160 & (r = (3435973836 & (r = (2863311530 & r) >>> 1 | (1431655765 & r) << 1)) >>> 2 | (858993459 & r) << 2)) >>> 4 | (252645135 & r) << 4)) >>> 8 | (16711935 & r) << 8, t2.rev15[n2] = (r >>> 16 | r << 16) >>> 17;
        }
        for (n2 = 0; 32 > n2; n2++) t2.ldef[n2] = t2.of0[n2] << 3 | t2.exb[n2], t2.ddef[n2] = t2.df0[n2] << 4 | t2.dxb[n2];
        e(t2.fltree, 144, 8), e(t2.fltree, 112, 9), e(t2.fltree, 24, 7), e(t2.fltree, 8, 8), v.F.makeCodes(t2.fltree, 9), v.F.codes2map(t2.fltree, 9, t2.flmap), v.F.revCodes(t2.fltree, 9), e(t2.fdtree, 32, 5), v.F.makeCodes(t2.fdtree, 5), v.F.codes2map(t2.fdtree, 5, t2.fdmap), v.F.revCodes(t2.fdtree, 5), e(t2.itree, 19, 0), e(t2.ltree, 286, 0), e(t2.dtree, 30, 0), e(t2.ttree, 320, 0);
      }();
      var iD = ["backups", "servers"], jD = ["backups", "servers"], kD = ["group"], nl = v.inflate, ks = v.deflate, ls = function(e) {
        function t2(e2, i, o, a2) {
          W(this, t2);
          var s = r.call(this, a2, "Session");
          return m(n(s), "chatManager", void 0), m(n(s), "joinedChannels", /* @__PURE__ */ new Set()), m(n(s), "msgDedupLru", new tc(void 0, { maxlen: 200 })), m(n(s), "startTime", Date.now()), m(n(s), "seq", U.fromNumber(1, true)), m(n(s), "userJoinOptions", new is(false)), m(n(s), "seqSentStatuses", [false, false]), m(n(s), "dialogueSequenceLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "loggedOut", false), m(n(s), "messageSentTimes", []), m(n(s), "curLoginSockets", [void 0, void 0]), m(n(s), "loginSocketSubs", [{ channels: /* @__PURE__ */ new Map(), receivers: [] }, { channels: /* @__PURE__ */ new Map(), receivers: [] }]), m(n(s), "lastLoginSockets", [new qe(1), new qe(1)]), m(n(s), "dialPendingMsgSubjectMap", /* @__PURE__ */ new Map()), m(n(s), "context", void 0), m(n(s), "connection", void 0), m(n(s), "instanceId", void 0), m(n(s), "registerSocketsFailureListener", function() {
            s.connection.once("socketsFailure", function() {
              s.log("socketsFailure, creating a new connection"), ad(function() {
                return s.connection.removeAllListeners(), s.connection = new Yr(s.context, s.logger, true), s.loginHandler(15e3, true);
              }).pipe(oe(function(e3) {
                return e3.pipe(cd(Zd.getParameter("RECONNECTING_AP_INTERVAL")));
              }), ob(s.connection.apClient.apFinish$)).subscribe(function() {
                s.log("new connection connected");
              });
            }), 0 === s.connection.listenerCount("tokenExpired") && s.connection.on("tokenExpired", function() {
              s.emit("tokenExpired");
            });
          }), s.context = e2, s.connection = i, s.instanceId = o, s.chatManager = new hD(a2), s.log("The instanceId is %s", s.instanceId.toString()), s;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "fetchFileUploadIndexGet", value: function(e2) {
          var n2 = e2.hash, r2 = e2.size;
          if (0 === (e2 = this.getLoginSockets()).length) throw new K("Client is not logged in");
          var i = this.incGetSeq();
          return e2.forEach(function(e3) {
            e3.sendPacket("FileUploadIndexGet", { seq: i, hash: n2, size: r2 });
          }), { ret: Ca.apply(void 0, G(e2.map(function(e3) {
            return e3.fromReceived("FileUploadIndexRet").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))), fin: Ca.apply(void 0, G(e2.map(function(e3) {
            return e3.fromReceived("FileUploadIndexFin").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))), err: Xb.apply(void 0, G(e2.map(function(e3) {
            return e3.fromReceived("FileUploadIndexErr").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The media message upload failure, code %d", e4.code], lg);
            }));
          }))), timeout: t2.genTimeoutError(Lh) };
        } }, { key: "requestFileUploadIndexSet", value: function(e2) {
          var n2 = e2.hash, r2 = e2.unit, i = e2.servers;
          if (0 === (e2 = this.getLoginSockets()).length) throw new K("Client is not logged in");
          var o = this.incGetSeq();
          return e2.forEach(function(e3) {
            e3.sendPacket("FileUploadIndexSet", { seq: o, servers: i, hash: n2, unit: r2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Lh)].concat(G(e2.map(function(e3) {
            return e3.fromReceived("FileUploadIndexErr").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["FileUploadIndexSet failure, code %d", e4.code], lg);
            }));
          })), G(e2.map(function(e3) {
            return e3.fromReceived("FileUploadIndexFin").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestFileDownloadIndexGet", value: function(e2) {
          var n2 = e2.size, r2 = e2.zone, i = e2.unit, o = e2.hash, a2 = this.getLoginSockets();
          if (0 === a2.length) throw new K("Client is not logged in");
          var s = this.incGetSeq();
          return a2.forEach(function(e3) {
            e3.sendPacket("FileDownloadIndexGet", { seq: s, size: n2, zone: r2, unit: i, hash: o });
          }), e2 = Ca.apply(void 0, G(a2.map(function(e3) {
            return e3.fromReceived("FileDownloadIndexRet").pipe(aa(function(e4) {
              return s.eq(e4.seq);
            }));
          }))).pipe(ba(function(e3) {
            var t3 = e3.backups, n3 = e3.servers;
            return e3 = ff(e3, iD), ua({ backupList: t3.map(function(e4) {
              return [e4];
            }), serverList: n3.map(function(e4) {
              return [e4];
            }) }, e3);
          }), cd(500)), a2 = jm(a2.map(function(e3) {
            return e3.fromReceived("FileDownloadIndexRet").pipe(aa(function(e4) {
              return s.eq(e4.seq);
            }));
          })), Ca(e2, a2.pipe(ba(function(e3) {
            return e3.reduce(function(e4, t3) {
              var n3 = e4.backupList, r3 = e4.serverList;
              e4 = t3.backups;
              var i2 = t3.servers;
              return t3 = ff(t3, jD), ua({ backupList: e4.map(function(e5, t4) {
                return [e5].concat(G(void 0 !== n3 && Array.isArray(n3[t4]) ? n3[t4] : []));
              }), serverList: i2.map(function(e5, t4) {
                return [e5].concat(G(void 0 !== n3 && Array.isArray(r3[t4]) ? r3[t4] : []));
              }) }, t3);
            }, {});
          })), t2.genTimeoutError(Lh));
        } }, { key: "loginHandler", value: function() {
          var e2 = this, t3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 2e4, n2 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
          if (this.loggedOut && n2) throw new K("Already logged out, request ignored");
          n2 && this.registerSocketsFailureListener(), this.connection.initConnection();
          var r2 = this.getSocketLoginObservables(this.connection.lastOpenSockets, this.seq), i = Date.now();
          return r2.forEach(function(t4, r3) {
            var o = e2.loginSocketSubs[r3].login;
            void 0 !== o && o.unsubscribe(), e2.loginSocketSubs[r3].login = t4.pipe(ca(function(t5) {
              var o2;
              e2.curLoginSockets[r3] = t5;
              var a2 = Date.now();
              eb("Link", { ackedServerIp: t5.address, destServerIp: t5.ip, ec: 0, sc: 0, elapse: fb(e2.startTime), lts: U.fromNumber(a2), responseTime: i - a2, sid: Xa(e2.instanceId), userId: e2.context.uid }, null !== (o2 = e2.context.config.enableCloudProxy) && void 0 !== o2 && o2), e2.emit("userJoined", t5.env), n2 && e2.connection.apClient.apFinish$.next(void 0);
            })).subscribe(e2.lastLoginSockets[r3]);
          }), this.initKeepAliveSender(), this.initKeepAliveReconnector(), this.initLoginReceiver(), Xb.apply(void 0, G(r2).concat([gb(this.connection, "connectionInitFailure").pipe(ca(function(e3) {
            if (sa(e3) || Sa(e3)) throw e3;
            throw new da("Login failure", { code: Zq, originalError: e3 });
          }))])).pipe(Ka(1), hb(t3), Ga(function(t4) {
            return t4 instanceof pb && e2.warn("Client login timeout"), t4 && t4.code === Kh && (e2.connection.emit("tokenExpired"), e2.connection.apClient.apFinish$.next(void 0)), e2.clearSockets(0, n2), Z(t4);
          }), ca(function() {
            n2 || e2.registerSocketsFailureListener();
          }), wg(function() {
            n2 || e2.connection.apClient.apFinish$.next(void 0);
          }));
        } }, { key: "logoutHandler", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3, n2, r2, i = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  return this.loggedOut = true, this.connection.apClient.apFinish$.next(void 0), t3 = this.getLoginSockets(), n2 = t3.map(function(e5) {
                    return e5.sendPacket("UserQuit", {}), i.connection.waitClosing(e5);
                  }), this.clearSockets(5e3), r2 = t3.map(function(e5) {
                    return e5.env;
                  }), [0, 1].filter(function(e5) {
                    return !r2.includes(e5);
                  }).forEach(function(e5) {
                    i.connection.closeSocket(e5, 0);
                  }), e4.abrupt("return", Xb.apply(void 0, G(n2)).toPromise());
                case 9:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "requestChannelJoin", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2 = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (0 !== this.getLoginSockets().length) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("Client is not logged in. Cannot join the channel", Vq);
                case 2:
                  return r2 = gb(this, "channelLeft").pipe(wb(function(e5) {
                    return e5 === t3;
                  }), Ka(1)), i = this.incGetSeq(), (o = this.lastLoginSockets.map(function(e5) {
                    return e5.pipe(Cc(function(e6, t4) {
                      0 !== t4 && a2.incSeqIfNeeded(e6.env);
                      var r3 = 0 === t4 ? i : a2.seq;
                      return e6.sendPacket("GroupEnter", { account: n2, seq: r3 }), e6.fromReceived("GroupReply").pipe(aa(function(e7) {
                        return r3.eq(e7.seq);
                      }), ca(function(e7) {
                        if (0 !== (e7 = e7.code)) throw new da(["Channel join failure. The response code is %d", e7], Rq);
                      }));
                    }), ob(r2), pe());
                  })).forEach(function(e5, n3) {
                    var r3 = function() {
                      return a2.loginSocketSubs[n3].channels.delete(t3.channelId);
                    };
                    a2.loginSocketSubs[n3].channels.set(t3.channelId, e5.subscribe({ error: r3, complete: r3 }));
                  }), e4.next = 8, Xb.apply(void 0, G(o)).pipe(Ka(1), hb(1e4), Ga(function(e5) {
                    return e5 instanceof pb && a2.warn("Channel join timeout"), Z(e5);
                  })).toPromise();
                case 8:
                  this.joinedChannels.add(t3);
                case 9:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "requestChannelLeave", value: function(e2, t3) {
          this.emit("channelLeft", e2), this.joinedChannels.delete(e2), this.getLoginSockets().forEach(function(e3) {
            e3.sendPacket("GroupLeave", { account: t3 });
          });
        } }, { key: "requestChannelMemberList", value: function(e2) {
          var n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in. Cannot get the channel members", cA);
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("GroupAllUsersList", { group: e2, pageNumber: 0, pageSize: 200, seq: r2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Pq)].concat(G(n2.map(function(t3) {
            return t3.fromReceived("GroupAllUsersResult").pipe(aa(function(t4) {
              var n3 = t4.seq;
              return t4.group === e2 && r2.eq(n3);
            }));
          }))));
        } }, { key: "requestPeersOnlineStatus", value: function(e2) {
          var n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in");
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("UserStatusList", { users: e2, seq: r2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(oA)].concat(G(n2.map(function(e3) {
            return e3.fromReceived("UserStatusResult").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestSetLocalUserAttributes", value: function(e2, n2) {
          var r2 = this, i = this.getLoginSockets();
          if (0 === i.length) throw new K("Client is not logged in");
          var o = this.incGetSeq();
          return i.forEach(function(t3, i2) {
            void 0 !== n2 && i2 !== n2 || t3.sendPacket("UserAttributeSet", { account: r2.context.uid, attributeInfos: Object.entries(e2).map(function(e3) {
              return { key: (e3 = ra(e3, 2))[0], value: e3[1] };
            }), seq: o });
          }), Ca.apply(void 0, G(i.map(function(e3) {
            return e3.fromReceived("UserAttributeErr").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The user attributes set failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(i.map(function(e3) {
            return e3.fromReceived("UserAttributeRsp").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestSetChannelAttributes", value: function(e2, n2, r2) {
          var i = this.getLoginSockets();
          if (0 === i.length) throw new K("Client is not logged in");
          var o = this.incGetSeq();
          return i.forEach(function(t3) {
            t3.sendPacket("GroupAttributeSet", { broadcast: r2, group: e2, attributeInfos: Object.entries(n2).map(function(e3) {
              return { key: (e3 = ra(e3, 2))[0], value: e3[1] };
            }), seq: o });
          }), Ca.apply(void 0, G(i.map(function(e3) {
            return e3.fromReceived("GroupAttributeErr").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The group attributes set failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(i.map(function(e3) {
            return e3.fromReceived("GroupAttributeRsp").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestAddOrUpdateLocalUserAttributes", value: function(e2) {
          var n2 = this, r2 = this.getLoginSockets();
          if (0 === r2.length) throw new K("Client is not logged in");
          var i = this.incGetSeq();
          return r2.forEach(function(t3) {
            t3.sendPacket("UserAttributeMod", { account: n2.context.uid, attributeInfos: Object.entries(e2).map(function(e3) {
              return { key: (e3 = ra(e3, 2))[0], value: e3[1] };
            }), seq: i });
          }), Ca.apply(void 0, G(r2.map(function(e3) {
            return e3.fromReceived("UserAttributeErr").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The user attributes add or update failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(r2.map(function(e3) {
            return e3.fromReceived("UserAttributeRsp").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestAddOrUpdateChannelAttributes", value: function(e2, n2, r2) {
          var i = this.getLoginSockets();
          if (0 === i.length) throw new K("Client is not logged in");
          var o = this.incGetSeq();
          return i.forEach(function(t3) {
            t3.sendPacket("GroupAttributeMod", { broadcast: r2, group: e2, attributeInfos: Object.entries(n2).map(function(e3) {
              return { key: (e3 = ra(e3, 2))[0], value: e3[1] };
            }), seq: o });
          }), Ca.apply(void 0, G(i.map(function(e3) {
            return e3.fromReceived("GroupAttributeErr").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The group attributes add or update failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(i.map(function(e3) {
            return e3.fromReceived("GroupAttributeRsp").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestDeleteLocalUserAttributesByKeys", value: function(e2) {
          var n2 = this, r2 = this.getLoginSockets();
          if (0 === r2.length) throw new K("Client is not logged in");
          var i = this.incGetSeq();
          return r2.forEach(function(t3) {
            t3.sendPacket("UserAttributeDel", { account: n2.context.uid, attributes: e2, seq: i });
          }), Ca.apply(void 0, G(r2.map(function(e3) {
            return e3.fromReceived("UserAttributeErr").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The user attributes delete failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(r2.map(function(e3) {
            return e3.fromReceived("UserAttributeRsp").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestDeleteChannelAttributesByKeys", value: function(e2, n2, r2) {
          var i = this.getLoginSockets();
          if (0 === i.length) throw new K("Client is not logged in");
          var o = this.incGetSeq();
          return i.forEach(function(t3) {
            t3.sendPacket("GroupAttributeDel", { group: e2, broadcast: r2, attributes: n2, seq: o });
          }), Ca.apply(void 0, G(i.map(function(e3) {
            return e3.fromReceived("GroupAttributeErr").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The channel attributes delete failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(i.map(function(e3) {
            return e3.fromReceived("GroupAttributeRsp").pipe(aa(function(e4) {
              return o.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestClearLocalUserAttributes", value: function() {
          var e2 = this, n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in");
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("UserAttributeSet", { account: e2.context.uid, seq: r2, attributeInfos: [] });
          }), Ca.apply(void 0, G(n2.map(function(e3) {
            return e3.fromReceived("UserAttributeErr").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The user attributes clear failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(n2.map(function(e3) {
            return e3.fromReceived("UserAttributeRsp").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestClearChannelAttributes", value: function(e2, n2) {
          var r2 = this.getLoginSockets();
          if (0 === r2.length) throw new K("Client is not logged in");
          var i = this.incGetSeq();
          return r2.forEach(function(t3) {
            t3.sendPacket("GroupAttributeSet", { group: e2, seq: i, attributeInfos: [], broadcast: n2 });
          }), Ca.apply(void 0, G(r2.map(function(e3) {
            return e3.fromReceived("GroupAttributeErr").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The channel attributes clear failure, code %d", e4.code], Sb);
            }));
          })).concat([t2.genTimeoutError(Tb)], G(r2.map(function(e3) {
            return e3.fromReceived("GroupAttributeRsp").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestGetUserAttributesByKeys", value: function(e2, n2) {
          var r2 = this.getLoginSockets();
          if (0 === r2.length) throw new K("Client is not logged in");
          var i = this.incGetSeq();
          return r2.forEach(function(t3) {
            t3.sendPacket("UserAttributeGet", { account: e2, seq: i, attributes: n2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Tb)].concat(G(r2.map(function(e3) {
            return e3.fromReceived("UserAttributeErr").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }), ba(function(e4) {
              if (10008 === (e4 = e4.code)) throw new da("The user requested is not online", Lq);
              throw new Wc(["User attribute operation unknown error code: %d", e4], Sb);
            }));
          })), G(r2.map(function(e3) {
            return e3.fromReceived("UserAttributeRet").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestGetChannelAttributesByKeys", value: function(e2, n2) {
          var r2 = this.getLoginSockets();
          if (0 === r2.length) throw new K("Client is not logged in");
          var i = this.incGetSeq();
          return r2.forEach(function(t3) {
            t3.sendPacket("GroupAttributeGet", { group: e2, seq: i, attributes: n2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Tb)].concat(G(r2.map(function(e3) {
            return e3.fromReceived("GroupAttributeErr").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }), ba(function(e4) {
              throw new da(["The channel attributes get failure, code %d", e4.code], Sb);
            }));
          })), G(r2.map(function(e3) {
            return e3.fromReceived("GroupAttributeRet").pipe(aa(function(e4) {
              return i.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestGetUserAttributeKeys", value: function(e2) {
          var n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in");
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("UserAttributeKeysGet", { account: e2, seq: r2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Tb)].concat(G(n2.map(function(e3) {
            return e3.fromReceived("UserAttributeErr").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }), ba(function(e4) {
              if (10008 === (e4 = e4.code)) throw new da("The user requested is not online", Lq);
              throw new Wc(["User attribute operation unknown error code: %d", e4], Sb);
            }));
          })), G(n2.map(function(e3) {
            return e3.fromReceived("UserAttributeKeysRet").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestGetChannelAttributesKeys", value: function(e2) {
          var n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in");
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("GroupAttributeKeysGet", { group: e2, seq: r2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Tb)].concat(G(n2.map(function(e3) {
            return e3.fromReceived("GroupAttributeErr").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }), ba(function(e4) {
              throw new Wc(["Channel attribute operation unknown error code: %d", e4.code], Sb);
            }));
          })), G(n2.map(function(e3) {
            return e3.fromReceived("GroupAttributeKeysRet").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestGetChannelMemberCount", value: function(e2) {
          var n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in");
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("GroupStatusList", { groups: e2, seq: r2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(Pq)].concat(G(n2.map(function(e3) {
            return e3.fromReceived("GroupStatusResult").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestSubscribePeersOnlineStatus", value: function(e2) {
          var n2 = this.getLoginSockets();
          if (0 === n2.length) throw new K("Client is not logged in");
          var r2 = this.incGetSeq();
          return n2.forEach(function(t3) {
            t3.sendPacket("SubscribeUserStatus", { seq: r2, users: e2 });
          }), Ca.apply(void 0, [t2.genTimeoutError(vA)].concat(G(n2.map(function(e3) {
            return e3.fromReceived("SubscribeResponse").pipe(aa(function(e4) {
              return r2.eq(e4.seq);
            }));
          }))));
        } }, { key: "requestUnsubscribePeersOnlineStatus", value: function(e2) {
          var t3 = this.getLoginSockets();
          if (0 === t3.length) throw new K("Client is not logged in");
          var n2 = this.incGetSeq();
          t3.forEach(function(t4) {
            t4.sendPacket("UnsubscribeUserStatus", { seq: n2, users: e2 });
          });
        } }, { key: "sendInvitationMessage", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s, u2, c2, l, f, h, p, d = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = t3.peerId, r2 = t3.callId, i = t3.extra, o = t3.isAcceptAck, a2 = t3.channelId, s = t3.type, u2 = { callId: r2 }, void 0 === o) {
                    e4.next = 6;
                    break;
                  }
                  if ("CallAccept" === s) {
                    e4.next = 5;
                    break;
                  }
                  throw Error("invalid invitation type");
                case 5:
                  u2.type = o ? "ack" : "request";
                case 6:
                  return u2.channel = a2, ("CallInvite" === s || "CallCancel" === s || "CallReject" === s || "CallAccept" === s && false === o) && void 0 !== i && (u2.extra = i), c2 = Bg(), this.log("The sent invitation body is %o", u2), l = function(e5) {
                    return { MiscMap: {}, sequence: U.fromNumber(1), dialogue: c2, instance: d.instanceId, dst: n2, ms: U.fromNumber(Date.now(), true), options: new ae({ IterationNumber: e5, MessageType: s }).toLong(), payload: new TextEncoder().encode(JSON.stringify(u2)), src: d.context.uid };
                  }, e4.next = 14, Kb(this.sendMessageToRetry(l, true)).pipe(hb(1e4), Ga(function(e5) {
                    return e5 instanceof pb && d.warn("Send invitation timeout"), Z(e5);
                  })).toPromise();
                case 14:
                  return f = e4.sent, h = f.code, p = f.retryTimes, e4.abrupt("return", { hasPeerReceived: 0 === h, hasReSent: 0 !== p });
                case 18:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "sendMediaMessage", value: function() {
          var e2 = J(w.mark(function e3(t3, n2, r2, i, o, a2) {
            var s, u2, c2, l, f, h, p, d, v2, b, g, y2, E2, _, O2, A, k, R2, T2, N2, S2, C, x, L2, P, j, M2, D2, q2, F2 = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (u2 = n2.width, c2 = void 0 === u2 ? 0 : u2, l = n2.height, f = void 0 === l ? 0 : l, h = n2.fileName, p = void 0 === h ? "" : h, d = n2.description, v2 = void 0 === d ? "" : d, b = n2.thumbnail, g = void 0 === b ? new Blob() : b, y2 = n2.thumbnailHeight, E2 = void 0 === y2 ? 0 : y2, _ = n2.thumbnailWidth, O2 = void 0 === _ ? 0 : _, A = n2.size, k = void 0 === A ? 0 : A, R2 = n2.mediaId, T2 = o.enableOfflineMessaging, N2 = o.enableHistoricalMessaging, za(r2)) {
                    e4.next = 4;
                    break;
                  }
                  throw new I("The send message arguments are not valid", i ? $k : hg);
                case 4:
                  if (!(32768 < new Blob([p, g, v2]).size)) {
                    e4.next = 6;
                    break;
                  }
                  throw new I("The size of message overflowed ", i ? ve : Hh);
                case 6:
                  return S2 = this.chatManager.getChatInfo(r2), C = S2.dialogue, x = S2.sequence, L2 = this.instanceId, this.log('A%s media message is sending to %s: "'.concat(L2, "-").concat(C, "#").concat(x, '"'), i ? " peer" : " channel", oa(r2)), m(s = {}, "media_description", v2), m(s, "media_width", c2), m(s, "media_height", f), m(s, "media_thumbnailwidth", O2), m(s, "media_thumbnailheight", E2), m(s, "media_size", k), m(s, "media_id", R2), m(s, "media_filename", p), P = uc(s, function(e5) {
                    return new TextEncoder().encode(e5.toString());
                  }), e4.t0 = Uint8Array, e4.next = 14, Ji(g);
                case 14:
                  return e4.t1 = e4.sent, P.media_thumbnail = new e4.t0(e4.t1), j = i && "IMAGE" === t3 ? "PeerImageMessage" : i && "FILE" === t3 ? "PeerFileMessage" : i || "IMAGE" !== t3 ? "ChannelFileMessage" : "ChannelImageMessage", M2 = function(e5) {
                    return { MiscMap: P, sequence: x, dialogue: C, instance: L2, dst: r2, ms: U.fromNumber(Date.now(), true), options: new ae({ IterationNumber: e5, CompressionMethod: "Uncompressed", MessageType: j, ToCache: T2, ToArchive: N2 }).toLong(), payload: new Uint8Array(), src: F2.context.uid };
                  }, e4.next = 20, Kb(this.sendMessageToRetry(M2, true)).pipe(hb(void 0 === a2 ? 1e4 : a2), Ga(function(e5) {
                    return e5 instanceof pb && F2.warn("Send message timeout"), Z(e5);
                  })).toPromise();
                case 20:
                  if (D2 = e4.sent, 2 !== (q2 = D2.code)) {
                    e4.next = 24;
                    break;
                  }
                  throw new da("The peer does not support this type of message", nA);
                case 24:
                  return e4.abrupt("return", { hasPeerReceived: 0 === q2 });
                case 25:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2, r2, i, o, a2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "sendRawMessage", value: function() {
          var e2 = J(w.mark(function e3(t3, n2, r2, i, o, a2) {
            var s, u2, c2, l, f, h, p, d, v2, b, g = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (s = o.enableOfflineMessaging, u2 = o.enableHistoricalMessaging, za(r2) && t3 instanceof Uint8Array && "string" == typeof n2) {
                    e4.next = 3;
                    break;
                  }
                  throw new I("The send message arguments are not valid", i ? $k : hg);
                case 3:
                  if (!(32768 < t3.byteLength + new Blob([n2]).size)) {
                    e4.next = 5;
                    break;
                  }
                  throw new ib("The message size is over the 32KB limit", i ? ve : Hh);
                case 5:
                  return c2 = !Zd.getParameter("DISABLE_MESSAGE_COMPRESSION") && 128 <= t3.byteLength, l = this.chatManager.getChatInfo(r2), f = l.dialogue, h = l.sequence, p = this.instanceId, this.log('A%s %s raw message is sending to %s: "'.concat(p, "-").concat(f, "#").concat(h, '"'), c2 ? " compressed" : "", i ? "peer" : "channel", oa(r2)), d = function(e5) {
                    return { MiscMap: { description: new TextEncoder().encode(n2) }, sequence: h, dialogue: f, instance: p, dst: r2, ms: U.fromNumber(Date.now(), true), options: new ae({ IterationNumber: e5, CompressionMethod: c2 ? "Zlib" : "Uncompressed", MessageType: i ? "PeerRawMessage" : "ChannelRawMessage", ToCache: s, ToArchive: u2 }).toLong(), payload: c2 ? ks(t3) : t3, src: g.context.uid };
                  }, e4.next = 12, Kb(this.sendMessageToRetry(d, true)).pipe(hb(void 0 === a2 ? 1e4 : a2), Ga(function(e5) {
                    return e5 instanceof pb && g.warn("Send message timeout"), Z(e5);
                  })).toPromise();
                case 12:
                  return v2 = e4.sent, b = v2.code, e4.abrupt("return", { hasPeerReceived: 0 === b });
                case 15:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2, r2, i, o, a2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "sendTextMessage", value: function() {
          var e2 = J(w.mark(function e3(t3, n2, r2, i, o) {
            var a2, s, u2, c2, l, f, h, p, d, v2, b, g = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (a2 = i.enableOfflineMessaging, s = i.enableHistoricalMessaging, za(n2)) {
                    e4.next = 3;
                    break;
                  }
                  throw new I("The send message arguments are not valid", r2 ? $k : hg);
                case 3:
                  if (!(32768 < new Blob([t3]).size)) {
                    e4.next = 5;
                    break;
                  }
                  throw new ib("The message size is over the 32KB limit", r2 ? ve : Hh);
                case 5:
                  return u2 = !Zd.getParameter("DISABLE_MESSAGE_COMPRESSION") && 128 <= new Blob([t3]).size, c2 = this.chatManager.getChatInfo(n2), l = c2.dialogue, f = c2.sequence, h = this.instanceId, this.log('A%s %s message is sending to %s: "'.concat(h, "-").concat(l, "#").concat(f, '"'), u2 ? " compressed" : "", r2 ? "peer" : "channel", oa(n2)), p = new TextEncoder().encode(t3), d = function(e5) {
                    return { MiscMap: {}, sequence: f, dialogue: l, instance: h, dst: n2, ms: U.fromNumber(Date.now(), true), options: new ae({ IterationNumber: e5, CompressionMethod: u2 ? "Zlib" : "Uncompressed", MessageType: r2 ? "PeerTextMessage" : "ChannelTextMessage", ToCache: a2, ToArchive: s }).toLong(), payload: u2 ? ks(p) : p, src: g.context.uid };
                  }, e4.next = 13, Kb(this.sendMessageToRetry(d, true)).pipe(hb(void 0 === o ? 1e4 : o), Ga(function(e5) {
                    return e5 instanceof pb && g.warn("Send message timeout"), Z(e5);
                  })).toPromise();
                case 13:
                  return v2 = e4.sent, b = v2.code, e4.abrupt("return", { hasPeerReceived: 0 === b });
                case 16:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3, n2, r2, i, o) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "cleanLoginSubs", value: function(e2, t3) {
          Object.entries(this.loginSocketSubs[e2]).forEach(function(e3) {
            var n2 = (e3 = ra(e3, 2))[1];
            "channels" === e3[0] && t3 || (Array.isArray(n2) || n2 instanceof Map ? n2.forEach(function(e4) {
              return e4.unsubscribe();
            }) : n2 && n2.unsubscribe());
          }), this.loginSocketSubs[e2] = { channels: t3 ? this.loginSocketSubs[e2].channels : /* @__PURE__ */ new Map(), receivers: [] };
        } }, { key: "sendMessageToRetry", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2, l, f, h = this, p = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (r2 = 2 < p.length && void 0 !== p[2] ? p[2] : 0, this.log("Attempt to send the message ".concat(n2 ? " with retrying, %o" : "without retrying"), { retryTimes: r2 }), 0 !== (i = this.getLoginSockets()).length) {
                    e4.next = 5;
                    break;
                  }
                  throw Error("no logged-in sockets");
                case 5:
                  return o = t3(r2), i.forEach(function(e5) {
                    e5.sendPacket("Message", o);
                  }), a2 = o.dialogue, s = o.sequence, u2 = o.instance, c2 = i.map(function(e5) {
                    return e5.fromReceived("Ack").pipe(wb(function(e6) {
                      return a2.eq(e6.dialogue) && s.eq(e6.sequence) && u2.eq(e6.instance);
                    }));
                  }), e4.prev = 9, e4.next = 12, Xb.apply(void 0, G(c2)).pipe(hb(6e3), Ga(function(e5) {
                    return Sa(e5) && h.warn("Message send timeout, retry times %d", r2), Z(e5);
                  }), Ka(1)).toPromise();
                case 12:
                  return l = e4.sent, f = l.code, this.log("The message has been acked, %o", { code: f }), e4.abrupt("return", { code: f, retryTimes: r2 });
                case 18:
                  if (e4.prev = 18, e4.t0 = e4.catch(9), !(e4.t0 instanceof pb && n2)) {
                    e4.next = 22;
                    break;
                  }
                  return e4.abrupt("return", this.sendMessageToRetry(t3, false, r2 + 1));
                case 22:
                  throw e4.t0;
                case 23:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[9, 18]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "initKeepAliveSender", value: function() {
          var e2 = this;
          this.lastLoginSockets.map(function(t3) {
            return t3.pipe(Cc(function(t4) {
              return Bc(0, 2750).pipe(ca(function() {
                e2.incSeqIfNeeded(t4.env), t4.sendPacket("Ping", { ms: U.fromNumber(Date.now(), true), seq: e2.seq });
              }));
            }));
          }).forEach(function(t3, n2) {
            var r2 = e2.loginSocketSubs[n2].keepAlive;
            void 0 !== r2 && r2.unsubscribe(), e2.loginSocketSubs[n2].keepAlive = t3.subscribe({ error: function() {
            } });
          });
        } }, { key: "initKeepAliveReconnector", value: function() {
          var e2 = this;
          this.lastLoginSockets.map(function(e3) {
            return e3.pipe(Cc(function(e4) {
              var t3, n2 = false, r2 = e4.userJoin$.pipe(ca(function() {
                n2 = true;
              })), i = e4.input$.pipe(ca(function(e5) {
                "Ping" !== Li[e5.uri].slice(0, -3) && (n2 = false);
              }));
              return Xb(Bc(15e3, 1e4).pipe(Pt(e4.receivedPacket), ca(function(r3) {
                r3 = ra(r3, 2), r3 = ra(r3[1], 2)[1], t3 !== r3 || n2 || e4.forceReconnect(), t3 = r3;
              })), r2, i);
            }));
          }).forEach(function(t3, n2) {
            var r2 = e2.loginSocketSubs[n2].keepAliveReconnector;
            void 0 !== r2 && r2.unsubscribe(), e2.loginSocketSubs[n2].keepAliveReconnector = t3.subscribe({ error: function() {
            } });
          });
        } }, { key: "initLoginReceiver", value: function() {
          var e2 = this;
          this.lastLoginSockets.map(function(t3) {
            return t3.pipe(Cc(function(t4) {
              return Xb(gb(t4, "reconnect").pipe(ca(e2.onSocketReconnect(t4))), t4.fromReceived("Message").pipe(ca(e2.onMessage(t4))), t4.fromReceived("GroupEnterNotice").pipe(ca(e2.onGroupEnterNotice())), t4.fromReceived("GroupLeaveNotice").pipe(ca(e2.onGroupLeaveNotice())), t4.fromReceived("GroupCountNotice").pipe(ca(e2.onGroupCountNotice())), t4.fromReceived("GroupAttributeAlt").pipe(ca(e2.onGroupAttributeAlt())), t4.fromReceived("UserJoinNotice").pipe(ca(e2.onUserNotice(S.PeerOnlineState.ONLINE))), t4.fromReceived("UserQuitNotice").pipe(ca(e2.onUserNotice(S.PeerOnlineState.OFFLINE))), t4.fromReceived("UserWaitNotice").pipe(ca(e2.onUserNotice(S.PeerOnlineState.UNREACHABLE)))).pipe(qf(void 0));
            }));
          }).forEach(function(t3, n2) {
            e2.loginSocketSubs[n2].receivers.push(t3.subscribe({ error: function() {
            } }));
          });
        } }, { key: "requestSocketLogin", value: function(e2, t3, n2) {
          var r2 = this;
          return im(ad(function() {
            r2.userJoinOptions = new is(t3), e2.sendPacket("UserJoin", { account: r2.context.uid, instance: r2.instanceId, opt: r2.userJoinOptions.toLong(), seq: n2, ticket: e2.ticket });
          }), e2.fromReceived("UserResp").pipe(aa(function(e3) {
            return n2.eq(e3.seq);
          }), ca(function(t4) {
            if (0 !== (t4 = t4.code)) throw r2.clearSockets(), r2.logError("Connected to gateway success but the Rtm server rejected login"), new da(["Login failure. The response code from the RTM service is %d", t4], jg);
            r2.log("ENV_%d logged in", e2.env);
          }), qf(e2), hb(15e3))).pipe(wb(function(e3) {
            return void 0 !== e3;
          }), Ga(function(e3) {
            return e3 instanceof pb && r2.warn("Login response timeout, rejoin: %s", t3), Z(e3);
          }));
        } }, { key: "getSocketLoginObservables", value: function(e2, t3) {
          var n2 = this;
          return e2.map(function(e3) {
            return e3.pipe(ca(function(e4) {
              0 === e4.listenerCount("socketUserDrop") && e4.on("socketUserDrop", function(t4) {
                return n2.onUserDrop(t4, e4);
              });
            }), Cc(function(e4, r2) {
              return n2.incSeqIfNeeded(e4.env), n2.requestSocketLogin(e4, 0 !== r2, 0 === r2 ? t3 : n2.seq);
            }), pe());
          });
        } }, { key: "incSeqIfNeeded", value: function(e2) {
          if (![0, 1].includes(e2)) throw new Fa({ INVALID_ENV: "The env argument is not 0 or 1" });
          this.seqSentStatuses[e2] && (this.seq = this.seq.add(1), this.seqSentStatuses = [false, false]), this.seqSentStatuses[e2] = true;
        } }, { key: "incGetSeq", value: function() {
          return this.seq = this.seq.add(1), this.seqSentStatuses = [true, true], this.seq;
        } }, { key: "getLoginSockets", value: function() {
          for (var e2 = this.curLoginSockets, t3 = -1, n2 = null == e2 ? 0 : e2.length, r2 = 0, i = []; ++t3 < n2; ) {
            var o = e2[t3];
            o && (i[r2++] = o);
          }
          return i;
        } }, { key: "emitMessage", value: function(e2, n2) {
          var r2 = e2.options, i = e2.payload, o = e2.src, a2 = e2.dst, s = e2.instance, u2 = e2.dialogue, c2 = e2.sequence, l = e2.ms, f = e2.MiscMap;
          this.dialogueSequenceLru.set(u2.toString(), c2), s = "".concat(s, "-").concat(u2, "#").concat(c2), this.msgDedupLru.has(s) ? this.warn("Env_%d: Messages out-of-order or not start with 1: %s", n2, s) : (this.msgDedupLru.set(s, void 0), n2 = new ae(r2), this.lastLoginSockets.forEach(function() {
            var n3 = J(w.mark(function n4(r3) {
              var i2;
              return w.wrap(function(n5) {
                for (; ; ) switch (n5.prev = n5.next) {
                  case 0:
                    return n5.next = 2, r3.pipe(Ka(1)).toPromise();
                  case 2:
                    i2 = n5.sent, t2.sendMessageAck(e2, i2);
                  case 4:
                  case "end":
                    return n5.stop();
                }
              }, n4);
            }));
            return function(e3) {
              return n3.apply(this, arguments);
            };
          }()), r2 = n2.isZlibCompressed(), n2.isInvitation() ? (a2 = pa(r2 ? nl(Xm(i, Uint8Array.of(0, 0, 0, 0))) : i), a2 = JSON.parse(a2), this.log("The received invitation body is %o", a2), this.emit("invitationMessage", { body: a2, type: n2.getInvitationType(), peerId: o, serverReceivedTs: l.toNumber() })) : n2.isTextMessage() ? (f = n2.isPeerTextMessage(), i = pa(r2 ? nl(Xm(i, Uint8Array.of(0, 0, 0, 0))) : i), this.info("Received a %s %s text message from %s to %s, %s", r2 ? " compressed" : "", f ? "peer" : "channel", oa(o), oa(a2), s), f ? (o = { text: i, peerId: o, properties: { serverReceivedTs: l.toNumber(), isOfflineMessage: n2.isFromCache() } }, this.emit("peerTextMessage", o)) : this.emit("channelTextMessage", { channelId: a2, memberId: o, text: i, properties: { serverReceivedTs: l.toNumber(), isOfflineMessage: false } })) : n2.isRawMessage() ? (u2 = n2.isRawPeerMessage(), f = void 0 === (f = f.description) ? "" : pa(f), i = r2 ? nl(i) : i, this.info("Received a %s %s raw message from %s to %s, %s", r2 ? " compressed" : "", u2 ? "peer" : "channel", oa(o), oa(a2), s), u2 ? (o = { desc: f, raw: i, peerId: o, properties: { serverReceivedTs: l.toNumber(), isOfflineMessage: n2.isFromCache() } }, this.emit("peerRawMessage", o)) : this.emit("channelRawMessage", { desc: f, raw: i, channelId: a2, memberId: o, properties: { serverReceivedTs: l.toNumber(), isOfflineMessage: false } })) : (n2.isImageMessage() || n2.isFileMessage()) && (i = n2.isPeerMessage(), this.info("Received a %s media message from %s to %s, %s", i ? "peer" : "channel", oa(o), oa(a2), s), i ? this.emit("peerMediaMessage", { messageType: n2.isImageMessage() ? "IMAGE" : "FILE", details: f, peerId: o, properties: { serverReceivedTs: l.toNumber(), isOfflineMessage: n2.isFromCache() } }) : this.emit("channelMediaMessage", { messageType: n2.isImageMessage() ? "IMAGE" : "FILE", details: f, memberId: o, channelId: a2, properties: { serverReceivedTs: l.toNumber(), isOfflineMessage: n2.isFromCache() } })));
        } }, { key: "onSocketReconnect", value: function(e2) {
          var t3 = this;
          return function() {
            var n2 = [0, 1].filter(function(t4) {
              return t4 !== e2.env;
            })[0];
            (n2 = t3.connection.curOpenSockets[n2]) && !n2.loggedIn && t3.emit("connectionLost");
          };
        } }, { key: "onUserDrop", value: function(e2, t3) {
          var n2;
          e2 = e2.code, eb("KickedOff", { code: 0, elapse: fb(this.startTime), linkId: parseInt(t3.name.split("-")[1], 10), lts: U.fromNumber(Date.now()), server: t3.address, serverCode: e2, sid: Xa(this.instanceId), userId: this.context.uid }, null !== (n2 = this.context.config.enableCloudProxy) && void 0 !== n2 && n2), 10006 === e2 || 10001 === e2 ? this.warn("Login too often and kicked off, reconnect and login") : 10009 === e2 ? (this.warn("The instance ID conflicts, reconnecting"), this.instanceId = Bg(), this.context.sid = Xa(this.instanceId), this.emit("instanceChanged", this.instanceId)) : [11, 14, 15, 16].includes(e2) && (this.emit("userDrop", e2), this.clearSockets());
        } }, { key: "clearSockets", value: function() {
          var e2 = this, t3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0, n2 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
          [0, 1].forEach(function(r2) {
            e2.cleanLoginSubs(r2, n2), e2.connection.closeSocket(r2, t3);
          });
        } }, { key: "onMessage", value: function(e2) {
          var t3 = this;
          return function(n2) {
            var r2 = n2.dialogue, i = n2.instance, o = n2.sequence, a2 = n2.options;
            if (n2.src === t3.context.uid) t3.log("The message is from the local account, ignored");
            else {
              var s = r2.toString(), u2 = t3.dialPendingMsgSubjectMap.get(s);
              if (r2 = "".concat(i, "-").concat(r2, "#").concat(o), u2) u2.next(n2), t3.log("Env_%d: The dialogue has pending messages, next: %s", e2.env, r2);
              else {
                var c2 = t3.dialogueSequenceLru.get(s);
                if (u2 = !c2 && o.eq(1), i = void 0 !== c2 && o.sub(c2).eq(1), u2 || i) t3.emitMessage(n2, e2.env);
                else {
                  if (c2) {
                    if (o.lte(c2)) return;
                    t3.log("Env_%d: The message pended, the sequence is not continuous with the last: %s", e2.env, r2);
                  } else t3.log("Env_%d: The message pended, the first sequence is not equal to 1: %s", e2.env, r2);
                  o = new Pa(), t3.dialPendingMsgSubjectMap.set(s, o);
                  var l = o.pipe(Qs(Pk), xg(function(e3, t4) {
                    return [].concat(G(e3), [t4]);
                  }, []), ba(function(e3) {
                    return G(e3).sort(function(e4, t4) {
                      return e4 = e4.sequence, t4 = t4.sequence, e4.eq(t4) ? 0 : e4.gt(t4) ? 1 : -1;
                    });
                  }), sm(1));
                  a2 = !(a2 = new ae(a2)).isFromCache() && !a2.isBufferedMessage(), l.pipe(ob(Bc(a2 ? 750 : 1500)), aa(function(e3) {
                    if (2 > e3.length) return false;
                    for (var t4 = void 0 === c2 ? U.fromNumber(1, true) : c2.add(1), n3 = 0; n3 < e3.length; t4 = t4.add(1), n3++) if (!e3[n3].sequence.eq(t4)) return false;
                    return true;
                  }), wg(function() {
                    t3.dialPendingMsgSubjectMap.delete(s);
                  })).subscribe(function(n3) {
                    n3.forEach(function(n4) {
                      t3.emitMessage(n4, e2.env), t3.log("Env_%d: The message queue has fully ordered, emitting: %s", e2.env, "".concat(n4.instance, "-").concat(n4.dialogue, "#").concat(n4.sequence));
                    });
                  }, function(n3) {
                    n3 instanceof vg && l.pipe(Ka(1)).subscribe(function(n4) {
                      return n4.forEach(function(n5) {
                        t3.log("Env_%d: The message pending queue expired, emitting: %s", e2.env, "".concat(n5.instance, "-").concat(n5.dialogue, "#").concat(n5.sequence)), t3.emitMessage(n5, e2.env);
                      });
                    });
                  }), o.next(n2);
                }
              }
            }
          };
        } }, { key: "onGroupEnterNotice", value: function() {
          var e2 = this;
          return function(t3) {
            e2.emit("memberNotice", { channelId: t3.group, seq: t3.seq, instance: t3.instance, memberId: t3.user, type: "MemberJoined", size: t3.size });
          };
        } }, { key: "onGroupLeaveNotice", value: function() {
          var e2 = this;
          return function(t3) {
            e2.emit("memberNotice", { channelId: t3.group, seq: t3.seq, instance: t3.instance, memberId: t3.user, type: "MemberLeft", size: t3.size });
          };
        } }, { key: "onGroupCountNotice", value: function() {
          var e2 = this;
          return function(t3) {
            e2.emit("memberNotice", { channelId: t3.group, seq: t3.seq, instance: t3.instance, type: "MemberCountUpdated", size: t3.size });
          };
        } }, { key: "onGroupAttributeAlt", value: function() {
          var e2 = this;
          return function(t3) {
            var n2 = t3.group;
            t3 = ff(t3, kD), e2.emit("channelAttributesUpdated", ua({ channelId: n2 }, t3));
          };
        } }, { key: "onUserNotice", value: function(e2) {
          var t3 = this;
          return function(n2) {
            t3.emit("peerOnlineStatusChanged", { peerId: n2.user, instance: n2.instance, seq: n2.seq, state: e2 });
          };
        } }], [{ key: "sendMessageAck", value: function(e2, t3) {
          var n2 = new ae(e2.options);
          (n2.isInvitation() || n2.isPeerMessage()) && t3.sendPacket("Ack", { code: 0, dialogue: e2.dialogue, instance: e2.instance, sequence: e2.sequence });
        } }]), t2;
      }(tb());
      m(ls, "genTimeoutError", function(e, t2) {
        return bb(void 0).pipe(cd(void 0 === t2 ? 1e4 : t2), ba(function() {
          throw new db(["Request timed out after %ds", void 0 === t2 ? 1e4 : t2], e);
        }));
      });
      var ms, ol, pl = 0, ql = 0;
      Ud.v1 = function(e, t2, n2) {
        n2 = t2 && n2 || 0;
        var r = t2 || [], i = (e = e || {}).node || ms, o = void 0 !== e.clockseq ? e.clockseq : ol;
        if (null == i || null == o) {
          var a2 = Jq();
          null == i && (i = ms = [1 | a2[0], a2[1], a2[2], a2[3], a2[4], a2[5]]), null == o && (o = ol = 16383 & (a2[6] << 8 | a2[7]));
        }
        a2 = void 0 !== e.msecs ? e.msecs : (/* @__PURE__ */ new Date()).getTime();
        var s = void 0 !== e.nsecs ? e.nsecs : ql + 1, u2 = a2 - pl + (s - ql) / 1e4;
        if (0 > u2 && void 0 === e.clockseq && (o = o + 1 & 16383), (0 > u2 || a2 > pl) && void 0 === e.nsecs && (s = 0), 1e4 <= s) throw Error("uuid.v1(): Can't create more than 10M uuids/sec");
        for (pl = a2, ql = s, ol = o, e = (1e4 * (268435455 & (a2 += 122192928e5)) + s) % 4294967296, r[n2++] = e >>> 24 & 255, r[n2++] = e >>> 16 & 255, r[n2++] = e >>> 8 & 255, r[n2++] = 255 & e, e = a2 / 4294967296 * 1e4 & 268435455, r[n2++] = e >>> 8 & 255, r[n2++] = 255 & e, r[n2++] = e >>> 24 & 15 | 16, r[n2++] = e >>> 16 & 255, r[n2++] = o >>> 8 | 128, r[n2++] = 255 & o, o = 0; 6 > o; ++o) r[n2 + o] = i[o];
        return t2 || Kq(r);
      }, Ud.v4 = Ud;
      var rl = Ph(), vd, bf = S.LocalInvitationFailureReason, Ba = S.LocalInvitationState, lD = (vd = function(e) {
        function t2(e2, i, o) {
          W(this, t2);
          var a2 = r.call(this, o, "RtmLocalInvitation", true);
          return m(n(a2), "state", Ba.IDLE), m(n(a2), "localInvitationEnd$", Ca(gb(n(a2), "LocalInvitationAccepted"), gb(n(a2), "LocalInvitationRefused"), gb(n(a2), "LocalInvitationFailure"), gb(n(a2), "LocalInvitationCanceled")).pipe(Ka(1))), m(n(a2), "callId", Ud.v4()), m(n(a2), "_content", ""), m(n(a2), "_channelId", ""), m(n(a2), "_response", ""), m(n(a2), "calleeId", void 0), m(n(a2), "logger", void 0), m(n(a2), "getSession", void 0), a2.calleeId = e2, a2.getSession = i, a2.logger = o, a2;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "channelId", get: function() {
          return this._channelId;
        }, set: function(e2) {
          this.state !== Ba.IDLE ? this.info("set channelId only allow before invitation sent to remote") : (this.log("set channelId for %s", this.callId), this._channelId = e2);
        } }, { key: "content", get: function() {
          return this._content;
        }, set: function(e2) {
          this.log("set content for %s", this.callId), this._content = e2;
        } }, { key: "response", get: function() {
          return this._response;
        }, set: function(e2) {
          throw new I('Cannot set the "response" of the LocalInvitation instance.', xc);
        } }, { key: "send", value: function() {
          var e2, t3 = this;
          if (this.state === Ba.SENT_TO_REMOTE || this.state === Ba.RECEIVED_BY_REMOTE) throw new K("The local invitation send failure. The call invitation has already been sent.", gA);
          if (this.isLocalInvitationEnd()) throw new K("The local invitation send failure. The call invitation has ended.", Ih);
          if (0 < this._channelId.length && !za(this._channelId)) throw new I("Illegal invitation channel ID", xc);
          if (!za(this.calleeId)) throw new I("Illegal invitation callee user ID", xc);
          if (8192 < Ig(this._content)) throw new I('The length of the "content" overflows. The number of bytes representing content must not exceed 8 Ã 1024 if encoded in UTF-8.', xc);
          this.state = Ba.SENT_TO_REMOTE, ad(J(w.mark(function n2() {
            var r2, i, o;
            return w.wrap(function(n3) {
              for (; ; ) switch (n3.prev = n3.next) {
                case 0:
                  return n3.next = 2, t3.getSession().sendInvitationMessage({ peerId: t3.calleeId, callId: t3.callId, extra: t3._content, type: "CallInvite", channelId: t3._channelId });
                case 2:
                  if (r2 = n3.sent, i = r2.hasPeerReceived, o = r2.hasReSent, !t3.isLocalInvitationEnd()) {
                    n3.next = 7;
                    break;
                  }
                  throw new db("send invitation timeout");
                case 7:
                  if (t3.log("The local invitation has sent to the callee"), i || o) {
                    n3.next = 11;
                    break;
                  }
                  throw e2 = new rl({ PEER_NOT_ONLINE: "The peer of the invitation is not online" });
                case 11:
                  if (i) {
                    n3.next = 14;
                    break;
                  }
                  throw e2 = new rl({ RESENT_AND_OFFLINE: "Resent and the peer of the invitation is not online" });
                case 14:
                case "end":
                  return n3.stop();
              }
            }, n2);
          }))).pipe(oe(function(e3) {
            return e3.pipe(ca(function(e4) {
              if (!(e4 instanceof rl)) throw e4;
            }), cd(2e3));
          }), hb(3e4), Ga(function(e3) {
            return Sa(e3) && t3.warn("local invitation ack timed out"), Z(e3);
          }), ob(this.localInvitationEnd$)).subscribe({ next: function() {
            t3.state === Ba.RECEIVED_BY_REMOTE ? t3.log('The local invitation state is already "RECEIVED_BY_REMOTE", skipped emitting "LocalInvitationReceivedByPeer"') : t3.state !== Ba.SENT_TO_REMOTE ? t3.log("The invitation has ended, skipped emitting the %s event", "LocalInvitationReceivedByPeer") : (t3.info("The peer received the local invitation %s.", t3.callId), t3.state = Ba.RECEIVED_BY_REMOTE, t3.emit("LocalInvitationReceivedByPeer"), t3.localInvitationEnd$.pipe(hb(6e4), Ga(function(e3) {
              return Sa(e3) && t3.warn("local invitation expired"), Z(e3);
            })).subscribe({ error: function() {
              t3.state = Ba.FAILURE, t3.emit("LocalInvitationFailure", bf.INVITATION_EXPIRE);
            } }));
          }, error: function(n2) {
            t3.isLocalInvitationEnd() ? t3.log("The invitation has ended, skipped emitting the %s event", "LocalInvitationFailure") : (t3.state = Ba.FAILURE, Sa(n2) && e2 ? "PEER_NOT_ONLINE" === e2.code ? t3.emit("LocalInvitationFailure", bf.PEER_OFFLINE) : "RESENT_AND_OFFLINE" === e2.code && t3.emit("LocalInvitationFailure", bf.PEER_NO_RESPONSE) : Sa(n2) ? t3.emit("LocalInvitationFailure", bf.PEER_NO_RESPONSE) : "RtmInvalidStatusError" === n2.name ? t3.emit("LocalInvitationFailure", bf.NOT_LOGGEDIN) : t3.emit("LocalInvitationFailure", bf.UNKNOWN));
          } });
        } }, { key: "cancel", value: function() {
          if (this.isLocalInvitationEnd()) throw new K("The local invitation cancel failure", Ih);
          if (this.state === Ba.IDLE) throw new K("The local invitation has not been sent", fA);
          if (8192 < Ig(this._content)) throw new I('The length of the "content" overflows. The number of bytes representing content must not exceed 8 Ã 1024 if encoded in UTF-8.', xc);
          this.getSession().sendInvitationMessage({ callId: this.callId, peerId: this.calleeId, type: "CallCancel", channelId: this._channelId, extra: this._content }), this.state = Ba.CANCELED, this.emit("LocalInvitationCanceled");
        } }, { key: "onAcceptReceived", value: function(e2) {
          if (this.isLocalInvitationEnd() && this.state !== Ba.ACCEPTED_BY_REMOTE) this.log("The invitation has ended, skipped emitting the %s event", "LocalInvitationAccepted");
          else {
            if (this.state === Ba.IDLE) throw new K("the local have not sent the invitation, how can remote accept it?");
            this.getSession().sendInvitationMessage({ callId: this.callId, isAcceptAck: true, type: "CallAccept", peerId: this.calleeId, channelId: this.channelId }), this.state === Ba.ACCEPTED_BY_REMOTE ? this.log("already in ACCEPTED_BY_REMOTE state, ignore emit ACCEPTED_BY_REMOTE") : (this.state === Ba.SENT_TO_REMOTE && (this.log("receive LocalInvitationAccepted before remote response to the invitation"), this.state = Ba.RECEIVED_BY_REMOTE, this.emit("LocalInvitationReceivedByPeer")), this.state = Ba.ACCEPTED_BY_REMOTE, this._response = e2, this.emit("LocalInvitationAccepted", e2));
          }
        } }, { key: "onRefuseReceived", value: function(e2) {
          if (this.isLocalInvitationEnd()) this.log("The invitation has ended, skipped emitting the %s event", "LocalInvitationRefused");
          else {
            if (this.state === Ba.IDLE) throw new K("the local have not sent the invitation, how can remote refuse it?");
            this.state === Ba.SENT_TO_REMOTE && (this.log("receive LocalInvitationRefused before remote response to the invitation"), this.state = Ba.RECEIVED_BY_REMOTE, this.emit("LocalInvitationReceivedByPeer")), this._response = e2, this.state = Ba.REFUSED_BY_REMOTE, this.emit("LocalInvitationRefused", e2);
          }
        } }, { key: "isLocalInvitationEnd", value: function() {
          return [Ba.CANCELED, Ba.FAILURE, Ba.ACCEPTED_BY_REMOTE, Ba.REFUSED_BY_REMOTE].includes(this.state);
        } }]), t2;
      }(tb()), fa(vd.prototype, "send", [Nb], Object.getOwnPropertyDescriptor(vd.prototype, "send"), vd.prototype), fa(vd.prototype, "cancel", [Nb], Object.getOwnPropertyDescriptor(vd.prototype, "cancel"), vd.prototype), vd), Rh = S.RemoteInvitationFailureReason, kb = S.RemoteInvitationState, mD = function(e) {
        function t2(e2) {
          var i = e2.invitationChannel, o = e2.extraContent, a2 = e2.callId, s = e2.callerId, u2 = e2.logger;
          e2 = e2.getSession, W(this, t2);
          var c2 = r.call(this, u2, "RtmRemoteInvitation", true);
          return m(n(c2), "state", kb.INVITATION_RECEIVED), m(n(c2), "remoteInvitationEnd$", Ca(gb(n(c2), "RemoteInvitationCanceled"), gb(n(c2), "RemoteInvitationRefused"), gb(n(c2), "RemoteInvitationAccepted"), gb(n(c2), "RemoteInvitationFailure")).pipe(Ka(1))), m(n(c2), "callerId", void 0), m(n(c2), "callId", void 0), m(n(c2), "_getSession", void 0), m(n(c2), "logger", void 0), m(n(c2), "_content", void 0), m(n(c2), "_channelId", void 0), m(n(c2), "_response", ""), c2._channelId = i, c2._content = o, c2.callId = a2, c2.callerId = s, c2._getSession = e2, c2.logger = u2, c2.remoteInvitationEnd$.pipe(hb(6e4), Ga(function(e3) {
            return Sa(e3) && c2.warn("Remote invitation expired"), Z(e3);
          })).subscribe({ error: function() {
            c2.state = kb.FAILURE, c2.emit("RemoteInvitationFailure", Rh.INVITATION_EXPIRE);
          } }), c2;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "channelId", get: function() {
          return this._channelId;
        }, set: function(e2) {
          throw new I('Cannot set the "response" of the RemoteInvitation instance.', xc);
        } }, { key: "content", get: function() {
          return this._content;
        }, set: function(e2) {
          throw new I('Cannot set the "content" of the RemoteInvitation instance.', xc);
        } }, { key: "response", get: function() {
          return this._response;
        }, set: function(e2) {
          this._response = e2;
        } }, { key: "accept", value: function() {
          var e2, t3 = this;
          if (this.isRemoteInvitationEnd()) throw new K("The local invitation has ended. Cannot accept.", Ih);
          if (this.state === kb.ACCEPT_SENT_TO_LOCAL) throw new K("The remote invitation is accepting. Cannot do the operation.", Qq);
          if (8192 < Ig(this._response)) throw new I('The length of the "response" overflows. The number of bytes representing content must not exceed 8 Ã 1024 if encoded in UTF-8.', xc);
          this.state = kb.ACCEPT_SENT_TO_LOCAL, Xb(mm(1e3).pipe(cb(function() {
            return ad(J(w.mark(function e3() {
              return w.wrap(function(e4) {
                for (; ; ) switch (e4.prev = e4.next) {
                  case 0:
                    return e4.abrupt("return", t3._getSession().sendInvitationMessage({ peerId: t3.callerId, callId: t3.callId, extra: t3.response, type: "CallAccept", isAcceptAck: false, channelId: t3.channelId }));
                  case 1:
                  case "end":
                    return e4.stop();
                }
              }, e3);
            })));
          }), wb(function(t4) {
            return e2 = t4.hasPeerReceived;
          }), Ka(1)), gb(this, "RemoteInvitationAccepted")).pipe(hb(5e3), ob(this.remoteInvitationEnd$)).subscribe({ error: function(n2) {
            if (t3.logError(n2), t3.state = kb.FAILURE, Sa(n2)) switch (e2) {
              case void 0:
              case true:
                return void t3.emit("RemoteInvitationFailure", Rh.ACCEPT_FAILURE);
              case false:
                return void t3.emit("RemoteInvitationFailure", Rh.PEER_OFFLINE);
            }
            t3.emit("RemoteInvitationFailure", Rh.UNKNOWN);
          } });
        } }, { key: "refuse", value: function() {
          if (this.state === kb.ACCEPT_SENT_TO_LOCAL) throw new K("The remote invitation is accepting. Cannot do the operation.", Qq);
          if (this.isRemoteInvitationEnd()) throw new K("The invitation is end. Cannot refuse", Ih);
          if (8192 < Ig(this._response)) throw new I('The length of the "response" overflows. The number of bytes representing content must not exceed 8 Ã 1024 if encoded in UTF-8.', xc);
          this._getSession().sendInvitationMessage({ peerId: this.callerId, callId: this.callId, extra: this.response, type: "CallReject", channelId: this.channelId }), this.state = kb.REFUSED, this.emit("RemoteInvitationRefused");
        } }, { key: "onCancelReceived", value: function(e2) {
          this.isRemoteInvitationEnd() ? this.log("The invitation has ended, skipped emitting the %s event", "RemoteInvitationCanceled") : (this.state === kb.ACCEPT_SENT_TO_LOCAL && this.log("caller canceled before receive accept"), this._content = e2, this.state = kb.CANCELED, this.emit("RemoteInvitationCanceled", e2));
        } }, { key: "onAcceptAckReceived", value: function() {
          this.state !== kb.ACCEPT_SENT_TO_LOCAL ? this.log("The invitation has ended, skipped emitting the %s event", "ori:".concat(this.state, ", to: RemoteInvitationAccepted")) : (this.state = kb.ACCEPTED, this.emit("RemoteInvitationAccepted"));
        } }, { key: "isRemoteInvitationEnd", value: function() {
          return [kb.ACCEPTED, kb.REFUSED, kb.CANCELED, kb.FAILURE].includes(this.state);
        } }]), t2;
      }(tb()), nD = function(e) {
        function t2(e2, i) {
          W(this, t2);
          var o = r.call(this, i, "InvitationManager");
          return m(n(o), "getSession", void 0), m(n(o), "invitationDispatcher", new ea.EventEmitter()), m(n(o), "outgoingLocalInvitations", /* @__PURE__ */ new Map()), m(n(o), "receivedRemoteInvitations", new tc(void 0, { maxlen: 1e4 })), m(n(o), "logger", void 0), o.getSession = cn(e2), o.logger = i, o.invitationDispatcher.on("remoteInvitationToManager", function(e3) {
            var t3 = e3.callId, n2 = e3.extra, r2 = e3.callerId;
            e3 = e3.channelId, o.receivedRemoteInvitations.has(t3) || ((n2 = new mD({ callerId: r2, callId: t3, getSession: o.getSession, logger: i, extraContent: n2, invitationChannel: e3 })).remoteInvitationEnd$.subscribe(function() {
              o.receivedRemoteInvitations.delete(t3);
            }), o.receivedRemoteInvitations.set(t3, n2), o.emit("remoteInvitationInstance", n2));
          }), o.invitationDispatcher.on("acceptAckToRemoteInvitation", function(e3) {
            (e3 = o.receivedRemoteInvitations.get(e3.callId)) && e3.onAcceptAckReceived();
          }), o.invitationDispatcher.on("cancelToRemoteInvitation", function(e3) {
            var t3 = e3.extra;
            (e3 = o.receivedRemoteInvitations.get(e3.callId)) && e3.onCancelReceived(t3);
          }), o.invitationDispatcher.on("acceptToLocalInvitation", function(e3) {
            var t3 = e3.extra;
            (e3 = o.outgoingLocalInvitations.get(e3.callId)) && e3.onAcceptReceived(t3);
          }), o.invitationDispatcher.on("refuseToLocalInvitation", function(e3) {
            var t3 = e3.extra;
            (e3 = o.outgoingLocalInvitations.get(e3.callId)) && e3.onRefuseReceived(t3);
          }), o;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "invitationMessageHandler", value: function(e2) {
          var t3 = e2.body, n2 = t3.callId, r2 = t3.extra;
          r2 = void 0 === r2 ? "" : r2;
          var i = t3.type, o = void 0 === (t3 = t3.channel) ? "" : t3, a2 = e2.type;
          switch (t3 = e2.peerId, e2 = e2.serverReceivedTs, a2) {
            case "CallAccept":
              "ack" === i ? this.invitationDispatcher.emit("acceptAckToRemoteInvitation", { callId: n2 }) : "request" === i && this.invitationDispatcher.emit("acceptToLocalInvitation", { callId: n2, extra: r2 });
              break;
            case "CallInvite":
              this.invitationDispatcher.emit("remoteInvitationToManager", { callId: n2, callerId: t3, extra: r2, channelId: o });
              break;
            case "CallCancel":
              if ("0" === n2) {
                n2 = "".concat("AgoraRTMLegacyEndcallCompatibleMessagePrefix", "_").concat(o, "_").concat(r2), this.getSession().emit("peerTextMessage", { peerId: t3, properties: { serverReceivedTs: e2, isOfflineMessage: false }, text: n2 });
                break;
              }
              this.invitationDispatcher.emit("cancelToRemoteInvitation", { callId: n2, extra: r2 });
              break;
            case "CallReject":
              this.invitationDispatcher.emit("refuseToLocalInvitation", { callId: n2, extra: r2 });
              break;
            default:
              throw Im("invitationType", a2);
          }
        } }, { key: "genLocalInvitation", value: function(e2) {
          var t3 = this, n2 = new lD(e2, this.getSession, this.logger);
          return n2.localInvitationEnd$.subscribe(function() {
            t3.outgoingLocalInvitations.delete(n2.callId);
          }), this.outgoingLocalInvitations.set(n2.callId, n2), n2;
        } }]), t2;
      }(tb()), oD = function(e, t2, n2) {
        var r = true, i = true;
        if ("function" != typeof e) throw new TypeError("Expected a function");
        return lb(n2) && (r = "leading" in n2 ? !!n2.leading : r, i = "trailing" in n2 ? !!n2.trailing : i), qC(e, t2, { leading: r, maxWait: t2, trailing: i });
      }, ub, cf;
      !function(e) {
        e[e.JOINED = 0] = "JOINED", e[e.LEFT = 1] = "LEFT";
      }(cf || (cf = {}));
      var ns = S.ConnectionState, pD = (ub = function(e) {
        function t2(e2, i, o, a2) {
          W(this, t2);
          var s = r.call(this, a2, "RtmChannel", true);
          return m(n(s), "onMemberCountUpdated", oD(function(e3) {
            e3 !== s.memberCount && (s.memberCount = e3, s.emit("MemberCountUpdated", e3));
          }, 1e3)), m(n(s), "getSession", void 0), m(n(s), "memberCount", 0), m(n(s), "memberJoinedLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "memberLeftLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "memberJoinStateLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "attributesSeqLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "channelId", void 0), m(n(s), "client", void 0), m(n(s), "onAttributesUpdated", function(e3) {
            var t3 = e3.channelId, n2 = e3.attributeMaps, r2 = e3.seq;
            e3 = e3.instance.toString();
            var i2 = s.attributesSeqLru.get(e3);
            if ((!i2 || r2.greaterThan(i2)) && (s.attributesSeqLru.set(e3, r2), t3 === s.channelId)) {
              for (t3 = {}, r2 = 0; r2 < n2.length; r2++) {
                var o2 = n2[r2];
                e3 = o2.key, i2 = o2.ms;
                var a3 = o2.value;
                if (o2 = o2.origin, "string" != typeof e3 || !U.isLong(i2) || "string" != typeof a3 || !za(o2)) break;
                t3[e3] = { value: a3, lastUpdateUserId: o2, lastUpdateTs: i2.toNumber() };
              }
              s.emit("AttributesUpdated", t3);
            }
          }), m(n(s), "onChannelTextMessage", function(e3) {
            var t3 = e3.memberId, n2 = e3.text, r2 = e3.properties;
            e3.channelId === s.channelId && s.emit("ChannelMessage", { text: n2, messageType: S.MessageType.TEXT }, t3, r2);
          }), m(n(s), "onChannelMediaMessage", function(e3) {
            var t3 = e3.memberId, n2 = e3.properties, r2 = e3.details, i2 = e3.messageType;
            e3.channelId === s.channelId && ("FILE" === i2 ? s.emit("ChannelMessage", { messageType: S.MessageType.FILE, size: parseInt(pa(r2.media_size), 10), description: pa(r2.media_description), fileName: pa(r2.media_filename), mediaId: pa(r2.media_id), thumbnail: new Blob([r2.media_thumbnail]) }, t3, n2) : "IMAGE" === i2 && s.emit("ChannelMessage", { messageType: S.MessageType.IMAGE, size: parseInt(pa(r2.media_size), 10), description: pa(r2.media_description), fileName: pa(r2.media_filename), mediaId: pa(r2.media_id), thumbnail: new Blob([r2.media_thumbnail]), height: parseInt(pa(r2.media_height), 10), width: parseInt(pa(r2.media_width), 10), thumbnailHeight: parseInt(pa(r2.media_thumbnailheight), 10), thumbnailWidth: parseInt(pa(r2.media_thumbnailwidth), 10) }, t3, n2));
          }), m(n(s), "onChannelRawMessage", function(e3) {
            var t3 = e3.desc, n2 = e3.raw, r2 = e3.memberId, i2 = e3.properties;
            e3.channelId === s.channelId && s.emit("ChannelMessage", { messageType: S.MessageType.RAW, rawMessage: n2, description: t3 }, r2, i2);
          }), m(n(s), "onMemberNotice", function(e3) {
            var t3 = e3.memberId, n2 = e3.type, r2 = e3.size;
            if (e3.channelId === s.channelId) {
              var i2 = e3.instance.toString();
              e3 = e3.seq.toString();
              var o2 = { MemberLeft: s.memberLeftLru, MemberJoined: s.memberJoinedLru, MemberCountUpdated: void 0 }[n2];
              if (o2) {
                if (o2.has(i2 + e3)) return void s.log("received duplicated %s notice (seq: %s), channel '%s', member '%s'", n2, e3, oa(s.channelId), oa(t3 || ""));
                if (o2.set(i2 + e3, void 0), "string" != typeof t3) return;
                if (t3 !== s.getSession().context.uid) {
                  if ((i2 = s.memberJoinStateLru.get(t3)) === cf.JOINED && "MemberJoined" === n2) return void s.log("received duplicated %s state (seq: %s), channel '%s', member '%s'", n2, e3, oa(s.channelId), oa(t3 || ""));
                  if (i2 === cf.LEFT && "MemberLeft" === n2) return void s.log("received duplicated %s state (seq: %s), channel '%s', member '%s'", n2, e3, oa(s.channelId), oa(t3 || ""));
                }
                s.memberJoinStateLru.set(t3, "MemberJoined" === n2 ? cf.JOINED : cf.LEFT);
              }
              s.info("Channel %s - %s, memberId: %s", n2, oa(s.channelId), "MemberCountUpdated" === n2 ? "[unknown]" : oa(t3 || "")), i2 = t3 === s.getSession().context.uid, "MemberLeft" === n2 && za(t3) || "MemberJoined" === n2 && za(t3) ? (i2 || s.emit(n2, t3), s.onMemberCountUpdated(r2)) : "MemberCountUpdated" === n2 && "number" == typeof r2 && s.onMemberCountUpdated(r2);
            }
          }), s.getSession = cn(i), s.channelId = e2, s.client = o, s.info("A channel created, id %s", oa(e2)), s;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "join", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3, n2, r2, i, o, a2, s;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (za(this.channelId)) {
                    e4.next = 2;
                    break;
                  }
                  throw new I(["The %s in the arguments is invalid", "channelId"], hA);
                case 2:
                  e4.prev = 2, t3 = this.getSession(), e4.next = 9;
                  break;
                case 6:
                  throw e4.prev = 6, e4.t0 = e4.catch(2), new K("The client is not logged in. Cannot do the operation", Vq);
                case 9:
                  if (!t3.joinedChannels.has(this)) {
                    e4.next = 12;
                    break;
                  }
                  throw eb("ChnJoin", { cname: this.channelId, lts: U.fromNumber(Date.now()), userId: t3.context.uid, elapse: fb(t3.startTime), errCode: Uq, sid: Xa(t3.instanceId) }, null !== (n2 = this.client.context.config.enableCloudProxy) && void 0 !== n2 && n2), new K("The channel has joined. Cannot rejoin", Uq);
                case 12:
                  if (e4.prev = 12, this.log("Joining the channel %s", oa(this.channelId)), !this.hasOtherChannelJoined()) {
                    e4.next = 17;
                    break;
                  }
                  throw eb("ChnJoin", { cname: this.channelId, lts: U.fromNumber(Date.now()), userId: t3.context.uid, elapse: fb(t3.startTime), errCode: Wq, sid: Xa(t3.instanceId) }, null !== (o = this.client.context.config.enableCloudProxy) && void 0 !== o && o), new K("A channel of the same channel ID has already joined. Cannot rejoin", Wq);
                case 17:
                  if (20 !== t3.joinedChannels.size) {
                    e4.next = 20;
                    break;
                  }
                  throw eb("ChnJoin", { cname: this.channelId, lts: U.fromNumber(Date.now()), userId: t3.context.uid, elapse: fb(t3.startTime), errCode: Tq, sid: Xa(t3.instanceId) }, null !== (a2 = this.client.context.config.enableCloudProxy) && void 0 !== a2 && a2), new ib("The joined channels has exceeded the limit of 20", Tq);
                case 20:
                  return eb("ChnJoin", { cname: this.channelId, lts: U.fromNumber(Date.now()), userId: t3.context.uid, elapse: fb(t3.startTime), errCode: 0, sid: Xa(t3.instanceId) }, null !== (r2 = this.client.context.config.enableCloudProxy) && void 0 !== r2 && r2), e4.next = 23, t3.requestChannelJoin(this, this.channelId);
                case 23:
                  eb("ChnJoinRes", { cname: this.channelId, lts: U.fromNumber(Date.now()), elapse: fb(t3.startTime), errCode: 0, sid: Xa(t3.instanceId), serverErrCode: 0, userId: t3.context.uid }, null !== (i = this.client.context.config.enableCloudProxy) && void 0 !== i && i), this.info("The channel %s joined successfully", oa(this.channelId)), t3.on("channelTextMessage", this.onChannelTextMessage), t3.on("channelRawMessage", this.onChannelRawMessage), t3.on("channelMediaMessage", this.onChannelMediaMessage), t3.on("memberNotice", this.onMemberNotice), t3.on("channelAttributesUpdated", this.onAttributesUpdated), e4.next = 41;
                  break;
                case 32:
                  if (e4.prev = 32, e4.t1 = e4.catch(12), this.logError(e4.t1), !sa(e4.t1)) {
                    e4.next = 37;
                    break;
                  }
                  throw e4.t1;
                case 37:
                  if (!Sa(e4.t1)) {
                    e4.next = 40;
                    break;
                  }
                  throw eb("ChnJoinRes", { cname: this.channelId, lts: U.fromNumber(Date.now()), elapse: fb(t3.startTime), errCode: Sq, sid: Xa(t3.instanceId), serverErrCode: 0, userId: t3.context.uid }, null !== (s = this.client.context.config.enableCloudProxy) && void 0 !== s && s), new db(["Join channel %s timed out", oa(this.channelId)], Sq);
                case 40:
                  throw new Wc(["The channel %s join failure", oa(this.channelId)], { code: Rq, originalError: e4.t1 });
                case 41:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[2, 6], [12, 32]]);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "leave", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3, n2, r2, i;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  e4.prev = 0, n2 = this.getSession(), e4.next = 7;
                  break;
                case 4:
                  throw e4.prev = 4, e4.t0 = e4.catch(0), new K("The client is not logged in. Cannot do the operation", jA);
                case 7:
                  if (n2.joinedChannels.has(this)) {
                    e4.next = 9;
                    break;
                  }
                  throw new K("The channel does not join. Cannot do the operation", iA);
                case 9:
                  e4.prev = 9, n2.requestChannelLeave(this, this.channelId), this.memberLeftLru.empty(), this.memberJoinedLru.empty(), this.attributesSeqLru.empty(), this.memberJoinStateLru.empty(), this.memberCount = 0, n2.removeListener("channelTextMessage", this.onChannelTextMessage), n2.removeListener("channelRawMessage", this.onChannelRawMessage), n2.removeListener("channelMediaMessage", this.onChannelMediaMessage), n2.removeListener("memberNotice", this.onMemberNotice), n2.removeListener("channelAttributesUpdated", this.onAttributesUpdated), e4.next = 32;
                  break;
                case 23:
                  if (e4.prev = 23, e4.t1 = e4.catch(9), this.logError(e4.t1), !sa(e4.t1)) {
                    e4.next = 30;
                    break;
                  }
                  throw void 0 === e4.t1.code && (e4.t1.code = Yq), eb("ChnLeave", { cname: this.channelId, lts: U.fromNumber(Date.now()), elapse: fb(n2.startTime), errCode: Yq, sid: Xa(n2.instanceId), userId: n2.context.uid }, null !== (i = this.client.context.config.enableCloudProxy) && void 0 !== i && i), e4.t1;
                case 30:
                  throw eb("ChnLeave", { cname: this.channelId, lts: U.fromNumber(Date.now()), elapse: fb(n2.startTime), errCode: Xq, sid: Xa(n2.instanceId), userId: n2.context.uid }, null !== (r2 = this.client.context.config.enableCloudProxy) && void 0 !== r2 && r2), new Wc("The channel leave failure", { code: Xq, originalError: e4.t1 });
                case 32:
                  eb("ChnLeave", { cname: this.channelId, lts: U.fromNumber(Date.now()), elapse: fb(n2.startTime), errCode: 0, sid: Xa(n2.instanceId), userId: n2.context.uid }, null !== (t3 = this.client.context.config.enableCloudProxy) && void 0 !== t3 && t3);
                case 33:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[0, 4], [9, 23]]);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "sendMessage", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s = this, u2 = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  n2 = 1 < u2.length && void 0 !== u2[1] ? u2[1] : {}, r2 = n2.enableHistoricalMessaging, i = void 0 !== r2 && r2, Tm(t3, Hh), e4.prev = 2, o = this.getSession(), e4.next = 9;
                  break;
                case 6:
                  throw e4.prev = 6, e4.t0 = e4.catch(2), new K("The client is not logged in. Cannot do the operation", ig);
                case 9:
                  if (o.joinedChannels.has(this)) {
                    e4.next = 11;
                    break;
                  }
                  throw new K("The channel does not join. Cannot do the operation", ig);
                case 11:
                  if (this.client.connectionState !== ns.RECONNECTING) {
                    e4.next = 16;
                    break;
                  }
                  return a2 = Date.now(), e4.next = 15, new Promise(function(e5, n3) {
                    var r3 = function() {
                      var r4 = J(w.mark(function r5() {
                        var u3;
                        return w.wrap(function(r6) {
                          for (; ; ) switch (r6.prev = r6.next) {
                            case 0:
                              return u3 = Date.now() - a2, r6.prev = 1, r6.next = 4, Gg({ message: t3, peerId: s.channelId, toPeer: false, session: s.getSession(), errorCodes: { NOT_LOGGED_IN: ig, TOO_OFTEN: Mq }, diff: u3, logger: s.logger, options: { enableHistoricalMessaging: i, enableOfflineMessaging: false } });
                            case 4:
                              e5(), r6.next = 12;
                              break;
                            case 7:
                              r6.prev = 7, r6.t0 = r6.catch(1), Sa(r6.t0) && n3(new db(Yd(s.name, "sendMessageToPeer", 1e4), Yk)), sa(r6.t0) && n3(r6.t0), n3(new da("Channel message send failure", { code: hg, originalError: r6.t0 }));
                            case 12:
                              return r6.prev = 12, clearTimeout(o2), r6.finish(12);
                            case 15:
                            case "end":
                              return r6.stop();
                          }
                        }, r5, null, [[1, 7, 12, 15]]);
                      }));
                      return function() {
                        return r4.apply(this, arguments);
                      };
                    }();
                    s.client.internalEmitter.once("RECONNECTED", r3);
                    var o2 = setTimeout(function() {
                      s.client.internalEmitter.off("RECONNECTED", r3), n3(new db(Yd(s.name, "sendMessageToPeer", 1e4), Yk));
                    }, 9e3);
                  });
                case 15:
                  return e4.abrupt("return");
                case 16:
                  if (this.client.connectionState === ns.CONNECTED) {
                    e4.next = 18;
                    break;
                  }
                  throw new K("The client is not logged in. Cannot do the operation", ig);
                case 18:
                  return e4.prev = 18, e4.next = 21, Gg({ message: t3, peerId: this.channelId, toPeer: false, session: this.getSession(), errorCodes: { NOT_LOGGED_IN: ig, TOO_OFTEN: Mq }, diff: 0, logger: this.logger, options: { enableHistoricalMessaging: i, enableOfflineMessaging: false } });
                case 21:
                  e4.next = 31;
                  break;
                case 23:
                  if (e4.prev = 23, e4.t1 = e4.catch(18), !Sa(e4.t1)) {
                    e4.next = 27;
                    break;
                  }
                  throw new db(Yd(this.name, "sendMessage", 1e4), Yk);
                case 27:
                  if (!sa(e4.t1)) {
                    e4.next = 30;
                    break;
                  }
                  throw this.logError(e4.t1), e4.t1;
                case 30:
                  throw new Wc("The channel message send failure", hg);
                case 31:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[2, 6], [18, 23]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getMembers", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3, n2, r2;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  e4.prev = 0, e4.prev = 1, t3 = this.getSession(), e4.next = 8;
                  break;
                case 5:
                  throw e4.prev = 5, e4.t0 = e4.catch(1), new K("The client is not logged in. Cannot do the operation", eA);
                case 8:
                  if (t3.joinedChannels.has(this)) {
                    e4.next = 10;
                    break;
                  }
                  throw new K("The channel does not join. Cannot do the operation", dA);
                case 10:
                  return n2 = this.getSession().requestChannelMemberList(this.channelId), e4.next = 13, n2.pipe(ba(function(e5) {
                    return e5.memberInfos.map(function(e6) {
                      return e6.account;
                    });
                  })).toPromise();
                case 13:
                  return r2 = e4.sent, this.info("Channel %s - get members success, %o", oa(this.channelId), r2.map(oa)), e4.abrupt("return", r2);
                case 18:
                  if (e4.prev = 18, e4.t1 = e4.catch(0), !sa(e4.t1)) {
                    e4.next = 23;
                    break;
                  }
                  throw this.logError(e4.t1), e4.t1;
                case 23:
                  throw new Wc("The channel members get failure", bA);
                case 24:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[0, 18], [1, 5]]);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "hasOtherChannelJoined", value: function() {
          var e2 = this;
          return !this.getSession().joinedChannels.has(this) && Array.from(this.getSession().joinedChannels).some(function(t3) {
            return t3.channelId === e2.channelId;
          });
        } }]), t2;
      }(tb()), fa(ub.prototype, "join", [Nb], Object.getOwnPropertyDescriptor(ub.prototype, "join"), ub.prototype), fa(ub.prototype, "leave", [Nb], Object.getOwnPropertyDescriptor(ub.prototype, "leave"), ub.prototype), fa(ub.prototype, "sendMessage", [Nb], Object.getOwnPropertyDescriptor(ub.prototype, "sendMessage"), ub.prototype), fa(ub.prototype, "getMembers", [Ma], Object.getOwnPropertyDescriptor(ub.prototype, "getMembers"), ub.prototype), ub), E, Eb = S.ConnectionChangeReason, T = S.ConnectionState, os = { DISCONNECTED: 1, CONNECTING: 2, CONNECTED: 3, RECONNECTING: 4, ABORTED: 5 }, qD = { LOGIN: 1, LOGIN_SUCCESS: 2, LOGIN_FAILURE: 3, LOGIN_TIMEOUT: 4, INTERRUPTED: 5, LOGOUT: 6, BANNED_BY_SERVER: 7, REMOTE_LOGIN: 8 }, rD = (E = function(e) {
        function t2(e2, i, o, a2) {
          W(this, t2);
          var s = r.call(this, i, "RtmClient", true);
          return m(n(s), "connectionState", T.DISCONNECTED), m(n(s), "internalEmitter", new ea()), m(n(s), "context", void 0), m(n(s), "attributes", {}), m(n(s), "loginPromise", void 0), m(n(s), "attributeDrafts", /* @__PURE__ */ new Set()), m(n(s), "session", void 0), m(n(s), "lastLoginTime", void 0), m(n(s), "reconnId", 0), m(n(s), "channelAttributesCacheLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "invitationManager", void 0), m(n(s), "subscribedPeerStatusCache", {}), m(n(s), "peerStatusSeqLru", new tc(void 0, { maxlen: 1e4 })), m(n(s), "peerUnreachableTimers", {}), m(n(s), "mediaTaskManager", void 0), m(n(s), "setParameters", void 0), m(n(s), "updateConfig", void 0), m(n(s), "userDropHandler", function(e3) {
            if (s.connectionState !== T.ABORTED) switch (e3) {
              case 11:
                s.logError("Kicked off by remote session"), s.onConnectionStateChanged(T.ABORTED, Eb.REMOTE_LOGIN);
                break;
              case 14:
              case 15:
              case 16:
                s.logError("Server banned because of illegal ".concat({ 14: "User ID", 15: "IP", 16: "Channel Name" }[e3])), s.onConnectionStateChanged(T.ABORTED, Eb.BANNED_BY_SERVER);
                break;
              default:
                s.logError("User kicked off for unknown code: ".concat(e3)), s.onConnectionStateChanged(T.ABORTED, Eb.INTERRUPTED);
            }
          }), s.context = new ZC(e2, o, i), s.mediaTaskManager = new fs(i), s.context.config = o, s.internalEmitter.setMaxListeners(512), s.setParameters = a2.bind(n(s)), s.updateConfig = a2.bind(n(s)), s.invitationManager = new nD(function() {
            return s.session;
          }, i), s.invitationManager.on("remoteInvitationInstance", function(e3) {
            s.emit("RemoteInvitationReceived", e3);
          }), s;
        }
        la(t2, e);
        var r = ma(t2);
        return Ha(t2, [{ key: "renewToken", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if ("string" == typeof t3 && 0 !== t3.length) {
                    e4.next = 2;
                    break;
                  }
                  throw new I("Invalid argument", rA);
                case 2:
                  if (this.connectionState !== T.ABORTED) {
                    e4.next = 5;
                    break;
                  }
                  return e4.next = 5, new Promise(function() {
                  });
                case 5:
                  if (this.connectionState === T.CONNECTED || this.connectionState === T.RECONNECTING) {
                    e4.next = 7;
                    break;
                  }
                  throw new K("The client is not logged in", uA);
                case 7:
                  if (void 0 !== this.session) {
                    e4.next = 9;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 9:
                  return e4.prev = 9, n2 = this.context.token, this.context.token = t3, e4.next = 14, this.session.connection.apClient.getApEdgeInfo$(false).pipe(Dd(function() {
                    return Error("No available edge address to connect");
                  }), oe(function(e5) {
                    return e5.pipe(ca(function(e6) {
                      if (sa(e6)) throw e6;
                    }), cd(2500), Ka(4));
                  }), Ka(1), hb(2e4), Ga(function(e5) {
                    return Sa(e5) && o.warn("renewToken timed out"), Z(e5);
                  })).toPromise();
                case 14:
                  r2 = e4.sent, i = r2.ticket, e4.next = 27;
                  break;
                case 18:
                  if (e4.prev = 18, e4.t0 = e4.catch(9), this.context.token = n2, e4.t0.code !== $q && e4.t0.code !== ar) {
                    e4.next = 23;
                    break;
                  }
                  throw new Ye("Invalid token", tA);
                case 23:
                  if (e4.t0.code !== Kh) {
                    e4.next = 25;
                    break;
                  }
                  throw new Ye("The token expired", sA);
                case 25:
                  if (!Sa(e4.t0)) {
                    e4.next = 27;
                    break;
                  }
                  throw new db("Renew token timed out", qA);
                case 27:
                  this.session.curLoginSockets.filter(function(e5) {
                    return void 0 !== e5;
                  }).forEach(function(e5) {
                    return e5.ticket = i;
                  });
                case 28:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[9, 18]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "queryPeersOnlineStatus", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", pA);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  if (!(!Array.isArray(t3) || 0 === t3.length || t3.some(function(e5) {
                    return !za(e5);
                  }) || 256 < t3.length)) {
                    e4.next = 6;
                    break;
                  }
                  throw new I("invalid arguments", er);
                case 6:
                  return e4.next = 8, this.session.requestPeersOnlineStatus(t3).toPromise();
                case 8:
                  return n2 = e4.sent, r2 = uc(Jk(n2.userInfos, "account"), function(e5) {
                    return !!e5.ts;
                  }), Object.keys(r2).forEach(function(e5) {
                    if (e5 in i.subscribedPeerStatusCache && i.subscribedPeerStatusCache[e5] !== S.PeerOnlineState.UNREACHABLE) {
                      var t4 = r2[e5] ? S.PeerOnlineState.ONLINE : S.PeerOnlineState.OFFLINE;
                      i.emit("PeersOnlineStatusChanged", m({}, e5, t4)), i.subscribedPeerStatusCache[e5] = t4;
                    }
                  }), e4.abrupt("return", r2);
                case 12:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getChannelMemberCount", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s, u2, c2 = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", aA);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  if (Array.isArray(t3) && t3.every(function(e5) {
                    return "string" == typeof e5;
                  }) && 0 !== t3.length) {
                    e4.next = 6;
                    break;
                  }
                  throw new I("Invalid arguments: channelIds", Oq);
                case 6:
                  if (!(32 < t3.length)) {
                    e4.next = 8;
                    break;
                  }
                  throw new I("getChannelMemberCount exceed limit of 32 channelIds", $z);
                case 8:
                  n2 = 0;
                case 9:
                  if (!(n2 < t3.length)) {
                    e4.next = 16;
                    break;
                  }
                  if (za(r2 = t3[n2])) {
                    e4.next = 13;
                    break;
                  }
                  throw new I(["getChannelMemberCount channel id %s is invalid", r2], Oq);
                case 13:
                  n2++, e4.next = 9;
                  break;
                case 16:
                  return e4.next = 18, this.session.requestGetChannelMemberCount(t3).toPromise();
                case 18:
                  for (i = e4.sent, o = i.groupInfos, a2 = {}, s = function(e5) {
                    var t4 = (e5 = o[e5]).group, n3 = e5.memberCount;
                    za(t4) && "number" == typeof n3 && (c2.session.joinedChannels.forEach(function(e6) {
                      e6.channelId === t4 && e6.onMemberCountUpdated(n3);
                    }), a2[t4] = n3);
                  }, u2 = 0; u2 < o.length; u2++) s(u2);
                  return e4.abrupt("return", a2);
                case 24:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "setLocalUserAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (uf({ attributes: t3, maxAttrValueSize: 8192, maxAttrsCount: 32, maxTotalSize: 16384 }), this.connectionState === T.CONNECTED) {
                    e4.next = 3;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 3:
                  if (void 0 !== this.session) {
                    e4.next = 5;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 5:
                  return n2 = this.session.requestSetLocalUserAttributes(t3).toPromise(), r2 = { attribute: t3, promise: n2 }, this.attributeDrafts.add(r2), e4.prev = 8, e4.next = 11, n2;
                case 11:
                  this.attributes = t3, e4.next = 19;
                  break;
                case 14:
                  if (e4.prev = 14, e4.t0 = e4.catch(8), !sa(e4.t0)) {
                    e4.next = 18;
                    break;
                  }
                  throw e4.t0;
                case 18:
                  throw new I("arguments is not valid", Ja);
                case 19:
                  return e4.prev = 19, this.attributeDrafts.delete(r2), e4.finish(19);
                case 22:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[8, 14, 19, 22]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "setChannelAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2 = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (r2 = 2 < u2.length && void 0 !== u2[2] ? u2[2] : {}, i = r2.enableNotificationToChannelMembers, o = void 0 !== i && i, uf({ attributes: n2, maxAttrValueSize: 8192, maxAttrsCount: 32, maxTotalSize: 32768 }), this.connectionState === T.CONNECTED) {
                    e4.next = 4;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 4:
                  if (void 0 !== this.session) {
                    e4.next = 6;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 6:
                  return a2 = this.session.requestSetChannelAttributes(t3, n2, o).toPromise(), e4.prev = 7, e4.next = 10, a2;
                case 10:
                  s = uc(n2, function(e5) {
                    return new Blob([e5]).size;
                  }), this.channelAttributesCacheLru.set(t3, s), e4.next = 19;
                  break;
                case 14:
                  if (e4.prev = 14, e4.t0 = e4.catch(7), !sa(e4.t0)) {
                    e4.next = 18;
                    break;
                  }
                  throw e4.t0;
                case 18:
                  throw new I("arguments is not valid", Ja);
                case 19:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[7, 14]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "addOrUpdateLocalUserAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = ua(ua({}, this.attributes), t3), uf({ attributes: t3, maxAttrValueSize: 8192, maxAttrsCount: 32, maxTotalSize: 16384 }), uf({ attributes: n2, maxAttrValueSize: 8192, maxAttrsCount: 32, maxTotalSize: 16384 }), this.connectionState === T.CONNECTED) {
                    e4.next = 5;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 5:
                  if (void 0 !== this.session) {
                    e4.next = 7;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 7:
                  return r2 = this.session.requestAddOrUpdateLocalUserAttributes(t3).toPromise(), i = { attribute: n2, promise: r2 }, this.attributeDrafts.add(i), e4.prev = 10, e4.next = 13, r2;
                case 13:
                  this.attributes = n2, e4.next = 21;
                  break;
                case 16:
                  if (e4.prev = 16, e4.t0 = e4.catch(10), !sa(e4.t0)) {
                    e4.next = 20;
                    break;
                  }
                  throw e4.t0;
                case 20:
                  throw new I("arguments is not valid", er);
                case 21:
                  return e4.prev = 21, this.attributeDrafts.delete(i), e4.finish(21);
                case 24:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[10, 16, 21, 24]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "addOrUpdateChannelAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2, l = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (r2 = 2 < l.length && void 0 !== l[2] ? l[2] : {}, i = r2.enableNotificationToChannelMembers, o = void 0 !== i && i, a2 = this.channelAttributesCacheLru.get(t3, {}), s = uc(n2, function(e5) {
                    return new Blob([e5]).size;
                  }), u2 = ua(ua({}, a2), s), uf({ attributes: n2, attrSizeMap: u2, maxAttrValueSize: 8192, maxAttrsCount: 32, maxTotalSize: 32768 }), this.connectionState === T.CONNECTED) {
                    e4.next = 7;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 7:
                  if (void 0 !== this.session) {
                    e4.next = 9;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 9:
                  return c2 = this.session.requestAddOrUpdateChannelAttributes(t3, n2, o).toPromise(), e4.prev = 10, e4.next = 13, c2;
                case 13:
                  this.channelAttributesCacheLru.set(t3, u2), e4.next = 21;
                  break;
                case 16:
                  if (e4.prev = 16, e4.t0 = e4.catch(10), !sa(e4.t0)) {
                    e4.next = 20;
                    break;
                  }
                  throw e4.t0;
                case 20:
                  throw new I("arguments is not valid", Ja);
                case 21:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[10, 16]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "deleteLocalUserAttributesByKeys", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (Array.isArray(t3) && 0 !== t3.length && !t3.some(function(e5) {
                    return 0 === e5.length;
                  })) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("arguments is not valid", Ja);
                case 2:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 4;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 4:
                  if (void 0 !== this.session) {
                    e4.next = 6;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 6:
                  return n2 = this.session.requestDeleteLocalUserAttributesByKeys(t3).toPromise(), r2 = { attribute: Gk(this.attributes, t3), promise: n2 }, this.attributeDrafts.add(r2), e4.prev = 9, e4.next = 12, n2;
                case 12:
                  for (i = 0; i < t3.length; i++) o = t3[i], delete this.attributes[o];
                  e4.next = 20;
                  break;
                case 15:
                  if (e4.prev = 15, e4.t0 = e4.catch(9), !sa(e4.t0)) {
                    e4.next = 19;
                    break;
                  }
                  throw e4.t0;
                case 19:
                  throw new I("arguments is not valid", Ja);
                case 20:
                  return e4.prev = 20, this.attributeDrafts.delete(r2), e4.finish(20);
                case 23:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[9, 15, 20, 23]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "deleteChannelAttributesByKeys", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2, l = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (r2 = 2 < l.length && void 0 !== l[2] ? l[2] : {}, i = r2.enableNotificationToChannelMembers, o = void 0 !== i && i, Array.isArray(n2) && 0 !== n2.length && za(t3) && !n2.some(function(e5) {
                    return 0 === e5.length || 512 < e5.length;
                  })) {
                    e4.next = 3;
                    break;
                  }
                  throw new K("arguments is not valid", Ja);
                case 3:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 5;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 5:
                  if (void 0 !== this.session) {
                    e4.next = 7;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 7:
                  return a2 = this.session.requestDeleteChannelAttributesByKeys(t3, n2, o).toPromise(), e4.prev = 8, e4.next = 11, a2;
                case 11:
                  if (s = this.channelAttributesCacheLru.get(t3)) for (u2 = 0; u2 < n2.length; u2++) c2 = n2[u2], delete s[c2];
                  e4.next = 20;
                  break;
                case 15:
                  if (e4.prev = 15, e4.t0 = e4.catch(8), !sa(e4.t0)) {
                    e4.next = 19;
                    break;
                  }
                  throw e4.t0;
                case 19:
                  throw new I("arguments is not valid", Ja);
                case 20:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[8, 15]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "clearLocalUserAttributes", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3, n2;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  return t3 = this.session.requestClearLocalUserAttributes().toPromise(), n2 = { attribute: {}, promise: t3 }, this.attributeDrafts.add(n2), e4.prev = 7, e4.next = 10, t3;
                case 10:
                  this.attributes = {}, e4.next = 18;
                  break;
                case 13:
                  if (e4.prev = 13, e4.t0 = e4.catch(7), !sa(e4.t0)) {
                    e4.next = 17;
                    break;
                  }
                  throw e4.t0;
                case 17:
                  throw new I("arguments is not valid", Ja);
                case 18:
                  return e4.prev = 18, this.attributeDrafts.delete(n2), e4.finish(18);
                case 21:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[7, 13, 18, 21]]);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "clearChannelAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2 = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = 1 < a2.length && void 0 !== a2[1] ? a2[1] : {}, r2 = n2.enableNotificationToChannelMembers, i = void 0 !== r2 && r2, this.connectionState === T.CONNECTED) {
                    e4.next = 3;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 3:
                  if (void 0 !== this.session) {
                    e4.next = 5;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 5:
                  return o = this.session.requestClearChannelAttributes(t3, i).toPromise(), e4.prev = 6, e4.next = 9, o;
                case 9:
                  this.channelAttributesCacheLru.delete(t3), e4.next = 17;
                  break;
                case 12:
                  if (e4.prev = 12, e4.t0 = e4.catch(6), !sa(e4.t0)) {
                    e4.next = 16;
                    break;
                  }
                  throw e4.t0;
                case 16:
                  throw new I("arguments is not valid", Ja);
                case 17:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[6, 12]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getUserAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (za(t3)) {
                    e4.next = 2;
                    break;
                  }
                  throw new I("Not a valid user ID", Ja);
                case 2:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 4;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 4:
                  if (void 0 !== this.session) {
                    e4.next = 6;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 6:
                  return e4.prev = 6, e4.next = 9, this.session.requestGetUserAttributeKeys(t3).toPromise();
                case 9:
                  return n2 = e4.sent, r2 = n2.keys, e4.next = 13, this.session.requestGetUserAttributesByKeys(t3, r2.slice(0, 512)).toPromise();
                case 13:
                  i = e4.sent, e4.next = 21;
                  break;
                case 16:
                  if (e4.prev = 16, e4.t0 = e4.catch(6), !sa(e4.t0)) {
                    e4.next = 20;
                    break;
                  }
                  throw e4.t0;
                case 20:
                  throw new I("arguments is not valid", Ja);
                case 21:
                  return e4.abrupt("return", Yp(i.attributeInfos.map(function(e5) {
                    return [e5.key, e5.value];
                  })));
                case 22:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[6, 16]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getChannelAttributes", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s, u2, c2, l, f, h;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (za(t3)) {
                    e4.next = 2;
                    break;
                  }
                  throw new I("Not a valid channel ID", Ja);
                case 2:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 4;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 4:
                  if (void 0 !== this.session) {
                    e4.next = 6;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 6:
                  return e4.prev = 6, e4.next = 9, this.session.requestGetChannelAttributesKeys(t3).toPromise();
                case 9:
                  return n2 = e4.sent, r2 = n2.keys, e4.next = 13, this.session.requestGetChannelAttributesByKeys(t3, r2).toPromise();
                case 13:
                  i = e4.sent, o = i.attributeMaps, e4.next = 22;
                  break;
                case 17:
                  if (e4.prev = 17, e4.t0 = e4.catch(6), !sa(e4.t0)) {
                    e4.next = 21;
                    break;
                  }
                  throw e4.t0;
                case 21:
                  throw new I("arguments is not valid", Ja);
                case 22:
                  a2 = {}, s = 0;
                case 24:
                  if (!(s < o.length)) {
                    e4.next = 32;
                    break;
                  }
                  if (u2 = o[s], c2 = u2.key, l = u2.ms, f = u2.value, h = u2.origin, "string" == typeof c2 && U.isLong(l) && "string" == typeof f && za(h)) {
                    e4.next = 28;
                    break;
                  }
                  return e4.abrupt("break", 32);
                case 28:
                  a2[c2] = { value: f, lastUpdateUserId: h, lastUpdateTs: l.toNumber() };
                case 29:
                  s++, e4.next = 24;
                  break;
                case 32:
                  return this.channelAttributesCacheLru.set(t3, uc(a2, function(e5) {
                    return new Blob([e5.value]).size;
                  })), e4.abrupt("return", a2);
                case 34:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[6, 17]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getChannelAttributesByKeys", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2, l, f, h;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  return Hm(t3, n2), e4.prev = 5, e4.next = 8, this.session.requestGetChannelAttributesByKeys(t3, n2).toPromise();
                case 8:
                  r2 = e4.sent, i = r2.attributeMaps, e4.next = 17;
                  break;
                case 12:
                  if (e4.prev = 12, e4.t0 = e4.catch(5), !sa(e4.t0)) {
                    e4.next = 16;
                    break;
                  }
                  throw e4.t0;
                case 16:
                  throw new I("arguments is not valid", Ja);
                case 17:
                  o = {}, a2 = this.channelAttributesCacheLru.get(t3, {}), s = 0;
                case 20:
                  if (!(s < i.length)) {
                    e4.next = 29;
                    break;
                  }
                  if (u2 = i[s], c2 = u2.key, l = u2.ms, f = u2.value, h = u2.origin, "string" == typeof c2 && U.isLong(l) && "string" == typeof f && za(h)) {
                    e4.next = 24;
                    break;
                  }
                  return e4.abrupt("break", 29);
                case 24:
                  a2[c2] = new Blob([f]).size, o[c2] = { value: f, lastUpdateUserId: h, lastUpdateTs: l.toNumber() };
                case 26:
                  s++, e4.next = 20;
                  break;
                case 29:
                  return this.channelAttributesCacheLru.set(t3, a2), e4.abrupt("return", o);
                case 31:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[5, 12]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "getUserAttributesByKeys", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", Ub);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  return Hm(t3, n2), e4.prev = 5, e4.next = 8, this.session.requestGetUserAttributesByKeys(t3, n2).toPromise();
                case 8:
                  r2 = e4.sent, e4.next = 16;
                  break;
                case 11:
                  if (e4.prev = 11, e4.t0 = e4.catch(5), !sa(e4.t0)) {
                    e4.next = 15;
                    break;
                  }
                  throw e4.t0;
                case 15:
                  throw new I("arguments is not valid", Ja);
                case 16:
                  return e4.abrupt("return", Yp(r2.attributeInfos.map(function(e5) {
                    return [e5.key, e5.value];
                  })));
                case 17:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[5, 11]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "login", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2 = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (Uk = true, n2 = Bg(), r2 = t3.token, t3.token === this.context.appId && (r2 = void 0), setTimeout(function() {
                    var e5;
                    eb("Session", { appId: a2.context.appId, did: navigator.userAgent, elapse: fb(a2.session && a2.session.startTime), index: { index1: t3.uid, index2: a2.context.appId, index3: "enableLogUpload=".concat(a2.context.config.enableLogUpload) }, installId: gg, lts: U.fromNumber(Date.now()), os: 7, sid: Xa(n2), token: r2 || "", userId: t3.uid, ver: "1.4.3-203", buildno: 603, subVersion: 203, version: 4 }, null !== (e5 = a2.context.config.enableCloudProxy) && void 0 !== e5 && e5);
                  }, 1e4), yd(t3) && za(t3.uid)) {
                    e4.next = 7;
                    break;
                  }
                  throw new I("not a valid user id", Jh);
                case 7:
                  if ("string" != typeof r2 || !r2) {
                    e4.next = 11;
                    break;
                  }
                  this.context.token = r2, e4.next = 13;
                  break;
                case 11:
                  if ("string" == typeof r2 || null == r2) {
                    e4.next = 13;
                    break;
                  }
                  throw new I('The "token" is not a valid string.', Jh);
                case 13:
                  return i = Date.now(), this.context.sid = Xa(n2), this.loginPromise = this.loginImpl({ uid: t3.uid, instanceId: n2 }), this.info("RTM Client logging in as ".concat(oa(t3.uid))), e4.prev = 17, e4.next = 20, this.loginPromise;
                case 20:
                  e4.next = 27;
                  break;
                case 22:
                  throw e4.prev = 22, e4.t0 = e4.catch(17), sa(e4.t0) && eb("Link", { ackedServerIp: "", destServerIp: "", ec: e4.t0.code || 1, sc: e4.t0.serverCode, elapse: fb(this.session && this.session.startTime), lts: U.fromNumber(Date.now()), responseTime: Date.now() - i, sid: Xa(n2), userId: t3.uid }, null !== (o = this.context.config.enableCloudProxy) && void 0 !== o && o), this.context.token = void 0, e4.t0;
                case 27:
                  return e4.prev = 27, this.loginPromise = void 0, e4.finish(27);
                case 30:
                  Uk = false;
                case 31:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[17, 22, 27, 30]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "logout", value: function() {
          var e2 = J(w.mark(function e3() {
            var t3;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (!this.loginPromise) {
                    e4.next = 3;
                    break;
                  }
                  return e4.next = 3, this.loginPromise;
                case 3:
                  if (this.connectionState !== T.DISCONNECTED) {
                    e4.next = 6;
                    break;
                  }
                  throw this.logError("Already in logout state"), new K("Logout failure. The client has already been logged out", br);
                case 6:
                  if (this.connectionState !== T.ABORTED) {
                    e4.next = 10;
                    break;
                  }
                  return this.info('Reset connection state from "ABORTED" to "DISCONNECTED"'), this.onConnectionStateChanged(T.DISCONNECTED, Eb.LOGOUT), e4.abrupt("return");
                case 10:
                  if (void 0 !== this.session) {
                    e4.next = 13;
                    break;
                  }
                  return this.onConnectionStateChanged(T.DISCONNECTED, Eb.LOGOUT), e4.abrupt("return");
                case 13:
                  return eb("Logout", { elapse: fb(this.session.startTime), lts: U.fromNumber(Date.now()), sid: Xa(this.session.instanceId), userId: this.context.uid }, null !== (t3 = this.context.config.enableCloudProxy) && void 0 !== t3 && t3), e4.next = 16, this.session.logoutHandler();
                case 16:
                  this.onConnectionStateChanged(T.DISCONNECTED, Eb.LOGOUT), this.log("Log out success");
                case 18:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function() {
            return e2.apply(this, arguments);
          };
        }() }, { key: "logoutSync", value: function() {
          var e2, t3 = this;
          if (this.connectionState === T.DISCONNECTED) throw this.logError("Already in logout state"), new K("Logout failure. The client has already been logged out", br);
          this.connectionState === T.ABORTED ? this.info('Reset connection state from "ABORTED" to "DISCONNECTED"') : void 0 !== this.session && (eb("Logout", { elapse: fb(this.session.startTime), lts: U.fromNumber(Date.now()), sid: Xa(this.session.instanceId), userId: this.context.uid }, null !== (e2 = this.context.config.enableCloudProxy) && void 0 !== e2 && e2), this.session.logoutHandler().then(function() {
            t3.log("Log out success");
          })), this.onConnectionStateChanged(T.DISCONNECTED, Eb.LOGOUT);
        } }, { key: "sendMessageToPeer", value: function() {
          var e2 = J(w.mark(function e3(t3, n2) {
            var r2, i, o, a2, s, u2, c2 = this, l = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (r2 = 2 < l.length && void 0 !== l[2] ? l[2] : {}, i = r2.enableOfflineMessaging, o = void 0 !== i && i, a2 = r2.enableHistoricalMessaging, s = void 0 !== a2 && a2, Tm(t3, ve), this.connectionState !== T.RECONNECTING) {
                    e4.next = 5;
                    break;
                  }
                  return u2 = Date.now(), e4.abrupt("return", new Promise(function(e5, r3) {
                    var i2 = function() {
                      var i3 = J(w.mark(function i4() {
                        var l2;
                        return w.wrap(function(i5) {
                          for (; ; ) switch (i5.prev = i5.next) {
                            case 0:
                              if (void 0 !== c2.session) {
                                i5.next = 2;
                                break;
                              }
                              throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                            case 2:
                              return l2 = Date.now() - u2, i5.prev = 3, i5.t0 = e5, i5.next = 7, Gg({ message: t3, peerId: n2, toPeer: true, session: c2.session, errorCodes: { NOT_LOGGED_IN: al, TOO_OFTEN: dr }, diff: l2, logger: c2.logger, options: { enableHistoricalMessaging: s, enableOfflineMessaging: o } });
                            case 7:
                              i5.t1 = i5.sent, (0, i5.t0)(i5.t1), i5.next = 16;
                              break;
                            case 11:
                              i5.prev = 11, i5.t2 = i5.catch(3), Sa(i5.t2) && r3(new db(Yd(c2.name, "sendMessageToPeer", 1e4), Zk)), sa(i5.t2) && r3(i5.t2), r3(new da("Peer-to-peer message send failure", { code: cr, originalError: i5.t2 }));
                            case 16:
                              return i5.prev = 16, clearTimeout(a3), i5.finish(16);
                            case 19:
                            case "end":
                              return i5.stop();
                          }
                        }, i4, null, [[3, 11, 16, 19]]);
                      }));
                      return function() {
                        return i3.apply(this, arguments);
                      };
                    }();
                    c2.internalEmitter.once("RECONNECTED", i2);
                    var a3 = setTimeout(function() {
                      c2.internalEmitter.off("RECONNECTED", i2), r3(new db(Yd(c2.name, "sendMessageToPeer", 1e4), Zk));
                    }, 9e3);
                  }));
                case 5:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 7;
                    break;
                  }
                  throw new K("Failed to send the peer-to-peer message. The client is not logged in", al);
                case 7:
                  if (void 0 !== this.session) {
                    e4.next = 9;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 9:
                  return e4.prev = 9, e4.next = 12, Gg({ message: t3, peerId: n2, toPeer: true, session: this.session, errorCodes: { NOT_LOGGED_IN: al, TOO_OFTEN: dr }, diff: 0, logger: this.logger, options: { enableHistoricalMessaging: s, enableOfflineMessaging: o } });
                case 12:
                  return e4.abrupt("return", e4.sent);
                case 15:
                  if (e4.prev = 15, e4.t0 = e4.catch(9), !Sa(e4.t0)) {
                    e4.next = 19;
                    break;
                  }
                  throw new db(Yd(this.name, "sendMessageToPeer", 1e4), Zk);
                case 19:
                  if (!sa(e4.t0)) {
                    e4.next = 21;
                    break;
                  }
                  throw e4.t0;
                case 21:
                  throw new da("Peer-to-peer message send failure", { code: cr, originalError: e4.t0 });
                case 22:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[9, 15]]);
          }));
          return function(t3, n2) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "createChannel", value: function(e2) {
          var t3 = this;
          if (!za(e2)) throw new I(["The %s in the arguments is invalid", Object.keys({ channelId: e2 })[0]], Zz);
          return new pD(e2, function() {
            return t3.session;
          }, this, this.logger);
        } }, { key: "createLocalInvitation", value: function(e2) {
          if (!za(e2)) throw new I(["The %s in the arguments is invalid", Object.keys({ calleeId: e2 })[0]], xc);
          return this.invitationManager.genLocalInvitation(e2);
        } }, { key: "subscribePeersOnlineStatus", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s, u2, c2, l, f, h, p, d, v2 = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", bl);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  if (Array.isArray(t3) && 0 !== t3.length) {
                    e4.next = 6;
                    break;
                  }
                  throw new I("Invalid arguments: peerIds", kg);
                case 6:
                  n2 = 0;
                case 7:
                  if (!(n2 < t3.length)) {
                    e4.next = 14;
                    break;
                  }
                  if (za(r2 = t3[n2])) {
                    e4.next = 11;
                    break;
                  }
                  throw new I(["subscribePeersOnlineStatus peer id %s is invalid", r2], kg);
                case 11:
                  n2++, e4.next = 7;
                  break;
                case 14:
                  if (!(512 < (i = t3 && t3.length ? vk(t3) : []).length + Object.keys(this.subscribedPeerStatusCache).length)) {
                    e4.next = 17;
                    break;
                  }
                  throw new ib("Subscribed peers overflows", gr);
                case 17:
                  return e4.next = 19, this.session.requestSubscribePeersOnlineStatus(i).toPromise();
                case 19:
                  o = e4.sent, a2 = o.errors, s = [], u2 = [], c2 = 0;
                case 24:
                  if (!(c2 < a2.length)) {
                    e4.next = 32;
                    break;
                  }
                  if (l = a2[c2], f = l.code, "string" == typeof (h = l.account)) {
                    e4.next = 28;
                    break;
                  }
                  throw new da("Returned account is invalid", fr);
                case 28:
                  0 !== f && s.push(h);
                case 29:
                  c2++, e4.next = 24;
                  break;
                case 32:
                  for (p = 0; p < i.length; p++) d = i[p], s.includes(d) || (u2.push(d), this.subscribedPeerStatusCache[d] = void 0);
                  if (this.session.requestPeersOnlineStatus(u2).pipe(ba(function(e5) {
                    return uc(Jk(e5.userInfos, "account"), function(e6) {
                      return !!e6.ts;
                    });
                  })).subscribe(function(e5) {
                    e5 = uc(e5, function(e6, t4) {
                      return e6 = e6 ? S.PeerOnlineState.ONLINE : S.PeerOnlineState.OFFLINE, v2.subscribedPeerStatusCache[t4] = e6;
                    }), v2.emit("PeersOnlineStatusChanged", e5);
                  }), 0 === s.length) {
                    e4.next = 36;
                    break;
                  }
                  throw new da("Subscription failed", fr);
                case 36:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "unsubscribePeersOnlineStatus", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", bl);
                case 2:
                  if (void 0 !== this.session) {
                    e4.next = 4;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 4:
                  if (Array.isArray(t3) && 0 !== t3.length) {
                    e4.next = 6;
                    break;
                  }
                  throw new I("Invalid arguments: peerIds", kg);
                case 6:
                  n2 = 0;
                case 7:
                  if (!(n2 < t3.length)) {
                    e4.next = 14;
                    break;
                  }
                  if (za(r2 = t3[n2])) {
                    e4.next = 11;
                    break;
                  }
                  throw new I(["subscribePeersOnlineStatus peer id %s is invalid", r2], kg);
                case 11:
                  n2++, e4.next = 7;
                  break;
                case 14:
                  if (!(512 < t3.length)) {
                    e4.next = 16;
                    break;
                  }
                  throw new ib("Unsubscribed peers overflows", gr);
                case 16:
                  for (i = t3 && t3.length ? vk(t3) : [], this.session.requestUnsubscribePeersOnlineStatus(i), o = 0; o < i.length; o++) a2 = i[o], delete this.subscribedPeerStatusCache[a2];
                case 19:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "queryPeersBySubscriptionOption", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 2;
                    break;
                  }
                  throw new K("The client is not logged in", bl);
                case 2:
                  if (t3 !== S.PeerSubscriptionOption.ONLINE_STATUS) {
                    e4.next = 4;
                    break;
                  }
                  return e4.abrupt("return", Object.keys(this.subscribedPeerStatusCache));
                case 4:
                  throw new I("Subscription option not supported", kg);
                case 5:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "createMessage", value: function(e2) {
          return "IMAGE" === e2.messageType ? ua({ width: 0, height: 0, fileName: "", description: "", thumbnail: new Blob(), thumbnailWidth: 0, thumbnailHeight: 0, size: 0 }, e2) : "FILE" === e2.messageType ? ua({ fileName: "", description: "", thumbnail: new Blob(), size: 0 }, e2) : e2;
        } }, { key: "downloadMedia", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s, u2, c2, l, f, h, p, d, v2, b = this, g = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = 1 < g.length && void 0 !== g[1] ? g[1] : {}, "string" == typeof t3) {
                    e4.next = 3;
                    break;
                  }
                  throw new I("invalid mediaId format", cl);
                case 3:
                  if (e4.prev = 3, r2 = t3.split("z"), i = ra(r2, 3), o = i[0], a2 = i[1], s = i[2], u2 = o.slice(1, 65), c2 = bD(u2), l = parseInt(o.slice(65), 10), f = parseInt(a2, 10), h = parseInt(s, 10), !(Number.isNaN(l) || Number.isNaN(f) || Number.isNaN(h))) {
                    e4.next = 12;
                    break;
                  }
                  throw new I("Invalid mediaId content", cl);
                case 12:
                  e4.next = 19;
                  break;
                case 14:
                  if (e4.prev = 14, e4.t0 = e4.catch(3), !sa(e4.t0)) {
                    e4.next = 18;
                    break;
                  }
                  throw e4.t0;
                case 18:
                  throw new I("parse mediaId failure", { code: cl, originalError: e4.t0 });
                case 19:
                  if (this.connectionState === T.CONNECTED) {
                    e4.next = 21;
                    break;
                  }
                  throw new K("The client is not logged in, cannot download", CA);
                case 21:
                  if (void 0 !== this.session) {
                    e4.next = 23;
                    break;
                  }
                  throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                case 23:
                  return p = this.mediaTaskManager.addDownloadTask({ unit: f, zone: l, hashHexStr: u2, size: h }, function() {
                    if (void 0 === b.session) throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                    return b.session.requestFileDownloadIndexGet({ hash: c2, zone: l, unit: f, size: h }).toPromise();
                  }, n2), e4.next = 26, this.mediaTaskManager.waitMediaTask(p);
                case 26:
                  return d = e4.sent, v2 = d.payload, e4.abrupt("return", v2);
                case 29:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[3, 14]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "createMediaMessageByUploading", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2, s, u2, c2, l, f, h, p, d, v2, b, g, y2, m2, E2, _, O2, A, k, R2, N2 = this, S2 = arguments;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = 1 < S2.length && void 0 !== S2[1] ? S2[1] : {}, r2 = 2 < S2.length && void 0 !== S2[2] ? S2[2] : {}, yd(n2)) {
                    e4.next = 4;
                    break;
                  }
                  throw new I("Invalid params", wf);
                case 4:
                  if (i = "thumbnailWidth" in n2 || "thumbnailHeight" in n2 || "width" in n2 || "height" in n2, o = n2.messageType, a2 = void 0 === o ? i ? "IMAGE" : "FILE" : o, s = n2.description, u2 = void 0 === s ? "" : s, c2 = n2.fileName, l = void 0 === c2 ? "" : c2, f = n2.thumbnail, "string" == typeof n2.messageType && "string" == typeof u2 && "string" == typeof l && (Pm(f) || void 0 === f) && Pm(t3)) {
                    e4.next = 8;
                    break;
                  }
                  throw new I("Invalid message params type", wf);
                case 8:
                  if (!i || "FILE" !== a2) {
                    e4.next = 10;
                    break;
                  }
                  throw new I("Invalid message params, unexpected field in RtmFileMessage", wf);
                case 10:
                  if (!(33554432 < (h = t3.size))) {
                    e4.next = 13;
                    break;
                  }
                  throw new ib("The payload size overflow 32 MB", wA);
                case 13:
                  return e4.next = 15, Ji(t3);
                case 15:
                  return p = e4.sent, e4.next = 18, aD(p);
                case 18:
                  if (d = e4.sent, this.connectionState === T.CONNECTED) {
                    e4.next = 21;
                    break;
                  }
                  throw new K("The client is not logged in", yA);
                case 21:
                  if ("IMAGE" !== a2) {
                    e4.next = 29;
                    break;
                  }
                  return e4.next = 24, Xt(n2, p);
                case 24:
                  v2 = e4.sent, b = v2.height, g = v2.width, y2 = v2.thumbnailWidth, m2 = v2.thumbnailHeight;
                case 29:
                  return E2 = this.mediaTaskManager.addUploadTask({ file: new Uint8Array(p), hash: d }, function() {
                    if (void 0 === N2.session) throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                    return N2.session.fetchFileUploadIndexGet({ hash: d, size: h });
                  }, function(e5, t4) {
                    if (void 0 === N2.session) throw new Fa({ SESSION_NOT_FOUND: "Failed to get session of the client" });
                    return N2.session.requestFileUploadIndexSet({ hash: d, unit: e5, servers: t4 }).toPromise();
                  }, r2), e4.next = 32, this.mediaTaskManager.waitMediaTask(E2);
                case 32:
                  if (_ = e4.sent, O2 = _.zone, A = _.retUnit, "IMAGE" !== a2) {
                    e4.next = 38;
                    break;
                  }
                  return k = { height: b, width: g, fileName: l, size: h, description: u2, thumbnail: f, messageType: a2, thumbnailWidth: y2, thumbnailHeight: m2, mediaId: "0".concat($r(d)).concat(O2, "z").concat(A, "z").concat(h, "z").concat(b, "z").concat(g) }, e4.abrupt("return", k);
                case 38:
                  return R2 = { fileName: l, size: h, description: u2, mediaId: "0".concat($r(d)).concat(O2, "z").concat(A, "z").concat(h), thumbnail: f, messageType: a2 }, e4.abrupt("return", R2);
                case 40:
                case "end":
                  return e4.stop();
              }
            }, e3, this);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "loginImpl", value: function() {
          var e2 = J(w.mark(function e3(t3) {
            var n2, r2, i, o, a2 = this;
            return w.wrap(function(e4) {
              for (; ; ) switch (e4.prev = e4.next) {
                case 0:
                  if (n2 = t3.uid, r2 = t3.instanceId, !(void 0 !== this.lastLoginTime && 500 > Date.now() - this.lastLoginTime)) {
                    e4.next = 4;
                    break;
                  }
                  throw new rC(["The frequency of login exceeded the limit of %d queries per second", 2], mA);
                case 4:
                  if (this.connectionState === T.DISCONNECTED) {
                    e4.next = 6;
                    break;
                  }
                  throw new K("The SDK is either logging in or has logged in the Agora RTM system", kA);
                case 6:
                  e4.prev = 6, this.context.uid = n2, e4.next = 13;
                  break;
                case 10:
                  throw e4.prev = 10, e4.t0 = e4.catch(6), new I(["The %s in the arguments is invalid", Object.keys({ uid: n2 })[0]], Jh);
                case 13:
                  return this.onConnectionStateChanged(T.CONNECTING, Eb.LOGIN), this.session = i = new ls(this.context, new Yr(this.context, this.logger, false), r2, this.logger), o = function() {
                    a2.connectionState === T.CONNECTED && (a2.onConnectionStateChanged(T.RECONNECTING, Eb.INTERRUPTED), a2.session) && a2.session.once("userJoined", function() {
                      a2.onConnectionStateChanged(T.CONNECTED, Eb.LOGIN_SUCCESS);
                    });
                  }, i.on("connectionLost", o), i.on("tokenExpired", function() {
                    a2.emit("TokenExpired");
                  }), i.once("userDrop", this.userDropHandler), this.session.on("peerTextMessage", function(e5) {
                    a2.emit("MessageFromPeer", { text: e5.text, messageType: S.MessageType.TEXT }, e5.peerId, e5.properties);
                  }), this.session.on("peerMediaMessage", function(e5) {
                    var t4 = e5.peerId, n3 = e5.properties, r3 = e5.messageType;
                    e5 = e5.details, "FILE" === r3 ? a2.emit("MessageFromPeer", { messageType: S.MessageType.FILE, size: parseInt(pa(e5.media_size), 10), description: pa(e5.media_description), fileName: pa(e5.media_filename), mediaId: pa(e5.media_id), thumbnail: new Blob([e5.media_thumbnail]) }, t4, n3) : "IMAGE" === r3 && a2.emit("MessageFromPeer", { messageType: S.MessageType.IMAGE, size: parseInt(pa(e5.media_size), 10), description: pa(e5.media_description), fileName: pa(e5.media_filename), mediaId: pa(e5.media_id), thumbnail: new Blob([e5.media_thumbnail]), height: parseInt(pa(e5.media_height), 10), width: parseInt(pa(e5.media_width), 10), thumbnailHeight: parseInt(pa(e5.media_thumbnailheight), 10), thumbnailWidth: parseInt(pa(e5.media_thumbnailwidth), 10) }, t4, n3);
                  }), this.session.on("peerRawMessage", function(e5) {
                    a2.emit("MessageFromPeer", { rawMessage: e5.raw, description: e5.desc, messageType: S.MessageType.RAW }, e5.peerId, e5.properties);
                  }), i.on("instanceChanged", function(e5) {
                    return r2 = e5;
                  }), i.on("peerOnlineStatusChanged", function(e5) {
                    var t4 = e5.instance.toString() + e5.state, n3 = a2.peerStatusSeqLru.get(t4);
                    !n3 || e5.seq.greaterThan(n3) ? (a2.peerStatusSeqLru.set(t4, e5.seq), e5.state !== a2.subscribedPeerStatusCache[e5.peerId] && a2.emit("PeersOnlineStatusChanged", m({}, e5.peerId, e5.state)), a2.subscribedPeerStatusCache[e5.peerId] = e5.state, clearTimeout(a2.peerUnreachableTimers[t4]), e5.state === S.PeerOnlineState.UNREACHABLE && (a2.peerUnreachableTimers[t4] = setTimeout(function() {
                      a2.subscribedPeerStatusCache[e5.peerId] === S.PeerOnlineState.UNREACHABLE && (a2.subscribedPeerStatusCache[e5.peerId] = S.PeerOnlineState.ONLINE, a2.emit("PeersOnlineStatusChanged", m({}, e5.peerId, S.PeerOnlineState.ONLINE)));
                    }, 3e4))) : a2.log("peerOnlineStatusChanged dedup for %s, %d", t4, e5.seq.toNumber());
                  }), i.on("invitationMessage", this.invitationManager.invitationMessageHandler.bind(this.invitationManager)), i.on("channelAttributesUpdated", function(e5) {
                    var t4 = e5.channelId;
                    e5 = e5.attributeMaps;
                    for (var n3 = {}, r3 = 0; r3 < e5.length; r3++) {
                      var i2 = e5[r3], o2 = i2.key, s = i2.ms, u2 = i2.value;
                      if (i2 = i2.origin, "string" != typeof o2 || !U.isLong(s) || "string" != typeof u2 || !za(i2)) break;
                      n3[o2] = new Blob([u2]).size;
                    }
                    a2.channelAttributesCacheLru.set(t4, n3);
                  }), i.on("userJoined", function(e5) {
                    if (0 !== Object.keys(a2.attributes).length) {
                      if (void 0 === a2.session) return;
                      a2.session.requestSetLocalUserAttributes(a2.attributes, e5).toPromise();
                    }
                    if (0 !== a2.attributeDrafts.size) for (var t4 = function(t5, n4) {
                      var r4 = (t5 = n4[t5]).attribute;
                      t5.promise.then(function() {
                        void 0 !== a2.session && a2.session.requestSetLocalUserAttributes(r4, e5).toPromise();
                      });
                    }, n3 = 0, r3 = Array.from(a2.attributeDrafts); n3 < r3.length; n3++) t4(n3, r3);
                    0 !== Object.keys(a2.subscribedPeerStatusCache).length && i.requestSubscribePeersOnlineStatus(Object.keys(a2.subscribedPeerStatusCache));
                  }), this.lastLoginTime = Date.now(), e4.prev = 29, e4.next = 32, i.loginHandler().toPromise();
                case 32:
                  this.mediaTaskManager.setAuthInfo({ ticket: i.connection.curOpenSockets.filter(function(e5) {
                    return void 0 !== e5;
                  })[0].ticket, instance: i.instanceId, useNewDomain: 0.5 <= Math.random(), loginOpt: i.userJoinOptions.toLong() }), e4.next = 44;
                  break;
                case 35:
                  if (e4.prev = 35, e4.t1 = e4.catch(29), !Sa(e4.t1)) {
                    e4.next = 40;
                    break;
                  }
                  throw this.onConnectionStateChanged(T.DISCONNECTED, Eb.LOGIN_TIMEOUT), new db(Yd(this.name, "login", 2e4), lA);
                case 40:
                  if (this.onConnectionStateChanged(T.DISCONNECTED, Eb.LOGIN_FAILURE), !sa(e4.t1)) {
                    e4.next = 43;
                    break;
                  }
                  throw e4.t1;
                case 43:
                  throw new da("Login failure", { code: Zq, originalError: e4.t1 });
                case 44:
                  this.onConnectionStateChanged(T.CONNECTED, Eb.LOGIN_SUCCESS);
                case 45:
                case "end":
                  return e4.stop();
              }
            }, e3, this, [[6, 10], [29, 35]]);
          }));
          return function(t3) {
            return e2.apply(this, arguments);
          };
        }() }, { key: "onConnectionStateChanged", value: function(e2, t3) {
          var n2, r2 = this;
          e2 === T.RECONNECTING && (this.reconnId += 1), eb("ConnectionStateChange", { elapse: fb(this.session && this.session.startTime), lts: U.fromNumber(Date.now()), newState: os[e2], oldState: os[this.connectionState], reason: qD[t3], sid: Xa(this.session && this.session.instanceId || U.fromNumber(0)), userId: this.context.uid, reconnId: this.reconnId }, null !== (n2 = this.context.config.enableCloudProxy) && void 0 !== n2 && n2), this.connectionState === T.RECONNECTING && e2 === T.CONNECTED && (0 !== Object.keys(this.subscribedPeerStatusCache).length && void 0 !== this.session && this.session.requestPeersOnlineStatus(Object.keys(this.subscribedPeerStatusCache)).pipe(ba(function(e3) {
            return uc(Jk(e3.userInfos, "account"), function(e4) {
              return !!e4.ts;
            });
          })).subscribe(function(e3) {
            e3 = uc(e3, function(e4, t4) {
              return e4 = e4 ? S.PeerOnlineState.ONLINE : S.PeerOnlineState.OFFLINE, r2.subscribedPeerStatusCache[t4] = e4;
            }), r2.emit("PeersOnlineStatusChanged", e3);
          }), this.internalEmitter.emit("RECONNECTED")), this.connectionState = e2, e2 !== T.ABORTED && e2 !== T.DISCONNECTED || (this.reconnId = 0, this.attributes = {}, this.session && (this.session.removeAllListeners(), this.session.joinedChannels.clear(), this.session.msgDedupLru.empty(), this.session.dialogueSequenceLru.empty(), this.session.dialPendingMsgSubjectMap.clear()), this.session = void 0, this.channelAttributesCacheLru.empty(), this.peerStatusSeqLru.empty(), this.peerUnreachableTimers = {}, this.subscribedPeerStatusCache = {}, this.attributeDrafts.clear(), this.context.token = void 0), this.mediaTaskManager.emit("connectionStateChanged", e2), this.emit("ConnectionStateChanged", e2, t3);
        } }]), t2;
      }(tb()), fa(E.prototype, "renewToken", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "renewToken"), E.prototype), fa(E.prototype, "queryPeersOnlineStatus", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "queryPeersOnlineStatus"), E.prototype), fa(E.prototype, "getChannelMemberCount", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "getChannelMemberCount"), E.prototype), fa(E.prototype, "setLocalUserAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "setLocalUserAttributes"), E.prototype), fa(E.prototype, "setChannelAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "setChannelAttributes"), E.prototype), fa(E.prototype, "addOrUpdateLocalUserAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "addOrUpdateLocalUserAttributes"), E.prototype), fa(E.prototype, "addOrUpdateChannelAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "addOrUpdateChannelAttributes"), E.prototype), fa(E.prototype, "deleteLocalUserAttributesByKeys", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "deleteLocalUserAttributesByKeys"), E.prototype), fa(E.prototype, "deleteChannelAttributesByKeys", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "deleteChannelAttributesByKeys"), E.prototype), fa(E.prototype, "clearLocalUserAttributes", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "clearLocalUserAttributes"), E.prototype), fa(E.prototype, "clearChannelAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "clearChannelAttributes"), E.prototype), fa(E.prototype, "getUserAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "getUserAttributes"), E.prototype), fa(E.prototype, "getChannelAttributes", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "getChannelAttributes"), E.prototype), fa(E.prototype, "getChannelAttributesByKeys", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "getChannelAttributesByKeys"), E.prototype), fa(E.prototype, "getUserAttributesByKeys", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "getUserAttributesByKeys"), E.prototype), fa(E.prototype, "login", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "login"), E.prototype), fa(E.prototype, "logout", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "logout"), E.prototype), fa(E.prototype, "logoutSync", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "logoutSync"), E.prototype), fa(E.prototype, "sendMessageToPeer", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "sendMessageToPeer"), E.prototype), fa(E.prototype, "createChannel", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "createChannel"), E.prototype), fa(E.prototype, "createLocalInvitation", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "createLocalInvitation"), E.prototype), fa(E.prototype, "subscribePeersOnlineStatus", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "subscribePeersOnlineStatus"), E.prototype), fa(E.prototype, "unsubscribePeersOnlineStatus", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "unsubscribePeersOnlineStatus"), E.prototype), fa(E.prototype, "queryPeersBySubscriptionOption", [Ma], Object.getOwnPropertyDescriptor(E.prototype, "queryPeersBySubscriptionOption"), E.prototype), fa(E.prototype, "createMessage", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "createMessage"), E.prototype), fa(E.prototype, "downloadMedia", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "downloadMedia"), E.prototype), fa(E.prototype, "createMediaMessageByUploading", [Nb], Object.getOwnPropertyDescriptor(E.prototype, "createMediaMessageByUploading"), E.prototype), E), ps = { LOG_FILTER_OFF: { error: false, warn: false, info: false, track: false, debug: false }, LOG_FILTER_ERROR: { error: true, warn: false, info: false, track: false, debug: false }, LOG_FILTER_WARNING: { error: true, warn: true, info: false, track: false, debug: false }, LOG_FILTER_INFO: { error: true, warn: true, info: true, track: false, debug: false }, LOG_FILTER_DEBUG: { error: true, warn: true, info: true, track: true, debug: true } }, qs = { enableLogUpload: false, logFilter: ps.LOG_FILTER_INFO, enableCloudProxy: false }, Zd = ua(ua({ createInstance: function(e) {
        var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, n2 = 2 < arguments.length ? arguments[2] : void 0;
        if (!/^[\dA-Za-z]{32}$/.test(e)) throw new I(["The %s in the arguments is invalid", Object.keys({ appId: e })[0]], Nq);
        var r = Object.keys(t2).filter(function(e2) {
          return !(e2 in qs);
        });
        if (0 !== r.length) throw new I("Invalid RTM config: ".concat(r.join(", ")), Nq);
        var i = ua(ua({}, qs), t2);
        if (void 0 !== n2 && (!Array.isArray(n2) || 0 === n2.length)) throw new I("Invalid area config");
        if (null != n2) {
          if (!n2.every(function(e2) {
            return e2 in S.LegacyAreaCode;
          })) throw new I("Invalid area codes: ".concat(n2.filter(function(e2) {
            return !(e2 in S);
          }).join(", ")));
          M = xe(n2.map(function(e2) {
            return zC[e2];
          }));
        }
        n2 = jl = Ya.__global_unique_id__ = (Ya.__global_unique_id__ || 0) + 1;
        var o = DC(i);
        r = EC(i);
        var a2 = FC(i), s = GC(n2, i), u2 = Tr(n2, i), c2 = u2("RTM:DEBUG", "<Entry> ");
        return Mr.rtmConfig = i, o("The Agora RTM Web SDK version is %s", "1.4.3-203"), t2.enableCloudProxy && o("RTM cloud proxy enabled"), t2.enableLogUpload && o("Log upload enabled"), M && c2("Area is set to %s", Array.from(M.CODES).map(function(e2) {
          return xf(F).find(function(t3) {
            return F[t3] === e2;
          });
        }).join(", ")), c2("Creating an RtmClient instance"), c2('The Git commit ID is "'.concat("v1.4.3-17-g1e27aa38", '"')), c2("The App ID is %s", Um(e, 4, 10, "*".repeat(6))), o("The process ID is %s", gg), c2("The build is %s", "v1.4.3-17-g1e27aa38"), c2("NODE_ENV is %s", "production"), new rD(e, { genLogger: u2, genTracker: s, info: o, warn: r, logError: a2, loggerId: n2 }, i, function(e2) {
          for (var t3 = 0, n3 = xf(e2); t3 < n3.length; t3++) {
            var r2 = n3[t3];
            try {
              var a3 = e2[r2];
              null != a3 && (e2.enableCloudProxy && o("RTM cloud proxy enabled"), e2.enableLogUpload && o("Log upload enabled"), i[r2] = a3);
            } catch (e3) {
              throw new I(["The %s in the arguments is invalid", r2], void 0);
            }
          }
        });
      }, BUILD: "v1.4.3-17-g1e27aa38", VERSION: "1.4.3-203", END_CALL_PREFIX: "AgoraRTMLegacyEndcallCompatibleMessagePrefix", processId: gg, ConnectionChangeReason: S.ConnectionChangeReason, ConnectionState: S.ConnectionState, LocalInvitationFailureReason: S.LocalInvitationFailureReason, LocalInvitationState: S.LocalInvitationState, RemoteInvitationFailureReason: S.RemoteInvitationFailureReason, RemoteInvitationState: S.RemoteInvitationState, MessageType: S.MessageType, PeerOnlineState: S.PeerOnlineState, PeerSubscriptionOption: S.PeerSubscriptionOption }, ps), {}, { setParameter: function(e, t2) {
        Object.keys(Nc).includes(e) && (Nc[e] = t2);
      }, getParameter: function(e) {
        return Nc[e];
      }, setArea: function(e) {
        var t2 = e.areaCodes;
        if (e = e.excludedArea, !Array.isArray(t2) || 0 === t2.length || !t2.every(function(e2) {
          return e2 in S.AreaCode;
        })) throw new I("Invalid area config");
        if (void 0 !== e && e === S.AreaCode.GLOBAL) throw new I("Excluded area cannot be global");
        if (void 0 === e) M = xe(t2.map(function(e2) {
          return F[e2];
        }));
        else {
          if (t2.includes(e)) throw new I("Excluded area cannot be in areaCodes");
          if (!(e in F)) throw new I("Invalid excludedArea:", e);
          M = bu({ areas: t2.map(function(e2) {
            return F[e2];
          }), excludedArea: F[e] });
        }
      } });
      return Zd;
    });
  }
});

// node_modules/agora-react-uikit/dist/index.modern.js
var import_react2 = __toESM(require_react());

// node_modules/agora-rtc-react/dist/index.modern.js
var index_modern_exports = {};
__export(index_modern_exports, {
  AgoraRTCErrorCode: () => AgoraRTCErrorCode,
  AgoraVideoPlayer: () => AgoraVideoPlayer,
  createBufferSourceAudioTrack: () => createBufferSourceAudioTrack,
  createCameraVideoTrack: () => createCameraVideoTrack,
  createClient: () => createClient,
  createCustomAudioTrack: () => createCustomAudioTrack,
  createCustomVideoTrack: () => createCustomVideoTrack,
  createMicrophoneAndCameraTracks: () => createMicrophoneAndCameraTracks,
  createMicrophoneAudioTrack: () => createMicrophoneAudioTrack,
  createScreenVideoTrack: () => createScreenVideoTrack,
  default: () => index_modern_default
});
var import_react = __toESM(require_react());
var import_agora_rtc_sdk_ng = __toESM(require_AgoraRTC_N_production());
__reExport(index_modern_exports, __toESM(require_AgoraRTC_N_production()));
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var AgoraRTCErrorCode;
(function(AgoraRTCErrorCode2) {
  AgoraRTCErrorCode2["UNEXPECTED_ERROR"] = "UNEXPECTED_ERROR";
  AgoraRTCErrorCode2["UNEXPECTED_RESPONSE"] = "UNEXPECTED_RESPONSE";
  AgoraRTCErrorCode2["TIMEOUT"] = "TIMEOUT";
  AgoraRTCErrorCode2["INVALID_PARAMS"] = "INVALID_PARAMS";
  AgoraRTCErrorCode2["NOT_SUPPORTED"] = "NOT_SUPPORTED";
  AgoraRTCErrorCode2["INVALID_OPERATION"] = "INVALID_OPERATION";
  AgoraRTCErrorCode2["OPERATION_ABORTED"] = "OPERATION_ABORTED";
  AgoraRTCErrorCode2["WEB_SECURITY_RESTRICT"] = "WEB_SECURITY_RESTRICT";
  AgoraRTCErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  AgoraRTCErrorCode2["NETWORK_TIMEOUT"] = "NETWORK_TIMEOUT";
  AgoraRTCErrorCode2["NETWORK_RESPONSE_ERROR"] = "NETWORK_RESPONSE_ERROR";
  AgoraRTCErrorCode2["API_INVOKE_TIMEOUT"] = "API_INVOKE_TIMEOUT";
  AgoraRTCErrorCode2["ENUMERATE_DEVICES_FAILED"] = "ENUMERATE_DEVICES_FAILED";
  AgoraRTCErrorCode2["DEVICE_NOT_FOUND"] = "DEVICE_NOT_FOUND";
  AgoraRTCErrorCode2["ELECTRON_IS_NULL"] = "ELECTRON_IS_NULL";
  AgoraRTCErrorCode2["ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR"] = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR";
  AgoraRTCErrorCode2["CHROME_PLUGIN_NO_RESPONSE"] = "CHROME_PLUGIN_NO_RESPONSE";
  AgoraRTCErrorCode2["CHROME_PLUGIN_NOT_INSTALL"] = "CHROME_PLUGIN_NOT_INSTALL";
  AgoraRTCErrorCode2["MEDIA_OPTION_INVALID"] = "MEDIA_OPTION_INVALID";
  AgoraRTCErrorCode2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  AgoraRTCErrorCode2["CONSTRAINT_NOT_SATISFIED"] = "CONSTRAINT_NOT_SATISFIED";
  AgoraRTCErrorCode2["TRACK_IS_DISABLED"] = "TRACK_IS_DISABLED";
  AgoraRTCErrorCode2["SHARE_AUDIO_NOT_ALLOWED"] = "SHARE_AUDIO_NOT_ALLOWED";
  AgoraRTCErrorCode2["LOW_STREAM_ENCODING_ERROR"] = "LOW_STREAM_ENCODING_ERROR";
  AgoraRTCErrorCode2["INVALID_UINT_UID_FROM_STRING_UID"] = "INVALID_UINT_UID_FROM_STRING_UID";
  AgoraRTCErrorCode2["CAN_NOT_GET_PROXY_SERVER"] = "CAN_NOT_GET_PROXY_SERVER";
  AgoraRTCErrorCode2["CAN_NOT_GET_GATEWAY_SERVER"] = "CAN_NOT_GET_GATEWAY_SERVER";
  AgoraRTCErrorCode2["VOID_GATEWAY_ADDRESS"] = "VOID_GATEWAY_ADDRESS";
  AgoraRTCErrorCode2["UID_CONFLICT"] = "UID_CONFLICT";
  AgoraRTCErrorCode2["INVALID_LOCAL_TRACK"] = "INVALID_LOCAL_TRACK";
  AgoraRTCErrorCode2["INVALID_TRACK"] = "INVALID_TRACK";
  AgoraRTCErrorCode2["SENDER_NOT_FOUND"] = "SENDER_NOT_FOUND";
  AgoraRTCErrorCode2["CREATE_OFFER_FAILED"] = "CREATE_OFFER_FAILED";
  AgoraRTCErrorCode2["SET_ANSWER_FAILED"] = "SET_ANSWER_FAILED";
  AgoraRTCErrorCode2["ICE_FAILED"] = "ICE_FAILED";
  AgoraRTCErrorCode2["PC_CLOSED"] = "PC_CLOSED";
  AgoraRTCErrorCode2["SENDER_REPLACE_FAILED"] = "SENDER_REPLACE_FAILED";
  AgoraRTCErrorCode2["GATEWAY_P2P_LOST"] = "GATEWAY_P2P_LOST";
  AgoraRTCErrorCode2["NO_ICE_CANDIDATE"] = "NO_ICE_CANDIDATE";
  AgoraRTCErrorCode2["CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS"] = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS";
  AgoraRTCErrorCode2["EXIST_DISABLED_VIDEO_TRACK"] = "EXIST_DISABLED_VIDEO_TRACK";
  AgoraRTCErrorCode2["INVALID_REMOTE_USER"] = "INVALID_REMOTE_USER";
  AgoraRTCErrorCode2["REMOTE_USER_IS_NOT_PUBLISHED"] = "REMOTE_USER_IS_NOT_PUBLISHED";
  AgoraRTCErrorCode2["CUSTOM_REPORT_SEND_FAILED"] = "CUSTOM_REPORT_SEND_FAILED";
  AgoraRTCErrorCode2["CUSTOM_REPORT_FREQUENCY_TOO_HIGH"] = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH";
  AgoraRTCErrorCode2["FETCH_AUDIO_FILE_FAILED"] = "FETCH_AUDIO_FILE_FAILED";
  AgoraRTCErrorCode2["READ_LOCAL_AUDIO_FILE_ERROR"] = "READ_LOCAL_AUDIO_FILE_ERROR";
  AgoraRTCErrorCode2["DECODE_AUDIO_FILE_FAILED"] = "DECODE_AUDIO_FILE_FAILED";
  AgoraRTCErrorCode2["WS_ABORT"] = "WS_ABORT";
  AgoraRTCErrorCode2["WS_DISCONNECT"] = "WS_DISCONNECT";
  AgoraRTCErrorCode2["WS_ERR"] = "WS_ERR";
  AgoraRTCErrorCode2["LIVE_STREAMING_TASK_CONFLICT"] = "LIVE_STREAMING_TASK_CONFLICT";
  AgoraRTCErrorCode2["LIVE_STREAMING_INVALID_ARGUMENT"] = "LIVE_STREAMING_INVALID_ARGUMENT";
  AgoraRTCErrorCode2["LIVE_STREAMING_INTERNAL_SERVER_ERROR"] = "LIVE_STREAMING_INTERNAL_SERVER_ERROR";
  AgoraRTCErrorCode2["LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED"] = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED";
  AgoraRTCErrorCode2["LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED"] = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED";
  AgoraRTCErrorCode2["LIVE_STREAMING_CDN_ERROR"] = "LIVE_STREAMING_CDN_ERROR";
  AgoraRTCErrorCode2["LIVE_STREAMING_INVALID_RAW_STREAM"] = "LIVE_STREAMING_INVALID_RAW_STREAM";
  AgoraRTCErrorCode2["LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT"] = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT";
  AgoraRTCErrorCode2["LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE"] = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE";
  AgoraRTCErrorCode2["LIVE_STREAMING_WARN_FREQUENT_REQUEST"] = "LIVE_STREAMING_WARN_FREQUENT_REQUEST";
  AgoraRTCErrorCode2["WEBGL_INTERNAL_ERROR"] = "WEBGL_INTERNAL_ERROR";
  AgoraRTCErrorCode2["BEAUTY_PROCESSOR_INTERNAL_ERROR"] = "BEAUTY_PROCESSOR_INTERNAL_ERROR";
  AgoraRTCErrorCode2["CROSS_CHANNEL_WAIT_STATUS_ERROR"] = "CROSS_CHANNEL_WAIT_STATUS_ERROR";
  AgoraRTCErrorCode2["CROSS_CHANNEL_FAILED_JOIN_SRC"] = "CROSS_CHANNEL_FAILED_JOIN_SEC";
  AgoraRTCErrorCode2["CROSS_CHANNEL_FAILED_JOIN_DEST"] = "CROSS_CHANNEL_FAILED_JOIN_DEST";
  AgoraRTCErrorCode2["CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST"] = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST";
  AgoraRTCErrorCode2["CROSS_CHANNEL_SERVER_ERROR_RESPONSE"] = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE";
  AgoraRTCErrorCode2["METADATA_OUT_OF_RANGE"] = "METADATA_OUT_OF_RANGE";
})(AgoraRTCErrorCode || (AgoraRTCErrorCode = {}));
var createClient = function createClient2(config) {
  var client;
  function createClosure() {
    if (!client) {
      client = import_agora_rtc_sdk_ng.default.createClient(config);
    }
    return client;
  }
  return function() {
    return createClosure();
  };
};
function createMicrophoneAndCameraTracks(audioConfig, videoConfig) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createMicrophoneAndCameraTracks(audioConfig, videoConfig)).then(function(_AgoraRTC$createMicro) {
        tracks = _AgoraRTC$createMicro;
        return tracks;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var tracks = null;
  return function useMicrophoneAndCameraTracks() {
    var _useState = (0, import_react.useState)(false), ready = _useState[0], setReady = _useState[1];
    var _useState2 = (0, import_react.useState)(null), agoraRTCError = _useState2[0], setAgoraRTCError = _useState2[1];
    var ref = (0, import_react.useRef)(tracks);
    (0, import_react.useEffect)(function() {
      if (ref.current === null) {
        createClosure().then(function(tracks2) {
          ref.current = tracks2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
      return function() {
        tracks = null;
      };
    }, []);
    return {
      ready,
      tracks: ref.current,
      error: agoraRTCError
    };
  };
}
function createBufferSourceAudioTrack(config) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createBufferSourceAudioTrack(config)).then(function(_AgoraRTC$createBuffe) {
        track = _AgoraRTC$createBuffe;
        return track;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var track = null;
  return function useBufferSourceAudioTrack() {
    var _useState3 = (0, import_react.useState)(false), ready = _useState3[0], setReady = _useState3[1];
    var _useState4 = (0, import_react.useState)(null), agoraRTCError = _useState4[0], setAgoraRTCError = _useState4[1];
    var ref = (0, import_react.useRef)(track);
    (0, import_react.useEffect)(function() {
      if (ref.current === null) {
        createClosure().then(function(track2) {
          ref.current = track2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
      return function() {
        track = null;
      };
    }, []);
    return {
      ready,
      track: ref.current,
      error: agoraRTCError
    };
  };
}
function createCameraVideoTrack(config) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createCameraVideoTrack(config)).then(function(_AgoraRTC$createCamer) {
        track = _AgoraRTC$createCamer;
        return track;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var track = null;
  return function useCameraVideoTrack() {
    var _useState5 = (0, import_react.useState)(false), ready = _useState5[0], setReady = _useState5[1];
    var _useState6 = (0, import_react.useState)(null), agoraRTCError = _useState6[0], setAgoraRTCError = _useState6[1];
    var ref = (0, import_react.useRef)(track);
    (0, import_react.useEffect)(function() {
      if (ref.current === null) {
        createClosure().then(function(track2) {
          ref.current = track2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
      return function() {
        track = null;
      };
    }, []);
    return {
      ready,
      track: ref.current,
      error: agoraRTCError
    };
  };
}
function createCustomAudioTrack(config) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createCustomAudioTrack(config)).then(function(_AgoraRTC$createCusto) {
        track = _AgoraRTC$createCusto;
        return track;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var track = null;
  return function useCustomAudioTrack() {
    var _useState7 = (0, import_react.useState)(false), ready = _useState7[0], setReady = _useState7[1];
    var _useState8 = (0, import_react.useState)(null), agoraRTCError = _useState8[0], setAgoraRTCError = _useState8[1];
    var ref = (0, import_react.useRef)(track);
    (0, import_react.useEffect)(function() {
      if (ref.current === null) {
        createClosure().then(function(track2) {
          ref.current = track2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
      return function() {
        track = null;
      };
    }, []);
    return {
      ready,
      track: ref.current,
      error: agoraRTCError
    };
  };
}
function createCustomVideoTrack(config) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createCustomVideoTrack(config)).then(function(_AgoraRTC$createCusto2) {
        track = _AgoraRTC$createCusto2;
        return track;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var track = null;
  return function useCustomVideoTrack() {
    var _useState9 = (0, import_react.useState)(false), ready = _useState9[0], setReady = _useState9[1];
    var _useState10 = (0, import_react.useState)(null), agoraRTCError = _useState10[0], setAgoraRTCError = _useState10[1];
    var ref = (0, import_react.useRef)(track);
    (0, import_react.useEffect)(function() {
      if (ref.current === null) {
        createClosure().then(function(track2) {
          ref.current = track2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
      return function() {
        track = null;
      };
    }, []);
    return {
      ready,
      track: ref.current,
      error: agoraRTCError
    };
  };
}
function createMicrophoneAudioTrack(config) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createMicrophoneAudioTrack(config)).then(function(_AgoraRTC$createMicro2) {
        track = _AgoraRTC$createMicro2;
        return track;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var track = null;
  return function useMicrophoneAudioTrack() {
    var _useState11 = (0, import_react.useState)(false), ready = _useState11[0], setReady = _useState11[1];
    var _useState12 = (0, import_react.useState)(null), agoraRTCError = _useState12[0], setAgoraRTCError = _useState12[1];
    var ref = (0, import_react.useRef)(track);
    (0, import_react.useEffect)(function() {
      if (ref.current === null) {
        createClosure().then(function(track2) {
          ref.current = track2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
      return function() {
        track = null;
      };
    }, []);
    return {
      ready,
      track: ref.current,
      error: agoraRTCError
    };
  };
}
function createScreenVideoTrack(config, withAudio) {
  var createClosure = function createClosure2() {
    try {
      return Promise.resolve(import_agora_rtc_sdk_ng.default.createScreenVideoTrack(config, withAudio)).then(function(_AgoraRTC$createScree) {
        tracks = _AgoraRTC$createScree;
        return tracks;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var tracks;
  return function useScreenVideoTrack() {
    var _useState13 = (0, import_react.useState)(false), ready = _useState13[0], setReady = _useState13[1];
    var _useState14 = (0, import_react.useState)(null), agoraRTCError = _useState14[0], setAgoraRTCError = _useState14[1];
    var ref = (0, import_react.useRef)(tracks);
    (0, import_react.useEffect)(function() {
      if (ref.current === void 0) {
        createClosure().then(function(tracks2) {
          ref.current = tracks2;
          setReady(true);
        }, function(e) {
          setAgoraRTCError(e);
        });
      } else {
        setReady(true);
      }
    }, []);
    return {
      ready,
      tracks: ref.current,
      error: agoraRTCError
    };
  };
}
var AgoraVideoPlayer = function AgoraVideoPlayer2(props) {
  var vidDiv = (0, import_react.useRef)(null);
  var videoTrack = props.videoTrack, config = props.config, other = _objectWithoutPropertiesLoose(props, ["videoTrack", "config"]);
  (0, import_react.useLayoutEffect)(function() {
    if (vidDiv.current !== null) videoTrack.play(vidDiv.current, config);
    return function() {
      videoTrack.stop();
    };
  }, [videoTrack]);
  return import_react.default.createElement("div", Object.assign({}, other, {
    ref: vidDiv
  }));
};
var index_modern_default = import_agora_rtc_sdk_ng.default;

// node_modules/agora-rtm-react/dist/index.modern.js
var index_modern_exports2 = {};
__export(index_modern_exports2, {
  createChannel: () => createChannel,
  createClient: () => createClient3,
  createLazyChannel: () => createLazyChannel,
  createLazyClient: () => createLazyClient,
  default: () => index_modern_default2
});
var import_agora_rtm_sdk = __toESM(require_agora_rtm_sdk());
__reExport(index_modern_exports2, __toESM(require_agora_rtm_sdk()));
var createClient3 = function createClient4(appId, config, areaCodes) {
  var client;
  function createClosure() {
    if (!client) {
      client = import_agora_rtm_sdk.default.createInstance(appId, config, areaCodes);
    }
    return client;
  }
  return function() {
    return createClosure();
  };
};
var createChannel = function createChannel2(channelId) {
  var channel;
  function createClosure(client) {
    if (!channel) {
      channel = client.createChannel(channelId);
    }
    return channel;
  }
  return function(client) {
    return createClosure(client);
  };
};
var createLazyClient = function createLazyClient2() {
  var client;
  function createClosure(appId, config, areaCodes) {
    if (!client) {
      client = import_agora_rtm_sdk.default.createInstance(appId, config, areaCodes);
    }
    return client;
  }
  return function(appId, config, areaCodes) {
    return createClosure(appId, config, areaCodes);
  };
};
var createLazyChannel = function createLazyChannel2() {
  var channel;
  function createClosure(client, channelId) {
    if (!channel) {
      channel = client.createChannel(channelId);
    }
    return channel;
  }
  return function(client, channelId) {
    return createClosure(client, channelId);
  };
};
var AreaCode;
(function(AreaCode2) {
  AreaCode2["GLOBAL"] = "GLOBAL";
  AreaCode2["INDIA"] = "INDIA";
  AreaCode2["JAPAN"] = "JAPAN";
  AreaCode2["ASIA"] = "ASIA";
  AreaCode2["EUROPE"] = "EUROPE";
  AreaCode2["CHINA"] = "CHINA";
  AreaCode2["NORTH_AMERICA"] = "NORTH_AMERICA";
})(AreaCode || (AreaCode = {}));
var index_modern_default2 = import_agora_rtm_sdk.default;

// node_modules/agora-react-uikit/dist/index.modern.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var RtcContext = import_react2.default.createContext({});
var RtcProvider = RtcContext.Provider;
var RtcConsumer = RtcContext.Consumer;
var remoteTrackState;
(function(remoteTrackState2) {
  remoteTrackState2[remoteTrackState2["yes"] = 0] = "yes";
  remoteTrackState2[remoteTrackState2["subbed"] = 1] = "subbed";
  remoteTrackState2[remoteTrackState2["no"] = 2] = "no";
})(remoteTrackState || (remoteTrackState = {}));
var layout;
(function(layout2) {
  layout2[layout2["grid"] = 0] = "grid";
  layout2[layout2["pin"] = 1] = "pin";
})(layout || (layout = {}));
var ToggleState;
(function(ToggleState2) {
  ToggleState2[ToggleState2["disabled"] = 0] = "disabled";
  ToggleState2[ToggleState2["enabled"] = 1] = "enabled";
  ToggleState2[ToggleState2["disabling"] = 2] = "disabling";
  ToggleState2[ToggleState2["enabling"] = 3] = "enabling";
})(ToggleState || (ToggleState = {}));
var initialValue = {
  rtcProps: {
    appId: "",
    channel: "",
    role: "host"
  },
  rtmProps: {}
};
var PropsContext = import_react2.default.createContext(initialValue);
var PropsProvider = PropsContext.Provider;
var MaxUidContext = import_react2.default.createContext([]);
var MaxUidProvider = MaxUidContext.Provider;
var MaxUidConsumer = MaxUidContext.Consumer;
var MinUidContext = import_react2.default.createContext([]);
var MinUidProvider = MinUidContext.Provider;
var MinUidConsumer = MinUidContext.Consumer;
var TracksContext = import_react2.default.createContext({});
var TracksProvider = TracksContext.Provider;
var initState = {
  max: [{
    uid: 0,
    hasAudio: remoteTrackState.no,
    hasVideo: remoteTrackState.no
  }],
  min: [],
  isScreensharing: false
};
var reducer = function reducer2(state, action) {
  var stateUpdate = initState;
  var uids = [].concat(state.max, state.min).map(function(u2) {
    return u2.uid;
  });
  switch (action.type) {
    case "Screensharing":
      {
        stateUpdate = _extends({}, state, {
          isScreensharing: action.value[0]
        });
        console.log("!Screensharingstate", state, stateUpdate);
      }
      break;
    case "update-user-video":
      {
        stateUpdate = {
          min: state.min.map(function(user) {
            if (user.uid === 0) {
              return {
                uid: 0,
                hasAudio: remoteTrackState.subbed,
                hasVideo: remoteTrackState.subbed
              };
            } else {
              return user;
            }
          }),
          max: state.max.map(function(user) {
            if (user.uid === 0) {
              return {
                uid: 0,
                hasAudio: remoteTrackState.subbed,
                hasVideo: remoteTrackState.subbed
              };
            } else {
              return user;
            }
          }),
          isScreensharing: state.isScreensharing
        };
      }
      break;
    case "user-joined":
      {
        if (uids.indexOf(action.value[0].uid) === -1) {
          var minUpdate = [].concat(state.min, [{
            uid: action.value[0].uid,
            hasAudio: remoteTrackState.no,
            hasVideo: remoteTrackState.no
          }]);
          if (minUpdate.length === 1 && state.max[0].uid === 0) {
            stateUpdate = {
              max: minUpdate,
              min: state.max,
              isScreensharing: state.isScreensharing
            };
          } else {
            stateUpdate = {
              min: minUpdate,
              max: state.max,
              isScreensharing: state.isScreensharing
            };
          }
        }
      }
      break;
    case "user-unpublished":
      {
        if (state.max[0].uid === action.value[0].uid) {
          stateUpdate = {
            max: [{
              uid: action.value[0].uid,
              hasAudio: action.value[1] === "audio" ? remoteTrackState.no : state.max[0].hasAudio,
              hasVideo: action.value[1] === "video" ? remoteTrackState.no : state.max[0].hasVideo
            }],
            min: state.min,
            isScreensharing: state.isScreensharing
          };
        } else {
          var UIKitUser = state.min.find(function(user) {
            return user.uid === action.value[0].uid;
          });
          if (UIKitUser) {
            var _minUpdate = [].concat(state.min.filter(function(user) {
              return user.uid !== action.value[0].uid;
            }), [{
              uid: action.value[0].uid,
              hasAudio: action.value[1] === "audio" ? remoteTrackState.no : UIKitUser.hasAudio,
              hasVideo: action.value[1] === "video" ? remoteTrackState.no : UIKitUser.hasVideo
            }]);
            stateUpdate = {
              min: _minUpdate,
              max: state.max,
              isScreensharing: state.isScreensharing
            };
          }
        }
      }
      break;
    case "user-published":
      {
        if (state.max[0].uid === action.value[0].uid) {
          stateUpdate = {
            max: [{
              uid: action.value[0].uid,
              hasAudio: action.value[1] === "audio" ? remoteTrackState.subbed : state.max[0].hasAudio,
              hasVideo: action.value[1] === "video" ? remoteTrackState.subbed : state.max[0].hasVideo
            }],
            min: state.min,
            isScreensharing: state.isScreensharing
          };
        } else {
          stateUpdate = {
            min: state.min.map(function(user) {
              if (user.uid !== action.value[0].uid) {
                return user;
              } else {
                return {
                  uid: user.uid,
                  hasAudio: action.value[1] === "audio" ? remoteTrackState.subbed : user.hasAudio,
                  hasVideo: action.value[1] === "video" ? remoteTrackState.subbed : user.hasVideo
                };
              }
            }),
            max: state.max,
            isScreensharing: state.isScreensharing
          };
        }
      }
      break;
    case "user-left":
      {
        if (state.max[0].uid === action.value[0].uid) {
          var _minUpdate2 = [].concat(state.min);
          stateUpdate = {
            max: [_minUpdate2.pop()],
            min: _minUpdate2,
            isScreensharing: state.isScreensharing
          };
        } else {
          stateUpdate = {
            min: state.min.filter(function(user) {
              return user.uid !== action.value[0].uid;
            }),
            max: state.max,
            isScreensharing: state.isScreensharing
          };
        }
      }
      break;
    case "user-swap":
      {
        if (state.max[0].uid === action.value[0].uid) ;
        else {
          stateUpdate = {
            max: [action.value[0]],
            min: [].concat(state.min.filter(function(user) {
              return user.uid !== action.value[0].uid;
            }), [state.max[0]]),
            isScreensharing: state.isScreensharing
          };
        }
      }
      break;
    case "local-user-mute-video":
      {
        stateUpdate = {
          min: state.min.map(function(user) {
            if (user.uid === 0) {
              return {
                uid: 0,
                hasAudio: user.hasAudio,
                hasVideo: action.value[0]
              };
            } else {
              return user;
            }
          }),
          max: state.max.map(function(user) {
            if (user.uid === 0) {
              return {
                uid: 0,
                hasAudio: user.hasAudio,
                hasVideo: action.value[0]
              };
            } else {
              return user;
            }
          }),
          isScreensharing: state.isScreensharing
        };
      }
      break;
    case "local-user-mute-audio":
      {
        stateUpdate = {
          min: state.min.map(function(user) {
            if (user.uid === 0) {
              return {
                uid: 0,
                hasAudio: action.value[0],
                hasVideo: user.hasVideo
              };
            } else {
              return user;
            }
          }),
          max: state.max.map(function(user) {
            if (user.uid === 0) {
              return {
                uid: 0,
                hasAudio: action.value[0],
                hasVideo: user.hasVideo
              };
            } else {
              return user;
            }
          }),
          isScreensharing: state.isScreensharing
        };
      }
      break;
    case "remote-user-mute-video":
      {
        stateUpdate = {
          min: state.min.map(function(user) {
            if (user.uid === action.value[0].uid) {
              return {
                uid: user.uid,
                hasVideo: action.value[1],
                hasAudio: user.hasAudio
              };
            } else return user;
          }),
          max: state.max.map(function(user) {
            if (user.uid === action.value[0].uid) return {
              uid: user.uid,
              hasVideo: action.value[1],
              hasAudio: user.hasAudio
            };
            else return user;
          }),
          isScreensharing: state.isScreensharing
        };
      }
      break;
    case "remote-user-mute-audio":
      {
        stateUpdate = {
          min: state.min.map(function(user) {
            if (user.uid === action.value[0].uid) return {
              uid: user.uid,
              hasAudio: action.value[1],
              hasVideo: user.hasVideo
            };
            else return user;
          }),
          max: state.max.map(function(user) {
            if (user.uid === action.value[0].uid) return {
              uid: user.uid,
              hasAudio: action.value[1],
              hasVideo: user.hasVideo
            };
            else return user;
          }),
          isScreensharing: state.isScreensharing
        };
      }
      break;
    case "leave-channel":
      stateUpdate = initState;
      break;
    case "ActiveSpeaker":
      {
        if (state.max[0].uid === action.value[0]) {
          stateUpdate = _extends({}, state);
        } else {
          stateUpdate = {
            max: [state.min.find(function(user) {
              return user.uid === action.value[0];
            })],
            min: [].concat(state.min.filter(function(user) {
              return user.uid !== action.value[0];
            }), [state.max[0]]),
            isScreensharing: state.isScreensharing
          };
        }
      }
      break;
  }
  console.log("!state-update", _extends({}, state, stateUpdate), stateUpdate);
  return _extends({}, state, stateUpdate);
};
var startScreenshare = function startScreenshare2(appId, channel, track, screenshareToken, screenshareUid, tokenUrl, enableDualStream) {
  try {
    var init = function init2() {
      try {
        try {
          console.log(screenClient);
          if (tokenUrl) {
            screenClient.on("token-privilege-will-expire", function() {
              try {
                console.log("token will expire");
                return Promise.resolve(fetch(tokenUrl + "/rtc/" + channel + "/publisher/uid/" + uid + "/")).then(function(res) {
                  return Promise.resolve(res.json()).then(function(data) {
                    var token = data.rtcToken;
                    screenClient.renewToken(token);
                  });
                });
              } catch (e) {
                return Promise.reject(e);
              }
            });
            screenClient.on("token-privilege-did-expire", function() {
              try {
                return Promise.resolve(fetch(tokenUrl + "/rtc/" + channel + "/publisher/uid/" + uid + "/")).then(function(res) {
                  return Promise.resolve(res.json()).then(function(data) {
                    var token = data.rtcToken;
                    screenClient.renewToken(token);
                  });
                });
              } catch (e) {
                return Promise.reject(e);
              }
            });
          }
          track.on("track-ended", function() {
            screenClient.leave();
            screenClient.removeAllListeners();
          });
        } catch (e) {
          console.log(e);
        }
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    };
    var join = function join2() {
      try {
        screenClient.setClientRole("host");
        var _temp3 = function() {
          if (tokenUrl) {
            var _temp4 = _catch(function() {
              return Promise.resolve(fetch(tokenUrl + "/rtc/" + channel + "/publisher/uid/" + uid + "/")).then(function(res) {
                return Promise.resolve(res.json()).then(function(data) {
                  var token = data.rtcToken;
                  return Promise.resolve(screenClient.join(appId, channel, token, uid)).then(function(_screenClient$join) {
                    returnedUid = _screenClient$join;
                  });
                });
              });
            }, function(e) {
              console.log(e);
            });
            if (_temp4 && _temp4.then) return _temp4.then(function() {
            });
          } else {
            return Promise.resolve(screenClient.join(appId, channel, screenshareToken || null, uid || 0)).then(function(_screenClient$join2) {
              returnedUid = _screenClient$join2;
            });
          }
        }();
        return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(function() {
        }) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    var publish = function publish2() {
      try {
        var _temp10 = function _temp102() {
          var _temp6 = function() {
            if (track.enabled) {
              var _temp9 = function() {
                if (!localVideoTrackHasPublished) {
                  return Promise.resolve(screenClient.publish([track]).then(function() {
                    localVideoTrackHasPublished = true;
                  })).then(function() {
                  });
                }
              }();
              if (_temp9 && _temp9.then) return _temp9.then(function() {
              });
            }
          }();
          if (_temp6 && _temp6.then) return _temp6.then(function() {
          });
        };
        var _temp11 = function() {
          if (enableDualStream) {
            return Promise.resolve(screenClient.enableDualStream()).then(function() {
            });
          }
        }();
        return Promise.resolve(_temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11));
      } catch (e) {
        return Promise.reject(e);
      }
    };
    var screenClient = index_modern_default.createClient({
      mode: "live",
      role: "host",
      codec: "vp8"
    });
    var returnedUid = 0;
    var uid = screenshareUid || 1;
    var localVideoTrackHasPublished = false;
    var stop = function stop2() {
      try {
        var _temp13 = _catch(function() {
          track.close();
          return Promise.resolve(screenClient.leave()).then(function() {
            screenClient.removeAllListeners();
          });
        }, function(e) {
          console.log(e);
        });
        return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(function() {
        }) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stopScreenshare = stop;
    return Promise.resolve(init()).then(function() {
      return Promise.resolve(join()).then(function() {
        return Promise.resolve(publish()).then(function() {
          if (returnedUid) console.log(returnedUid);
        });
      });
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
var stopScreenshare = function stopScreenshare2() {
};
var useClient = createClient({
  codec: "vp8",
  mode: "live"
});
var RtcConfigure = function RtcConfigure2(props) {
  var uid = (0, import_react2.useRef)();
  var screenTrack = (0, import_react2.useRef)();
  var isScreensharingRef = (0, import_react2.useRef)(false);
  var _useContext = (0, import_react2.useContext)(TracksContext), localVideoTrack = _useContext.localVideoTrack, localAudioTrack = _useContext.localAudioTrack;
  var _useContext2 = (0, import_react2.useContext)(PropsContext), callbacks = _useContext2.callbacks, rtcProps = _useContext2.rtcProps;
  var _useState = (0, import_react2.useState)(false), ready = _useState[0], setReady = _useState[1];
  var _useState2 = (0, import_react2.useState)(false), channelJoined = _useState2[0], setChannelJoined = _useState2[1];
  var joinRes = null;
  var canJoin = (0, import_react2.useRef)(new Promise(function(resolve, reject) {
    joinRes = resolve;
    console.log(reject);
  }));
  var client = useClient();
  if (rtcProps.customRtcClient) {
    client.removeAllListeners();
    client = rtcProps.customRtcClient;
  }
  var localVideoTrackHasPublished = false;
  var localAudioTrackHasPublished = false;
  var mediaStore = (0, import_react2.useRef)({});
  var callActive = props.callActive;
  if (callActive === void 0) {
    callActive = true;
  }
  var _useReducer = (0, import_react2.useReducer)(reducer, initState), uidState = _useReducer[0], dispatch = _useReducer[1];
  (0, import_react2.useEffect)(function() {
    var init = function init2() {
      try {
        try {
          console.log(client);
          client.on("user-joined", function() {
            try {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var remoteUser = args[0];
              if (remoteUser.uid === props.screenshareUid && isScreensharingRef.current || remoteUser.uid === 1 && isScreensharingRef.current) {
              } else {
                mediaStore.current[remoteUser.uid] = {};
              }
              dispatch({
                type: "user-joined",
                value: args
              });
              return Promise.resolve();
            } catch (e) {
              return Promise.reject(e);
            }
          });
          client.on("user-published", function() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            try {
              var remoteUser = args[0], mediaType = args[1];
              console.log("user-published", remoteUser.uid);
              if (remoteUser.uid === props.screenshareUid && isScreensharingRef.current || remoteUser.uid === 1 && isScreensharingRef.current) {
                dispatch({
                  type: "user-published",
                  value: args
                });
              } else {
                client.subscribe(remoteUser, mediaType).then(function(_e) {
                  mediaStore.current[remoteUser.uid][mediaType + "Track"] = remoteUser[mediaType + "Track"];
                  if (mediaType === "audio") {
                    var _remoteUser$audioTrac;
                    (_remoteUser$audioTrac = remoteUser.audioTrack) === null || _remoteUser$audioTrac === void 0 ? void 0 : _remoteUser$audioTrac.play();
                  } else {
                    if (rtcProps.enableDualStream && rtcProps.dualStreamMode) {
                      client.setStreamFallbackOption(remoteUser.uid, rtcProps.dualStreamMode);
                    }
                  }
                  dispatch({
                    type: "user-published",
                    value: args
                  });
                })["catch"](function(e) {
                  return console.log(e);
                });
              }
              return Promise.resolve();
            } catch (e) {
              return Promise.reject(e);
            }
          });
          client.on("user-unpublished", function() {
            try {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }
              var remoteUser = args[0], mediaType = args[1];
              console.log("user-unpublished", remoteUser.uid);
              if (mediaType === "audio") {
                var _remoteUser$audioTrac2;
                (_remoteUser$audioTrac2 = remoteUser.audioTrack) === null || _remoteUser$audioTrac2 === void 0 ? void 0 : _remoteUser$audioTrac2.stop();
              }
              dispatch({
                type: "user-unpublished",
                value: args
              });
              return Promise.resolve();
            } catch (e) {
              return Promise.reject(e);
            }
          });
          client.on("connection-state-change", function() {
            try {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              var curState = args[0], prevState = args[1], reason = args[2];
              console.log("connection", prevState, curState, reason);
              if (curState === "CONNECTED") {
                setChannelJoined(true);
              } else if (curState === "DISCONNECTED") {
                try {
                  stopScreenshare();
                  isScreensharingRef.current = false;
                } catch (e) {
                  console.log("stopscreenshare", e);
                }
                dispatch({
                  type: "leave-channel",
                  value: null
                });
              } else {
                setChannelJoined(false);
              }
              return Promise.resolve();
            } catch (e) {
              return Promise.reject(e);
            }
          });
          client.on("user-left", function() {
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }
            dispatch({
              type: "user-left",
              value: args
            });
          });
          if (rtcProps.tokenUrl) {
            var tokenUrl = rtcProps.tokenUrl, channel = rtcProps.channel, _uid = rtcProps.uid;
            client.on("token-privilege-will-expire", function() {
              try {
                console.log("token will expire");
                return Promise.resolve(fetch(tokenUrl + "/rtc/" + channel + "/publisher/uid/" + (_uid || 0) + "/")).then(function(res) {
                  return Promise.resolve(res.json()).then(function(data) {
                    var token = data.rtcToken;
                    client.renewToken(token);
                  });
                });
              } catch (e) {
                return Promise.reject(e);
              }
            });
            client.on("token-privilege-did-expire", function() {
              try {
                return Promise.resolve(fetch(tokenUrl + "/rtc/" + channel + "/publisher/uid/" + (_uid || 0) + "/")).then(function(res) {
                  return Promise.resolve(res.json()).then(function(data) {
                    var token = data.rtcToken;
                    client.renewToken(token);
                  });
                });
              } catch (e) {
                return Promise.reject(e);
              }
            });
          }
          if (callbacks) {
            var events = Object.keys(callbacks);
            events.map(function(e) {
              try {
                client.on(e, function() {
                  ;
                  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                    args[_key6] = arguments[_key6];
                  }
                  callbacks[e].apply(null, args);
                });
              } catch (e2) {
                console.log(e2);
              }
            });
          }
          ;
          joinRes(true);
          setReady(true);
        } catch (e) {
          console.log("!!!", e);
        }
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    };
    if (joinRes) {
      init();
      return function() {
        try {
          client.removeAllListeners();
        } catch (e) {
          console.log(e);
        }
      };
    } else return function() {
    };
  }, [rtcProps.appId]);
  (0, import_react2.useEffect)(function() {
    var join = function join2() {
      try {
        return Promise.resolve(canJoin.current).then(function() {
          var tokenUrl = rtcProps.tokenUrl, channel = rtcProps.channel, userUid = rtcProps.uid, appId = rtcProps.appId, token = rtcProps.token;
          var _temp3 = function() {
            if (client && !ignore) {
              if (rtcProps.role === "audience") {
                client.setClientRole(rtcProps.role);
              } else {
                client.setClientRole("host");
              }
              var _temp4 = function() {
                if (tokenUrl) {
                  var _temp5 = _catch(function() {
                    return Promise.resolve(fetch(tokenUrl + "/rtc/" + channel + "/publisher/uid/" + (userUid || 0) + "/")).then(function(res) {
                      return Promise.resolve(res.json()).then(function(data) {
                        var token2 = data.rtcToken;
                        return Promise.resolve(client.join(appId, channel, token2, userUid || 0)).then(function(_client$join) {
                          uid.current = _client$join;
                        });
                      });
                    });
                  }, function(e) {
                    console.log(e);
                  });
                  if (_temp5 && _temp5.then) return _temp5.then(function() {
                  });
                } else {
                  return Promise.resolve(client.join(appId, channel, token || null, userUid || 0)).then(function(_client$join2) {
                    uid.current = _client$join2;
                  });
                }
              }();
              if (_temp4 && _temp4.then) return _temp4.then(function() {
              });
            } else {
              console.error("trying to join before RTC Engine was initialized");
            }
          }();
          if (_temp3 && _temp3.then) return _temp3.then(function() {
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };
    var ignore = false;
    if (callActive) {
      join();
      console.log("Attempted join: ", rtcProps.channel);
    } else {
      console.log("In precall - waiting to join");
    }
    return function() {
      ignore = true;
      if (callActive) {
        console.log("Leaving channel");
        try {
          stopScreenshare();
          isScreensharingRef.current = false;
        } catch (e) {
          console.log(e);
        }
        canJoin.current = client.leave()["catch"](function(err) {
          return console.log(err);
        });
      }
    };
  }, [rtcProps.channel, rtcProps.uid, callActive, rtcProps.tokenUrl]);
  (0, import_react2.useEffect)(function() {
    var publish = function publish2() {
      try {
        var _temp15 = function _temp152() {
          function _temp10() {
            var _temp8 = function() {
              if (localVideoTrack !== null && localVideoTrack !== void 0 && localVideoTrack.enabled && channelJoined) {
                var _temp13 = function() {
                  if (!localVideoTrackHasPublished) {
                    return Promise.resolve(client.publish([localVideoTrack]).then(function() {
                      localVideoTrackHasPublished = true;
                    })).then(function() {
                    });
                  }
                }();
                if (_temp13 && _temp13.then) return _temp13.then(function() {
                });
              }
            }();
            if (_temp8 && _temp8.then) return _temp8.then(function() {
            });
          }
          var _temp9 = function() {
            if (localAudioTrack !== null && localAudioTrack !== void 0 && localAudioTrack.enabled && channelJoined) {
              var _temp14 = function() {
                if (!localAudioTrackHasPublished) {
                  return Promise.resolve(client.publish([localAudioTrack]).then(function() {
                    localAudioTrackHasPublished = true;
                  })).then(function() {
                  });
                }
              }();
              if (_temp14 && _temp14.then) return _temp14.then(function() {
              });
            }
          }();
          return _temp9 && _temp9.then ? _temp9.then(_temp10) : _temp10(_temp9);
        };
        var _temp16 = function() {
          if (rtcProps.enableDualStream) {
            return Promise.resolve(client.enableDualStream()).then(function() {
            });
          }
        }();
        return Promise.resolve(_temp16 && _temp16.then ? _temp16.then(_temp15) : _temp15(_temp16));
      } catch (e) {
        return Promise.reject(e);
      }
    };
    console.log("Publish", localVideoTrack, localAudioTrack, callActive);
    if (callActive) {
      publish();
    }
  }, [callActive, localVideoTrack === null || localVideoTrack === void 0 ? void 0 : localVideoTrack.enabled, localAudioTrack === null || localAudioTrack === void 0 ? void 0 : localAudioTrack.enabled, channelJoined]);
  (0, import_react2.useEffect)(function() {
    if (localVideoTrack && localAudioTrack !== null) {
      mediaStore.current[0] = {
        audioTrack: localAudioTrack,
        videoTrack: localVideoTrack
      };
      dispatch({
        type: "update-user-video",
        value: [localAudioTrack, localVideoTrack]
      });
    }
  }, [rtcProps.channel, channelJoined]);
  (0, import_react2.useEffect)(function() {
    if (channelJoined && rtcProps.token) {
      client.renewToken(rtcProps.token).then(function(e) {
        return console.log("renewed token", e);
      });
    }
  }, [rtcProps.token, channelJoined]);
  (0, import_react2.useEffect)(function() {
    if (rtcProps.role) {
      client.setClientRole(rtcProps.role).then(function(e) {
        return console.log("changed role", e);
      });
    }
  }, [rtcProps.role, channelJoined]);
  (0, import_react2.useEffect)(function() {
    var enableActiveSpeaker = function enableActiveSpeaker2() {
      try {
        var _temp18 = function() {
          if (rtcProps.activeSpeaker && rtcProps.layout !== layout.grid) {
            client.on("volume-indicator", function(volumes) {
              var highestvolumeObj = volumes.reduce(function(highestVolume, volume) {
                if (highestVolume === null) {
                  return volume;
                } else {
                  if (volume.level > highestVolume.level) {
                    return volume;
                  }
                  return highestVolume;
                }
              }, null);
              var activeSpeaker = highestvolumeObj ? highestvolumeObj.uid : void 0;
              var mapActiveSpeakerToZero = activeSpeaker === uid.current ? 0 : activeSpeaker;
              if (activeSpeaker !== void 0) {
                dispatch({
                  type: "ActiveSpeaker",
                  value: [mapActiveSpeakerToZero]
                });
              }
            });
            return Promise.resolve(client.enableAudioVolumeIndicator()).then(function() {
            });
          }
        }();
        return Promise.resolve(_temp18 && _temp18.then ? _temp18.then(function() {
        }) : void 0);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    if (callActive) {
      enableActiveSpeaker();
    }
    return function() {
      client.removeAllListeners("volume-indicator");
    };
  }, [rtcProps.activeSpeaker, rtcProps.layout]);
  var toggleScreensharing = function toggleScreensharing2() {
    try {
      var start = function start2() {
        try {
          dispatch({
            type: "Screensharing",
            value: [true]
          });
          return Promise.resolve(index_modern_default.createScreenVideoTrack({}, "disable")).then(function(_AgoraRTC$createScree) {
            screenTrack.current = _AgoraRTC$createScree;
            var uid2 = rtcProps.screenshareUid || 1;
            mediaStore.current[uid2] = {
              videoTrack: screenTrack.current
            };
            screenTrack.current.on("track-ended", function() {
              isScreensharingRef.current = false;
              dispatch({
                type: "Screensharing",
                value: [false]
              });
            });
            isScreensharingRef.current = true;
            return Promise.resolve(startScreenshare(rtcProps.appId, rtcProps.channel, screenTrack.current, rtcProps.screenshareToken, rtcProps.screenshareUid, rtcProps.tokenUrl, rtcProps.enableDualStream)).then(function() {
            });
          });
        } catch (e) {
          return Promise.reject(e);
        }
      };
      var stop = function stop2() {
        stopScreenshare();
        isScreensharingRef.current = false;
      };
      if (isScreensharingRef.current) {
        stop();
      } else {
        start();
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return import_react2.default.createElement(RtcProvider, {
    value: {
      client,
      mediaStore: mediaStore.current,
      localVideoTrack,
      localAudioTrack,
      dispatch,
      localUid: uid,
      channelJoined,
      toggleScreensharing,
      isScreensharing: isScreensharingRef.current
    }
  }, import_react2.default.createElement(MaxUidProvider, {
    value: uidState.max
  }, import_react2.default.createElement(MinUidProvider, {
    value: uidState.min
  }, ready ? props.children : null)));
};
var icons = {
  videocam: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("polygon", {
    points: "23 7 16 12 23 17 23 7"
  }), import_react2.default.createElement("rect", {
    x: "1",
    y: "5",
    width: "15",
    height: "14",
    rx: "2",
    ry: "2"
  })),
  videocamOff: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("path", {
    d: "M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"
  }), import_react2.default.createElement("line", {
    x1: "1",
    y1: "1",
    x2: "23",
    y2: "23"
  })),
  remoteSwap: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("polyline", {
    points: "15 3 21 3 21 9"
  }), import_react2.default.createElement("polyline", {
    points: "9 21 3 21 3 15"
  }), import_react2.default.createElement("line", {
    x1: "21",
    y1: "3",
    x2: "14",
    y2: "10"
  }), import_react2.default.createElement("line", {
    x1: "3",
    y1: "21",
    x2: "10",
    y2: "14"
  })),
  callEnd: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("path", {
    d: "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"
  }), import_react2.default.createElement("line", {
    x1: "23",
    y1: "1",
    x2: "1",
    y2: "23"
  })),
  mic: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("path", {
    d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"
  }), import_react2.default.createElement("path", {
    d: "M19 10v2a7 7 0 0 1-14 0v-2"
  }), import_react2.default.createElement("line", {
    x1: "12",
    y1: "19",
    x2: "12",
    y2: "23"
  }), import_react2.default.createElement("line", {
    x1: "8",
    y1: "23",
    x2: "16",
    y2: "23"
  })),
  micOff: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("line", {
    x1: "1",
    y1: "1",
    x2: "23",
    y2: "23"
  }), import_react2.default.createElement("path", {
    d: "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"
  }), import_react2.default.createElement("path", {
    d: "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"
  }), import_react2.default.createElement("line", {
    x1: "12",
    y1: "19",
    x2: "12",
    y2: "23"
  }), import_react2.default.createElement("line", {
    x1: "8",
    y1: "23",
    x2: "16",
    y2: "23"
  })),
  screen: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("rect", {
    x: "2",
    y: "3",
    width: "20",
    height: "14",
    rx: "2",
    ry: "2"
  }), import_react2.default.createElement("line", {
    x1: "8",
    y1: "21",
    x2: "16",
    y2: "21"
  }), import_react2.default.createElement("line", {
    x1: "12",
    y1: "17",
    x2: "12",
    y2: "21"
  })),
  stop: import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }), import_react2.default.createElement("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }))
};
var BtnTemplate = function BtnTemplate2(props) {
  var onClick = props.onClick, name = props.name, disabled = props.disabled, style2 = props.style;
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps;
  var _ref = styleProps || {}, theme = _ref.theme, BtnTemplateStyles = _ref.BtnTemplateStyles, iconSize = _ref.iconSize, customIcon = _ref.customIcon;
  return import_react2.default.createElement("div", {
    style: _extends({}, {
      width: 35,
      height: 35,
      borderRadius: "100%",
      borderWidth: 2,
      borderStyle: "solid",
      borderColor: "#fff",
      backgroundColor: "rgba(0,80,180,0.2)",
      alignItems: "center",
      justifyContent: "center",
      display: "flex",
      cursor: disabled ? "auto" : "pointer",
      margin: 4
    }, BtnTemplateStyles, style2),
    onClick
  }, customIcon ? import_react2.default.createElement("img", {
    src: customIcon[name],
    alt: name
  }) : import_react2.default.createElement("svg", {
    style: {
      width: iconSize || 24,
      height: iconSize || 24
    },
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    opacity: disabled ? "0.5" : "1",
    stroke: theme || "#fff",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }, icons[name]));
};
function EndCall() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, callbacks = _useContext.callbacks;
  var _ref = styleProps || {}, localBtnStyles = _ref.localBtnStyles;
  var _ref2 = localBtnStyles || {}, endCall = _ref2.endCall;
  return import_react2.default.createElement(BtnTemplate, {
    style: endCall || {
      backgroundColor: "#ef5588",
      borderColor: "#f00"
    },
    name: "callEnd",
    onClick: function onClick() {
      return (callbacks === null || callbacks === void 0 ? void 0 : callbacks.EndCall) && callbacks.EndCall();
    }
  });
}
var LocalContext = (0, import_react2.createContext)({});
var LocalUserContext = function LocalUserContext2(props) {
  var max = (0, import_react2.useContext)(MaxUidContext);
  var min = (0, import_react2.useContext)(MinUidContext);
  var localUser;
  if (max[0].uid === 0) {
    localUser = max[0];
  } else {
    localUser = min.find(function(u2) {
      return u2.uid === 0;
    });
  }
  return import_react2.default.createElement(LocalContext.Provider, {
    value: localUser
  }, props.children);
};
var muteAudio = function(user, dispatch, localAudioTrack, callbacks) {
  try {
    var _temp4 = function() {
      if (user.uid === 0) {
        var localState = user.hasAudio;
        var _temp5 = function() {
          if (localState === ToggleState.enabled || localState === ToggleState.disabled) {
            var newState = localState === ToggleState.enabled ? ToggleState.disabling : ToggleState.enabling;
            dispatch({
              type: "local-user-mute-audio",
              value: [newState]
            });
            callbacks && callbacks["local-user-mute-audio"] && callbacks["local-user-mute-audio"](newState);
            var _temp6 = _catch(function() {
              return Promise.resolve(localAudioTrack === null || localAudioTrack === void 0 ? void 0 : localAudioTrack.setEnabled(localState !== ToggleState.enabled)).then(function() {
                newState = localState === ToggleState.enabled ? ToggleState.disabled : ToggleState.enabled;
                callbacks && callbacks["local-user-mute-audio"] && callbacks["local-user-mute-audio"](newState);
                dispatch({
                  type: "local-user-mute-audio",
                  value: [localState === ToggleState.enabled ? ToggleState.disabled : ToggleState.enabled]
                });
              });
            }, function() {
              dispatch({
                type: "local-user-mute-audio",
                value: [localState]
              });
            });
            if (_temp6 && _temp6.then) return _temp6.then(function() {
            });
          }
        }();
        if (_temp5 && _temp5.then) return _temp5.then(function() {
        });
      }
    }();
    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function() {
    }) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
};
function LocalAudioMute() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, callbacks = _useContext.callbacks;
  var _ref = styleProps || {}, localBtnStyles = _ref.localBtnStyles;
  var _ref2 = localBtnStyles || {}, muteLocalAudio = _ref2.muteLocalAudio;
  var _useContext2 = (0, import_react2.useContext)(RtcContext), dispatch = _useContext2.dispatch, localAudioTrack = _useContext2.localAudioTrack;
  var local = (0, import_react2.useContext)(LocalContext);
  return import_react2.default.createElement("div", null, import_react2.default.createElement(BtnTemplate, {
    style: muteLocalAudio,
    name: local.hasAudio === ToggleState.enabled ? "mic" : "micOff",
    onClick: function onClick() {
      return localAudioTrack && muteAudio(local, dispatch, localAudioTrack, callbacks);
    }
  }));
}
function Screenshare() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps;
  var _ref = styleProps || {}, localBtnStyles = _ref.localBtnStyles;
  var _ref2 = localBtnStyles || {}, screenshare = _ref2.screenshare;
  var _useContext2 = (0, import_react2.useContext)(RtcContext), toggleScreensharing = _useContext2.toggleScreensharing, isScreensharing = _useContext2.isScreensharing;
  return import_react2.default.createElement("div", null, import_react2.default.createElement(BtnTemplate, {
    style: screenshare,
    name: isScreensharing ? "stop" : "screen",
    onClick: function onClick() {
      return toggleScreensharing();
    }
  }));
}
var muteVideo = function(user, dispatch, localVideoTrack, callbacks) {
  try {
    var _temp4 = function() {
      if (user.uid === 0) {
        var localState = user.hasVideo;
        var _temp5 = function() {
          if (localState === ToggleState.enabled || localState === ToggleState.disabled) {
            var newState = localState === ToggleState.enabled ? ToggleState.disabling : ToggleState.enabling;
            dispatch({
              type: "local-user-mute-video",
              value: [newState]
            });
            callbacks && callbacks["local-user-mute-video"] && callbacks["local-user-mute-video"](newState);
            var _temp6 = _catch(function() {
              return Promise.resolve(localVideoTrack === null || localVideoTrack === void 0 ? void 0 : localVideoTrack.setEnabled(localState !== ToggleState.enabled)).then(function() {
                newState = localState === ToggleState.enabled ? ToggleState.disabled : ToggleState.enabled;
                callbacks && callbacks["local-user-mute-video"] && callbacks["local-user-mute-video"](newState);
                dispatch({
                  type: "local-user-mute-video",
                  value: [newState]
                });
              });
            }, function() {
              dispatch({
                type: "local-user-mute-video",
                value: [localState]
              });
            });
            if (_temp6 && _temp6.then) return _temp6.then(function() {
            });
          }
        }();
        if (_temp5 && _temp5.then) return _temp5.then(function() {
        });
      }
    }();
    return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function() {
    }) : void 0);
  } catch (e) {
    return Promise.reject(e);
  }
};
function LocalVideoMute() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, callbacks = _useContext.callbacks;
  var _ref = styleProps || {}, localBtnStyles = _ref.localBtnStyles;
  var _ref2 = localBtnStyles || {}, muteLocalVideo = _ref2.muteLocalVideo;
  var _useContext2 = (0, import_react2.useContext)(RtcContext), dispatch = _useContext2.dispatch, localVideoTrack = _useContext2.localVideoTrack;
  var local = (0, import_react2.useContext)(LocalContext);
  return import_react2.default.createElement("div", null, import_react2.default.createElement(BtnTemplate, {
    style: muteLocalVideo,
    name: local.hasVideo === ToggleState.enabled ? "videocam" : "videocamOff",
    onClick: function onClick() {
      return localVideoTrack && muteVideo(local, dispatch, localVideoTrack, callbacks);
    }
  }));
}
function LocalControls() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, rtcProps = _useContext.rtcProps;
  var _ref = styleProps || {}, localBtnContainer = _ref.localBtnContainer;
  return import_react2.default.createElement("div", {
    style: _extends({}, {
      backgroundColor: "#007bff",
      width: "100%",
      height: 70,
      zIndex: 10,
      display: "flex",
      flexDirection: "row",
      justifyContent: "space-evenly",
      alignItems: "center"
    }, localBtnContainer)
  }, rtcProps.role !== "audience" && import_react2.default.createElement(LocalVideoMute, null), rtcProps.role !== "audience" && import_react2.default.createElement(LocalAudioMute, null), rtcProps.role !== "audience" && rtcProps.enableScreensharing && import_react2.default.createElement(Screenshare, null), import_react2.default.createElement(EndCall, null));
}
var rtmStatusEnum;
(function(rtmStatusEnum2) {
  rtmStatusEnum2[rtmStatusEnum2["initFailed"] = 0] = "initFailed";
  rtmStatusEnum2[rtmStatusEnum2["offline"] = 1] = "offline";
  rtmStatusEnum2[rtmStatusEnum2["initialising"] = 2] = "initialising";
  rtmStatusEnum2[rtmStatusEnum2["loggingIn"] = 3] = "loggingIn";
  rtmStatusEnum2[rtmStatusEnum2["loggedIn"] = 4] = "loggedIn";
  rtmStatusEnum2[rtmStatusEnum2["connected"] = 5] = "connected";
  rtmStatusEnum2[rtmStatusEnum2["loginFailed"] = 6] = "loginFailed";
})(rtmStatusEnum || (rtmStatusEnum = {}));
var clientRoleRaw;
(function(clientRoleRaw2) {
  clientRoleRaw2[clientRoleRaw2["broadcaster"] = 0] = "broadcaster";
  clientRoleRaw2[clientRoleRaw2["audience"] = 1] = "audience";
})(clientRoleRaw || (clientRoleRaw = {}));
var mutingDevice;
(function(mutingDevice2) {
  mutingDevice2[mutingDevice2["camera"] = 0] = "camera";
  mutingDevice2[mutingDevice2["microphone"] = 1] = "microphone";
})(mutingDevice || (mutingDevice = {}));
var popUpStateEnum;
(function(popUpStateEnum2) {
  popUpStateEnum2[popUpStateEnum2["closed"] = 0] = "closed";
  popUpStateEnum2[popUpStateEnum2["muteMic"] = 1] = "muteMic";
  popUpStateEnum2[popUpStateEnum2["muteCamera"] = 2] = "muteCamera";
  popUpStateEnum2[popUpStateEnum2["unmuteMic"] = 3] = "unmuteMic";
  popUpStateEnum2[popUpStateEnum2["unmuteCamera"] = 4] = "unmuteCamera";
})(popUpStateEnum || (popUpStateEnum = {}));
var RtmContext = (0, import_react2.createContext)(null);
var RtmProvider = RtmContext.Provider;
var RtmConsumer = RtmContext.Consumer;
function RemoteVideoMute(props) {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps;
  var _useContext2 = (0, import_react2.useContext)(RtmContext), sendMuteRequest = _useContext2.sendMuteRequest, uidMap = _useContext2.uidMap;
  var _ref = styleProps || {}, remoteBtnStyles = _ref.remoteBtnStyles;
  var _ref2 = remoteBtnStyles || {}, muteRemoteVideo = _ref2.muteRemoteVideo;
  var UIKitUser = props.UIKitUser;
  var isMuted = UIKitUser.hasVideo === remoteTrackState.no;
  return UIKitUser.uid !== 0 && uidMap[UIKitUser.uid] ? import_react2.default.createElement("div", null, import_react2.default.createElement(BtnTemplate, {
    name: UIKitUser.hasVideo === remoteTrackState.subbed ? "videocam" : "videocamOff",
    style: muteRemoteVideo,
    onClick: function onClick() {
      return sendMuteRequest(mutingDevice.camera, UIKitUser.uid, !isMuted);
    }
  })) : null;
}
function RemoteAudioMute(props) {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps;
  var _ref = styleProps || {}, remoteBtnStyles = _ref.remoteBtnStyles;
  var _useContext2 = (0, import_react2.useContext)(RtmContext), sendMuteRequest = _useContext2.sendMuteRequest, uidMap = _useContext2.uidMap;
  var _ref2 = remoteBtnStyles || {}, muteRemoteAudio = _ref2.muteRemoteAudio;
  var UIKitUser = props.UIKitUser;
  var isMuted = UIKitUser.hasAudio === remoteTrackState.no;
  return UIKitUser.uid !== 0 && uidMap[UIKitUser.uid] ? import_react2.default.createElement("div", null, import_react2.default.createElement(BtnTemplate, {
    style: muteRemoteAudio,
    name: UIKitUser.hasAudio === remoteTrackState.subbed ? "mic" : "micOff",
    onClick: function onClick() {
      return sendMuteRequest(mutingDevice.microphone, UIKitUser.uid, !isMuted);
    }
  })) : null;
}
function SwapUser(props) {
  var _useContext = (0, import_react2.useContext)(RtcContext), dispatch = _useContext.dispatch;
  var UIKitUser = props.UIKitUser;
  return import_react2.default.createElement("div", null, import_react2.default.createElement(BtnTemplate, {
    name: "remoteSwap",
    onClick: function onClick() {
      return dispatch({
        type: "user-swap",
        value: [UIKitUser]
      });
    }
  }));
}
var VideoPlaceholder = function VideoPlaceholder2(props) {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, rtcProps = _useContext.rtcProps;
  var _ref = styleProps || {}, maxViewStyles = _ref.maxViewStyles, maxViewOverlayContainer = _ref.maxViewOverlayContainer;
  var user = props.user;
  var CustomVideoPlaceholder = rtcProps.CustomVideoPlaceholder;
  return !CustomVideoPlaceholder ? import_react2.default.createElement("div", {
    key: user.uid,
    style: _extends({}, style.max, maxViewStyles)
  }, import_react2.default.createElement("div", {
    style: style.imgContainer
  }, import_react2.default.createElement("img", {
    style: style.img,
    src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJmZWF0aGVyIGZlYXRoZXItdXNlciI+PHBhdGggZD0iTTIwIDIxdi0yYTQgNCAwIDAgMC00LTRIOGE0IDQgMCAwIDAtNCA0djIiPjwvcGF0aD48Y2lyY2xlIGN4PSIxMiIgY3k9IjciIHI9IjQiPjwvY2lyY2xlPjwvc3ZnPg=="
  })), props.isShown && import_react2.default.createElement("div", {
    style: _extends({}, style.btnContainer, maxViewOverlayContainer)
  }, props.showButtons && import_react2.default.createElement(import_react2.default.Fragment, null, !rtcProps.disableRtm && import_react2.default.createElement(RemoteVideoMute, {
    UIKitUser: user
  }), !rtcProps.disableRtm && import_react2.default.createElement(RemoteAudioMute, {
    UIKitUser: user
  }), props.showSwap && import_react2.default.createElement(SwapUser, {
    UIKitUser: user
  })))) : CustomVideoPlaceholder && CustomVideoPlaceholder(_extends({}, props), null);
};
var style = {
  max: {
    flex: 1,
    display: "flex",
    backgroundColor: "#007bff33",
    flexDirection: "row",
    position: "relative"
  },
  imgContainer: {
    flex: 10,
    display: "flex",
    justifyContent: "center"
  },
  img: {
    width: 100,
    height: 100,
    position: "absolute",
    alignSelf: "center",
    justifySelf: "center",
    margin: "auto",
    display: "flex"
  },
  btnContainer: {
    position: "absolute",
    margin: 5,
    flexDirection: "column",
    display: "flex"
  }
};
var Username = function Username2(props) {
  var _useContext = (0, import_react2.useContext)(RtmContext), usernames = _useContext.usernames;
  var _useContext2 = (0, import_react2.useContext)(PropsContext), rtmProps = _useContext2.rtmProps, styleProps = _useContext2.styleProps;
  var user = props.user;
  return rtmProps !== null && rtmProps !== void 0 && rtmProps.displayUsername ? import_react2.default.createElement("p", {
    style: _extends({}, styles.username, styleProps === null || styleProps === void 0 ? void 0 : styleProps.usernameText)
  }, user.uid === 1 ? "Screenshare" : usernames[user.uid]) : import_react2.default.createElement(import_react2.default.Fragment, null);
};
var styles = {
  username: {
    position: "absolute",
    background: "#007bffaa",
    padding: "2px 8px",
    color: "#fff",
    margin: 0,
    bottom: 0,
    right: 0,
    zIndex: 90
  }
};
var MaxVideoView = function MaxVideoView2(props) {
  var _useContext = (0, import_react2.useContext)(RtcContext), mediaStore = _useContext.mediaStore;
  var _useContext2 = (0, import_react2.useContext)(PropsContext), styleProps = _useContext2.styleProps, rtcProps = _useContext2.rtcProps;
  var _ref = styleProps || {}, maxViewStyles = _ref.maxViewStyles, videoMode = _ref.videoMode, maxViewOverlayContainer = _ref.maxViewOverlayContainer;
  var renderModeProp = videoMode === null || videoMode === void 0 ? void 0 : videoMode.max;
  var _useState = (0, import_react2.useState)(false), isShown = _useState[0], setIsShown = _useState[1];
  var user = props.user;
  return import_react2.default.createElement("div", {
    style: _extends({}, styles$1.container, props.style, maxViewStyles),
    onMouseEnter: function onMouseEnter() {
      return setIsShown(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setIsShown(false);
    }
  }, user.hasVideo === 1 ? import_react2.default.createElement("div", {
    style: styles$1.videoContainer
  }, !rtcProps.disableRtm && import_react2.default.createElement(Username, {
    user
  }), import_react2.default.createElement(AgoraVideoPlayer, {
    style: styles$1.videoplayer,
    config: {
      fit: renderModeProp || "cover"
    },
    videoTrack: mediaStore[user.uid].videoTrack
  }), isShown && import_react2.default.createElement("div", {
    style: _extends({}, styles$1.overlay, maxViewOverlayContainer)
  }, !rtcProps.disableRtm && import_react2.default.createElement(RemoteVideoMute, {
    UIKitUser: user
  }), !rtcProps.disableRtm && import_react2.default.createElement(RemoteAudioMute, {
    UIKitUser: user
  }))) : import_react2.default.createElement("div", {
    style: styles$1.videoContainer
  }, !rtcProps.disableRtm && import_react2.default.createElement(Username, {
    user
  }), import_react2.default.createElement(VideoPlaceholder, {
    user,
    isShown,
    showButtons: true
  })));
};
var styles$1 = {
  container: {
    display: "flex",
    flex: 1
  },
  videoContainer: {
    display: "flex",
    flex: 1,
    position: "relative"
  },
  videoplayer: {
    width: "100%",
    display: "flex",
    flex: 1
  },
  overlay: {
    position: "absolute",
    margin: 5,
    flexDirection: "column",
    display: "flex"
  },
  username: {
    position: "absolute",
    background: "#007bffaa",
    padding: "2px 8px",
    color: "#fff",
    margin: 0,
    bottom: 0,
    right: 0,
    zIndex: 90
  }
};
var MinVideoView = function MinVideoView2(props) {
  var _useContext = (0, import_react2.useContext)(RtcContext), mediaStore = _useContext.mediaStore;
  var _useContext2 = (0, import_react2.useContext)(PropsContext), styleProps = _useContext2.styleProps, rtcProps = _useContext2.rtcProps;
  var _ref = styleProps || {}, minViewStyles = _ref.minViewStyles, videoMode = _ref.videoMode, minViewOverlayContainer = _ref.minViewOverlayContainer;
  var renderModeProp = videoMode === null || videoMode === void 0 ? void 0 : videoMode.min;
  var _useState = (0, import_react2.useState)(false), isShown = _useState[0], setIsShown = _useState[1];
  var user = props.user;
  return import_react2.default.createElement("div", {
    style: _extends({}, {
      display: "flex",
      flex: 1
    }, minViewStyles),
    onMouseEnter: function onMouseEnter() {
      return setIsShown(true);
    },
    onMouseLeave: function onMouseLeave() {
      return setIsShown(false);
    }
  }, user.hasVideo === 1 ? import_react2.default.createElement("div", {
    style: _extends({}, {
      display: "flex",
      flex: 1,
      position: "relative"
    })
  }, import_react2.default.createElement(AgoraVideoPlayer, {
    style: {
      flex: 10,
      display: "flex"
    },
    config: {
      fit: renderModeProp !== void 0 ? renderModeProp : "cover"
    },
    videoTrack: mediaStore[user.uid].videoTrack
  }), isShown && import_react2.default.createElement("div", {
    style: _extends({}, {
      margin: 4,
      position: "absolute",
      flex: 1,
      display: "flex",
      flexDirection: "column"
    }, minViewOverlayContainer)
  }, !rtcProps.disableRtm && import_react2.default.createElement(RemoteVideoMute, {
    UIKitUser: user
  }), !rtcProps.disableRtm && import_react2.default.createElement(RemoteAudioMute, {
    UIKitUser: user
  }), import_react2.default.createElement(SwapUser, {
    UIKitUser: user
  }))) : import_react2.default.createElement(VideoPlaceholder, {
    user,
    isShown,
    showButtons: true,
    showSwap: true
  }));
};
var styles$2 = { "test": "_3ybTi", "scrollbar": "_3Sxu7" };
var PinnedVideo = function PinnedVideo2() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, rtcProps = _useContext.rtcProps;
  var _ref = styleProps || {}, minViewContainer = _ref.minViewContainer, pinnedVideoContainer = _ref.pinnedVideoContainer, maxViewContainer = _ref.maxViewContainer, scrollViewContainer = _ref.scrollViewContainer;
  var parentRef = (0, import_react2.useRef)(null);
  var _useState = (0, import_react2.useState)(0), width = _useState[0], setWidth = _useState[1];
  var _useState2 = (0, import_react2.useState)(0), height = _useState2[0], setHeight = _useState2[1];
  var isLandscape = width > height;
  (0, import_react2.useEffect)(function() {
    var handleResize = function handleResize2() {
      if (parentRef.current) {
        setWidth(parentRef.current.offsetWidth);
        setHeight(parentRef.current.offsetHeight);
      }
    };
    window.addEventListener("resize", handleResize);
    if (parentRef.current) {
      setWidth(parentRef.current.offsetWidth);
      setHeight(parentRef.current.offsetHeight);
    }
    return function() {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  return import_react2.default.createElement("div", {
    ref: parentRef,
    style: _extends({}, {
      display: "flex",
      flex: 1,
      flexDirection: isLandscape ? "row" : "column-reverse",
      overflow: "hidden"
    }, pinnedVideoContainer)
  }, import_react2.default.createElement("div", {
    style: _extends({}, {
      display: "flex",
      flex: isLandscape ? 5 : 4
    }, maxViewContainer)
  }, import_react2.default.createElement(MaxUidConsumer, null, function(maxUsers) {
    return rtcProps.role === "audience" && maxUsers[0].uid === 0 ? null : import_react2.default.createElement(MaxVideoView, {
      user: maxUsers[0]
    });
  })), import_react2.default.createElement("div", {
    className: styles$2.scrollbar,
    style: _extends({}, {
      overflowY: isLandscape ? "scroll" : "hidden",
      overflowX: !isLandscape ? "scroll" : "hidden",
      display: "flex",
      flex: 1,
      flexDirection: isLandscape ? "column" : "row"
    }, scrollViewContainer)
  }, import_react2.default.createElement(MinUidConsumer, null, function(minUsers) {
    return minUsers.map(function(user) {
      return rtcProps.role === "audience" && user.uid === 0 ? null : import_react2.default.createElement("div", {
        style: _extends({}, {
          minHeight: isLandscape ? "35vh" : "99%",
          minWidth: isLandscape ? "99%" : "40vw",
          margin: 2,
          display: "flex"
        }, minViewContainer),
        key: user.uid
      }, import_react2.default.createElement(MinVideoView, {
        user
      }));
    });
  })));
};
var GridVideo = function GridVideo2() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps, rtcProps = _useContext.rtcProps;
  var _ref = styleProps || {}, gridVideoCells = _ref.gridVideoCells, gridVideoContainer = _ref.gridVideoContainer;
  var max = (0, import_react2.useContext)(MaxUidContext);
  var min = (0, import_react2.useContext)(MinUidContext);
  var users = rtcProps.role === "audience" ? [].concat(max, min).filter(function(user) {
    return user.uid !== 0;
  }) : [].concat(max, min);
  var parentRef = (0, import_react2.useRef)(null);
  var _useState = (0, import_react2.useState)(window.innerWidth), width = _useState[0], setWidth = _useState[1];
  var _useState2 = (0, import_react2.useState)(window.innerHeight), height = _useState2[0], setHeight = _useState2[1];
  var isLandscape = width > height;
  var unit = "minmax(0, 1fr) ";
  (0, import_react2.useEffect)(function() {
    var handleResize = function handleResize2() {
      if (parentRef.current) {
        setWidth(parentRef.current.offsetWidth);
        setHeight(parentRef.current.offsetHeight);
      }
    };
    window.addEventListener("resize", handleResize);
    if (parentRef.current) {
      setWidth(parentRef.current.offsetWidth);
      setHeight(parentRef.current.offsetHeight);
    }
    return function() {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  return import_react2.default.createElement("div", {
    ref: parentRef,
    style: _extends({}, {
      width: "100%",
      height: "100%",
      display: "grid",
      gridTemplateColumns: isLandscape ? users.length > 9 ? unit.repeat(4) : users.length > 4 ? unit.repeat(3) : users.length > 1 ? unit.repeat(2) : unit : users.length > 8 ? unit.repeat(3) : users.length > 2 ? unit.repeat(2) : unit
    }, gridVideoContainer)
  }, users.map(function(user) {
    return import_react2.default.createElement(MaxVideoView, {
      user,
      style: _extends({}, {
        height: "100%",
        width: "100%"
      }, gridVideoCells),
      key: user.uid
    });
  }));
};
var useTracks = createMicrophoneAndCameraTracks({
  encoderConfig: {}
}, {
  encoderConfig: {}
});
var TracksConfigure = function TracksConfigure2(props) {
  var _useState = (0, import_react2.useState)(false), ready = _useState[0], setReady = _useState[1];
  var _useState2 = (0, import_react2.useState)(null), localVideoTrack = _useState2[0], setLocalVideoTrack = _useState2[1];
  var _useState3 = (0, import_react2.useState)(null), localAudioTrack = _useState3[0], setLocalAudioTrack = _useState3[1];
  var _useTracks = useTracks(), trackReady = _useTracks.ready, tracks = _useTracks.tracks, error = _useTracks.error;
  var mediaStore = (0, import_react2.useRef)({});
  (0, import_react2.useEffect)(function() {
    if (tracks !== null) {
      setLocalAudioTrack(tracks[0]);
      setLocalVideoTrack(tracks[1]);
      mediaStore.current[0] = {
        audioTrack: tracks[0],
        videoTrack: tracks[1]
      };
      setReady(true);
    } else if (error) {
      console.error(error);
      setReady(false);
    }
    return function() {
      if (tracks) {
        var _tracks$, _tracks$2;
        (_tracks$ = tracks[0]) === null || _tracks$ === void 0 ? void 0 : _tracks$.close();
        (_tracks$2 = tracks[1]) === null || _tracks$2 === void 0 ? void 0 : _tracks$2.close();
      }
    };
  }, [trackReady, error]);
  return import_react2.default.createElement(TracksProvider, {
    value: {
      localVideoTrack,
      localAudioTrack
    }
  }, ready ? props.children : null);
};
var timeNow = function timeNow2() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var useChannel = createLazyChannel();
var useClient$1 = createLazyClient();
var RtmConfigure = function RtmConfigure2(props) {
  var _useContext = (0, import_react2.useContext)(PropsContext), rtcProps = _useContext.rtcProps, rtmProps = _useContext.rtmProps;
  var _useState = (0, import_react2.useState)(false), isLoggedIn = _useState[0], setLoggedIn = _useState[1];
  var rtmClient = useClient$1(rtcProps.appId);
  var channel = useChannel(rtmClient, rtcProps.channel);
  var localUid = (0, import_react2.useRef)("");
  var timerValueRef = (0, import_react2.useRef)(5);
  var local = (0, import_react2.useContext)(LocalContext);
  var _useContext2 = (0, import_react2.useContext)(PropsContext), rtmCallbacks = _useContext2.rtmCallbacks;
  var _useState2 = (0, import_react2.useState)({}), uidMap = _useState2[0], setUidMap = _useState2[1];
  var _useState3 = (0, import_react2.useState)({}), usernames = _useState3[0], setUsernames = _useState3[1];
  var _useState4 = (0, import_react2.useState)({}), userDataMap = _useState4[0], setUserDataMap = _useState4[1];
  var _useState5 = (0, import_react2.useState)(popUpStateEnum.closed), popUpState = _useState5[0], setPopUpState = _useState5[1];
  var _useState6 = (0, import_react2.useState)(rtmStatusEnum.offline), rtmStatus = _useState6[0], setRtmStatus = _useState6[1];
  var _useContext3 = (0, import_react2.useContext)(RtcContext), rtcUid = _useContext3.localUid, localAudioTrack = _useContext3.localAudioTrack, localVideoTrack = _useContext3.localVideoTrack, dispatch = _useContext3.dispatch, channelJoined = _useContext3.channelJoined;
  var login = function login2() {
    try {
      var tokenUrl = rtcProps.tokenUrl;
      var _temp4 = function() {
        if (tokenUrl) {
          var _temp5 = _catch(function() {
            return Promise.resolve(fetch(tokenUrl + "/rtm/" + ((rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.uid) || localUid.current))).then(function(res) {
              return Promise.resolve(res.json()).then(function(data) {
                var serverToken = data.rtmToken;
                return Promise.resolve(rtmClient.login({
                  uid: (rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.uid) || localUid.current,
                  token: serverToken
                })).then(function() {
                  timerValueRef.current = 5;
                });
              });
            });
          }, function() {
            setTimeout(function() {
              try {
                timerValueRef.current = timerValueRef.current + timerValueRef.current;
                login2();
                return Promise.resolve();
              } catch (e) {
                return Promise.reject(e);
              }
            }, timerValueRef.current * 1e3);
          });
          if (_temp5 && _temp5.then) return _temp5.then(function() {
          });
        } else {
          var _temp6 = _catch(function() {
            return Promise.resolve(rtmClient.login({
              uid: (rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.uid) || localUid.current,
              token: (rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.token) || void 0
            })).then(function() {
              timerValueRef.current = 5;
            });
          }, function() {
            setTimeout(function() {
              try {
                timerValueRef.current = timerValueRef.current + timerValueRef.current;
                login2();
                return Promise.resolve();
              } catch (e) {
                return Promise.reject(e);
              }
            }, timerValueRef.current * 1e3);
          });
          if (_temp6 && _temp6.then) return _temp6.then(function() {
          });
        }
      }();
      return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var joinChannel = function joinChannel2() {
    try {
      var _temp8 = _catch(function() {
        return Promise.resolve(channel.join()).then(function() {
          timerValueRef.current = 5;
        });
      }, function() {
        setTimeout(function() {
          try {
            timerValueRef.current = timerValueRef.current + timerValueRef.current;
            joinChannel2();
            return Promise.resolve();
          } catch (e) {
            return Promise.reject(e);
          }
        }, timerValueRef.current * 1e3);
      });
      return Promise.resolve(_temp8 && _temp8.then ? _temp8.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var init = function init2() {
    try {
      setRtmStatus(rtmStatusEnum.initialising);
      rtcProps.uid ? localUid.current = String(rtcProps.uid) : localUid.current = String(timeNow());
      rtmClient.on("ConnectionStateChanged", function(state, reason) {
        console.log(state, reason);
      });
      rtmClient.on("TokenExpired", function() {
        try {
          var tokenUrl2 = rtcProps.tokenUrl;
          console.log("token expired - renewing");
          var _temp11 = function() {
            if (tokenUrl2) {
              var _temp12 = _catch(function() {
                return Promise.resolve(fetch(tokenUrl2 + "/rtm/" + ((rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.uid) || localUid.current))).then(function(res) {
                  return Promise.resolve(res.json()).then(function(data) {
                    var serverToken = data.rtmToken;
                    return Promise.resolve(rtmClient.renewToken(serverToken)).then(function() {
                      timerValueRef.current = 5;
                    });
                  });
                });
              }, function(error) {
                console.error("TokenExpiredError", error);
              });
              if (_temp12 && _temp12.then) return _temp12.then(function() {
              });
            }
          }();
          return Promise.resolve(_temp11 && _temp11.then ? _temp11.then(function() {
          }) : void 0);
        } catch (e) {
          return Promise.reject(e);
        }
      });
      rtmClient.on("MessageFromPeer", function(message, peerId) {
        handleReceivedMessage(message, peerId);
      });
      channel.on("ChannelMessage", function(message, peerId) {
        handleReceivedMessage(message, peerId);
      });
      channel.on("MemberJoined", function(peerId) {
        try {
          return Promise.resolve(sendPeerMessage(createUserData(), peerId)).then(function() {
          });
        } catch (e) {
          return Promise.reject(e);
        }
      });
      channel.on("MemberCountUpdated", function(count) {
        try {
          console.log("RTM-MemberCountUpdated: ", count);
          return Promise.resolve();
        } catch (e) {
          return Promise.reject(e);
        }
      });
      if (rtmCallbacks !== null && rtmCallbacks !== void 0 && rtmCallbacks.channel) {
        Object.keys(rtmCallbacks.channel).map(function(callback) {
          if (rtmCallbacks.channel) {
            channel.on(callback, rtmCallbacks.channel[callback]);
          }
        });
      } else if (rtmCallbacks !== null && rtmCallbacks !== void 0 && rtmCallbacks.client) {
        Object.keys(rtmCallbacks.client).map(function(callback) {
          if (rtmCallbacks.client) {
            rtmClient.on(callback, rtmCallbacks.client[callback]);
          }
        });
      }
      if (rtcProps.tokenUrl) {
        var tokenUrl = rtcProps.tokenUrl, uid = rtcProps.uid;
        rtmClient.on("TokenExpired", function() {
          try {
            console.log("token expired");
            return Promise.resolve(fetch(tokenUrl + "/rtm/" + (uid || 0) + "/")).then(function(res) {
              return Promise.resolve(res.json()).then(function(data) {
                var token = data.rtmToken;
                rtmClient.renewToken(token);
              });
            });
          } catch (e) {
            return Promise.reject(e);
          }
        });
      }
      setRtmStatus(rtmStatusEnum.loggingIn);
      return Promise.resolve(login()).then(function() {
        setRtmStatus(rtmStatusEnum.loggedIn);
        return Promise.resolve(joinChannel()).then(function() {
          setRtmStatus(rtmStatusEnum.connected);
          setUsernames(function(p) {
            return _extends({}, p, {
              0: rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.username
            });
          });
          sendChannelMessage(createUserData());
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var createUserData = function createUserData2() {
    return {
      messageType: "UserData",
      rtmId: (rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.uid) || localUid.current,
      rtcId: rtcUid.current,
      username: rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.username,
      role: rtcProps.role === "audience" ? 1 : 0,
      uikit: {
        platform: "web",
        framework: "react",
        version: "1.2.0"
      },
      agora: {
        rtm: index_modern_default2.VERSION,
        rtc: index_modern_default.VERSION
      }
    };
  };
  var sendMuteRequest = function sendMuteRequest2(device, rtcId, mute) {
    var forced = (rtmProps === null || rtmProps === void 0 ? void 0 : rtmProps.showPopUpBeforeRemoteMute) === false;
    var payload = {
      messageType: "MuteRequest",
      device,
      rtcId,
      mute,
      isForceful: forced
    };
    var peerId = uidMap[rtcId];
    if (forced && !mute) {
      console.log("cannot send force unmute request");
    } else if (peerId) {
      sendPeerMessage(payload, peerId);
    } else {
      console.log("peer not found");
    }
  };
  var handleReceivedMessage = function handleReceivedMessage2(message, peerId) {
    var messageObject;
    if (message.messageType === "RAW") {
      messageObject = parsePayload(message.rawMessage);
    } else if (message.messageType === "TEXT") {
      messageObject = JSON.parse(message.text);
    }
    console.log(messageObject, peerId);
    if (messageObject) {
      switch (messageObject.messageType) {
        case "UserData":
          handleReceivedUserDataMessage(messageObject);
          break;
        case "MuteRequest":
          handleReceivedMuteMessage(messageObject);
          break;
        case "RtmDataRequest":
          switch (messageObject.type) {
            case "ping":
              handlePing(peerId);
              break;
            case "userData":
              handleUserDataRequest(peerId);
              break;
            default:
              console.log(peerId);
          }
          break;
        default:
          console.log("unknown message content");
      }
    } else {
      console.log("unknown rtm message type");
    }
  };
  var handleReceivedUserDataMessage = function handleReceivedUserDataMessage2(userData) {
    setUidMap(function(p) {
      var _extends2;
      return _extends({}, p, (_extends2 = {}, _extends2[userData.rtcId] = userData.rtmId, _extends2));
    });
    setUsernames(function(p) {
      var _extends3;
      return _extends({}, p, (_extends3 = {}, _extends3[userData.rtcId] = userData.username, _extends3));
    });
    setUserDataMap(function(p) {
      var _extends4;
      return _extends({}, p, (_extends4 = {}, _extends4[userData.rtmId] = userData, _extends4));
    });
  };
  var handleReceivedMuteMessage = function handleReceivedMuteMessage2(muteRequest) {
    if (rtcUid.current === muteRequest.rtcId) {
      if (muteRequest.isForceful) {
        if (muteRequest.mute) {
          if (muteRequest.device === mutingDevice.microphone) {
            localAudioTrack && muteAudio(local, dispatch, localAudioTrack);
          } else if (muteRequest.device === mutingDevice.camera) {
            localVideoTrack && muteVideo(local, dispatch, localVideoTrack);
          }
        } else console.error("cannot force unmute");
      } else {
        if (muteRequest.device === mutingDevice.microphone) {
          if (muteRequest.mute) setPopUpState(popUpStateEnum.muteMic);
          else setPopUpState(popUpStateEnum.unmuteMic);
        } else if (muteRequest.device === mutingDevice.camera) {
          if (muteRequest.mute) setPopUpState(popUpStateEnum.muteCamera);
          else setPopUpState(popUpStateEnum.unmuteCamera);
        }
      }
    }
  };
  var handlePing = function handlePing2(peerId) {
    sendPeerMessage({
      messageType: "RtmDataRequest",
      type: "pong"
    }, peerId);
  };
  var handleUserDataRequest = function handleUserDataRequest2(peerId) {
    sendPeerMessage(createUserData(), peerId);
  };
  var sendChannelMessage = function sendChannelMessage2(payload) {
    try {
      var message = rtmClient.createMessage({
        text: JSON.stringify(payload),
        messageType: index_modern_default2.MessageType.TEXT
      });
      var _temp14 = _catch(function() {
        return Promise.resolve(channel.sendMessage(message)).then(function() {
        });
      }, function(e) {
        console.error(e);
      });
      return Promise.resolve(_temp14 && _temp14.then ? _temp14.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var sendPeerMessage = function sendPeerMessage2(payload, peerId) {
    try {
      var message = rtmClient.createMessage({
        text: JSON.stringify(payload),
        messageType: index_modern_default2.MessageType.TEXT
      });
      var _temp16 = _catch(function() {
        return Promise.resolve(rtmClient.sendMessageToPeer(message, String(peerId))).then(function() {
        });
      }, function(e) {
        console.error(e);
      });
      return Promise.resolve(_temp16 && _temp16.then ? _temp16.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var end = function end2() {
    try {
      return Promise.resolve(rtmClient.logout()).then(function() {
        return Promise.resolve(rtmClient.removeAllListeners()).then(function() {
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  (0, import_react2.useEffect)(function() {
    if (channelJoined) {
      init();
      setLoggedIn(true);
    }
    return function() {
      if (channelJoined) {
        end();
      }
    };
  }, [rtcProps.channel, rtcProps.appId, channelJoined]);
  return import_react2.default.createElement(RtmProvider, {
    value: {
      rtmStatus,
      sendPeerMessage,
      sendChannelMessage,
      sendMuteRequest,
      rtmClient,
      uidMap,
      usernames,
      userDataMap,
      popUpState,
      setPopUpState
    }
  }, isLoggedIn ? props.children : import_react2.default.createElement(import_react2.default.Fragment, null));
};
var enc = new TextEncoder();
var dec = new TextDecoder();
var createRawMessage = function createRawMessage2(msg) {
  return enc.encode(JSON.stringify(msg));
};
var parsePayload = function parsePayload2(data) {
  return JSON.parse(dec.decode(data));
};
function PopUp() {
  var _useContext = (0, import_react2.useContext)(PropsContext), styleProps = _useContext.styleProps;
  var _useContext2 = (0, import_react2.useContext)(RtmContext), popUpState = _useContext2.popUpState, setPopUpState = _useContext2.setPopUpState;
  var _ref = styleProps || {}, popUpContainer = _ref.popUpContainer;
  var _useContext3 = (0, import_react2.useContext)(RtcContext), dispatch = _useContext3.dispatch, localVideoTrack = _useContext3.localVideoTrack, localAudioTrack = _useContext3.localAudioTrack;
  var local = (0, import_react2.useContext)(LocalContext);
  return popUpState !== popUpStateEnum.closed ? import_react2.default.createElement("div", {
    style: _extends({}, styles$3.container, popUpContainer)
  }, import_react2.default.createElement("div", {
    style: {
      color: "#fff",
      fontSize: 18,
      fontWeight: 700
    }
  }, popUpState === popUpStateEnum.muteCamera || popUpState === popUpStateEnum.muteMic ? "Mute " : "Unmute ", popUpState === popUpStateEnum.muteCamera || popUpState === popUpStateEnum.unmuteCamera ? "Camera" : "Mic", "?"), import_react2.default.createElement("div", {
    style: {
      flexDirection: "row",
      display: "flex",
      width: "100%",
      justifyContent: "space-around"
    }
  }, import_react2.default.createElement("div", {
    onClick: function onClick() {
      switch (popUpState) {
        case popUpStateEnum.muteCamera:
          local.hasVideo && localVideoTrack && muteVideo(local, dispatch, localVideoTrack);
          break;
        case popUpStateEnum.muteMic:
          local.hasAudio && localAudioTrack && muteAudio(local, dispatch, localAudioTrack);
          break;
        case popUpStateEnum.unmuteCamera:
          !local.hasVideo && localVideoTrack && muteVideo(local, dispatch, localVideoTrack);
          break;
        case popUpStateEnum.unmuteMic:
          !local.hasAudio && localAudioTrack && muteAudio(local, dispatch, localAudioTrack);
          break;
      }
      setPopUpState(popUpStateEnum.closed);
    },
    style: styles$3.button
  }, "Confirm"), import_react2.default.createElement("div", {
    style: styles$3.buttonClose,
    onClick: function onClick() {
      return setPopUpState(popUpStateEnum.closed);
    }
  }, "Close"))) : null;
}
var styles$3 = {
  button: {
    color: "#fff",
    cursor: "pointer",
    borderWidth: 2,
    borderStyle: "solid",
    borderColor: "#fff",
    padding: "2px 4px",
    borderRadius: 4
  },
  buttonClose: {
    color: "#fff",
    cursor: "pointer",
    borderWidth: 2,
    borderStyle: "solid",
    borderColor: "#fff",
    padding: "2px 4px",
    borderRadius: 4
  },
  container: {
    backgroundColor: "#007bffaa",
    position: "absolute",
    width: 240,
    height: 80,
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    zIndex: 100,
    display: "flex",
    flexDirection: "column",
    justifyContent: "space-evenly",
    alignItems: "center"
  }
};
var AgoraUIKit = function AgoraUIKit2(props) {
  var styleProps = props.styleProps, rtcProps = props.rtcProps;
  var _ref = styleProps || {}, UIKitContainer = _ref.UIKitContainer;
  return import_react2.default.createElement(PropsProvider, {
    value: props
  }, import_react2.default.createElement("div", {
    style: _extends({}, style$1, UIKitContainer)
  }, rtcProps.role === "audience" ? import_react2.default.createElement(VideocallUI, null) : import_react2.default.createElement(TracksConfigure, null, import_react2.default.createElement(VideocallUI, null))));
};
var VideocallUI = function VideocallUI2() {
  var _useContext = (0, import_react2.useContext)(PropsContext), rtcProps = _useContext.rtcProps;
  return import_react2.default.createElement(RtcConfigure, {
    callActive: rtcProps.callActive
  }, import_react2.default.createElement(LocalUserContext, null, rtcProps.disableRtm ? import_react2.default.createElement(import_react2.default.Fragment, null, (rtcProps === null || rtcProps === void 0 ? void 0 : rtcProps.layout) === layout.grid ? import_react2.default.createElement(GridVideo, null) : import_react2.default.createElement(PinnedVideo, null), import_react2.default.createElement(LocalControls, null)) : import_react2.default.createElement(RtmConfigure, null, import_react2.default.createElement(PopUp, null), (rtcProps === null || rtcProps === void 0 ? void 0 : rtcProps.layout) === layout.grid ? import_react2.default.createElement(GridVideo, null) : import_react2.default.createElement(PinnedVideo, null), import_react2.default.createElement(LocalControls, null))));
};
var style$1 = {
  display: "flex",
  flex: 1,
  minHeight: 0,
  flexDirection: "column"
};
var index_modern_default3 = AgoraUIKit;
export {
  BtnTemplate,
  EndCall,
  GridVideo,
  LocalAudioMute,
  LocalControls,
  LocalUserContext,
  LocalVideoMute,
  MaxUidContext,
  MaxVideoView,
  MinUidContext,
  MinVideoView,
  PinnedVideo,
  PropsContext,
  RemoteAudioMute,
  PopUp as RemoteMutePopUp,
  RemoteVideoMute,
  RtcConfigure,
  RtcConsumer,
  RtcContext,
  RtcProvider,
  RtmConfigure,
  RtmConsumer,
  RtmContext,
  RtmProvider,
  SwapUser,
  ToggleState,
  TracksConfigure,
  TracksContext,
  VideoPlaceholder,
  VideocallUI,
  createRawMessage,
  index_modern_default3 as default,
  icons,
  layout,
  muteAudio,
  muteVideo,
  mutingDevice,
  parsePayload,
  popUpStateEnum,
  rtmStatusEnum
};
/*! Bundled license information:

agora-rtc-sdk-ng/AgoraRTC_N-production.js:
  (*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> *)

agora-rtm-sdk/index.js:
  (*
   @preserve
   AgoraRTM Web SDK 1.4.3-203 - commit: v1.4.3-17-g1e27aa38
   Copyright (C) 2018-2021 Agora Lab.
   This file is licensed under the AGORA, INC. SDK LICENSE AGREEMENT
   A copy of this license may be found at https://www.agora.io/en/sdk-license-agreement/
  *)
*/
//# sourceMappingURL=agora-react-uikit.js.map
